[{"title":"内容简介","url":"/2022/02/01/0.%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/","content":"<p>记录学习中的计算机理论、网络、编程相关的资料、笔记以及心得体会。 </p>\n<p>记录博客的目的</p>\n<ul>\n<li>一是为了系统的大知识块，梳理结构知识点，加深记忆。</li>\n<li>二是把学过的东西记录下来，方便之后随时查询。</li>\n<li>三是希望给有需要的人一点帮助，共同交流学习。</li>\n</ul>\n<h2 id=\"一、英语\"><a href=\"#一、英语\" class=\"headerlink\" title=\"一、英语\"></a>一、英语</h2><ul>\n<li><p>单词</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV15y4y1z72G?spm_id_from=333.999.0.0\">恋练有词</a></li>\n</ul>\n</li>\n<li><p>长难句</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1oA411Y7PU?spm_id_from=333.999.0.0\">撷斌斌66句</a></li>\n</ul>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1mC4y1p7Fh?spm_id_from=333.999.0.0\">田静每日一句总结</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二、数学\"><a href=\"#二、数学\" class=\"headerlink\" title=\"二、数学\"></a>二、数学</h2><ul>\n<li>高等数学<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1Eb411u7Fw?spm_id_from=333.999.0.0\">宋浩</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1s441197c6?spm_id_from=333.999.0.0\">微积分B</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Mt4y1v7Kf?from=search&seid=2035021172623191966&spm_id_from=333.337.0.0\">微积分 中英字幕</a></li>\n</ul>\n</li>\n<li>线性代数<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1aW411Q7x1?spm_id_from=333.999.0.0\">宋浩</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV11z4y1f7ym?spm_id_from=333.999.0.0\">清华大学上</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV14k4y1y7uR?spm_id_from=333.999.0.0\">清华大学下</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV14L4y1H7GM?p=1\">微积分 中英字幕</a></li>\n</ul>\n</li>\n<li>概率论与数理统计<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1ot411y7mU?spm_id_from=333.999.0.0\">宋浩</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV17Z4y1T7mF?spm_id_from=333.999.0.0\">清华大学上</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV17Z4y1T7mF?spm_id_from=333.999.0.0\">清华大学下</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1hk4y127Q1?spm_id_from=333.999.0.0\">清华大学习题</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三、计算机408相关视频\"><a href=\"#三、计算机408相关视频\" class=\"headerlink\" title=\"三、计算机408相关视频\"></a>三、计算机408相关视频</h2><h3 id=\"3-1-计算机组成原理\"><a href=\"#3-1-计算机组成原理\" class=\"headerlink\" title=\"3.1 计算机组成原理\"></a>3.1 计算机组成原理</h3><ul>\n<li>图书讲解<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1Vh411r7ef?spm_id_from=333.999.0.0\">深入理解计算机系统</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Wv411x7zP?spm_id_from=333.999.0.0\">计算机组成原理</a></li>\n</ul>\n</li>\n<li>视频<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1iW411d7hd\">深入理解计算机系统 CSAPP 中英字幕</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1q5411u7zQ?spm_id_from=333.999.0.0\">电子科技大学</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1WW411Q7PF?spm_id_from=333.999.0.0\">哈工大</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-2-操作系统\"><a href=\"#3-2-操作系统\" class=\"headerlink\" title=\"3.2 操作系统\"></a>3.2 操作系统</h3><ul>\n<li>图书讲解<ul>\n<li><a href=\"https://www.bilibili.com/video/BV14P4y1x7YF?spm_id_from=333.999.0.0\">操作系统概念</a></li>\n</ul>\n</li>\n<li>视频<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1eK4y1b7Bn?spm_id_from=333.999.0.0\">清华大学</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1wW41167Av?spm_id_from=333.999.0.0\">清华大学实验</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1wq4y1M7qf?spm_id_from=333.999.0.0\">清华陈渝</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-3-数据结构\"><a href=\"#3-3-数据结构\" class=\"headerlink\" title=\"3.3 数据结构\"></a>3.3 数据结构</h3><ul>\n<li>图书讲解<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1B34y1S7Js?spm_id_from=333.999.0.0\">算法导论</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1854y147bW?spm_id_from=333.999.0.0\">C程序设计</a></li>\n</ul>\n</li>\n<li>视频<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1C54y1L7JM?spm_id_from=333.999.0.0\">清华大学</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1B54y1a7f7?spm_id_from=333.999.0.0\">算法训练营</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1nJ411V7bd?spm_id_from=333.999.0.0\">青岛大学</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Th411Y72K?spm_id_from=333.999.0.0\">算法导论+数据结构 中英字幕</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-4-计算机网络\"><a href=\"#3-4-计算机网络\" class=\"headerlink\" title=\"3.4 计算机网络\"></a>3.4 计算机网络</h3><ul>\n<li>图书讲解<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1534y1o7eD?spm_id_from=333.999.0.0\">计算机网络-自顶向下方法</a></li>\n</ul>\n</li>\n<li>视频<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1Aa4y1E7h4?spm_id_from=333.999.0.0\">华南理工大学</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1c4411d7jb?spm_id_from=333.999.0.0\">湖科大教书匠</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1H3411y7q6?spm_id_from=333.999.0.0\">方老师计算机网络</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"四、Java\"><a href=\"#四、Java\" class=\"headerlink\" title=\"四、Java\"></a>四、Java</h2><ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744\">廖雪峰网站</a></li>\n</ul>\n<h2 id=\"五、华为HCIE（R-amp-S）\"><a href=\"#五、华为HCIE（R-amp-S）\" class=\"headerlink\" title=\"五、华为HCIE（R&amp;S）\"></a>五、华为HCIE（R&amp;S）</h2><ul>\n<li>待补充！！！</li>\n</ul>\n"},{"title":"1.函数、极限、连续","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_1.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_1.%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%81%E9%99%90%E3%80%81%E8%BF%9E%E7%BB%AD/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h4 id=\"1-函数\"><a href=\"#1-函数\" class=\"headerlink\" title=\"1. 函数\"></a>1. 函数</h4><h5 id=\"1-1-概念\"><a href=\"#1-1-概念\" class=\"headerlink\" title=\"1.1 概念\"></a>1.1 概念</h5><h5 id=\"1-2-函数特性\"><a href=\"#1-2-函数特性\" class=\"headerlink\" title=\"1.2 函数特性\"></a>1.2 函数特性</h5><h5 id=\"1-3-函数分类\"><a href=\"#1-3-函数分类\" class=\"headerlink\" title=\"1.3 函数分类\"></a>1.3 函数分类</h5><h4 id=\"2-函数极限\"><a href=\"#2-函数极限\" class=\"headerlink\" title=\"2. 函数极限\"></a>2. 函数极限</h4><h5 id=\"2-1-定义\"><a href=\"#2-1-定义\" class=\"headerlink\" title=\"2.1 定义\"></a>2.1 定义</h5><h5 id=\"2-2-无穷小、无穷大\"><a href=\"#2-2-无穷小、无穷大\" class=\"headerlink\" title=\"2.2 无穷小、无穷大\"></a>2.2 无穷小、无穷大</h5><h5 id=\"2-3-函数极限的性质与定理\"><a href=\"#2-3-函数极限的性质与定理\" class=\"headerlink\" title=\"2.3 函数极限的性质与定理\"></a>2.3 函数极限的性质与定理</h5><h5 id=\"2-4-计算函数极限的方法\"><a href=\"#2-4-计算函数极限的方法\" class=\"headerlink\" title=\"2.4 计算函数极限的方法\"></a>2.4 计算函数极限的方法</h5><h4 id=\"3-数列极限\"><a href=\"#3-数列极限\" class=\"headerlink\" title=\"3. 数列极限\"></a>3. 数列极限</h4><h5 id=\"3-1-定义\"><a href=\"#3-1-定义\" class=\"headerlink\" title=\"3.1 定义\"></a>3.1 定义</h5><h5 id=\"3-2-极限的性质\"><a href=\"#3-2-极限的性质\" class=\"headerlink\" title=\"3.2 极限的性质\"></a>3.2 极限的性质</h5><h5 id=\"3-3-证明极限存在的方法\"><a href=\"#3-3-证明极限存在的方法\" class=\"headerlink\" title=\"3.3 证明极限存在的方法\"></a>3.3 证明极限存在的方法</h5><h5 id=\"3-4-计算极限的方法\"><a href=\"#3-4-计算极限的方法\" class=\"headerlink\" title=\"3.4 计算极限的方法\"></a>3.4 计算极限的方法</h5><h4 id=\"4-连续和间断\"><a href=\"#4-连续和间断\" class=\"headerlink\" title=\"4. 连续和间断\"></a>4. 连续和间断</h4><h5 id=\"4-1-定义\"><a href=\"#4-1-定义\" class=\"headerlink\" title=\"4.1 定义\"></a>4.1 定义</h5><h5 id=\"4-2-连续相关定理\"><a href=\"#4-2-连续相关定理\" class=\"headerlink\" title=\"4.2 连续相关定理\"></a>4.2 连续相关定理</h5><h5 id=\"4-3-间断点的分类\"><a href=\"#4-3-间断点的分类\" class=\"headerlink\" title=\"4.3 间断点的分类\"></a>4.3 间断点的分类</h5><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h4 id=\"【1】\"><a href=\"#【1】\" class=\"headerlink\" title=\"【1】\"></a>【1】</h4><h4 id=\"【2】\"><a href=\"#【2】\" class=\"headerlink\" title=\"【2】\"></a>【2】</h4><h4 id=\"【3】\"><a href=\"#【3】\" class=\"headerlink\" title=\"【3】\"></a>【3】</h4><h4 id=\"【4】\"><a href=\"#【4】\" class=\"headerlink\" title=\"【4】\"></a>【4】</h4><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h4 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"{1}\"></a>{1}</h4><h4 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"{2}\"></a>{2}</h4><h4 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"{3}\"></a>{3}</h4><h4 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"{4}\"></a>{4}</h4><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3><h4 id=\"lt-1-gt\"><a href=\"#lt-1-gt\" class=\"headerlink\" title=\"&lt;1&gt;\"></a>&lt;1&gt;</h4><h4 id=\"lt-2-gt\"><a href=\"#lt-2-gt\" class=\"headerlink\" title=\"&lt;2&gt;\"></a>&lt;2&gt;</h4><h4 id=\"lt-3-gt\"><a href=\"#lt-3-gt\" class=\"headerlink\" title=\"&lt;3&gt;\"></a>&lt;3&gt;</h4><h4 id=\"lt-4-gt\"><a href=\"#lt-4-gt\" class=\"headerlink\" title=\"&lt;4&gt;\"></a>&lt;4&gt;</h4>","categories":["数学","1.高等数学","1.函数、极限、连续"],"tags":["写作"]},{"title":"内容简介","url":"/2022/02/14/0.%E7%BB%8F%E5%85%B8%E4%B9%A6%E7%B1%8D/","content":"<h1 align=\"center\">超过1000本的计算机经典书籍分享</h1>\n\n<ul>\n<li><p><a href=\"#00%E3%80%81C%E8%AF%AD%E8%A8%80\">00、C语言</a></p>\n</li>\n<li><p><a href=\"#01%E3%80%81C++\">01、C++</a></p>\n</li>\n<li><p><a href=\"#02%E3%80%81Java\">02、Java</a></p>\n<ul>\n<li><a href=\"#2.1%E3%80%81Java%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6\">2.1、Java基础到进阶</a></li>\n<li><a href=\"#2.2%E3%80%81Java-%E5%A4%A7%E6%95%B0%E6%8D%AE\">2.2、Java 大数据</a></li>\n<li><a href=\"#2.3%E3%80%81Java%E5%B7%A5%E5%85%B7\">2.3、Java工具</a></li>\n</ul>\n</li>\n<li><p><a href=\"#03%E3%80%81Python\">03、Python</a>  </p>\n<ul>\n<li><a href=\"#3.1%E3%80%81Python%E4%B9%A6%E7%B1%8D\">3.1 Python书籍</a></li>\n<li><a href=\"#3.2%E3%80%81Python%E7%88%AC%E8%99%AB\">3.2 Python爬虫</a></li>\n<li><a href=\"#3.3%E3%80%81Python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90\">3.3 Python数据分析</a></li>\n<li><a href=\"#3.4%E3%80%81Python%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96\">3.4 Python数据可视化</a></li>\n<li><a href=\"#3.5%E3%80%81Python%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98\">3.5 Python数据挖掘</a></li>\n</ul>\n</li>\n<li><p><a href=\"#04%E3%80%81Go%E8%AF%AD%E8%A8%80\">04、Go语言</a></p>\n</li>\n<li><p><a href=\"#05%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95\">05、数据结构与算法</a></p>\n</li>\n<li><p><a href=\"#06%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\">06、操作系统</a></p>\n</li>\n<li><p><a href=\"#07%E3%80%81Linux\">07、Linux</a></p>\n</li>\n<li><p><a href=\"#08%E3%80%81%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84\">08、后端架构</a></p>\n</li>\n<li><p><a href=\"#09%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86\">09、计算机系统知识</a></p>\n</li>\n<li><p><a href=\"#10%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\">10、计算机网络</a></p>\n</li>\n<li><p><a href=\"#11%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93\">11、数据库</a></p>\n</li>\n<li><p><a href=\"#12%E3%80%81%E5%89%8D%E7%AB%AF&%E5%85%A8%E6%A0%88\">12、前端&amp;全栈</a></p>\n</li>\n<li><p><a href=\"#13%E3%80%81%E5%AE%89%E5%8D%93IOS%E9%80%86%E5%90%91\">13、安卓IOS逆向</a></p>\n</li>\n<li><p><a href=\"#14%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0&%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD\">14、机器学习&amp;深度学习&amp;人工智能</a></p>\n<ul>\n<li><a href=\"#14.1%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\">14.1 机器学习</a></li>\n<li><a href=\"#14.2%E3%80%81%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0\">14.2 深度学习</a></li>\n<li><a href=\"#14.3%E3%80%81OpenCv\">14.3 OpenCv</a></li>\n<li><a href=\"#14.4%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89(CV)\">14.4 计算机视觉(CV)</a></li>\n<li><a href=\"#14.4%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89(CV)\">14.5 自然语言处理(NLP)</a></li>\n</ul>\n</li>\n<li><p><a href=\"#15%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\">15、设计模式</a></p>\n</li>\n<li><p><a href=\"#16%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80\">16、汇编语言</a></p>\n</li>\n<li><p><a href=\"#17%E3%80%81Git\">17、Git</a></p>\n</li>\n<li><p><a href=\"#18%E3%80%81%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3\">18、数学相关</a></p>\n</li>\n<li><p><a href=\"#19%E3%80%81%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%8A%9B%E6%8F%90%E5%8D%87\">19、程序员个人能力提升</a></p>\n</li>\n<li><p><a href=\"#20%E3%80%81%E5%85%B6%E4%BD%99%E8%B5%84%E6%96%99\">20、其余资料</a></p>\n</li>\n<li><p><a href=\"#21%E3%80%81%E7%A4%BE%E6%8B%9B%E6%A0%A1%E6%8B%9B%E5%90%84%E7%A7%8D%E9%9D%A2%E7%BB%8F%E6%B1%87%E6%80%BB\">21、社招校招各种面经汇总</a></p>\n</li>\n<li><p><a href=\"#%E6%88%91%E5%BB%BA%E8%AE%AE%E4%BD%A0%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%BB%A5%E5%90%8E%E8%82%AF%E5%AE%9A%E7%94%A8%E5%BE%97%E4%B8%8A\">22、我建议你下载，以后肯定用得上</a></p>\n</li>\n<li><p><a href=\"#Donate\">友情打赏</a></p>\n</li>\n</ul>\n<h4 id=\"00、C语言\"><a href=\"#00、C语言\" class=\"headerlink\" title=\"00、C语言\"></a><span id=\"00、C语言\">00、C语言</span></h4><ul>\n<li><p>《C程序设计语言（第二版）》 <a href=\"https://pan.baidu.com/s/1haNxg0Ett2MvCDc05N0O0g\">百度云链接</a>  提取码：2and </p>\n</li>\n<li><p>《C Primer Plus 中英版》 <a href=\"https://pan.baidu.com/s/1O8lJSj7P78NyffnKNG1pbw\">百度云链接</a> 提取码：2dox </p>\n</li>\n<li><p>《征服C指针》 <a href=\"https://pan.baidu.com/s/1rZYNFyDcuTsiQak4dUsmVQ\">百度云链接</a>   提取码：c7gx </p>\n</li>\n<li><p>《C陷阱与缺陷》 <a href=\"https://pan.baidu.com/s/1YiT2O6srFgtcYnK47gz8gA\">百度云链接</a> 提取码：rq3g </p>\n</li>\n<li><p>《C和指针中文版》 <a href=\"https://pan.baidu.com/s/1QANwu3qu1dq2JRaVmYxm7Q\">百度云链接</a> 提取码：1gt3 </p>\n</li>\n<li><p>《经典C程序100例》 <a href=\"https://pan.baidu.com/s/1AVcXE4i_iUJ3bh-QeRJzLA\">百度云链接</a>  提取码：juxk </p>\n</li>\n<li><p>《C专家编程》 <a href=\"https://pan.baidu.com/s/1rjer0Wmv2v3TclcBSJtAtQ\">百度云链接</a> 提取码：i4yp </p>\n</li>\n<li><p>《C语言深度解剖》 <a href=\"https://pan.baidu.com/s/100km3RzJcnwX2Kzr10_rTQ\">百度云链接</a>  提取码：zekk </p>\n</li>\n<li><p>《C语言解析教程》 <a href=\"https://pan.baidu.com/s/1n8Dny_r70OYtgIkcKisuxg\">百度云链接</a>  提取码：ndi3 </p>\n</li>\n<li><p>《C语言函数大全》 <a href=\"https://pan.baidu.com/s/1pJLgloXUCpyKLIzvPuP0LQ\">百度云链接</a> 提取码：peou </p>\n</li>\n<li><p>《C语言程序设计-现代方法》 <a href=\"https://pan.baidu.com/s/1DEbvpUOuIkcKC2DqY8Us_Q\">百度云链接</a> 提取码：kn4d </p>\n</li>\n<li><p>《C语言参考手册第五版》 <a href=\"https://pan.baidu.com/s/1AabhkPDP-MqLmw4V6GaGWA\">百度云链接</a>  提取码：0kjd </p>\n</li>\n<li><p>《C语言编程精粹》 <a href=\"https://pan.baidu.com/s/1vTsLTZ4-Q6r0JyAHnZAvUA\">百度云链接</a>  提取码：tior </p>\n</li>\n<li><p>《C程序设计语言（第2版新版）及其课后答案》 <a href=\"https://pan.baidu.com/s/1UZlIkyzwejAVNwVyYHq7qA\">百度云链接</a> 提取码：e4zs </p>\n</li>\n<li><p>《C程序设计语言（第2版英文）及其课后答案》 <a href=\"https://pan.baidu.com/s/1CcTYBiykp-RlVx8PwvE4sg\">百度云链接</a>  提取码：8s3d </p>\n</li>\n<li><p>《C程序设计语言(英文第2版)Prentice Hall.-.The C Programming Language(2nd Edition)》 <a href=\"https://pan.baidu.com/s/1wE_f5jLlKhPJbkHArocV5g\">百度云链接</a>  提取码：14x6</p>\n</li>\n</ul>\n<h4 id=\"01、C\"><a href=\"#01、C\" class=\"headerlink\" title=\"01、C++\"></a>01、C++</h4><ul>\n<li><p>《阿秀个人在学习C++过程中的笔记，包括黑马C++视频笔记，TCPIP网络编程笔记》 <a href=\"https://pan.baidu.com/s/18XAu8OTsJmX_sfZ1qpmCcw\">百度云链接</a>   提取码：fw8s</p>\n</li>\n<li><p>《<a href=\"https://mp.weixin.qq.com/s/PuZpyvFzYr7ZBqe5imS9BQ\">6个可以写在简历上的C++项目</a>》 <a href=\"https://pan.baidu.com/s/1efly72L--IaBt8prveuwwQ\">百度云链接</a>   提取码：sq61 </p>\n</li>\n<li><p>《<a href=\"https://mp.weixin.qq.com/s/IHh4p-Pd6x6UPHXJrlDgQg\">推荐一个不错的C++项目，我可能是发现这个项目的第一人</a>》  <a href=\"https://pan.baidu.com/s/1Mw6158y5ZtIfvSgTSqWd1A\">百度云链接</a>  提取码：s04w</p>\n</li>\n<li><p>《侯捷C++视频合集-包括C++面向对象开发&amp;STL标准库与源码解析&amp;C++内存管理机制&amp;C++新标准C++11&amp;14》 <a href=\"https://pan.baidu.com/s/1vbK1_zbyPySLR5nn5CLFvw\">百度云链接</a>     提取码：h5if </p>\n</li>\n<li><p>《陈硕-Linux&amp;C++ 网络编程实践》 <a href=\"https://pan.baidu.com/s/1ydTecrZg5V5wIVlFxshZKw\">百度云链接</a>   提取码：ubjp </p>\n</li>\n<li><p>《C++ Primer Plus》 <a href=\"https://pan.baidu.com/s/1TzMuz-lAwZYNptDET84F6g\">百度云链接</a> 提取码：zy86 </p>\n</li>\n<li><p>《C++ Primer(第五版)带书签 高清完整版》 <a href=\"https://pan.baidu.com/s/1ADj-FnyloWB4xeobjVimeA\">百度云链接</a> 提取码：ksax </p>\n</li>\n<li><p>《C++ Primer 习题集》 <a href=\"https://pan.baidu.com/s/1S_iGX7aWf_xHROheDr0LBw\">百度云链接</a> 提取码：yjqc </p>\n</li>\n<li><p>《C++ Primer 5th 英文版》 <a href=\"https://pan.baidu.com/s/1j3Xu_fxEYpIUWHN88HGjGg\">百度云链接</a> 提取码：zt2t </p>\n</li>\n<li><p>《C++ Primer-第4版》<a href=\"https://pan.baidu.com/s/1acriBigOzoY4sH2Ndwt8Rw\">百度云链接</a> 提取码：9vox </p>\n</li>\n<li><p>《C++ Templates》 <a href=\"https://pan.baidu.com/s/1P1aHoTzEQtMaRiOSLp9EAQ\">百度云链接</a> 提取码：d5at </p>\n</li>\n<li><p>《STL源码剖析 + 源码》 <a href=\"https://pan.baidu.com/s/10THUVaHbI1Bxl2jC8yTihQ\">百度云链接</a> 提取码：5j2e </p>\n</li>\n<li><p>《C++编程调试秘笈》 <a href=\"https://pan.baidu.com/s/14KoQ6rdGRI1uSO9xpFWqmg\">百度云链接</a> 提取码：9nc3 </p>\n</li>\n<li><p>《侯捷STL课件》 <a href=\"https://pan.baidu.com/s/1SHbg4JsZRQVQdGLrPxIG9A\">百度云链接</a> 提取码：3sta </p>\n</li>\n<li><p>《深度探索C++对象模型》 <a href=\"https://pan.baidu.com/s/1vLE-BjhYXRUWrZi9O-YPTQ\">百度云链接</a> 提取码：b706 </p>\n</li>\n<li><p>《深入理解C++11》 <a href=\"https://pan.baidu.com/s/1qcnizj9f3fwhaQikx7lMDg\">百度云链接</a> 提取码：n7rz </p>\n</li>\n<li><p>《提高C++性能的编程技术.左飞》 <a href=\"https://pan.baidu.com/s/1EhRbebB5VqVFcvv3QYiUhg\">百度云链接</a>  提取码：d2wk </p>\n</li>\n<li><p>《Effective-C++-第二版》<a href=\"https://pan.baidu.com/s/17PHddLiLYJ0ZuJc64jxL3A\">百度云链接</a>  提取码：4ha8 </p>\n</li>\n<li><p>《深入理解C++11新特性解析与应用》<a href=\"https://pan.baidu.com/s/1vFPvSLDxJWivUmZj-ntmwQ\">百度云链接</a>  提取码：b9hr </p>\n</li>\n<li><p>《Effective C++ 第三版 高清PDF》 <a href=\"https://pan.baidu.com/s/1DgblW6ia5MY4YUd4w8hG4A\">百度云链接</a> 提取码：drvd </p>\n</li>\n<li><p>《Effective STL中文版》 <a href=\"https://pan.baidu.com/s/1Di-1-MMHTAMe5_1oksJCpA\">百度云链接</a> 提取码：ifhx </p>\n</li>\n<li><p>《C++ 编程规范-101条规则准则与最佳实践》 <a href=\"https://pan.baidu.com/s/15yklDyd61mP9lzfWxTNhCg\">百度云链接</a> 提取码：evgk </p>\n</li>\n<li><p>《C++编程思想（两卷合订本）》 <a href=\"https://pan.baidu.com/s/1vf0Lx5cNj9cGlvI1XVS8Kg\">百度云链接</a> 提取码：8sba   </p>\n</li>\n<li><p>《C++并发编程实战》 <a href=\"https://pan.baidu.com/s/1xvTgDicB7LqFrwMMJQEPZQ\">百度云链接</a> 提取码：a6tw </p>\n</li>\n<li><p>《C++沉思录中文第二版》 <a href=\"https://pan.baidu.com/s/1YDYhVnwCW_23qXgMRu-t_Q\">百度云链接</a> 提取码：a1lk </p>\n</li>\n<li><p>《C++程序设计语言》 <a href=\"https://pan.baidu.com/s/1Jp2FkuoJ0SCpwRTr6HSaEA\">百度云链接</a> 提取码：ynhi </p>\n</li>\n<li><p>《C++ 大学教程》 <a href=\"https://pan.baidu.com/s/1viWM-CXCUoXrVtye0Xu63Q\">百度云链接</a> 提取码：pczs </p>\n</li>\n<li><p>《C++对象模型》 <a href=\"https://pan.baidu.com/s/1DMhs3yMmqH9jK0iH3FC-Fw\">百度云链接</a> 提取码：gaa7 </p>\n</li>\n<li><p>《C++工程实践经验课》 <a href=\"https://pan.baidu.com/s/10J3j5EHCQa4YSoOEMk9T_A\">百度云链接</a> 提取码：bzxi </p>\n</li>\n<li><p>《C++设计新思维-泛型编程与设计之应用》 <a href=\"https://pan.baidu.com/s/1ARk_xhfYEtb82f8bysrBog\">百度云链接</a> 提取码：5w6t </p>\n</li>\n<li><p>《Modern C++ Design》 <a href=\"https://pan.baidu.com/s/1i2HxMhsrUGL9A4kENjfiMA\">百度云链接</a> 提取码：7rcb </p>\n</li>\n<li><p>《C++实践工程学-陈硕》 <a href=\"https://pan.baidu.com/s/1-xFH5CtM5kbUylSgdc_AIw\">百度云链接</a> 提取码：3dwb </p>\n</li>\n<li><p>《跟我一起写makefile》 <a href=\"https://pan.baidu.com/s/1Rhcd4xnP0e7uqcnmLCKy_w\">百度云链接</a> 提取码：ei8h </p>\n</li>\n<li><p>《C++语言的设计和演化》 <a href=\"https://pan.baidu.com/s/1mL5auhf1tale3LLBRfOCxw\">百度云链接</a>  提取码：rii6 </p>\n</li>\n<li><p>《C++标准程序库—自修教程与参考手册》 <a href=\"https://pan.baidu.com/s/1r61wjBMyNeDzbM7mTzGy0Q\">百度云链接</a>   提取码：x2g8 </p>\n</li>\n<li><p>《泛型编程与STL中文版》 <a href=\"https://pan.baidu.com/s/18VMdxtwWOKZkh3_Dz1qE2w\">百度云链接</a>   提取码：rbcd </p>\n</li>\n<li><p>《More Exceptional C++中文版》 <a href=\"https://pan.baidu.com/s/1JXQFYVMfgaF6WbmyfMDc2g\">百度云链接</a>  提取码：tgcb</p>\n</li>\n</ul>\n<h4 id=\"02、Java\"><a href=\"#02、Java\" class=\"headerlink\" title=\"02、Java\"></a>02、Java</h4><h5 id=\"2-1、Java基础到进阶\"><a href=\"#2-1、Java基础到进阶\" class=\"headerlink\" title=\"2.1、Java基础到进阶\"></a>2.1、Java基础到进阶</h5><ul>\n<li>《深入分析JavaWeb技术内幕》 <a href=\"https://pan.baidu.com/s/1ALUZ-U0oqxxq-_5uGRZZhQ\">百度云链接</a> 提取码：g1qz </li>\n<li>《深入剖析Tomcat》 <a href=\"https://pan.baidu.com/s/1l4amHIQzRdppXLr08BX9Zg\">百度云链接</a>  提取码：o06x </li>\n<li>《Effective Java 2nd Edition 英文版》 <a href=\"https://pan.baidu.com/s/1uoU2FicD7xRHRPcKL0lOZw\">百度云链接</a>  提取码：czeq </li>\n<li>《Effective Java 中文第二版》 <a href=\"https://pan.baidu.com/s/1u3G6IRSiEQPK-i766kx7Bg\">百度云链接</a> 提取码：5p9e </li>\n<li>《Java性能优化权威指南》 <a href=\"https://pan.baidu.com/s/18wbGLR2FKYjEtvwSLuO53g\">百度云链接</a> 提取码：9g85 </li>\n<li>《Java核心技术(卷1）第8版》 <a href=\"https://pan.baidu.com/s/1dLyU_Ngybat-sjTYUQIVGQ\">百度云链接</a>  提取码：pmx2 </li>\n<li>《Java核心技术(卷2）第8版》 <a href=\"https://pan.baidu.com/s/13C_89pRjE3ccBmXr1GQVyA\">百度云链接</a>  提取码：in8y </li>\n<li>《Head First Java第二版涵盖java5.0》 <a href=\"https://pan.baidu.com/s/1vKNf1gqquCh0x8gcsVgWnA\">百度云链接</a> 提取码：qfz2 </li>\n<li>《Java 8 实战》 <a href=\"https://pan.baidu.com/s/1kxgntpEDq4kAzygasmJndQ\">百度云链接</a> 提取码：3ej1 </li>\n<li>《阿里巴巴Java开发手册、1.0.0公开版》   <a href=\"https://pan.baidu.com/s/16puKNw6Hl2FOibLxntAnrg\">百度云链接</a>    提取码：pl9v </li>\n<li>《阿里巴巴Java开发手册、1.1.0正式版》   <a href=\"https://pan.baidu.com/s/1h89f6LXQVXjPBzo-QCbVeQ\">百度云链接</a>   提取码：zrxy </li>\n<li>《阿里巴巴Java开发手册、1.2.0升级版》   <a href=\"https://pan.baidu.com/s/13kkSmXVlLJoESqVYHxcBQw\">百度云链接</a>   提取码: p350</li>\n<li>《阿里巴巴Java开发手册、1.3.0终极版》   <a href=\"https://pan.baidu.com/s/1iwVotVtFSDQgIo83gJARtw\">百度云链接</a>   提取码：ycoc </li>\n<li>《阿里巴巴Java开发手册、1.4.0详尽版》   <a href=\"https://pan.baidu.com/s/1CHAlcaUpeHVaYhboCsx2fQ\">百度云链接</a>   提取码：dya6 </li>\n<li>《阿里巴巴Java开发手册、华山版》   <a href=\"https://pan.baidu.com/s/1fmMyblrL2pZKxholhZrh3w\">百度云链接</a>   提取码：z3fh </li>\n<li>《阿里巴巴Java开发手册-嵩山版》   <a href=\"https://pan.baidu.com/s/1zQNtk7WuHjxu-XpfLCbqGw\">百度云链接</a>   提取码：z8mf </li>\n<li>《阿里巴巴Java开发手册、泰山版》   <a href=\"https://pan.baidu.com/s/1G40U8gnqKCTRC5N8jl6YKQ\">百度云链接</a>  提取码：6cxz </li>\n<li>《Java编程思想（第四版）》 <a href=\"https://pan.baidu.com/s/1exH0byT5YogMOmo7J1dDSQ\">百度云链接</a> 提取码：ogz5 </li>\n<li>《Java并发编程的艺术》 <a href=\"https://pan.baidu.com/s/1te0Uuz5bM1UURQzGBt1OxA\">百度云链接</a> 提取码：v8pj </li>\n<li>《JAVA并发编程实践》 <a href=\"https://pan.baidu.com/s/1ROwaQIPzhfkmSA-IjFAWgA\">百度云链接</a> 提取码：se4k </li>\n<li>《Java从小白到大牛精简版》 <a href=\"https://pan.baidu.com/s/1MzIRLTt8QwB5JNfuMZIXeA\">百度云链接</a> 提取码：zmer </li>\n<li>《Java核心技术卷1基础知识原书第10版》 <a href=\"https://pan.baidu.com/s/1QII6NBlHclyhbct5gESu1Q\">百度云链接</a> 提取码：c6d5 </li>\n<li>《Java核心技术卷2高级特性原书第10版》 <a href=\"https://pan.baidu.com/s/1MqJHgJIywE5HsIMhcZ3Nxw\">百度云链接</a>  提取码：gjlh </li>\n<li>《码出高效：Java开发手册》 <a href=\"https://pan.baidu.com/s/1gKnYgHl9hT5R4BDyiPXnMg\">百度云链接</a> 提取码：4i0f </li>\n<li>《阿里巴巴Java开发手册v1.2.0》 <a href=\"https://pan.baidu.com/s/174XVbFQadas1YNsf5o91gQ\">百度云链接</a> 提取码：129f </li>\n<li>《深入理解Java虚拟机：JVM高级特性与最佳实践（最新第二版）》 <a href=\"https://pan.baidu.com/s/1QlyCQQVelB20NcdV2DHcoA\">百度云链接</a> 提取码：qbfq </li>\n<li>《Camel in Action》 <a href=\"https://pan.baidu.com/s/1iRDPaCKzTqyBJyntuYqHAg\">百度云链接</a> 提取码：kcs0 </li>\n<li>《Head First Servlet and JSP(高清中文版)》 <a href=\"https://pan.baidu.com/s/1YqABaGl4tzZy5U3yzm2N4g\">百度云链接</a> 提取码：q55k </li>\n<li>《Maven实战（高清完整带书签）》 <a href=\"https://pan.baidu.com/s/1rZjjNs5OjYoSMtQfqB_y0w\">百度云链接</a> 提取码：4q4a </li>\n<li>《Spring 5 Recipes, 4th Edition》 <a href=\"https://pan.baidu.com/s/1xqPeJinO2Lpq9a4SmG-0bQ\">百度云链接</a> 提取码：o3uk </li>\n<li>《Spring in action 中文版（第4版）》 <a href=\"https://pan.baidu.com/s/1ZUm2XxWLjvZcyUqJfMGwAw\">百度云链接</a> 提取码：daya </li>\n<li>《轻量级JavaEE企业应用实战》 <a href=\"https://pan.baidu.com/s/1ZHicisOFzP9CoP-3tD1QKQ\">百度云链接</a>   提取码：1rn2 </li>\n<li>《ThinkInJava（JAVA编程思想）》 <a href=\"https://pan.baidu.com/s/1l-1rTjPakUxUZKWfE6kZeA\">百度云链接</a>  提取码：e5rp </li>\n<li>《Head First Java 中文高清版》 <a href=\"https://pan.baidu.com/s/19oFYnyPcNLTXH-ZrJVFlHw\">百度云链接</a>  提取码：yry8 </li>\n<li>《Netty in Action第五版》 <a href=\"https://pan.baidu.com/s/1y2tbY28qTq3NF5cY3ZaiXQ\">百度云链接</a>   提取码：ty0o </li>\n<li>《Java核心知识点整理》 <a href=\"https://pan.baidu.com/s/1XkMVhq7gUBdXWogNENT9LQ\">百度云链接</a>  提取码：3s2p </li>\n<li>《Java并发编程实践 英语版》 <a href=\"https://pan.baidu.com/s/10IcIPmx20GiYewVqx2uq3g\">百度云链接</a>  提取码：9mp0 </li>\n<li>《Effective Java（中文版第3版）》 <a href=\"https://pan.baidu.com/s/1-ufGk6AAMQ_Y1xWDZmryFw\">百度云链接</a>  提取码：ruo1 </li>\n<li>《Netty实战》 <a href=\"https://pan.baidu.com/s/1a6Fb7x1CX9ol2pRaAScfcA\">百度云链接</a>    提取码：rd2m </li>\n<li>《Spring实战（第4版）》 <a href=\"https://pan.baidu.com/s/1dtUTpLrnmz7G18ALF-pn2Q\">百度云链接</a>   提取码：7kfk </li>\n<li>《java从入门到精通（第4版）》 <a href=\"https://pan.baidu.com/s/1VXIU5ZhhgM9yZbCTc-_53g\">百度云链接</a>  提取码：movm </li>\n<li>《Spring.in.Action.5th.Edition》 <a href=\"https://pan.baidu.com/s/1LLMYTl4O-6VYE-pAXc_DjA\">百度云链接</a>   提取码：le2h </li>\n<li>《Spring 技术内幕》 <a href=\"https://pan.baidu.com/s/1BIvCo6DIeO1L4krcfmc7gg\">百度云链接</a>  提取码：gni3 </li>\n<li>《Java EE框架整合开发入门到实战：Spring+Spring MVC+MyBatis（微课版）》 <a href=\"https://pan.baidu.com/s/1WDYTZblZYcprboy99jWTcg\">百度云链接</a>  提取码：asxu </li>\n<li>《大型网站技术架构：核心原理与案例分析》 <a href=\"https://pan.baidu.com/s/1rg4wy2MLFJ2QLFJ0ZUk3Tw\">百度云链接</a>  提取码：q0ua </li>\n<li>《大话java性能优化》 <a href=\"https://pan.baidu.com/s/1Th4KRYD7Zd4-k80is_p0Ow\">百度云链接</a>  提取码：hfeg </li>\n<li>《分布式Java应用基础与实践》 <a href=\"https://pan.baidu.com/s/13pE0UvCDRdsBRvryzhyDxQ\">百度云链接</a>   提取码：dv70 </li>\n<li>《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）+(华章原创精品)+-+周志明》 <a href=\"https://pan.baidu.com/s/1nVSkeYvTW5BRF0VjV4SOOA\">百度云链接</a>  提取码：rs4z </li>\n<li>《Java核心技术(卷I)基础知识(原书第9版)》 <a href=\"https://pan.baidu.com/s/1APT2jNg_z_oT-9-Yuunfuw\">百度云链接</a>   提取码：4d76 </li>\n<li>《深入分析Java Web技术内幕 旧版》 <a href=\"https://pan.baidu.com/s/1SSs5GwTMFX-Oxo3_mijLyg\">百度云链接</a>  提取码：8s2v </li>\n<li>《SSM企业级框架实战》 <a href=\"https://pan.baidu.com/s/1BQNBTyb7xvsp5xDl9X0wbg\">百度云链接</a>   提取码：h5p2</li>\n</ul>\n<h5 id=\"2-2、Java-大数据\"><a href=\"#2-2、Java-大数据\" class=\"headerlink\" title=\"2.2、Java 大数据\"></a>2.2、Java 大数据</h5><ul>\n<li>《大数据架构师指南》 <a href=\"https://pan.baidu.com/s/1NtepEEqg6QlXW0mpgwJY4Q\">百度云链接</a>  提取码：vi00 </li>\n<li>《大数据之路：阿里巴巴大数据实践》 <a href=\"https://pan.baidu.com/s/1L8-ytWwG458IQ0pcN89gkg\">百度云链接</a>   提取码：xbco </li>\n<li>《深入理解Spark：核心思想与源码分析》 <a href=\"https://pan.baidu.com/s/1_wOyrysgbmXdFOrMZikm2Q\">百度云链接</a> 提取码：rkov </li>\n<li>《图解Spark 、 核心技术与案例实战》 <a href=\"https://pan.baidu.com/s/14qC88dEgX9zMwqRTvdSecA\">百度云链接</a>  提取码：kfaj </li>\n<li>《Apache+Kylin权威指南》 <a href=\"https://pan.baidu.com/s/1Y56PGhUkfKEDwoRRxV2nkQ\">百度云链接</a>  提取码：y31o </li>\n<li>《Hadoop The Definitive Guide》 <a href=\"https://pan.baidu.com/s/1BX0N_y4nerRHdQmcn7zSVg\">百度云链接</a>  提取码：ws9o </li>\n<li>《Hadoop技术内幕：深入理解MapReduce架构设计与实现原理》<a href=\"https://pan.baidu.com/s/1wRmSrFslfMYXw4tQ1ICG2w\">百度云链接</a>  提取码：afhy </li>\n<li>《Kafka &amp; Mafka技术分享及讨论》 <a href=\"https://pan.baidu.com/s/1vH-K8nqiLcHvOfJ2upAHiw\">百度云链接</a>  提取码：4u7i </li>\n<li>《Scala编程中文版(33章全)》 <a href=\"https://pan.baidu.com/s/1AGg5tC34KiacOztfu7F5sQ\">百度云链接</a>  提取码：6m1n </li>\n<li>《Spark大数据处理：技术、应用与性能优化(全)》 <a href=\"https://pan.baidu.com/s/1fy94A8lf17DPzE5l5SyREw\">百度云链接</a>  提取码：ghw3 </li>\n<li>《Spark机器学习》 <a href=\"https://pan.baidu.com/s/1-EBePGITd-xMR_u57b_roA\">百度云链接</a>  提取码：3li7 </li>\n<li>《Spark快速大数据分析》 <a href=\"https://pan.baidu.com/s/1j1o_E6wEu7AWK-rS3PVJHQ\">百度云链接</a>  提取码：jlqc </li>\n<li>《Spark最佳实践》 <a href=\"https://pan.baidu.com/s/1DswMXw66a6dqRcPfsDgB5w\">百度云链接</a>  提取码：ziy5 </li>\n<li>《ClickHouse中文文档》 <a href=\"https://pan.baidu.com/s/11FdgWUu4pm7pAGX007xuRQ\">百度云链接</a>   提取码：vjb3 </li>\n<li>《Flink基础教程》 <a href=\"https://pan.baidu.com/s/1RrgY8KKEu4R9xFvum16kpg\">百度云链接</a>  提取码：7ttp </li>\n<li>《CDH集群运维手册》 <a href=\"https://pan.baidu.com/s/1Vs8qAAfct6SqCII-NEsAwg\">百度云链接</a>  提取码：38qp </li>\n<li>《Elasticsearch.权威指南（中文版）》 <a href=\"https://pan.baidu.com/s/1QhZThm3O4yT2JhOaSDbptg\">百度云链接</a>   提取码：fmo0 </li>\n<li>《Hadoop应用架构》 <a href=\"https://pan.baidu.com/s/138cwS-hwADC-VfjXnpSOMQ\">百度云链接</a>   提取码：ezgg </li>\n<li>《Elasticsearch集成Hadoop最佳实践》 <a href=\"https://pan.baidu.com/s/1Hd_2n8OqcyM7ewcHzOgIYA\">百度云链接</a>   提取码：eiro </li>\n<li>《Apache Spark源码剖析》 <a href=\"https://pan.baidu.com/s/1v2ocTrQUuL9YYMKhSruEWw\">百度云链接</a>   提取码：pe9u </li>\n<li>《Flume构建高可用、可扩展的海量日志采集系统》 <a href=\"https://pan.baidu.com/s/1c297eE8UC4G2_9uNRHi79A\">百度云链接</a>   提取码：qxc4 </li>\n<li>《HBase_权威指南》 <a href=\"https://pan.baidu.com/s/1hN6dJGxbW_4vZsjKxFqLlg\">百度云链接</a>   提取码：y8bm </li>\n<li>《HBase实战中文版》 <a href=\"https://pan.baidu.com/s/1aUDxws8QGqiVaL1rSNYBaQ\">百度云链接</a>   提取码：6tek </li>\n<li>《Hive编程指南》 <a href=\"https://pan.baidu.com/s/1vxA0UYovVGPN9-QO27hOJA\">百度云链接</a>  提取码：a88l </li>\n<li>《HBase不睡觉书 带目录（高清）》 <a href=\"https://pan.baidu.com/s/1p8VGyUSRYHBf1NmyljV-zQ\">百度云链接</a>  提取码：wpmv </li>\n<li>《Apache Kafka实战》 <a href=\"https://pan.baidu.com/s/1YeaRpLrjVoBg-bwCaFx9Cw\">百度云链接</a>   提取码：1zdo </li>\n<li>《Mahout算法解析与案例实战》 <a href=\"https://pan.baidu.com/s/1Ae39bzWSlUXdnSfeJ78IZA\">百度云链接</a>   提取码：0vtf </li>\n<li>《Kafka权威指南(2018中文版)》 <a href=\"https://pan.baidu.com/s/1YrlPRpaqa7tLziEX9ohgyQ\">百度云链接</a>   提取码：nwrk </li>\n<li>《Kafka源码解析与实战》 <a href=\"https://pan.baidu.com/s/1CGfjE0BIVL9g9ri41X9kMA\">百度云链接</a>  提取码：t83m </li>\n<li>《MapReduce设计模式 [美.迈纳.舒克著]》 <a href=\"https://pan.baidu.com/s/1upYNCxt7No0talDDGZxMqQ\">百度云链接</a>  提取码：flxj </li>\n<li>《Spark快速数据处理》 <a href=\"https://pan.baidu.com/s/1d9TKEE-UZHndzg4KhbrVvg\">百度云链接</a>   提取码：4m6s </li>\n<li>《spark开发基础之Scala快餐》 <a href=\"https://pan.baidu.com/s/1AA1m3en-DuaWdeGxwZiwKA\">百度云链接</a>   提取码：hxz0 </li>\n<li>《Lucene实战（第2版）》 <a href=\"https://pan.baidu.com/s/1oLXp9q7GC4prxzsSUiPNJA\">百度云链接</a>   提取码：uot4 </li>\n<li>《Spark最佳实践陈欢，林世飞著》 <a href=\"https://pan.baidu.com/s/1VJYOam6wh9_ZbMbb5DvEiw\">百度云链接</a>   提取码：nmmq </li>\n<li>《Spark大数据分析核心概念技术及实践OCR》 <a href=\"https://pan.baidu.com/s/1m9eTHFolH_UUuZlGe8YefA\">百度云链接</a>   提取码：zbvo </li>\n<li>《Storm技术内幕与大数据实践》 <a href=\"https://pan.baidu.com/s/1hdd7zomaAnuvdB0WPWj59g\">百度云链接</a>   提取码：duju </li>\n<li>《Spark内核设计的艺术架构设计与实现（耿嘉安）》 <a href=\"https://pan.baidu.com/s/1T7sigw6XmDx_1J1sb6WUZg\">百度云链接</a>    提取码：xuww </li>\n<li>《Presto技术内幕》 <a href=\"https://pan.baidu.com/s/1J_t8S8jzK1H3yN6z13gyEA\">百度云链接</a>   提取码：tsw5 </li>\n<li>《决战大数据》 <a href=\"https://pan.baidu.com/s/1aYWTMBO1wfwgAlvC1xxrcA\">百度云链接</a>   提取码：eu4p </li>\n<li>《Apache Kafka源码剖析》 <a href=\"https://pan.baidu.com/s/12DvTslL0zbCe84GTg2ribw\">百度云链接</a>   提取码：qryy </li>\n<li>《从Paxos到Zookeeper  分布式一致性原理与实践》 <a href=\"https://pan.baidu.com/s/1yunwJmaCqpl4G4X_N6uTtQ\">百度云链接</a>  提取码：6iyn </li>\n<li>《可视化数据》 <a href=\"https://pan.baidu.com/s/1cmrBDzrMP_J4OVEZ-6OKQQ\">百度云链接</a>   提取码：f29x </li>\n<li>《基于Apache Kylin 构建大数据分析平台》 <a href=\"https://pan.baidu.com/s/1fSBhqGNzgoJG7rNc93AIXQ\">百度云链接</a>   提取码：vn2b </li>\n<li>《从零开始学Storm》 <a href=\"https://pan.baidu.com/s/1fctekVikyzNGjXnlxlG3dw\">百度云链接</a>   提取码：jfrn </li>\n<li>《最全的大数据解决方案》 <a href=\"https://pan.baidu.com/s/120wArPLKMgezx-xlT6ejkg\">百度云链接</a>   提取码：me79 </li>\n<li>《深入学习MongoDB》 <a href=\"https://pan.baidu.com/s/1ILBAPa6z6ipWjaIWgKJF_Q\">百度云链接</a>  提取码：4qzy </li>\n<li>《大数据技术原理与应用概念、存储、处理、分析与应用(第2版)》 <a href=\"https://pan.baidu.com/s/1ZacXfKqdR759h6q7at8dWQ\">百度云链接</a>   提取码：h10h </li>\n<li>《机器学习与数据挖掘方法和应用（经典）》 <a href=\"https://pan.baidu.com/s/17ewpQWcP-UUbGYcVtiVLag\">百度云链接</a>    提取码：ry6j </li>\n<li>《大数据Spark企业级实战版》 <a href=\"https://pan.baidu.com/s/12LMxppofExsFq_lt0hO4uw\">百度云链接</a>   提取码：v6im </li>\n<li>《实战Elasticsearch、Logstash、Kibana：分布式大数据搜索与日志挖掘及可视》 <a href=\"https://pan.baidu.com/s/1mOjfp2GHmsuo0Cfn_DjLZw\">百度云链接</a>   提取码：yrpe </li>\n<li>《深入理解Spark 核心思想与源码分析 耿嘉安著》 <a href=\"https://pan.baidu.com/s/1tBXiDkowwU5ep4R-wjrP4A\">百度云链接</a>  提取码：z2eu  </li>\n<li>《相关性搜索：利用Solr与Elasticsearch创建智能应用》 <a href=\"https://pan.baidu.com/s/1HnLiTnH0yJAgfpMpKsNddA\">百度云链接</a>   提取码：its4</li>\n</ul>\n<h5 id=\"2-3、Java工具\"><a href=\"#2-3、Java工具\" class=\"headerlink\" title=\"2.3、Java工具\"></a>2.3、Java工具</h5><ul>\n<li>《Java常见工具》 <a href=\"https://pan.baidu.com/s/1OAqk_Z3wa0sexuIE2HqVDg\">百度云链接</a>  提取码：agnz</li>\n</ul>\n<h4 id=\"03、Python\"><a href=\"#03、Python\" class=\"headerlink\" title=\"03、Python\"></a>03、Python</h4><h5 id=\"3-1、Python书籍\"><a href=\"#3-1、Python书籍\" class=\"headerlink\" title=\"3.1、Python书籍\"></a>3.1、Python书籍</h5><ul>\n<li>《编程小白的第一本Python入门书》 <a href=\"https://pan.baidu.com/s/1ZuwmzTlOGqmsSMSyxmfsog\">百度云链接</a>  提取码：bjl4 </li>\n<li>《笨办法学Python（第三版）》 <a href=\"https://pan.baidu.com/s/1ebex54bAnxr-8xrjAPWecw\">百度云链接</a>  提取码：516m </li>\n<li>《可爱的Python插图版_文字版》 <a href=\"https://pan.baidu.com/s/1zxL-3Wwea3CmRqDo41r8Mg\">百度云链接</a>  提取码：4yln </li>\n<li>《A Byte of Python3(中文版)》 <a href=\"https://pan.baidu.com/s/1yztl8hzdTpWpxpCorpzB5Q\">百度云链接</a>  提取码：ic4e </li>\n<li>《Python编程：从入门到实践》 <a href=\"https://pan.baidu.com/s/1Al63fjBymXsH-Eel4SgYrQ\">百度云链接</a>  提取码：tvw0 </li>\n<li>《Python3简明教程》 <a href=\"https://pan.baidu.com/s/1anQzjh8Y_vhzLk0V9I_Q4A\">百度云链接</a>  提取码：ue6k </li>\n<li>《Python编程初学者指南》 <a href=\"https://pan.baidu.com/s/1rWfRX7PdB8d4ZOMlbQavJg\">百度云链接</a>  提取码：90t7 </li>\n<li>《Python编程快速上手 让繁琐工作自动化》 <a href=\"https://pan.baidu.com/s/18GuxesQbHIH8eWAMXhgy0g\">百度云链接</a>  提取码：tpri </li>\n<li>《Python编程入门经典》 <a href=\"https://pan.baidu.com/s/10a5CLxFcWvwMPXletk-_kA\">百度云链接</a>   提取码：xyv2 </li>\n<li>《Python3.5.2-入门指南-高清》<a href=\"https://pan.baidu.com/s/1wu6c6rN5g2oF_18lp3or3A\">百度云链接</a>  提取码：ttgn </li>\n<li>《Python3.5.1入门指南中文版-带书签目录》 <a href=\"https://pan.baidu.com/s/1qSigiK5dxLRTKJxawXSqiw\">百度云链接</a>  提取码：chaa </li>\n<li>《Deep Learning  With Python》 <a href=\"https://pan.baidu.com/s/1xZDTV4imCMlWt1vH_aFmUA\">百度云链接</a>   提取码：gw8c </li>\n<li>《NumPy Basics》 <a href=\"https://pan.baidu.com/s/1qVJm3hNMSgKo9T29gD881Q\">百度云链接</a>  提取码：3prf </li>\n<li>《Pandas Basics》 <a href=\"https://pan.baidu.com/s/1JBrdSLZeCoaP1H5zjNSL1Q\">百度云链接</a>  提取码：oqwg </li>\n<li>《笨办法学Python（第四版）》 <a href=\"https://pan.baidu.com/s/1-G4H-6dPvS1LqcH5UjFMyA\">百度云链接</a>  提取码：zr14 </li>\n<li>《Python Cookbook（第3版）中文版》 <a href=\"https://pan.baidu.com/s/1nMxg7kck9fj86cn6SGWklg\">百度云链接</a>  提取码：8gsx </li>\n<li>《Python操作word,excel,pdf》 <a href=\"https://pan.baidu.com/s/1izQZpqM5x3AkwsUlkSQiVA\">百度云链接</a>  提取码：foas </li>\n<li>《Python高级编程第2版 张亮 阿信（译）完整版》 <a href=\"https://pan.baidu.com/s/1EGb1dKaZMeAoioi4FJhuuQ\">百度云链接</a>  提取码：ydku </li>\n<li>《Python核心编程 第3版 中文版》 <a href=\"https://pan.baidu.com/s/1TvqZpEJtBi5bxg2htTjd5g\">百度云链接</a>  提取码：umlb </li>\n<li>《Python核心编程翻译版第二版》 <a href=\"https://pan.baidu.com/s/1ceg53dJIziyZLu2kl-QT1Q\">百度云链接</a>  提取码：5gg3 </li>\n<li>《Python灰帽子—黑客与逆向工程师的Python编程之道》 <a href=\"https://pan.baidu.com/s/1Nvsrh_2qK2BahQ0_zhJNOw\">百度云链接</a>  提取码：9vo0 </li>\n<li>《Python基础教程（第二版）》 <a href=\"https://pan.baidu.com/s/1nbFJI0pfWVtiTX7duab_iA\">百度云链接</a>  提取码：r10m </li>\n<li>《Python开发技术详解》 <a href=\"https://pan.baidu.com/s/1D4DtRUHZG1z3XTQIP1U7rQ\">百度云链接</a>  提取码：r6ca </li>\n<li>《Python开发实战》 <a href=\"https://pan.baidu.com/s/1T82h4i0ALu09LqbtP6_bpA\">百度云链接</a>  提取码：9qce </li>\n<li>《Python入门教材(中文)》 <a href=\"https://pan.baidu.com/s/1fazYRtZuPwe8oKaVSLWRhA\">百度云链接</a>  提取码：d90e </li>\n<li>《Python数据处理》 <a href=\"https://pan.baidu.com/s/1SccYA_iWwagWwYJ5M1cuNQ\">百度云链接</a>  提取码：yqvb </li>\n<li>《Python网络编程基础》 <a href=\"https://pan.baidu.com/s/1prcpoVAr74T0b6YEgh7Z8g\">百度云链接</a>  提取码：neke </li>\n<li>《Python学习手册(第4版)》 <a href=\"https://pan.baidu.com/s/1e9miZ4j3jIgaGRluWfJXnQ\">百度云链接</a>  提取码：gsio </li>\n<li>《Python正则表达式-深入浅出》 <a href=\"https://pan.baidu.com/s/1Xidv2uZWHTcIz3FYZZYW3g\">百度云链接</a>  提取码：sw5p </li>\n<li>《Python知识手册-V2.0.1》 <a href=\"https://pan.baidu.com/s/1RvTAeCtOytVFAVfdmmJr6w\">百度云链接</a>  提取码：98a6 </li>\n<li>《Django.JavaScript.Integration.AJAX.and.jQuery》 <a href=\"https://pan.baidu.com/s/1giS6ICt46pKXaQXTWU6tWg\">百度云链接</a>   提取码：tiup </li>\n<li>《mod_python手册》 <a href=\"https://pan.baidu.com/s/1sd2uTJBFull0wUrOI39USg\">百度云链接</a>   提取码：q42d </li>\n<li>《python-basic》 <a href=\"https://pan.baidu.com/s/1SQipRbStAc54vgxLN3GDSw\">百度云链接</a>   提取码：1abg </li>\n<li>《Python.Essential.Reference,3rd.Edition》 <a href=\"https://pan.baidu.com/s/1RPga_Kj3CiNBe6IxkcEs9g\">百度云链接</a>   提取码：hhkc </li>\n<li>《Python.UNIX和Linux系统管理指南》 <a href=\"https://pan.baidu.com/s/1Zp0vBpoa_hzq9fsrJG0d0A\">百度云链接</a>   提取码：lno0 </li>\n<li>《Head_First_Python（中文版）》 <a href=\"https://pan.baidu.com/s/1HXrdZv6wzVrpveNLb9TZ0Q\">百度云链接</a>   提取码：45kr </li>\n<li>《Python.Cookbook(第2版)中文版》 <a href=\"https://pan.baidu.com/s/1rBjLppqDeWjm4N8AS9bUpw\">百度云链接</a>  提取码：zsw4 </li>\n<li>《Python技术参考大全》 <a href=\"https://pan.baidu.com/s/1hminDwWjEraoBeB9Ujun8w\">百度云链接</a>   提取码：mugz </li>\n<li>《Python入门指南 2.5b》 <a href=\"https://pan.baidu.com/s/1w7M08ej77cl7i9cfFx4OVQ\">百度云链接</a>  提取码：82s3 </li>\n<li>《Python3程序开发指南.第二版(带书签)》 <a href=\"https://pan.baidu.com/s/15LtRh6XacQYNXZxi5Q7u2Q\">百度云链接</a>    提取码：gepi </li>\n<li>《python标准库中文版PDF(带章节书签)》 <a href=\"https://pan.baidu.com/s/14qaj1p07wnrLfvPXlZOo5A\">百度云链接</a>    提取码：dnxu </li>\n<li>《Python参考手册(第4版)》 <a href=\"https://pan.baidu.com/s/1alALXeSdsyBNBsEPaAPF9A\">百度云链接</a>    提取码：azjk </li>\n<li>《python程序员指南中文版》 <a href=\"https://pan.baidu.com/s/1ubmuxQc8CcRAknZRQXr5SQ\">百度云链接</a>    提取码：0ia6 </li>\n<li>《Python学习手册(第3版)》 <a href=\"https://pan.baidu.com/s/1f197WOHN9c9mjkUQ7i3WTg\">百度云链接</a>    提取码：2pla </li>\n<li>《think-python》 <a href=\"https://pan.baidu.com/s/1pdIn6cFKALuFZPbHQp4goA\">百度云链接</a>    提取码：vt8r </li>\n<li>《think python2》 <a href=\"https://pan.baidu.com/s/1lePK-L11Vix9GStATx2rzw\">百度云链接</a>    提取码: vaof</li>\n<li>《Python技术手册(第2版)》 <a href=\"https://pan.baidu.com/s/1j3LP-AtRkh6_dNl25Qlxeg\">百度云链接</a>     提取码：iovv </li>\n<li>《Python进阶》 <a href=\"https://pan.baidu.com/s/1djVxEMYDDGruBlZgzDjpYQ\">百度云链接</a>     提取码：4f3r </li>\n<li>《python编程金典》 <a href=\"https://pan.baidu.com/s/1_nk1ANCwIx9OxxhQ7JK7Xg\">百度云链接</a>     提取码：q3mu </li>\n<li>《Python高级编程》 <a href=\"https://pan.baidu.com/s/1_IjVqkINdbGxMT13ViA9RQ\">百度云链接</a>      提取码：gi6z</li>\n</ul>\n<h5 id=\"3-2、Python爬虫\"><a href=\"#3-2、Python爬虫\" class=\"headerlink\" title=\"3.2、Python爬虫\"></a>3.2、Python爬虫</h5><ul>\n<li>《Python3网络爬虫数据采集》 <a href=\"https://pan.baidu.com/s/1OLmGm-IZOtwKrRRRpVu5xw\">百度云链接</a>  提取码：jkk3 </li>\n<li>《精通Scrapy网络爬虫、刘硕》  <a href=\"https://pan.baidu.com/s/1wV51nhVt0dYMczMEJGjoww\">百度云链接</a>  提取码：0f1v </li>\n<li>《用Python写网络爬虫》 <a href=\"https://pan.baidu.com/s/160g7nG95o4qoI3ajaCrRbw\">百度云链接</a>  提取码：657p </li>\n<li>《Python和数据分析》 <a href=\"https://pan.baidu.com/s/1RpRNDSWnpHDf4M2qxJ-RWQ\">百度云链接</a>    提取码：wmlk </li>\n<li>《Data Structures and Algorithms in Python [Goodrich, Tamassia &amp; Goldwasser 2013-03-18]》 <a href=\"https://pan.baidu.com/s/1SM4peGzGMNR-JS3xoGOLVA\">百度云链接</a>   提取码：41qe</li>\n</ul>\n<h5 id=\"3-3、Python数据分析\"><a href=\"#3-3、Python数据分析\" class=\"headerlink\" title=\"3.3、Python数据分析\"></a>3.3、Python数据分析</h5><ul>\n<li>《B站-七周成为数据分析师》 <a href=\"https://pan.baidu.com/s/1k6SC07XNCnaVtDgOOIUXdg\">百度云链接</a>  提取码：iw7k </li>\n<li>《B站-Python3数据分析与挖掘建模实战》 <a href=\"https://pan.baidu.com/s/1iLj3p5IXWTsTPb_4tGJ70w\">百度云链接</a>  提取码：q43k </li>\n<li>《B站_用Tableau做数据分析》 <a href=\"https://pan.baidu.com/s/1G0LthnGlfKCzGZ2dmQO-Bg\">百度云链接</a>  提取码：v1l2 </li>\n<li>《Python for Data Analysis》 <a href=\"https://pan.baidu.com/s/1W3ONWyrEojbDJvMENN8JZg\">百度云链接</a>  提取码：fdla </li>\n<li>《Python金融大数据分析》 <a href=\"https://pan.baidu.com/s/1be4PpHYhNI7ulWYEIf6REg\">百度云链接</a>  提取码：8bb7 </li>\n<li>《Python科学计算与数据分析》 <a href=\"https://pan.baidu.com/s/1p_zmvXjMlcpLbNlYoYBK1g\">百度云链接</a>  提取码：yu6t </li>\n<li>《Python数据分析基础》 <a href=\"https://pan.baidu.com/s/1yr7PeYPJE9xzNcjKnBeknQ\">百度云链接</a>  提取码：n5et </li>\n<li>《利用Python进行数据分析》 <a href=\"https://pan.baidu.com/s/1HMfse3neYt2FWfIumR3T3Q\">百度云链接</a>  提取码：o5jb </li>\n<li>《Python数据分析基础教程：NumPy学习指南（第2版）》 <a href=\"https://pan.baidu.com/s/1KTNQucI3t_g-llW5NX9kHw\">百度云链接</a>   提取码：lq48 </li>\n<li>《Python数据分析实战_2016版》 <a href=\"https://pan.baidu.com/s/1BdFVwiFbix-yveuItPn2Pw\">百度云链接</a>  提取码：0yue </li>\n<li>《Python数据分析与挖掘实战》 <a href=\"https://pan.baidu.com/s/1MNC4LCxoXXrakLLBYs4YqA\">百度云链接</a>  提取码：8qjq </li>\n<li>《Tableau：数据可视化之极速BI》 <a href=\"https://pan.baidu.com/s/12lOA4AipHGaNph-SYesBCQ\">百度云链接</a>  提取码：59ey </li>\n<li>《Tableau：数据可视化之极速BI数据源》 <a href=\"https://pan.baidu.com/s/1j9L2Oui6q1bSZ26ZdT1YvA\">百度云链接</a>  提取码：kdrw </li>\n<li>《Tableau商业智能与可视化应用实战》 <a href=\"https://pan.baidu.com/s/10n85f0LsKmIK5FV3lmlr3A\">百度云链接</a>  提取码：ptkp </li>\n<li>《Python数据分析14天入门训练营》课程资料 <a href=\"https://pan.baidu.com/s/1vDNlNNsz6GUVJaROkf2kRQ\">百度云链接</a>  提取码：sr2z </li>\n<li>《触手可及的大数据分析工具：Tableau案例集 数据源》 <a href=\"https://pan.baidu.com/s/17wKWXhmnGaKGAnWkj4evmQ\">百度云链接</a>  提取码：ff3n </li>\n<li>《触手可及的大数据分析工具 Tableau案例集》 <a href=\"https://pan.baidu.com/s/1vvnlry-nc_tQ3sgpqzSZUQ\">百度云链接</a>  提取码：pjym </li>\n<li>《大数据分析精品资料》 <a href=\"https://pan.baidu.com/s/17TBwSey21_HsSq2N8cndqA\">百度云链接</a>   提取码：fs3o </li>\n<li>《利用Python进行数据分析-第二版》 <a href=\"https://pan.baidu.com/s/1rmnrrg3kQiOtOtzmnWN-Jw\">百度云链接</a>  提取码：2hdl </li>\n<li>《人人都是数据分析师：Tableau应用实战》 <a href=\"https://pan.baidu.com/s/1pMR94zfb8kaPr_1HsOYe_A\">百度云链接</a>  提取码：yfq7 </li>\n<li>《数据分析实战》 <a href=\"https://pan.baidu.com/s/1RsqfSfRyeeXTasz3VXAykA\">百度云链接</a>  提取码：7sw2 </li>\n<li>《数据分析修炼手册》 <a href=\"https://pan.baidu.com/s/1cinQiucE4K7k4GISfll2JA\">百度云链接</a>  提取码：qfs7 </li>\n<li>《数据分析学习顺序》 <a href=\"https://pan.baidu.com/s/1bnqCMfn74ATTb-Nt1l1yJQ\">百度云链接</a>  提取码：9dy8 </li>\n<li>《增长黑客_创业公司的用户与收入增长秘籍、范冰》 <a href=\"https://pan.baidu.com/s/1M1ZZblb3RAM0HjlnKEBpkw\">百度云链接</a>  提取码：llq2</li>\n</ul>\n<h5 id=\"3-4、Python数据可视化\"><a href=\"#3-4、Python数据可视化\" class=\"headerlink\" title=\"3.4、Python数据可视化\"></a>3.4、Python数据可视化</h5><ul>\n<li><p>《Python数据可视化编程实战》 <a href=\"https://pan.baidu.com/s/1sBuA63eBEuAJhhHOYJLUSw\">百度云链接</a>  提取码：iglx </p>\n</li>\n<li><p>《数据可视化之美》 <a href=\"https://pan.baidu.com/s/10Xe1KJvFHYGUy4vnPQbGAQ\">百度云链接</a>  提取码：snio</p>\n</li>\n</ul>\n<h5 id=\"3-5、Python数据挖掘\"><a href=\"#3-5、Python数据挖掘\" class=\"headerlink\" title=\"3.5、Python数据挖掘\"></a>3.5、Python数据挖掘</h5><ul>\n<li><p>《Python编程-数据挖掘入门与实践(中文完整版)-图灵程序》 <a href=\"https://pan.baidu.com/s/1Ynu2E8WJcLi5-F4hD7MqMQ\">百度云链接</a>  提取码：22c2 </p>\n</li>\n<li><p>《Python数据挖掘入门与实践》 <a href=\"https://pan.baidu.com/s/1n_P0BtKe-WBfbUMPy1dWvw\">百度云链接</a>  提取码：1r46 </p>\n</li>\n<li><p>《数据挖掘导论、完整版》 <a href=\"https://pan.baidu.com/s/1BqtnKZZWH3an4nSQN7PScw\">百度云链接</a> 提取码：c8dx  </p>\n</li>\n<li><p>《数据挖掘原理与算法》 <a href=\"https://pan.baidu.com/s/1G2Uh0Om20IYJwNImA4fKFw\">百度云链接</a>  提取码：yx67</p>\n</li>\n</ul>\n<h4 id=\"04、Go语言\"><a href=\"#04、Go语言\" class=\"headerlink\" title=\"04、Go语言\"></a>04、Go语言</h4><ul>\n<li><p>《Go Web 编程》 <a href=\"https://pan.baidu.com/s/1XHGe8wFZ_x3UeGyzgyMARA\">百度云链接</a>   提取码：h9qu </p>\n</li>\n<li><p>《Go并发编程实战》 <a href=\"https://pan.baidu.com/s/15m5sR-2S6xF57vDW9Qi0Fg\">百度云链接</a>  提取码：7t2d </p>\n</li>\n<li><p>《Go语言编程》 <a href=\"https://pan.baidu.com/s/1ia7WPlnzOOOkKvytqfF6Gw\">百度云链接</a>   提取码：o2fn </p>\n</li>\n<li><p>《Go语言标准库参考》 <a href=\"https://pan.baidu.com/s/1_pVFevjGCDgPrDlVB-E7Ug\">百度云链接</a>  提取码：ygbj </p>\n</li>\n<li><p>《Go语言程序设计》 <a href=\"https://pan.baidu.com/s/1_MEFLoQvaHcKlOkHgFzrZw\">百度云链接</a>  提取码：rbuo </p>\n</li>\n<li><p>《Go语言圣经》 <a href=\"https://pan.baidu.com/s/1k1t5EFdvauob2uzu4gAizQ\">百度云链接</a> 提取码：7qhr  </p>\n</li>\n<li><p>《Go语言实战》 <a href=\"https://pan.baidu.com/s/19jTChKmcy566H2yaUOUgiQ\">百度云链接</a>  提取码：aqjp </p>\n</li>\n<li><p>《Go语言学习笔记》 <a href=\"https://pan.baidu.com/s/1yrmiUv_3x7SGuYYiXAj3LA\">百度云链接</a>  提取码：zj1d </p>\n</li>\n<li><p>《学习 Go 语言(Golang)》 <a href=\"https://pan.baidu.com/s/1eQrTmd7tAGQmwEl_sKWShg\">百度云链接</a>  提取码：d98t</p>\n</li>\n</ul>\n<h4 id=\"05、数据结构与算法\"><a href=\"#05、数据结构与算法\" class=\"headerlink\" title=\"05、数据结构与算法\"></a>05、数据结构与算法</h4><ul>\n<li>《谷歌大佬总结的三本LeetCode刷题笔记，支持Java、C++、Go三种语言》 <a href=\"https://pan.baidu.com/s/14_G6dHVpi7KFJ2NH3SC7IQ\">百度云链接</a>  提取码：ujuc  </li>\n<li>《啊哈！算法 哈磊》 <a href=\"https://pan.baidu.com/s/1ShKCKjoTIeThwQf0oHc_8w\">百度云链接</a>  提取码：5fop </li>\n<li>《大话数据结构》 <a href=\"https://pan.baidu.com/s/1qedzjHo_mFTrUvcFXm44tg\">百度云链接</a> 提取码：ehu4  </li>\n<li>《背包九讲》 <a href=\"https://pan.baidu.com/s/1kg20UyREHVzuGZQANhTmfQ\">百度云链接</a>  提取码：8ioa </li>\n<li>《带你快速刷完67道剑指offer》 <a href=\"https://pan.baidu.com/s/1s7Pxb12RtnfH48ps2BiCrA\">百度云链接</a>   提取码：dxm0 </li>\n<li>《编程之美-完整版》 <a href=\"https://pan.baidu.com/s/1_wwULGQtjwI_MR0_biZvUA\">百度云链接</a>  提取码：yumy </li>\n<li>《编程珠玑 第二版 人民邮电出版社》 <a href=\"https://pan.baidu.com/s/1SYhLeAXyDWXEw-FPPFsGHQ\">百度云链接</a>  提取码：gqg5 </li>\n<li>《编程珠玑 英文第二版-Programming.Pearls》 <a href=\"https://pan.baidu.com/s/14L8E-vG9efQKr_f0EkqX-Q\">百度云链接</a>  提取码：xsdt </li>\n<li>《程序员代码面试指南 IT名企算法与数据结构题目最优解（左程云著）》 <a href=\"https://pan.baidu.com/s/1joDK8w23976nwVugfgYQHg\">百度云链接</a> 提取码：p6r8 </li>\n<li>《程序员的算法趣题》 <a href=\"https://pan.baidu.com/s/11R4BUkD24rIMDhQoxp1Odw\">百度云链接</a>  提取码：1r8q </li>\n<li>《程序员面试金典》 <a href=\"https://pan.baidu.com/s/1BrwDEX6qJAcTRemwZpNm2g\">百度云链接</a>  提取码：7k9q </li>\n<li>《计算机程序设计艺术卷1：基本算法》 <a href=\"https://pan.baidu.com/s/1WDSHk8N5sjzXna_he8LZ6w\">百度云链接</a>  提取码：4ey6 </li>\n<li>《计算机程序设计艺术卷2：半数值算法》 <a href=\"https://pan.baidu.com/s/1EeiGyvuzyvloQkH7_b9zZA\">百度云链接</a>  提取码：tmep </li>\n<li>《计算机程序设计艺术卷3：排序与查找》 <a href=\"https://pan.baidu.com/s/1secLsfX8_d2bnsR7b9EJFA\">百度云链接</a> 提取码：ebud </li>\n<li>《剑指Offer》 <a href=\"https://pan.baidu.com/s/1ZpLaXTtkX1MMuD9bu_3oHQ\">百度云链接</a>  提取码：20z4</li>\n<li>《漫画算法：小灰的算法之旅》 <a href=\"https://pan.baidu.com/s/1FkP7Axl6s23p2jF56unqwg\">百度云链接</a> 提取码：2fof  </li>\n<li>《妙趣横生的算法（C语言实现 第2版）》 <a href=\"https://pan.baidu.com/s/1Wxyl6EFPOctNU0ZgpHA_ig\">百度云链接</a> 提取码：uvm8 </li>\n<li>《数据结构-C语言 严蔚敏 pdf》 <a href=\"https://pan.baidu.com/s/1L3f5zLWRZN4-1kKD-CA5NA\">百度云链接</a>  提取码：g0o5 </li>\n<li>《严蔚敏：数据结构题集(C语言版)》 <a href=\"https://pan.baidu.com/s/1_jpX6NYUIqE2BQmYYdT4aA\">百度云链接</a>  提取码：u7m0 </li>\n<li>《数据结构与算法 Python语言描述_裘宗燕》 <a href=\"https://pan.baidu.com/s/11Z_Cs4_MQIxhJyhz_AJXQg\">百度云链接</a>  提取码：1c9u </li>\n<li>《数据结构与算法分析C++描述》 <a href=\"https://pan.baidu.com/s/186SUUTsuQzoqe4dbxUYWNg\">百度云链接</a>   提取码：nhnz </li>\n<li>《数据结构与算法分析—Java语言描述》 <a href=\"https://pan.baidu.com/s/1kTbnQhh3XeXu8e_XRRU85Q\">百度云链接</a>  提取码：cyn6 </li>\n<li>《数据结构与算法分析：C语言描述原书第2版 高清版》 <a href=\"https://pan.baidu.com/s/1jSuFAqBmtKNqB84SjuWI9Q\">百度云链接</a>   提取码：gy53 </li>\n<li>《算法（第4版）》 <a href=\"https://pan.baidu.com/s/1N6UcwKech2x_Ixde9vXFRw\">百度云链接</a>   提取码：e65w </li>\n<li>《算法导论原书第3版》 <a href=\"https://pan.baidu.com/s/1mX7CVpIyDcjkHuqy98orpA\">百度云链接</a>  提取码：xl63 </li>\n<li>《算法导论中文版》 <a href=\"https://pan.baidu.com/s/11B72LuPWUAzsTn1c1TPSwA\">百度云链接</a>  提取码：okm5 </li>\n<li>《算法分析与设计》 <a href=\"https://pan.baidu.com/s/1TnxVZkwfuQwWzK6kDAgA7w\">百度云链接</a>  提取码：mmcx </li>\n<li>《算法谜题》 <a href=\"https://pan.baidu.com/s/1c2egFp2ME7ItqPLJPqyt1g\">百度云链接</a>  提取码：tq0f </li>\n<li>《算法图解》 <a href=\"https://pan.baidu.com/s/1xTOT6otkrwY3Pw5JGqaiHA\">百度云链接</a>  提取码：i2k7 </li>\n<li>《挑战程序设计竞赛(第1版)》 <a href=\"https://pan.baidu.com/s/1oEfnV0xou7VLveCNsEv7Kw\">百度云链接</a>    提取码：gm3c </li>\n<li>《挑战程序设计竞赛(第2版)》 <a href=\"https://pan.baidu.com/s/1_Q9kpWu1tQC9lIIkSGx1zQ\">百度云链接</a>    提取码：app8 </li>\n<li>《Cookbook-LeetCode》 <a href=\"https://pan.baidu.com/s/1lExDvtaqr-IWxvT1AHBE1g\">百度云链接</a>  提取码：evzs </li>\n<li>《Cormen-Introduction to Algorithms》 <a href=\"https://pan.baidu.com/s/17rtAshLD_kPrk3ohKbxbkg\">百度云链接</a>  提取码：unt9 </li>\n<li>《JavaScrit数据结构与算法（第2版）》 <a href=\"https://pan.baidu.com/s/1Eq-DcxfBqyMKP1zEyEQ6vg\">百度云链接</a>  提取码：sbxc </li>\n<li>《Java数据结构和算法.（第二版）》 <a href=\"https://pan.baidu.com/s/1kQydNS6uqW7r7xDLDd8N1Q\">百度云链接</a>  提取码：owjm </li>\n<li>《labuladong的算法小抄官方完整版》 <a href=\"https://pan.baidu.com/s/1qLczv399rEbhXO_fP1yp0Q\">百度云链接</a>   提取码：x3uv </li>\n<li>《Sedgewick-Algorithms》 <a href=\"https://pan.baidu.com/s/1HXbonThL98N-uGgIDPq0Og\">百度云链接</a>  提取码：reyi </li>\n<li>《Data-Structures-Problem-Solving-Using-Java》 <a href=\"https://pan.baidu.com/s/1m2HQcZa4mr1POkCBm3JIYA\">百度云链接</a>   提取码：mkvu </li>\n<li>《leetcode-solution》 <a href=\"https://pan.baidu.com/s/1iQHRdcPPkrqHTZJNgBWMkw\">百度云链接</a>   提取码：zfdq </li>\n<li>《算法竞赛入门经典训练指南》 <a href=\"https://pan.baidu.com/s/1EGOZdzjHpLG-Gn7hiN5nDg\">百度云链接</a>   提取码：ktkh </li>\n<li>《算法竞赛入门经典及答案》 <a href=\"https://pan.baidu.com/s/1Jm4sjlHyrEI6-8SJNwfjwQ\">百度云链接</a>   提取码：hw1u </li>\n<li>《分布式算法导论》 <a href=\"https://pan.baidu.com/s/1Nbwrr8ukzDXgcwVAz7_x7w\">百度云链接</a>   提取码：i8oy </li>\n<li>《算法之道》 <a href=\"https://pan.baidu.com/s/1bYsTGe5DoBfBonY3YcZVDw\">百度云链接</a>   提取码：f2td </li>\n<li>《C++数据结构与算法 （第4版）带书签目录 完整版》 <a href=\"https://pan.baidu.com/s/1t1bsfdO6MbrPE9MNurkHew\">百度云链接</a>   提取码：6yyw </li>\n<li>《趣学算法》 <a href=\"https://pan.baidu.com/s/16pUBD7NDO8190Q_9La5IRQ\">百度云链接</a>  提取码：lkah</li>\n</ul>\n<h4 id=\"06、操作系统\"><a href=\"#06、操作系统\" class=\"headerlink\" title=\"06、操作系统\"></a>06、操作系统</h4><ul>\n<li>《深入理解计算机系统 第3版》 <a href=\"https://pan.baidu.com/s/1_J-lMdgmx_Pjw0B-mB3cOA\">百度云链接</a>   提取码：rqey </li>\n<li>《现代操作系统、英文版》 <a href=\"https://pan.baidu.com/s/11uvYULUEOm-Wu827PX1i-g\">百度云链接</a>   提取码：9kvb </li>\n<li>《现代操作系统（第三版）中文版》 <a href=\"https://pan.baidu.com/s/1Wfzq1gWF9dEaXVgSXoLKgQ\">百度云链接</a>   提取码：qmfc </li>\n<li>《30天自制操作系统 (图灵程序设计丛书)》 <a href=\"https://pan.baidu.com/s/1oY_pKauVOso44BKKKU8pYQ\">百度云链接</a>   提取码：vtbf </li>\n<li>《操作系统设计与实现》 <a href=\"https://pan.baidu.com/s/1Rp7orpMgo1rjU59GGMo_mg\">百度云链接</a>   提取码：fvo8 </li>\n<li>《操作系统真象还原》 <a href=\"https://pan.baidu.com/s/11_ZXZ0415gKbuhwTKf66hw\">百度云链接</a>    提取码：blrx </li>\n<li>《操作系统精髓与设计原理 第6版》 <a href=\"https://pan.baidu.com/s/1NAUB37lqUwkGvHpi3O-1xQ\">百度云链接</a>   提取码：y7pk </li>\n<li>《操作系统精髓与设计原理 第8版》 <a href=\"https://pan.baidu.com/s/1TD_TFEcXwV8xxxA10hDBXg\">百度云链接</a>   提取码：buzn </li>\n<li>《自己动手写操作系统》 <a href=\"https://pan.baidu.com/s/1rpTNR_f5VgTtVy-swSim9w\">百度云链接</a>   提取码：zzvy </li>\n<li>《CMU2017-Lab》 <a href=\"https://pan.baidu.com/s/1YjrpbkoJ3QEbgduCGBV10A\">百度云链接</a>    提取码：fabh </li>\n<li>《Compilers_ Principles, Techniques, and Tools》 <a href=\"https://pan.baidu.com/s/1bxyVbHGZv8TkFMe4pVGMUw\">百度云链接</a>   提取码：o3h5 </li>\n<li>《Computer Systems_ A Programmer’s Perspective》 <a href=\"https://pan.baidu.com/s/1DfRNQzaDTVSTItkLPHTqbA\">百度云链接</a>   提取码：p5kp </li>\n<li>《Orange’s一个操作系统的实现》 <a href=\"https://pan.baidu.com/s/1BucJk6YqXzGAIiBI6oAwyQ\">百度云链接</a>   提取码：u6ic </li>\n<li>《编译原理》 <a href=\"https://pan.baidu.com/s/1xyRsZNjvt7ah3UbL3I8TMw\">百度云链接</a>   提取码：8i54 </li>\n<li>《操作系统概念、英文版》 <a href=\"https://pan.baidu.com/s/1TjgS3Juxo72hdGYJkKDjHA\">百度云链接</a>   提取码：2rof </li>\n<li>《操作系统概念》 <a href=\"https://pan.baidu.com/s/1rjfR6Qvyo1jbr-LzcRQ9dg\">百度云链接</a>    提取码：u3by </li>\n<li>《操作系统概述、公众号资源》  <a href=\"https://pan.baidu.com/s/1Iy2BQCOIzYW_S1Tv6fVDZA\">百度云链接</a>   提取码：apgg </li>\n<li>《操作系统之哲学原理 第2版》 <a href=\"https://pan.baidu.com/s/1iOwocriRPY8UMZWbVmXTaA\">百度云链接</a>   提取码：xzzn </li>\n<li>《分布式系统概念与设计 原书第5版》 <a href=\"https://pan.baidu.com/s/1RFp3qAyfhoFd4u8fkKlxcQ\">百度云链接</a>   提取码：r2wn </li>\n<li>《计算机系统要素、从零开始构建现代计算机》 <a href=\"https://pan.baidu.com/s/1FsEHp6bPkdZVaFEiK3pCIA\">百度云链接</a>   提取码：hylp</li>\n</ul>\n<h4 id=\"07、Linux\"><a href=\"#07、Linux\" class=\"headerlink\" title=\"07、Linux\"></a>07、Linux</h4><ul>\n<li><p>《Linux 内核设计与实现》 <a href=\"https://pan.baidu.com/s/1TyDQo4sQNw4y-jf_2cvYsQ\">百度云链接</a>   提取码：1f28 </p>\n</li>\n<li><p>《Linux UNIX系统编程手册、上》 <a href=\"https://pan.baidu.com/s/1uj9cpVgr2gGAgYl-OKLdgg\">百度云链接</a> 提取码：htnh </p>\n</li>\n<li><p>《Linux UNIX系统编程手册、下》 <a href=\"https://pan.baidu.com/s/1y_4FTpsLev6lnfmX9pPSmA\">百度云链接</a>  提取码：lxd4 </p>\n</li>\n<li><p>《UNIX网络编程卷1：套接字 API》 <a href=\"https://pan.baidu.com/s/1neeJhRQlvYUkg3CjMXX1Sw\">百度云链接</a>  提取码：3g7h </p>\n</li>\n<li><p>《UNIX网络编程卷2：进程间通信》 <a href=\"https://pan.baidu.com/s/1y0NiccCKS7timEAff6stoA\">百度云链接</a>  提取码：7anx </p>\n</li>\n<li><p>《UNIX环境高级编程 第三版》 <a href=\"https://pan.baidu.com/s/1e0UDP3zZqlw3f0F-Ob3QkA\">百度云链接</a> 提取码：eb50 </p>\n</li>\n<li><p>《《UNIX系统编程手册 上》.((德)Michael Kerrisk ).[PDF]@ckook》 <a href=\"https://pan.baidu.com/s/1Z4DHMSvkSjmGv2cubm2HfA\">百度云链接</a>  提取码：2gkj </p>\n</li>\n<li><p>《《UNIX系统编程手册 下》.((德)Michael Kerrisk ).[PDF]@ckook》 <a href=\"https://pan.baidu.com/s/1-YB-H2I5Bxdek9YxD0jgGg\">百度云链接</a>  提取码：wtyp </p>\n</li>\n<li><p>《Linux宝典》 <a href=\"https://pan.baidu.com/s/1DItPt6A1P-id40zB0__5Pw\">百度云链接</a>   提取码：225z </p>\n</li>\n<li><p>《Linux常用命令大全》 <a href=\"https://pan.baidu.com/s/1uRT7xh_83LoM004lmB8NgA\">百度云链接</a>   提取码：8b4u </p>\n</li>\n<li><p>《LINUX防火墙（原书第3版）》 <a href=\"https://pan.baidu.com/s/1GM0iXFNca6Secz893tMc8g\">百度云链接</a>    提取码：o9md </p>\n</li>\n<li><p>《Linux高级程序设计中文第三版杨宗德、人电出版社》 <a href=\"https://pan.baidu.com/s/1iXnRNkGjURXvKoANWrq8UA\">百度云链接</a>   提取码：4cms </p>\n</li>\n<li><p>《Linux环境编程：从应用到内核》 <a href=\"https://pan.baidu.com/s/1gnseg9k8eFv73b0DWrETAQ\">百度云链接</a>   提取码：8v8w </p>\n</li>\n<li><p>《Linux内核设计与实现 第3版》 <a href=\"https://pan.baidu.com/s/1G7JK6vYcHLUBLeGGlBkSjw\">百度云链接</a>   提取码：vzmc </p>\n</li>\n<li><p>《Linux内核完全注释》 <a href=\"https://pan.baidu.com/s/1JMZnMxOTxj99QYhvVTT0jA\">百度云链接</a>   提取码：wr95 </p>\n</li>\n<li><p>《Linux系统命令及shell脚本实践指南Linux unix技术丛书》 <a href=\"https://pan.baidu.com/s/1q8d4wVSkumyjhWphyTIZiw\">百度云链接</a>   提取码：gygv </p>\n</li>\n<li><p>《Unix &amp; Linux 大学教程》 <a href=\"https://pan.baidu.com/s/1NNbY2MaJ6qudamuaiEKzZA\">百度云链接</a>   提取码：thfb </p>\n</li>\n<li><p>《汇编语言基于Linux环境第3版》 <a href=\"https://pan.baidu.com/s/1WseMMExVQ6_N6MQriTY22w\">百度云链接</a>    提取码：0357 </p>\n</li>\n<li><p>《鸟哥的Linux私房菜基础篇和服务器篇》 <a href=\"https://pan.baidu.com/s/1JXQX2kDGVuq_JRpwK9z8jw\">百度云链接</a>   提取码：kbpi </p>\n</li>\n<li><p>《深入Linux内核架构 (图灵程序设计丛书·Linux UNIX系列)》 <a href=\"https://pan.baidu.com/s/1sld7OS999MC2rjXWjRslsA\">百度云链接</a>   提取码：6int </p>\n</li>\n<li><p>《深入理解Linux内核》 <a href=\"https://pan.baidu.com/s/1eJ8nXGOUW1cyIKyNEY4SPA\">百度云链接</a>    提取码：sm3l </p>\n</li>\n<li><p>《[Linux命令详解词典].施威铭研究室.扫描版》 <a href=\"https://pan.baidu.com/s/1TS1idjijuZCXTgQfb6vTjQ\">百度云链接</a>   提取码：oc3u </p>\n</li>\n<li><p>《Advanced Programming in the UNIX® Environment》 <a href=\"https://pan.baidu.com/s/1kUpdpnbTavbRGzr42Pmbiw\">百度云链接</a>   提取码：sm6b </p>\n</li>\n<li><p>《Harley Hahn’s Guide to UNIX and Linux》 <a href=\"https://pan.baidu.com/s/1pZwME_usn6ieDsP0d2o9eg\">百度云链接</a>   提取码：99c1 </p>\n</li>\n<li><p>《Linux Kernel Development》 <a href=\"https://pan.baidu.com/s/1yaF6nMPQspvNNP4oA6uadQ\">百度云链接</a>   提取码：rvnn </p>\n</li>\n<li><p>《Linux多线程服务端编程 书签高清非扫描、陈硕》 <a href=\"https://pan.baidu.com/s/1Mf3eAcwSqgUBUS73ly0Dmg\">百度云链接</a>   提取码：5kq1 </p>\n</li>\n<li><p>《Linux网络编程》 <a href=\"https://pan.baidu.com/s/1X5U4qb7mW1R0P2EMM9yJZA\">百度云链接</a>    提取码：vdbg </p>\n</li>\n<li><p>《Linux高性能服务器编程》 <a href=\"https://pan.baidu.com/s/1W24HUg4nHJWSkgBUEOcC0w\">百度云链接</a>    提取码：jt32 </p>\n</li>\n<li><p>《Unix-Linux编程实践教程》 <a href=\"https://pan.baidu.com/s/1loUsYlQpUaLRpLwCp9TFjA\">百度云链接</a>   提取码：w5p1 </p>\n</li>\n<li><p>《UNIX编程艺术-中文版【The+Art+of+UNIX+Programming】》 <a href=\"https://pan.baidu.com/s/1bjgIO8_lPMgv_4V8H6tAOw\">百度云链接</a>    提取码：8hhc</p>\n</li>\n</ul>\n<h4 id=\"08、后端架构\"><a href=\"#08、后端架构\" class=\"headerlink\" title=\"08、后端架构\"></a>08、后端架构</h4><ul>\n<li>《Redis开发与运维(付磊)》 <a href=\"https://pan.baidu.com/s/1J3P3XLdvP9gr3umPe2Y3IA\">百度云链接</a>    提取码：rtow </li>\n<li>《后台开发》 <a href=\"https://pan.baidu.com/s/1jfXLNkyByzprEtqiuC9R_A\">百度云链接</a>    提取码：7k53 </li>\n<li>《后台开发核心技术与应用实践高清PDF》 <a href=\"https://pan.baidu.com/s/14jK3cGT0yuAhVI5twVd6Ew\">百度云链接</a>    提取码：syau </li>\n<li>《深入理解Nginx模块开发与架构解析第2版》 <a href=\"https://pan.baidu.com/s/1tOn_25CKSY9ZtupqZKeNZw\">百度云链接</a>    提取码：o14w </li>\n<li>《Kafka权威指南》 <a href=\"https://pan.baidu.com/s/1D-oNXE-OiOZ-nTzwOjc92w\">百度云链接</a>   提取码：pn4r </li>\n<li>《RabbitMQ实战指南》  <a href=\"https://pan.baidu.com/s/1riCazeEYSNLJxGaI9QzZzA\">百度云链接</a>  提取码：l0xj</li>\n</ul>\n<h4 id=\"09、计算机系统知识\"><a href=\"#09、计算机系统知识\" class=\"headerlink\" title=\"09、计算机系统知识\"></a>09、计算机系统知识</h4><ul>\n<li><p>《大话计算机》 <a href=\"https://pan.baidu.com/s/1DFvp8RlQLMN4_4iYiBo1YQ\">百度云链接</a> 提取码：9jc8 </p>\n</li>\n<li><p>《编码：隐匿在计算机软硬件背后的语言》 <a href=\"https://pan.baidu.com/s/112j7NXaFxzAusaLkZau9uQ\">百度云链接</a> 提取码：60p1 </p>\n</li>\n<li><p>《程序是怎样跑起来的》 <a href=\"https://pan.baidu.com/s/15BjPm4uFvJHNoedrOjCdIg\">百度云链接</a> 提取码：u30m </p>\n</li>\n<li><p>《计算机是怎样跑起来的》 <a href=\"https://pan.baidu.com/s/1drr-zVUYsAqvFFM_aVpEIg\">百度云链接</a> 提取码：uwfk </p>\n</li>\n<li><p>《程序员的自我修养—链接、装载与库、书签目录版本》 <a href=\"https://pan.baidu.com/s/1DwDoGT8eEoMTpVOKJkQ4wg\">百度云链接</a> 提取码：ivmv </p>\n</li>\n<li><p>《计算机组成与设计：硬件_软件接口》 <a href=\"https://pan.baidu.com/s/1q7Bp_4sEqhFUzhrTUrprRA\">百度云链接</a> 提取码：dhda </p>\n</li>\n<li><p>《Patterson-Computer Organization and Design_The Hardware_Software Interface》 <a href=\"https://pan.baidu.com/s/1_1wOcREbVyP-mY78ximbeQ\">百度云链接</a> 提取码：zn24 </p>\n</li>\n<li><p>《Code、The Hidden Language of Computer Hardware and Software》 <a href=\"https://pan.baidu.com/s/1UQJ7NEnPluPoUZ2iCs9_zA\">百度云链接</a>  提取码：pytl  </p>\n</li>\n<li><p>《计算机组成  结构化方法  中文 第6版》 <a href=\"https://pan.baidu.com/s/1lhCYoQb3mkBtlsuOu16zTg\">百度云链接</a>    提取码：c1qy</p>\n</li>\n</ul>\n<h4 id=\"10、计算机网络\"><a href=\"#10、计算机网络\" class=\"headerlink\" title=\"10、计算机网络\"></a>10、计算机网络</h4><ul>\n<li>《计算机网络-自顶向下方法-第6版》 <a href=\"https://pan.baidu.com/s/1iLzPlkAylfyKGso1rtwWzQ\">百度云链接</a> 提取码：oj35 </li>\n<li>《计算机网络：自顶向下方法课后习题参考答案》 <a href=\"https://pan.baidu.com/s/1nsl7kc7bx4faRcwKXmYCvQ\">百度云链接</a> 提取码：d25h </li>\n<li>《HTTP核心总结》 <a href=\"https://pan.baidu.com/s/157of30-s21okWDgBz-FG6A\">百度云链接</a> 提取码：2fk9 </li>\n<li>《HTTP权威指南》 <a href=\"https://pan.baidu.com/s/1_1GR-53UE6HHaHnzjdeq6Q\">百度云链接</a> 提取码：1jhn </li>\n<li>《TCPIP详解三部曲卷1：协议》 <a href=\"https://pan.baidu.com/s/1uvlA8rgsdEw3PwWejZWKVg\">百度云链接</a>  提取码：j2iq </li>\n<li>《TCPIP详解三部曲卷2：实现》 <a href=\"https://pan.baidu.com/s/1dU5VNXfN0V9MIFsxVXw93g\">百度云链接</a>  提取码：r1cl </li>\n<li>《TCPIP详解三部曲卷3》 <a href=\"https://pan.baidu.com/s/13BDPDFfnaZXHdiGV0SuYKw\">百度云链接</a>  提取码：zee6 </li>\n<li>《TCP源码分析》 <a href=\"https://pan.baidu.com/s/1e9x58bRuntVMR-igdnnuIA\">百度云链接</a> 提取码：dhlo </li>\n<li>《Wireshark 数据包分析实战（第二版）》 <a href=\"https://pan.baidu.com/s/126-_exlgE1gwqDc7eBKl5w\">百度云链接</a> 提取码：shyo </li>\n<li>《Wireshark网络分析的艺术》 <a href=\"https://pan.baidu.com/s/1eaCwGFXC5t_7sOaZyGSaIg\">百度云链接</a> 提取码：lljf </li>\n<li>《Wireshark网络分析就这么简单》 <a href=\"https://pan.baidu.com/s/1S179DBl2xp1AfT3MQXKDwg\">百度云链接</a> 提取码：9j5j </li>\n<li>《计算机网络 第七版》 <a href=\"https://pan.baidu.com/s/1qcRML0XOAFWzo9OwJfVAwQ\">百度云链接</a> 提取码：89yv </li>\n<li>《计算机网络：系统方法》 <a href=\"https://pan.baidu.com/s/1NP0JtrCcKz7KP03ivuf-nA\">百度云链接</a> 提取码：uhke </li>\n<li>《图解HTTP》 <a href=\"https://pan.baidu.com/s/1F-xfG8fnSIu_bS_ehkZvdw\">百度云链接</a> 提取码：faxi </li>\n<li>《图解TCPIP(第5版)》 <a href=\"https://pan.baidu.com/s/1kvM_vINqRdgIe-SBnIDKjA\">百度云链接</a> 提取码：j86n </li>\n<li>《网络是怎样连接的 (图灵程序设计丛书)》 <a href=\"https://pan.baidu.com/s/1MXO3asDFShFC7C1tzT3vSg\">百度云链接</a> 提取码：vhm1 </li>\n<li>《Computer Networking_ A Top-down Approach》 <a href=\"https://pan.baidu.com/s/1A5IxiuiuIb80vaW5OAvBTQ\">百度云链接</a> 提取码：ewr3 </li>\n<li>《Computer Networks, A Systems Approach》 <a href=\"https://pan.baidu.com/s/13f2pu5TKfYBK8oXEmvDPtg\">百度云链接</a> 提取码：o98i</li>\n</ul>\n<h4 id=\"11、数据库\"><a href=\"#11、数据库\" class=\"headerlink\" title=\"11、数据库\"></a>11、数据库</h4><ul>\n<li><p>《MySQL必知必会 PDF + 源码》 <a href=\"https://pan.baidu.com/s/1zVp5YyqO1PrU_-kdm_CZog\">百度云链接</a>   提取码：45id </p>\n</li>\n<li><p>《数据库系统实现（第二版）》 <a href=\"https://pan.baidu.com/s/1QaYz2VnJVrAMW1V9qQM2ng\">百度云链接</a>  提取码：hjds </p>\n</li>\n<li><p>《高性能MySQL（第3版）].Baron.Scbwartz等.扫描版》 <a href=\"https://pan.baidu.com/s/1EFj1KKQ61WNMlHT48mwYhw\">百度云链接</a> 提取码：nszh </p>\n</li>\n<li><p>《深入浅出MySQL++数据库开发、优化与管理维护+第2版+唐汉明》 <a href=\"https://pan.baidu.com/s/18BeYVzM0FDk3DdSAfy-4yQ\">百度云链接</a> 提取码：a0uo </p>\n</li>\n<li><p>《数据库系统概念》 <a href=\"https://pan.baidu.com/s/1TI2TK1TbiHZiXfWZGaDKlA\">百度云链接</a> 提取码：eugi </p>\n</li>\n<li><p>《Database System Concepts》 <a href=\"https://pan.baidu.com/s/1MQ2fh9QjH6BxntQbuiQNgg\">百度云链接</a> 提取码：1u2u </p>\n</li>\n<li><p>《MongoDB权威指南》 <a href=\"https://pan.baidu.com/s/1trgNvpJyXt-T6VVbEUwFbw\">百度云链接</a> 提取码：vcca </p>\n</li>\n<li><p>《MySQL技术内幕  InnoDB存储引擎  第2版》 <a href=\"https://pan.baidu.com/s/1qVtnm_HhPEQbPPQp0Lcf4g\">百度云链接</a> 提取码：c9qa </p>\n</li>\n<li><p>《Redis设计与实现》 <a href=\"https://pan.baidu.com/s/1pV6nTDFJTS7IuFG1LKUK6g\">百度云链接</a> 提取码：r7r6 </p>\n</li>\n<li><p>《Redis实战》 <a href=\"https://pan.baidu.com/s/1QyrBT_VYLvuI25KeorLMfQ\">百度云链接</a> 提取码：eebx </p>\n</li>\n<li><p>《Redis开发与运维》 <a href=\"https://pan.baidu.com/s/1KVNEBOTE3GyUhCN9IpxMHg\">百度云链接</a>  提取码：ot6f </p>\n</li>\n<li><p>《SQLite 权威指南》 <a href=\"https://pan.baidu.com/s/1OpzEYWcYzCnsUDgjJoujeg\">百度云链接</a> 提取码：5bh2 </p>\n</li>\n<li><p>《SQL查询的艺术》 <a href=\"https://pan.baidu.com/s/13a9gJZ7zy69qGOresD5dTQ\">百度云链接</a> 提取码：tsfm </p>\n</li>\n<li><p>《分布式数据库系统  大数据时代新型数据库技术》 <a href=\"https://pan.baidu.com/s/1mHpGbyPqcR1RHHWYG6m4rg\">百度云链接</a> 提取码：zsxl </p>\n</li>\n<li><p>《分布式数据库系统原理.第3版》 <a href=\"https://pan.baidu.com/s/198SOMGm1U6ksiB5Dk2jiNw\">百度云链接</a> 提取码：xkv4 </p>\n</li>\n<li><p>《数据库系统概念 中文第6版》 <a href=\"https://pan.baidu.com/s/1l3zRQukLpRjXEI6625jAZw\">百度云链接</a> 提取码：fupf </p>\n</li>\n<li><p>《Nosql数据库入门》 <a href=\"https://pan.baidu.com/s/1J6yqqz8DueNUue9FS763zQ\">百度云链接</a>   提取码：ll6k </p>\n</li>\n<li><p>《MySQL5.5从零开始学》 <a href=\"https://pan.baidu.com/s/1BVYoA56hlzm4Act-v_M_kA\">百度云链接</a>   提取码：3u1c </p>\n</li>\n<li><p>《NoSQL精粹_中文完整版》 <a href=\"https://pan.baidu.com/s/1ttAxk1p-Ha9_yfPDcNbMsg\">百度云链接</a>   提取码：vwcg </p>\n</li>\n<li><p>《Redis入门指南》 <a href=\"https://pan.baidu.com/s/1WF4rswmI7QUwWmkz0RUG7g\">百度云链接</a>    提取码：wcga </p>\n</li>\n<li><p>《数据库原理、应用与实践（SQL Server）》 <a href=\"https://pan.baidu.com/s/1FV7E4CjzUk_ecYXNBGP2Bw\">百度云链接</a>    提取码：mgw3</p>\n</li>\n</ul>\n<h4 id=\"12、前端-amp-全栈\"><a href=\"#12、前端-amp-全栈\" class=\"headerlink\" title=\"12、前端&amp;全栈\"></a>12、前端&amp;全栈</h4><ul>\n<li><p>《[HTML与CSS入门经典(第7版)].（美）奥利弗，（美）莫里森.扫描版》 <a href=\"https://pan.baidu.com/s/1E_hGtyCxxYFRa4-7gepsOg\">百度云链接</a> 提取码：t8lj </p>\n</li>\n<li><p>《[JavaScript.DOM编程艺术（第2版）]》 <a href=\"https://pan.baidu.com/s/1QyHkKNdVb9qhzaLmNxThHg\">百度云链接</a> 提取码：gpaz </p>\n</li>\n<li><p>《Bootstrap实战》 <a href=\"https://pan.baidu.com/s/1OAx72Wf9PsvWUmwkpHFs3g\">百度云链接</a> 提取码：7xtf </p>\n</li>\n<li><p>《HTML5揭秘》 <a href=\"https://pan.baidu.com/s/1r0JhCMPva0s8sC2HNjphLg\">百度云链接</a> 提取码：v9qw </p>\n</li>\n<li><p>《HTML5与CSS3基础教程（第8版）》 <a href=\"https://pan.baidu.com/s/1ljIv5URpcxT056382D9JuA\">百度云链接</a>提取码：9i5k </p>\n</li>\n<li><p>《Javascript 高效图形编程-中文版》 <a href=\"https://pan.baidu.com/s/1uenyHwrThfCUwZz4kfLbMg\">百度云链接</a> 提取码：ksmm </p>\n</li>\n<li><p>《javascript高级程序设计》 <a href=\"https://pan.baidu.com/s/1dDCy6XQoOfdUZn05FIfW8w\">百度云链接</a>  提取码：zmz4 </p>\n</li>\n<li><p>《jQuery高级编程，中文完整扫描版》 <a href=\"https://pan.baidu.com/s/1azNEKU69AyGucl4ERNe-7Q\">百度云链接</a>  提取码：x1wi </p>\n</li>\n<li><p>《jQuery技术内幕 深入解析jQuery架构设计与实现原理》 <a href=\"https://pan.baidu.com/s/1hU3c9W9EYPc0PoeXanONBQ\">百度云链接</a>  提取码：1e3e </p>\n</li>\n<li><p>《jQuery权威指南》 <a href=\"https://pan.baidu.com/s/1Ng_CFZa3uN4rsbpfWSwJBw\">百度云链接</a> 提取码：tflj </p>\n</li>\n<li><p>《Node.js开发指南》 <a href=\"https://pan.baidu.com/s/1ZO8AVB8ECEcFLl8kGppBGg\">百度云链接</a>  提取码：r1oj </p>\n</li>\n<li><p>《nodebook》 <a href=\"https://pan.baidu.com/s/1pJ4sLnCMUPeceDrM7pz9mA\">百度云链接</a> 提取码：himg </p>\n</li>\n<li><p>《JavaScript高级程序设计（第3版）中文 高清》 <a href=\"https://pan.baidu.com/s/1yW9-ZzPkKyNRePdYEK7E3A\">百度云链接</a> 提取码：uus7 </p>\n</li>\n<li><p>《疯狂AJAX讲义》 <a href=\"https://pan.baidu.com/s/1-IJNk0xIKYRpfx2SAjPC2g\">百度云链接</a> 提取码：w85h </p>\n</li>\n<li><p>《深入浅出Node.js》 <a href=\"https://pan.baidu.com/s/1vZuoMxAwEbJl9wc6Vlmo7Q\">百度云链接</a> 提取码：cmkj</p>\n</li>\n</ul>\n<h4 id=\"13、安卓IOS逆向\"><a href=\"#13、安卓IOS逆向\" class=\"headerlink\" title=\"13、安卓IOS逆向\"></a>13、安卓IOS逆向</h4><ul>\n<li><p>《Android软件安全与逆向分析》 <a href=\"https://pan.baidu.com/s/1qFzWwIoAGxiyIz2aC1j8pQ\">百度云链接</a>   提取码：wmnt</p>\n</li>\n<li><p>《IOS应有逆向工程：分析与实战》 <a href=\"https://pan.baidu.com/s/1d6tvtINDP0sWroeG9NTC2Q\">百度云链接</a>   提取码：q9co</p>\n</li>\n<li><p>《逆向工程核心原理》 <a href=\"https://pan.baidu.com/s/1fIqsK3uutqPhIbXPSvXRoA\">百度云链接</a>  提取码：j0qg</p>\n</li>\n</ul>\n<h4 id=\"14、机器学习-amp-深度学习-amp-人工智能\"><a href=\"#14、机器学习-amp-深度学习-amp-人工智能\" class=\"headerlink\" title=\"14、机器学习&amp;深度学习&amp;人工智能\"></a>14、机器学习&amp;深度学习&amp;人工智能</h4><h5 id=\"14-1、机器学习\"><a href=\"#14-1、机器学习\" class=\"headerlink\" title=\"14.1、机器学习\"></a>14.1、机器学习</h5><ul>\n<li>《Python机器学习及实践－从零开始通往KAGGLE竞赛之路》 <a href=\"https://pan.baidu.com/s/1y4XL_fMcWNMAhzFpnHpcAw\">百度云链接</a>   提取码：5tei</li>\n<li>《Python机器学习经典实例》 <a href=\"https://pan.baidu.com/s/1QPolrwtE3Qzm_QAHK_Cwdg\">百度云链接</a>  提取码：clxi</li>\n<li>《Python神经网络编程高清版》 <a href=\"https://pan.baidu.com/s/1Ibyk_glLNnelApw4HVbMxA\">百度云链接</a>   提取码：lw2j</li>\n<li>《Python数据科学手册》 <a href=\"https://pan.baidu.com/s/1qbK1HAOh3xKHs8gAXUNa9w\">百度云链接</a>    提取码：pps1</li>\n<li>《贝叶斯思维统计建模的Python学习法》 <a href=\"https://pan.baidu.com/s/1m9lpaTfS7mTkCkqQf4uTeg\">百度云链接</a>   提取码：h9tf</li>\n<li>《机器学习7》 <a href=\"https://pan.baidu.com/s/1MlWEUGxdigsmzmwOcoETxQ\">百度云链接</a>    提取码：bbcs</li>\n<li>《机器学习_周志华》 <a href=\"https://pan.baidu.com/s/1QX0O_xZv3q-6j6zY20LVgg\">百度云链接</a> 提取码：pgyb</li>\n<li>《机器学习numpy和pandas基础》 <a href=\"https://pan.baidu.com/s/1cSyqyq3v21moW4gkYDcM_Q\">百度云链接</a> 提取码：1i2k</li>\n<li>《机器学习导论》 <a href=\"https://pan.baidu.com/s/1XEnqBe-bZ9sRRKK9C2HX5g\">百度云链接</a> 提取码：dylv</li>\n<li>《机器学习实战》 <a href=\"https://pan.baidu.com/s/1cXJ-_Ab_DOGGnc5jnQOeCA\">百度云链接</a> 提取码：94sv</li>\n<li>《集体智慧编程》 <a href=\"https://pan.baidu.com/s/1TwNvL2nJIptmsLxT1LTYTw\">百度云链接</a>  提取码：xf8i</li>\n<li>《数据科学入门》 <a href=\"https://pan.baidu.com/s/1Em1YfSmHhC_NCZsVY103IQ\">百度云链接</a>   提取码：mo58</li>\n<li>《数据科学与大数据(英文版)》 <a href=\"https://pan.baidu.com/s/1yGxt8TCdMcYcBFMC2KDHMg\">百度云链接</a>   提取码：r0v6</li>\n<li>《统计学个人笔记》 <a href=\"https://pan.baidu.com/s/1ALqzc-YbPEPJVdPnyJFRtQ\">百度云链接</a>   提取码：luao</li>\n<li>《统计学习方法-李航》 <a href=\"https://pan.baidu.com/s/1y-VtISgOUWOT_JbZYHduqg\">百度云链接</a> 提取码：digx</li>\n<li>《图解机器学习》 <a href=\"https://pan.baidu.com/s/19iRXr96iIRuZ8rDES9U4PQ\">百度云链接</a>  提取码：1r22</li>\n<li>《推荐系统实践》 <a href=\"https://pan.baidu.com/s/1PuD-qC-0_u7eiOOBjHqDoQ\">百度云链接</a>  提取码：d7xu</li>\n<li>《Scala机器学习》 <a href=\"https://pan.baidu.com/s/1VB7oOgxZ9f_CnUnu-uqykA\">百度云链接</a>  提取码：wy2c </li>\n<li>《Spark+MLlib机器学习实践+_王晓华》 <a href=\"https://pan.baidu.com/s/1mFs-AKpGGPa_K70cqG7YBQ\">百度云链接</a>    提取码：z6ig </li>\n<li>《机器学习(清晰)》 <a href=\"https://pan.baidu.com/s/1rIqqRtGUESS9_RBCPqbFSg\">百度云链接</a>   提取码：6jab </li>\n<li>《机器学习常见面试题》 <a href=\"https://pan.baidu.com/s/1dqqlwYXf9hTlZJfSLx8JQQ\">百度云链接</a>   提取码：wa3t </li>\n<li>《Python+Spark 2.0+Hadoop机器学习与大数据实战_林大贵(著)》 <a href=\"https://pan.baidu.com/s/14bBsgC-k68Tvg5XYMdxBCw\">百度云链接</a>   提取码：1jkd </li>\n<li>《Spark MLlib机器学习_黄美灵》 <a href=\"https://pan.baidu.com/s/1xInTAnn7UjSw8rhl7A-nIQ\">百度云链接</a>   提取码：gk6z </li>\n<li>《百面_机器学习 算法工程师带你去面试。清晰版带书签》 <a href=\"https://pan.baidu.com/s/1rnEWMpIU1MF1uOvpmNbvqg\">百度云链接</a>  提取码：0q1f </li>\n<li>《机器学习与R语言》 <a href=\"https://pan.baidu.com/s/1eQWUAqLFKiyRkms-xmQ98g\">百度云链接</a>    提取码：dj4g </li>\n<li>《白话大数据与机器学习》 <a href=\"https://pan.baidu.com/s/16x5sUv1ohAnLBCROUzdcVQ\">百度云链接</a>   提取码：ryqa</li>\n</ul>\n<h5 id=\"14-2、深度学习\"><a href=\"#14-2、深度学习\" class=\"headerlink\" title=\"14.2、深度学习\"></a>14.2、深度学习</h5><ul>\n<li>《Deeplearning深度学习笔记最新版》 <a href=\"https://pan.baidu.com/s/1hwWQh-9hLcKicO9yZuvyEw\">百度云链接</a>   提取码：xn7v</li>\n<li>《Python深度学习》 <a href=\"https://pan.baidu.com/s/1_rpiEWxLRcm769VPmB2K4w\">百度云链接</a>  提取码：e2ia</li>\n<li>《常用推荐算法（50页干货）》 <a href=\"https://pan.baidu.com/s/11392gRCpmKH2oL3m9OKqvg\">百度云链接</a>   提取码：o747</li>\n<li>《动手学深度学习-李沐》 <a href=\"https://pan.baidu.com/s/1zrWff1Rh0nepPIE7QGyfIQ\">百度云链接</a>   提取码：xefc</li>\n<li>《深度学习(最全的中文版)_2017年新书》 <a href=\"https://pan.baidu.com/s/1kKjU_m0Vhv-Fqqn-hpB0CQ\">百度云链接</a>   提取码：rjtr</li>\n<li>《深度学习500问》 <a href=\"https://pan.baidu.com/s/1yprRliW0juvoshwSWru86g\">百度云链接</a>   提取码：emzm</li>\n<li>《深度学习_中文版》 <a href=\"https://pan.baidu.com/s/1gGzT91J0tOjv0WyNg36nvQ\">百度云链接</a>   提取码：ippy</li>\n<li>《深度学习框架》 <a href=\"https://pan.baidu.com/s/1DtbfkkbRou4QMbim24q9dA\">百度云链接</a>  提取码：sko2</li>\n<li>《深度学习入门：基于Python的理论与实现.pdf+代码》 <a href=\"https://pan.baidu.com/s/1v_m7KtMMGn-sTkCIpJb8CA\">百度云链接</a>  提取码：vub4</li>\n<li>《神经网络与深度学习》 <a href=\"https://pan.baidu.com/s/1D0Ec7_U97YKrcDWeO6JX3w\">百度云链接</a>   提取码：ifjq</li>\n<li>《【高扬】白话深度学习姊妹篇、白话大数据与ML》 <a href=\"https://pan.baidu.com/s/1oLdFYseNHafAJ6jScmkD9w\">百度云链接</a>  提取码：kra4</li>\n<li>《Keras》 <a href=\"https://pan.baidu.com/s/1-bI-1IZsq_SE4o-ukolPPw\">百度云链接</a>    提取码：4d41 </li>\n<li>《Keras中文手册》 <a href=\"https://pan.baidu.com/s/1lAOWL71hH2pri9K5FjkaKg\">百度云链接</a>   提取码：cncz </li>\n<li>《Programming-PyTorch-for-Deep-Learning.Creating-》 <a href=\"https://pan.baidu.com/s/1pysapPgaxDOl8KRRcqF-8A\">百度云链接</a>   提取码：sss5 </li>\n<li>《Tensorflow 实战Google深度学习框架（完整版pdf)》 <a href=\"https://pan.baidu.com/s/1VuvABzDxwGgT4IBHdWLbdg\">百度云链接</a>   提取码：pvkt </li>\n<li>《TensorFlow斯坦福大学-深度学习基础教程[aibbt.com]》 <a href=\"https://pan.baidu.com/s/1L5DFy4qQZK1E5bsec0hRXQ\">百度云链接</a>   提取码：5lgw </li>\n<li>《TensorFlow 官方文档中文版、v1.2[aibbt.com]》 <a href=\"https://pan.baidu.com/s/1e9GHUSghaNLJ3EpymjfJWA\">百度云链接</a>   提取码：wkid </li>\n<li>《TensorFlow技术解析与实战.李嘉璇》 <a href=\"https://pan.baidu.com/s/1CInr-398G303GHqMVPNeOQ\">百度云链接</a>   提取码：kw18 </li>\n<li>《面向机器智的TensorFlow实践》 <a href=\"https://pan.baidu.com/s/1XAF0ya6Ap62rBXuh4h9HOw\">百度云链接</a>   提取码：jid6 </li>\n<li>《TensorFlow面向机器智能的TensorFlow实践 (智能系统与技术丛书)_[aibbt.com]》 <a href=\"https://pan.baidu.com/s/1Ba2bEoBqKXLIRWlzTc050A\">百度云链接</a>   提取码：a4oa </li>\n<li>《TensorFlow实战_黄文坚（完整）[aibbt.com]》 <a href=\"https://pan.baidu.com/s/1YMw9Yaik2nlFuWLMhITtmg\">百度云链接</a>   提取码：eimo </li>\n<li>《新版深度学习》 <a href=\"https://pan.baidu.com/s/1jDaJRHeXhZQDeUzgQ_aQPw\">百度云链接</a>     提取码：l60i</li>\n</ul>\n<h5 id=\"14-3、OpenCv\"><a href=\"#14-3、OpenCv\" class=\"headerlink\" title=\"14.3、OpenCv\"></a>14.3、OpenCv</h5><ul>\n<li>《OpenCV-Python-Tutorial-中文版20160814》 <a href=\"https://pan.baidu.com/s/1TxZM4vtZ5Zu3QzKwWgYMqA\">百度云链接</a>   提取码：138m</li>\n<li>《学习OpenCV 3 中文版》 <a href=\"https://pan.baidu.com/s/1SKHzdW7BpyD_RAEtFV-Xug\">百度云链接</a>  提取码：1z20</li>\n</ul>\n<h5 id=\"14-4、计算机视觉-CV\"><a href=\"#14-4、计算机视觉-CV\" class=\"headerlink\" title=\"14.4、计算机视觉(CV)\"></a>14.4、计算机视觉(CV)</h5><ul>\n<li>《Computer vision》 <a href=\"https://pan.baidu.com/s/12jPqt6_VMkuDwkV-hGj2uA\">百度云链接</a>  提取码：p3la</li>\n<li>《Python计算机视觉》 <a href=\"https://pan.baidu.com/s/1KFQJGSNvNjVVh2R_7yh6Cw\">百度云链接</a>   提取码：d4fk</li>\n<li>《图像处理分析与机器视觉(最新版)》 <a href=\"https://pan.baidu.com/s/1c7qRU3A9K_SfQ_tzJLr8sQ\">百度云链接</a>   提取码：ukvz</li>\n</ul>\n<h5 id=\"14-5、自然语言处理-NLP\"><a href=\"#14-5、自然语言处理-NLP\" class=\"headerlink\" title=\"14.5、自然语言处理(NLP)\"></a>14.5、自然语言处理(NLP)</h5><ul>\n<li>《deep_learning_for_nlp》 <a href=\"https://pan.baidu.com/s/1dUzKQVHtH-Ty8dJ1Y56G5A\">百度云链接</a>   提取码：fhq3</li>\n<li>《Embedding Methods for NLP emnlp tutorial》 <a href=\"https://pan.baidu.com/s/1Pt1zvQSo62EbEKTJ3NobiA\">百度云链接</a>  提取码：0bcg</li>\n<li>《Python自然语言处理中文翻译 NLTK 中文版》 <a href=\"https://pan.baidu.com/s/17aQxPLPcfDk9Ethd4XwcAw\">百度云链接</a>   提取码：cew3</li>\n<li>《Writing Code for NLP Research-1》 <a href=\"https://pan.baidu.com/s/1USq32Brkb9yBGDrHzsTSaw\">百度云链接</a>   提取码：vexm</li>\n<li>《斯坦福CS224n 自然语言处理与深度学习、笔记 hankcs》 <a href=\"https://pan.baidu.com/s/1fHKDrdSGHr3Bh6gWDz7WgQ\">百度云链接</a>   提取码：hihe</li>\n<li>《语音与语言处理Speech+and+Language+Processing》 <a href=\"https://pan.baidu.com/s/1OfGadsMwkKY0gWIUIJlmjQ\">百度云链接</a>   提取码：hweq</li>\n</ul>\n<h4 id=\"15、设计模式\"><a href=\"#15、设计模式\" class=\"headerlink\" title=\"15、设计模式\"></a>15、设计模式</h4><ul>\n<li>《大话设计模式》 <a href=\"https://pan.baidu.com/s/1iJSWVgqspqviEgHUUqhqDw\">百度云链接</a>   提取码：4o24</li>\n<li>《HeadFirst设计模式（中文版）》 <a href=\"https://pan.baidu.com/s/1lEz-hfm64QNJrrkx_skyrw\">百度云链接</a>  提取码：5c3f</li>\n<li>《图解设计模式》 <a href=\"https://pan.baidu.com/s/1g8Xa3G4dKL2PZ61XorHGsA\">百度云链接</a>   提取码：ih0f</li>\n<li>《研磨设计模式》 <a href=\"https://pan.baidu.com/s/1NsS6qCLukciKAUs3pmXNqA\">百度云链接</a>   提取码：wafq</li>\n<li>《常见设计模式解析与实现、C++版》 <a href=\"https://pan.baidu.com/s/1deQPnnlUzaLOgvTepl0j0A\">百度云链接</a>  提取码：3q7d </li>\n<li>《敏捷开发-设计模式》 <a href=\"https://pan.baidu.com/s/1tLrlJy-XE8P6nIXSEXr7_Q\">百度云链接</a>  提取码：h1xq </li>\n<li>《head first design patterns》 <a href=\"https://pan.baidu.com/s/1d8vBIBlNRve4i00sG7aLkg\">百度云链接</a>   提取码：err5</li>\n<li>《设计模式之禅（第2版）》 <a href=\"https://pan.baidu.com/s/1h_kDML8qeWMkoVUsMrQ_iQ\">百度云链接</a>     提取码：m68r</li>\n</ul>\n<h4 id=\"16、汇编语言\"><a href=\"#16、汇编语言\" class=\"headerlink\" title=\"16、汇编语言\"></a>16、汇编语言</h4><ul>\n<li>《x86汇编语言：从实模式到保护模式_书籍及配套资料》 <a href=\"https://pan.baidu.com/s/1d6grZC-PjCR7zGXx4ju6Qw\">百度云链接</a> 提取码：ne7j</li>\n<li>《汇编语言_王爽及相关资料》 <a href=\"https://pan.baidu.com/s/1LVQ9JvZ-ZBAxt8nZL7xVIA\">百度云链接</a>  提取码：cx9w</li>\n<li>《老“码”识途 从机器码到框架的系统观逆向修炼之路》 <a href=\"https://pan.baidu.com/s/1lVUEMXs0Au7CHmHk5zJPkg\">百度云链接</a>   提取码：b773</li>\n<li>《80x86汇编语言程序设计教程》 <a href=\"https://pan.baidu.com/s/19LBZuTluq6vx9BHXBM7Ehg\">百度云链接</a>  提取码：eogv</li>\n</ul>\n<h4 id=\"17、Git\"><a href=\"#17、Git\" class=\"headerlink\" title=\"17、Git\"></a>17、Git</h4><ul>\n<li><p>《Git参考手册-新》 <a href=\"https://pan.baidu.com/s/1bIAdpZ41nvjGHuBxlieqZA\">百度云链接</a>  提取码：amrb</p>\n</li>\n<li><p>《从0开始学习GitHub系列》 <a href=\"https://pan.baidu.com/s/1bnOGOjwum0P32zijD-3NBA\">百度云链接</a>   提取码：uhcw</p>\n</li>\n<li><p>《专业git中文》 <a href=\"https://pan.baidu.com/s/11K3Csq9O3LH-d7xzRiHHsw\">百度云链接</a>    提取码：4q2z</p>\n</li>\n<li><p>《Git权威指南》 <a href=\"https://pan.baidu.com/s/1TZGXb6j2lXOMNcR31FnWAg\">百度云链接</a>   提取码：yj4c</p>\n</li>\n</ul>\n<h4 id=\"18、数学相关\"><a href=\"#18、数学相关\" class=\"headerlink\" title=\"18、数学相关\"></a>18、数学相关</h4><ul>\n<li>《程序员的数学卷1、清晰版》 <a href=\"https://pan.baidu.com/s/1I6hyoiiOtM52FTi9MzZMUw\">百度云链接</a> 提取码：4ztn </li>\n<li>《程序员的数学卷2、概率统计》 <a href=\"https://pan.baidu.com/s/1QhvvJxyEiUook7xD4r1cZw\">百度云链接</a> 提取码：7o4m </li>\n<li>《程序员的数学卷3、线性统计》 <a href=\"https://pan.baidu.com/s/1T8xNHZsnfcPgFByRKBUb7Q\">百度云链接</a> 提取码：3kq6 </li>\n<li>《计算复杂性：现代方法》 <a href=\"https://pan.baidu.com/s/1TDVfB4RQKMDriq4dZfNuWg\">百度云链接</a>   提取码：yu3m</li>\n<li>《离散数学及其应用》 <a href=\"https://pan.baidu.com/s/17e1KX0j5RCNcd8JnWPrNrw\">百度云链接</a>  提取码：gcbx</li>\n<li>《数学之美》 <a href=\"https://pan.baidu.com/s/1IBIViE2Sifx-ANFU12nmPQ\">百度云链接</a>   提取码：vxqr</li>\n<li>《Computational Complexity_ A Modern Approach》 <a href=\"https://pan.baidu.com/s/1-XpRBBfJpv9F40R7wwG0_w\">百度云链接</a>  提取码：vq08</li>\n<li>《Discrete Mathematics and Its Applications》 <a href=\"https://pan.baidu.com/s/1Tp-DYhM6CfLflqPDB4BF_g\">百度云链接</a>   提取码：fuox</li>\n<li>《Operations Research Applications And Algorithms》 <a href=\"https://pan.baidu.com/s/18q6kf2pYT708E9pZoq0HQQ\">百度云链接</a>   提取码：lrou</li>\n<li>《概率论与数理统计、陈希孺》 <a href=\"https://pan.baidu.com/s/1A7eB7YKLSGB-mJwlezPJ0w\">百度云链接</a>   提取码：iks9</li>\n</ul>\n<h4 id=\"19、程序员软技能\"><a href=\"#19、程序员软技能\" class=\"headerlink\" title=\"19、程序员软技能\"></a>19、程序员软技能</h4><ul>\n<li><p>《码农翻身：用故事给技术加点料_刘欣》 <a href=\"https://pan.baidu.com/s/1dv8jHAhyoyGfpzXJA4747w\">百度云链接</a>   提取码：t2di</p>\n</li>\n<li><p>《奔跑吧，程序员：从零开始打造产品、技术和团队》 <a href=\"https://pan.baidu.com/s/1T3851MxuIrbrc4HOqdpuSA\">百度云链接</a>  提取码：yx4j</p>\n</li>\n<li><p>《代码大全2中文版》 <a href=\"https://pan.baidu.com/s/13Gajn1_aiBkjoGFcJI1zCA\">百度云链接</a>  提取码：0lml</p>\n</li>\n<li><p>《代码整洁之道》 <a href=\"https://pan.baidu.com/s/1CTPGRQkyFGUrwVVnv4d5xg\">百度云链接</a>  提取码：3c81</p>\n</li>\n<li><p>《黑客与画家》 <a href=\"https://pan.baidu.com/s/1BaB4TCWothorFJAbZhGLpQ\">百度云链接</a>  提取码：1i8c</p>\n</li>\n<li><p>《浪潮之巅（完整版）》 <a href=\"https://pan.baidu.com/s/1k0J1Fy9GoYieRdxKCU51AA\">百度云链接</a>  提取码：ikcl</p>\n</li>\n<li><p>《敏捷软件开发：原则、模式与实践》 <a href=\"https://pan.baidu.com/s/1o9ECMcIF0gML_9qk7c1cgQ\">百度云链接</a> 提取码：sw72</p>\n</li>\n<li><p>《重构：改善既有代码的设计（第2版）》 <a href=\"https://pan.baidu.com/s/1FnB3MeuYTZSfK6ITUc7pjg\">百度云链接</a>   提取码：kbup</p>\n</li>\n<li><p>《how-to-be-a-programmer-cn》 <a href=\"https://pan.baidu.com/s/1Qm4cFNZBz0rs_qaLzXwmbA\">百度云链接</a>    提取码：ns57 </p>\n</li>\n<li><p>《华为大数据应用开发指南》 <a href=\"https://pan.baidu.com/s/123YjmqnOvwF4nfPTbpFLIQ\">百度云链接</a>   提取码：2snr </p>\n</li>\n<li><p>《华为金融大数据解决方案汇报V2.0》 <a href=\"https://pan.baidu.com/s/1a55192jVn0WInbaBnD82bg\">百度云链接</a>   提取码：s9zi </p>\n</li>\n<li><p>《人月神话-中文-目录-文字版》 <a href=\"https://pan.baidu.com/s/12OGlEZJ31DTbX2Lk-NvnmQ\">百度云链接</a>    提取码：vumo </p>\n</li>\n<li><p>《孙金城丨阿里巴巴-Blink SQL关键技术及实现原理》 <a href=\"https://pan.baidu.com/s/1aJ7dprgQWSH7AXY00TdfvA\">百度云链接</a>    提取码：6mjd </p>\n</li>\n<li><p>《程序员健康指南》 <a href=\"https://pan.baidu.com/s/1aA2yIW75siSOtatLGGw4sQ\">百度云链接</a>     提取码：0bxr </p>\n</li>\n<li><p>《概念与技术（第3版）》 <a href=\"https://pan.baidu.com/s/18GAz4RnQYfxrL6Aq2PtDUQ\">百度云链接</a>   提取码：oolp </p>\n</li>\n<li><p>《技术之瞳+阿里巴巴技术笔试心得》 <a href=\"https://pan.baidu.com/s/1z1OwnM4Kw4-0VUfZK8CyfQ\">百度云链接</a>    提取码：978f </p>\n</li>\n<li><p>《阿里双十一技术》 <a href=\"https://pan.baidu.com/s/1DGBivuWJUx-4PQrHVQOv0Q\">百度云链接</a>    提取码：y5dd </p>\n</li>\n<li><p>《程序开发心理学》 <a href=\"https://pan.baidu.com/s/1vrFohI0hY7707-oKW_SlIA\">百度云链接</a>    提取码：1a20 </p>\n</li>\n<li><p>《大数据之路：阿里巴巴大数据实践》 <a href=\"https://pan.baidu.com/s/1vnF2Wp4VsnN_JhccwXEqhw\">百度云链接</a>   提取码：8uvo </p>\n</li>\n<li><p>《软件工程-实践者的研究方法.8th》 <a href=\"https://pan.baidu.com/s/18u_2S118ZPPDHOBiE__p_A\">百度云链接</a>    提取码：qb99</p>\n</li>\n</ul>\n<h4 id=\"20、其余资料\"><a href=\"#20、其余资料\" class=\"headerlink\" title=\"20、其余资料\"></a>20、其余资料</h4><ul>\n<li><p>《精通正则表达式》 <a href=\"https://pan.baidu.com/s/1pTI1QLL1dZ3vPpI8qJXwEw\">百度云链接</a> 提取码：4xum</p>\n</li>\n<li><p>《深入浅出谈CUDA》 <a href=\"https://pan.baidu.com/s/1O6K0diUw2QqDKbyF-XmfOA\">百度云链接</a>  提取码：rnzq</p>\n</li>\n<li><p>《数字信号处理教程  第3版 by 程佩青 (z-lib.org)》 <a href=\"https://pan.baidu.com/s/1gZV5-KpENoByu_w2N1fBYA\">百度云链接</a>  提取码：qn5b</p>\n</li>\n<li><p>《微服务设计中文完整版》<a href=\"https://pan.baidu.com/s/119YoewAQZF_ttx_vOI3CZg\">百度云链接</a>  提取码：7qp6 </p>\n</li>\n<li><p>《kotlin-for-android-developers-zh》 <a href=\"https://pan.baidu.com/s/1RdKFNdfuPTOAjB_2JnlrNw\">百度云链接</a>    提取码：numu </p>\n</li>\n<li><p>《kotlin-in-chinese》 <a href=\"https://pan.baidu.com/s/1NPzDqDetR1CQeXER-q56Vw\">百度云链接</a>    提取码：cf9o </p>\n</li>\n<li><p>《Kubernetes权威指南第2版》 <a href=\"https://pan.baidu.com/s/17JthYP4j6mXY3MMmgwT7CQ\">百度云链接</a>    提取码：lke6 </p>\n</li>\n<li><p>《progit2》 <a href=\"https://pan.baidu.com/s/1X9CkC47MkWRGIG71YVa1yg\">百度云链接</a>     提取码：edtb </p>\n</li>\n<li><p>《区块链+将如何重新定义世界》 <a href=\"https://pan.baidu.com/s/1qDF2wDsgG9y8ectMTZwXKw\">百度云链接</a>    提取码：twnt </p>\n</li>\n<li><p>《数字图像处理第二版中文版（冈萨雷斯）》 <a href=\"https://pan.baidu.com/s/1QX8yDgtc8uYjJxPDqPYWJw\">百度云链接</a>     提取码：40t2 </p>\n</li>\n<li><p>《图像工程(第二版)》 <a href=\"https://pan.baidu.com/s/1fZcLOzVx36PfRsp2-9xgIQ\">百度云链接</a>   提取码：8iom </p>\n</li>\n<li><p>《时间序列分析及应用：R语言（原书第2版）》 <a href=\"https://pan.baidu.com/s/1p-FBC2u5HBN8dmMjnXcVzg\">百度云链接</a>    提取码：sc0q </p>\n</li>\n<li><p>《特征提取与图像处理(第二版)》 <a href=\"https://pan.baidu.com/s/1i5GSIRl8vP_tPx-JDphx3A\">百度云链接</a>     提取码：baid </p>\n</li>\n<li><p>《Unity3D／2D游戏开发从0到1》 <a href=\"https://pan.baidu.com/s/1Xr1i8f4Hgaog4Cqypv81vw\">百度云链接</a>    提取码：5tih </p>\n</li>\n<li><p>《第一本Docker书》 <a href=\"https://pan.baidu.com/s/1DAKip2_QjnGkp1yH5O0phQ\">百度云链接</a>    提取码：v781 </p>\n</li>\n<li><p>《精通比特幣》 <a href=\"https://pan.baidu.com/s/1-I-1ZUUTzNBeJAM8zlEUNw\">百度云链接</a>    提取码：yn8l </p>\n</li>\n<li><p>《计算机图形学  第4版》 <a href=\"https://pan.baidu.com/s/1mZ4_exUMEcch06TlddhSAQ\">百度云链接</a>   提取码：6qbr </p>\n</li>\n<li><p>《数据挖掘、推理与预测》 <a href=\"https://pan.baidu.com/s/1HJuM_CXoTB3LsC83smeU3g\">百度云链接</a>    提取码：5fv5</p>\n</li>\n</ul>\n<h4 id=\"21、社招校招汇总\"><a href=\"#21、社招校招汇总\" class=\"headerlink\" title=\"21、社招校招汇总\"></a>21、社招校招汇总</h4><ul>\n<li><p>《《<a href=\"https://github.com/forthespada/InterviewGuide\">逆袭进大厂</a>  也就是《InterViewGuide》V4- 2021.06.17 by 阿秀》<a href=\"https://pan.baidu.com/s/1b153vXtVjpFUs4KkbmLPSQ\">百度云链接</a>   提取码：9u76</p>\n</li>\n<li><p>《《<a href=\"https://github.com/forthespada/InterviewGuide\">逆袭进大厂</a>  也就是《InterViewGuide》V3- 2021.04.05 by 阿秀》 <a href=\"https://pan.baidu.com/s/1ufHyDMP6cOAeal7CDXbExQ\">百度云链接</a>     提取码：kzew </p>\n</li>\n<li><p>《<a href=\"https://github.com/forthespada/InterviewGuide\">逆袭进大厂</a>  超全面试总结强烈推荐、C++、操作系统、计算机网络、MySQL、Redis等》V1<br><a href=\"https://pan.baidu.com/s/14VFpE0X8nAhQtkTliOzePA\">百度云链接</a>   提取码：6lxd </p>\n</li>\n<li><p>《《<a href=\"https://github.com/forthespada/InterviewGuide\">逆袭进大厂</a>  超全面试总结强烈推荐、C++、操作系统、计算机网络、MySQL、Redis等》V2》<a href=\"https://pan.baidu.com/s/18UoSWI7CSKYE3jfybBP-Cw\">百度云链接</a>  提取码：zogg</p>\n</li>\n<li><p>《<a href=\"https://github.com/forthespada/InterviewGuide\">逆袭进大厂</a> 超全面试总结强烈推荐、C++、操作系统、计算机网络、MySQL、Redis等》V0<br><a href=\"https://pan.baidu.com/s/1RCHHSAzSKUSlLlmKXJeiNw\">百度云链接</a>   提取码：aa06  </p>\n</li>\n<li><p>《计算机校招直播视频、2021.02.25晚视频号录播》 <a href=\"https://pan.baidu.com/s/1QLDmX1O7QZNWjb2Rr9Pxuw\">百度云链接</a>  提取码：w0ez </p>\n</li>\n<li><p>《C++面经总结》 <a href=\"https://pan.baidu.com/s/1XHPpDHZsRDanLnZGUuEHmQ\">百度云链接</a>   提取码：esr8 </p>\n</li>\n<li><p>《牛客网Java校招题库PDF版》 <a href=\"https://pan.baidu.com/s/13vXyf6onhnvqBTyx3ocBNg\">百度云链接</a>    ：提取码：kgl6  </p>\n</li>\n<li><p>《Java大厂面试总结》  <a href=\"https://pan.baidu.com/s/14xD_nZ2rb64LG1_ZZSOyQA\">百度云链接</a>   提取码：4bn1 </p>\n</li>\n<li><p>《C++面经、牛客大佬总结的涉及C++ 操作系统 计算机网络 数据库等知识点》 <a href=\"https://pan.baidu.com/s/1oT9oIgPvXDEG01LaNbOU_g\">百度云链接</a>  提取码：czbh </p>\n</li>\n<li><p>《程序员面试宝典》 <a href=\"https://pan.baidu.com/s/1pikO4SHPCMFlvd-xF_B_2A\">百度云链接</a>  提取码：gm2t</p>\n</li>\n<li><p>《机器学习 算法工程师带你去面试》 <a href=\"https://pan.baidu.com/s/1Y9eDhh-B3qgKFeUTTKm23Q\">百度云链接</a>  提取码：n7pm</p>\n</li>\n<li><p>《机器学习常见面试题》 <a href=\"https://pan.baidu.com/s/1QzdmIUt8B_7GXR1WFN4aqw\">百度云链接</a>  提取码：i9yw</p>\n</li>\n<li><p>《招聘笔记》 <a href=\"https://pan.baidu.com/s/1ZG3pUJP9s2LTouZIgabh4A\">百度云链接</a>  提取码：q48f</p>\n</li>\n<li><p>《校招求职分享直播PPT、分享人：拱白菜的阿秀》 <a href=\"https://pan.baidu.com/s/1j8KpU6tETcVrMWDYcfPIeQ\">百度云链接</a>  提取码：wnh8 </p>\n</li>\n<li><p>《牛客网SQL练习题全解析》 <a href=\"https://pan.baidu.com/s/1wiqqET6I9Nqu4yvGuGzv2w\">百度云链接</a>  提取码：olgp </p>\n</li>\n<li><p>《2018最新BAT python面试题》 <a href=\"https://pan.baidu.com/s/1nBrDlLuHhSTN5dQN_qwgjA\">百度云链接</a>   提取码：96cx </p>\n</li>\n<li><p>《Java程序员面试宝典》 <a href=\"https://pan.baidu.com/s/1TGTIYMTiT1Fx7J5AFVniUA\">百度云链接</a>    提取码：ah1m </p>\n</li>\n<li><p>《Java面试突击-V3.0》 <a href=\"https://pan.baidu.com/s/15DFE4I7kH9U574-6sYyfYw\">百度云链接</a>   提取码：0q4h </p>\n</li>\n<li><p>《阿里Java面试问题大全》 <a href=\"https://pan.baidu.com/s/1O91SA7-OZTitu8aCUZuwWg\">百度云链接</a>    提取码：amr8 </p>\n</li>\n<li><p>《牛客网IT名企2016笔试真题+答案》 <a href=\"https://pan.baidu.com/s/1rgQJHdJIwxUe_5iJNl54Xw\">百度云链接</a>    提取码：nm5z</p>\n</li>\n</ul>\n<h4 id=\"22、我建议你下载，以后肯定用得上\"><a href=\"#22、我建议你下载，以后肯定用得上\" class=\"headerlink\" title=\"22、我建议你下载，以后肯定用得上\"></a>22、我建议你下载，以后肯定用得上</h4><ul>\n<li>《城市新青年：美团外卖骑手就业报告》 <a href=\"https://pan.baidu.com/s/1P2VV4CwKPKpxV6myjtJ_Hg\">百度云链接</a>   提取码：i8y5 </li>\n<li>《活着、余华》  <a href=\"https://pan.baidu.com/s/1Pk6yeTM2nUgHUM5ji2Gn4Q\">百度云链接</a>  提取码：29s4 </li>\n<li>《许三观卖血记、余华》 <a href=\"https://pan.baidu.com/s/1xILsVtG29ByWpFcKYvdTsw\">百度云链接</a>  提取码: ukmj </li>\n<li>《平凡的世界、路遥》  <a href=\"https://pan.baidu.com/s/1hNPgA3YlllyEuc-fBw2lhg\">百度云链接</a>  提取码：vaa6</li>\n</ul>\n","tags":["写作"]},{"title":"2.一元函数微分学","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_1.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_2.%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","1.高等数学","2.一元函数微分学"],"tags":["写作"]},{"title":"4.向量代数与空间解析几何","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_1.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_4.%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","1.高等数学","4.向量代数与空间解析几何"],"tags":["写作"]},{"title":"3.一元函数积分学","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_1.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_3.%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","1.高等数学","3.一元函数积分学"],"tags":["写作"]},{"title":"5.多元函数微分学","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_1.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_5.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","1.高等数学","5.多元函数微分学"],"tags":["写作"]},{"title":"6.多元函数积分学","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_1.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_6.%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","1.高等数学","6.多元函数积分学"],"tags":["写作"]},{"title":"7.无穷级数","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_1.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_7.%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","1.高等数学","7.无穷级数"],"tags":["写作"]},{"title":"8.常微分方程","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_1.%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6_8.%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","1.高等数学","8.常微分方程"],"tags":["写作"]},{"title":"1.行列式","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_2.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_1.%E8%A1%8C%E5%88%97%E5%BC%8F/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","2.线性代数","1.行列式"],"tags":["写作"]},{"title":"2.矩阵","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_2.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_2.%E7%9F%A9%E9%98%B5/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","2.线性代数","2.矩阵"],"tags":["写作"]},{"title":"3.向量","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_2.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_3.%E5%90%91%E9%87%8F/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","2.线性代数","3.向量"],"tags":["写作"]},{"title":"4.线性方程组","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_2.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_4.%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","2.线性代数","4.线性方程组"],"tags":["写作"]},{"title":"5.特征值、特征向量、相似矩阵","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_2.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_5.%E7%89%B9%E5%BE%81%E5%80%BC%E3%80%81%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E3%80%81%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","2.线性代数","5.特征值、特征向量、相似矩阵"],"tags":["写作"]},{"title":"6.二次型","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_2.%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0_6.%E4%BA%8C%E6%AC%A1%E5%9E%8B/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","2.线性代数","6.二次型"],"tags":["写作"]},{"title":"1.随机时间和概率","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_3.%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_1.%E9%9A%8F%E6%9C%BA%E6%97%B6%E9%97%B4%E5%92%8C%E6%A6%82%E7%8E%87/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","3.概率论与数理统计","1.随机时间和概率"],"tags":["写作"]},{"title":"3.多元随机变量及其分布","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_3.%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_3.%E5%A4%9A%E5%85%83%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","3.概率论与数理统计","3.多元随机变量及其分布"],"tags":["写作"]},{"title":"2.随机变量及其概率分布","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_3.%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_2.%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","3.概率论与数理统计","2.随机变量及其概率分布"],"tags":["写作"]},{"title":"4.随机变量的数字特征","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_3.%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_4.%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","3.概率论与数理统计","4.随机变量的数字特征"],"tags":["写作"]},{"title":"5.大数定律和中心极限定理","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_3.%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_5.%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E5%92%8C%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","3.概率论与数理统计","5.大数定律和中心极限定理"],"tags":["写作"]},{"title":"6.数理统计的基本概念","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_3.%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_6.%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","3.概率论与数理统计","6.数理统计的基本概念"],"tags":["写作"]},{"title":"7.参数估计","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_3.%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_7.%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","3.概率论与数理统计","7.参数估计"],"tags":["写作"]},{"title":"8.假设检验","url":"/2022/02/04/1-%E6%95%B0%E5%AD%A6_3.%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1_8.%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/","content":"<h3 id=\"1-知识梳理\"><a href=\"#1-知识梳理\" class=\"headerlink\" title=\"(1)知识梳理\"></a>(1)知识梳理</h3><h3 id=\"2-必备结论\"><a href=\"#2-必备结论\" class=\"headerlink\" title=\"(2)必备结论\"></a>(2)必备结论</h3><h3 id=\"3-经典例题\"><a href=\"#3-经典例题\" class=\"headerlink\" title=\"(3)经典例题\"></a>(3)经典例题</h3><h3 id=\"4-错题集\"><a href=\"#4-错题集\" class=\"headerlink\" title=\"(4)错题集\"></a>(4)错题集</h3>","categories":["数学","3.概率论与数理统计","8.假设检验"],"tags":["写作"]},{"title":"计算机系统概述","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","content":"<h1 id=\"计算机发展历程\"><a href=\"#计算机发展历程\" class=\"headerlink\" title=\"计算机发展历程\"></a>计算机发展历程</h1><h2 id=\"什么是计算机系统\"><a href=\"#什么是计算机系统\" class=\"headerlink\" title=\"什么是计算机系统\"></a>什么是计算机系统</h2><ul>\n<li><p>计算机系统 &#x3D; 硬件 + 软件</p>\n</li>\n<li><p>硬件</p>\n</li>\n<li><p>软件</p>\n<ul>\n<li><p>系统软件：管理整个计算机系统</p>\n</li>\n<li><p>应用软件：按任务需要编制成的各种程序</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"硬件的发展\"><a href=\"#硬件的发展\" class=\"headerlink\" title=\"硬件的发展\"></a>硬件的发展</h2><ul>\n<li><p>第一代：电子管时代</p>\n<ul>\n<li>机器语言</li>\n</ul>\n</li>\n<li><p>第二代：晶体管时代</p>\n<ul>\n<li><p>面向过程的程序设计语言</p>\n</li>\n<li><p>操作系统雏形</p>\n</li>\n</ul>\n</li>\n<li><p>第三代：中小规模集成电路时代</p>\n<ul>\n<li><p>半导体存储器</p>\n</li>\n<li><p>分时操作系统</p>\n</li>\n</ul>\n</li>\n<li><p>第四代：超大规模集成电路时代</p>\n<ul>\n<li><p>微处理器</p>\n<ul>\n<li>机器字长：计算机一次整数运算所能处理的二进制位数</li>\n</ul>\n</li>\n<li><p>并行，流水线，高速缓存，虚拟存储器出现</p>\n</li>\n</ul>\n</li>\n<li><p>元件的更新变化</p>\n<ul>\n<li>摩尔定律<ul>\n<li>18个月晶体管翻一倍</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"目前的发展趋势\"><a href=\"#目前的发展趋势\" class=\"headerlink\" title=\"目前的发展趋势\"></a>目前的发展趋势</h2><ul>\n<li><p>更微型、多用途</p>\n</li>\n<li><p>更巨型、超高速</p>\n</li>\n</ul>\n<h1 id=\"计算机硬件的基本组成\"><a href=\"#计算机硬件的基本组成\" class=\"headerlink\" title=\"计算机硬件的基本组成\"></a>计算机硬件的基本组成</h1><h2 id=\"五大部分\"><a href=\"#五大部分\" class=\"headerlink\" title=\"五大部分\"></a>五大部分</h2><ul>\n<li><p>输入设备：将信息转换成机器能识别的形式</p>\n</li>\n<li><p>输出设备：将结果转换成人们熟悉的形式</p>\n</li>\n<li><p>主存储器：存放数据和程序</p>\n</li>\n<li><p>运算器：算术运算、逻辑运算</p>\n</li>\n<li><p>控制器：指挥各部件，使程序运行</p>\n</li>\n</ul>\n<h2 id=\"早期冯诺依曼机的结构\"><a href=\"#早期冯诺依曼机的结构\" class=\"headerlink\" title=\"早期冯诺依曼机的结构\"></a>早期冯诺依曼机的结构</h2><ul>\n<li><p>提出存储程序的概念</p>\n<ul>\n<li>将指令以二进制代码的形式先输入主存储器，然后存储器中的存储程序的首地址执行程序的第一条指令，以后就按照该程序的规定顺序执行其他指令，直至程序结束执行</li>\n</ul>\n</li>\n<li><p>结构<img src=\"https://api2.mubu.com/v3/document_image/4ffa67a3-fd5f-476c-b73d-79c2ee54d2a8-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>计算机由五大部件组成</p>\n</li>\n<li><p>指令和数据以同等地位存于存储器，可按地址寻访</p>\n</li>\n<li><p>指令和数据用二进制表示</p>\n</li>\n<li><p>指令由操作码和地址码组成</p>\n</li>\n<li><p>存储程序</p>\n</li>\n<li><p>以运算器为中心（输入&#x2F;输出设备与存储器之间的数据传送通过运算器完成）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"现代计算机的结构\"><a href=\"#现代计算机的结构\" class=\"headerlink\" title=\"现代计算机的结构\"></a>现代计算机的结构</h2><ul>\n<li><p>结构<img src=\"https://api2.mubu.com/v3/document_image/18f65294-2e7b-47f6-952a-77b699afd367-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>特点：以存储器为中心</p>\n<ul>\n<li>CPU&#x3D;运算器+控制器</li>\n</ul>\n</li>\n<li><p>硬件</p>\n<ul>\n<li><p>主机</p>\n<ul>\n<li><p>CPU</p>\n<ul>\n<li><p>运算器</p>\n</li>\n<li><p>控制器</p>\n</li>\n</ul>\n</li>\n<li><p>主存</p>\n</li>\n</ul>\n</li>\n<li><p>I&#x2F;O设备</p>\n<ul>\n<li><p>辅存</p>\n</li>\n<li><p>输入设备</p>\n</li>\n<li><p>输出设备</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"各个硬件的工作原理\"><a href=\"#各个硬件的工作原理\" class=\"headerlink\" title=\"各个硬件的工作原理\"></a>各个硬件的工作原理</h1><h2 id=\"主存储器\"><a href=\"#主存储器\" class=\"headerlink\" title=\"主存储器\"></a>主存储器</h2><ul>\n<li><p>存储体：数据在存储体内按地址存储</p>\n</li>\n<li><p>MAR：存储单元的个数</p>\n</li>\n<li><p>MDR：存储字长</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>存储单元：每个存储单元存放一串二进制代码</p>\n</li>\n<li><p>存储字：存储单元中的二进制代码</p>\n</li>\n<li><p>存储字长：存储单元中二进制代码的位数</p>\n</li>\n<li><p>存储元：电子元件，每个存储元存 1bit</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"运算器\"><a href=\"#运算器\" class=\"headerlink\" title=\"运算器\"></a>运算器</h2><ul>\n<li><p>简述：实现算术运算（加减乘除）、逻辑运算（与或非）</p>\n</li>\n<li><p>ACC：累加器，用于存放操作数，或运算结果</p>\n</li>\n<li><p>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果</p>\n</li>\n<li><p>X：通用的操作数寄存器，用于存放操作数</p>\n</li>\n<li><p>ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</p>\n</li>\n<li><p>加减乘除时，各部件的存储内容：<img src=\"https://api2.mubu.com/v3/document_image/3bbeae70-1697-4aef-a71d-1a79a0bf1f61-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<h2 id=\"控制器\"><a href=\"#控制器\" class=\"headerlink\" title=\"控制器\"></a>控制器</h2><ul>\n<li><p>PC：程序计数器，存放下一条指令地址，有自动加1功能</p>\n</li>\n<li><p>IR：指令寄存器，存放当前执行的指令</p>\n</li>\n<li><p>CU：控制单元，分析指令，给出控制信号</p>\n</li>\n<li><p>执行指令的步骤：</p>\n<ul>\n<li><p>取指令：PC</p>\n</li>\n<li><p>分析指令：IR</p>\n</li>\n<li><p>执行指令：CU</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h2><ul>\n<li><p>简述：</p>\n<ul>\n<li><p>初始：指令、数据存入主存</p>\n</li>\n<li><p>取指令：PC指向第一条指令</p>\n</li>\n<li><p>分析指令：从主存中取指令放入IR，PC自动加一，CU分析指令</p>\n</li>\n<li><p>执行指令：CU指挥其他部件执行指令</p>\n</li>\n</ul>\n</li>\n<li><p>常见指令的执行步骤：</p>\n<ul>\n<li><p>取数：<img src=\"https://api2.mubu.com/v3/document_image/5230673c-d09e-452a-a193-33b819cffaf6-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>乘法：<img src=\"https://api2.mubu.com/v3/document_image/c1fd6e05-7f0c-45b7-9da1-0c219be9b997-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>加法：<img src=\"https://api2.mubu.com/v3/document_image/fe4afb1a-73ba-4b76-8325-abfdd74f9f6b-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>存数：<img src=\"https://api2.mubu.com/v3/document_image/b7ec2b92-35ca-40be-91a9-e0debb1f78fb-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>停机：<img src=\"https://api2.mubu.com/v3/document_image/1c84ea99-d83b-4794-80b4-b106ecdddf94-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>指令执行的步骤：</p>\n<ul>\n<li><p>必经步骤</p>\n<ul>\n<li><p>PC) —&gt; MAR</p>\n</li>\n<li><p>M(MAR) —&gt; MDR</p>\n</li>\n<li><p>(MDR) —&gt; IR</p>\n</li>\n<li><p>取指令结束</p>\n</li>\n<li><p>(PC)+1 —&gt; PC</p>\n</li>\n<li><p>OP(IR) —&gt; CU</p>\n</li>\n<li><p>分析指令结束</p>\n</li>\n</ul>\n</li>\n<li><p>不同指令具体步骤不同</p>\n<ul>\n<li><p>Ad(IR) —&gt; MAR</p>\n</li>\n<li><p>M(MAR) —&gt; MDR</p>\n</li>\n<li><p>(MDR) —&gt; ACC</p>\n</li>\n<li><p>执行指令结束</p>\n</li>\n</ul>\n</li>\n<li><p>注：指令的含义</p>\n<ul>\n<li><p>M：主存中某存储单元</p>\n</li>\n<li><p>ACC、MQ、X、MAR、MDR：相应寄存器</p>\n</li>\n<li><p>M(MAR)：取存储单元中的数据</p>\n</li>\n<li><p>(ACC)：取相应寄存器中的数据</p>\n</li>\n<li><p>指令：操作码+地址码</p>\n</li>\n<li><p>OP(IR)：取操作码</p>\n</li>\n<li><p>Ad(IR)：取地址码</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"计算机系统的多级层次结构\"><a href=\"#计算机系统的多级层次结构\" class=\"headerlink\" title=\"计算机系统的多级层次结构\"></a>计算机系统的多级层次结构</h1><h2 id=\"五层：下层是上层的基础，上层是下层的扩展\"><a href=\"#五层：下层是上层的基础，上层是下层的扩展\" class=\"headerlink\" title=\"五层：下层是上层的基础，上层是下层的扩展\"></a>五层：下层是上层的基础，上层是下层的扩展</h2><ul>\n<li><p>M4：高级语言机器（执行高级语言）</p>\n<ul>\n<li>用编译程序翻译成汇编语言程序</li>\n</ul>\n</li>\n<li><p>M3：汇编语言机器（执行汇编语言）</p>\n<ul>\n<li><p>用汇编程序翻译成机器语言程序</p>\n</li>\n<li><p>注：汇编语言指令和机器语言指令一一对应</p>\n</li>\n</ul>\n</li>\n<li><p>M2：操作系统机器（向上提供广义指令）</p>\n<ul>\n<li>向上提供广义指令（系统调用）</li>\n</ul>\n</li>\n<li><p>M1：传统机器（执行机器语言指令）</p>\n<ul>\n<li>执行二进制机器指令</li>\n</ul>\n</li>\n<li><p>M0：微程序机器（执行微指令）</p>\n<ul>\n<li>由硬件直接执行微指令</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三个级别的语言\"><a href=\"#三个级别的语言\" class=\"headerlink\" title=\"三个级别的语言\"></a>三个级别的语言</h2><ul>\n<li><p>高级语言：C&#x2F;C++、Java</p>\n</li>\n<li><p>汇编语言：助记符（与机器语言一一对应）</p>\n</li>\n<li><p>机器语言：二进制代码</p>\n</li>\n</ul>\n<h2 id=\"三种翻译程序\"><a href=\"#三种翻译程序\" class=\"headerlink\" title=\"三种翻译程序\"></a>三种翻译程序</h2><ul>\n<li><p>编译程序：高级语言一次性翻译为汇编语言，或直接翻译为机器语言</p>\n</li>\n<li><p>汇编程序：将汇编语言翻译成机器语言</p>\n</li>\n<li><p>解释程序：高级语言翻译为机器语言（翻译一句，执行一句）</p>\n</li>\n</ul>\n<h1 id=\"计算机的性能指标\"><a href=\"#计算机的性能指标\" class=\"headerlink\" title=\"计算机的性能指标\"></a>计算机的性能指标</h1><h2 id=\"存储器的容量\"><a href=\"#存储器的容量\" class=\"headerlink\" title=\"存储器的容量\"></a>存储器的容量</h2><ul>\n<li><p>MAR：存储单元数量</p>\n</li>\n<li><p>MDR：每个存储单元大小</p>\n</li>\n</ul>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><ul>\n<li><p>时钟周期：</p>\n</li>\n<li><p>主频（时钟频率）：</p>\n</li>\n<li><p>CPI：</p>\n</li>\n<li><p>CPU执行时间：</p>\n</li>\n<li><p>IPS：</p>\n</li>\n<li><p>FLOPS：</p>\n</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><ul>\n<li><p>数据通路宽度</p>\n</li>\n<li><p>吞吐量</p>\n</li>\n<li><p>响应时间</p>\n</li>\n<li><p>基准程序</p>\n</li>\n</ul>\n<h2 id=\"常用数量单元\"><a href=\"#常用数量单元\" class=\"headerlink\" title=\"常用数量单元\"></a>常用数量单元</h2><ul>\n<li><p>描述存储容量、文件大小：K&#x3D;2^10</p>\n</li>\n<li><p>描述频率、速率：K&#x3D;10^3</p>\n</li>\n</ul>\n<h1 id=\"（数据库管理系统）DBMS与（数据库系统）DBS的区别\"><a href=\"#（数据库管理系统）DBMS与（数据库系统）DBS的区别\" class=\"headerlink\" title=\"（数据库管理系统）DBMS与（数据库系统）DBS的区别\"></a>（数据库管理系统）DBMS与（数据库系统）DBS的区别</h1><ul>\n<li><p>DBMS是位于用户和操作系统之间的一层数据管理系统（系统软件）</p>\n</li>\n<li><p>DBS是指计算机系统引入数据库后的系统</p>\n<ul>\n<li><p>数据库</p>\n</li>\n<li><p>数据库管理系统</p>\n</li>\n<li><p>数据库管理员</p>\n</li>\n<li><p>应用系统</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"计算机系统层次结构\"><a href=\"#计算机系统层次结构\" class=\"headerlink\" title=\"计算机系统层次结构\"></a>计算机系统层次结构</h1><h2 id=\"计算机系统构成\"><a href=\"#计算机系统构成\" class=\"headerlink\" title=\"计算机系统构成\"></a>计算机系统构成</h2><ul>\n<li><p>硬件</p>\n</li>\n<li><p>软件</p>\n</li>\n<li><p>注：硬件与软件在逻辑上是等效的</p>\n</li>\n<li><p>功能实现</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li><p>1、功能使用频繁</p>\n</li>\n<li><p>2、硬件实现成本低</p>\n</li>\n</ul>\n</li>\n<li><p>综上，使用硬件的实现效率要高于软件实现</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"计算机硬件的基本组成-1\"><a href=\"#计算机硬件的基本组成-1\" class=\"headerlink\" title=\"计算机硬件的基本组成\"></a>计算机硬件的基本组成</h2><ul>\n<li><p>早期冯诺依曼机</p>\n<ul>\n<li><p>组成：运算器、存储器、控制器、输入设备、输出设备</p>\n</li>\n<li><p>指令与数据共存于存储器，按照地址访问</p>\n</li>\n<li><p>指令与数据以二进制代码构成</p>\n</li>\n<li><p>指令组成：操作码与地址码</p>\n<ul>\n<li><p>操作码表示操作</p>\n</li>\n<li><p>地址码表示操作数存储位置</p>\n</li>\n</ul>\n</li>\n<li><p>指令顺序存放，顺序执行（特定条件可改变执行顺序）</p>\n</li>\n<li><p>运算器为中心，输入输出设备通过运算器与存储器传送数据（现代以存情器为中心）</p>\n</li>\n<li><p>“存储程序”：将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束</p>\n</li>\n</ul>\n</li>\n<li><p>现代计算机结构</p>\n<ul>\n<li><p>存储器为中心</p>\n</li>\n<li><p>I&#x2F;O操作尽可能的绕开CPU，实现&#x2F;0设备与存储器直接完成，从而提高运行效率</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"计算机软件的分类\"><a href=\"#计算机软件的分类\" class=\"headerlink\" title=\"计算机软件的分类\"></a>计算机软件的分类</h2><ul>\n<li><p>以功能进行分类</p>\n<ul>\n<li><p>系统软件</p>\n<ul>\n<li>操作系统（OS）、数据库管理系统（DBMS）、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序</li>\n</ul>\n</li>\n<li><p>应用软件</p>\n<ul>\n<li>为用户解决某个问题的程序：科学计算类程序、工程设计类程序、数据统计与处理程序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>语言分类</p>\n<ul>\n<li><p>机器语言（二进制代码语言）</p>\n<ul>\n<li>机器语言是计算机唯一可以直接识别和执行的语言</li>\n</ul>\n</li>\n<li><p>汇编语言</p>\n<ul>\n<li>利用英文单词代替二进制指令代码，有助于记忆（必须要经过汇编程序对其进行翻译）</li>\n</ul>\n</li>\n<li><p>方便程序设计人员使用的语言</p>\n<ul>\n<li>高级语言—&gt;汇编语言——&gt;机器语言或者高级语言——&gt;机器语言</li>\n</ul>\n</li>\n<li><p>最后一定会变成机器语言因为机器语言唯一机器可以识别与执行的语言</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"计算机工作过程\"><a href=\"#计算机工作过程\" class=\"headerlink\" title=\"计算机工作过程\"></a>计算机工作过程</h2><ul>\n<li><p>具体步骤</p>\n<ul>\n<li><p>程序、数据装入主存</p>\n</li>\n<li><p>从程序起始地址开始运行</p>\n</li>\n<li><p>程序首地址取出指令—&gt;指令译码、指令执行—&gt;完成功能并计算下一条指令地址</p>\n</li>\n<li><p>新得到的指令地址读出下一条指令，直到程序结束</p>\n</li>\n</ul>\n</li>\n<li><p>信息流程：此外，取完指令PC+1，自动形成下一条指令地址</p>\n<ul>\n<li><p>取指令</p>\n<ul>\n<li>PC——&gt;MAR——&gt;M（存储器）——&gt;MDR——&gt;IR</li>\n</ul>\n</li>\n<li><p>分析指令</p>\n<ul>\n<li>OP（IR）——&gt;CU</li>\n</ul>\n</li>\n<li><p>执行指令</p>\n<ul>\n<li>Ad（IR）——&gt;MAR——&gt;M——&gt;MDR———ACC</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"计算机系统的的多级层次结构\"><a href=\"#计算机系统的的多级层次结构\" class=\"headerlink\" title=\"计算机系统的的多级层次结构\"></a>计算机系统的的多级层次结构</h2><ul>\n<li><p>虚拟机器（高级语言机器）</p>\n<ul>\n<li>用汇编程序翻译成汇编语言程序</li>\n</ul>\n</li>\n<li><p>虚拟机器（汇编语言机器）</p>\n<ul>\n<li>编程翻译成机器语言程序</li>\n</ul>\n</li>\n<li><p>虚拟机器（操作系统机器）</p>\n<ul>\n<li>机器语言解释操作系统</li>\n</ul>\n</li>\n<li><p>软硬件交互界面</p>\n</li>\n<li><p>传统机器（使用机器语言的机器）</p>\n<ul>\n<li>微程序解释机器指令</li>\n</ul>\n</li>\n<li><p>微程序机器（微指令系统）</p>\n<ul>\n<li>硬件直接执行微指令</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"各硬部件\"><a href=\"#各硬部件\" class=\"headerlink\" title=\"各硬部件\"></a>各硬部件</h2><ul>\n<li><p>主存</p>\n<ul>\n<li><p>存储体</p>\n<ul>\n<li><p>概念：存储元、存储单元、存储字、存储字长、地址</p>\n</li>\n<li><p>MAR</p>\n<ul>\n<li>地址寄存器，用于指明要读&#x2F;写哪个存储单元。其位数反映存储单元数量</li>\n</ul>\n</li>\n<li><p>MDR</p>\n<ul>\n<li>数据寄存器，用于暂存要读&#x2F;写的数据。其位数&#x3D;存储字长</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>运算器</p>\n<ul>\n<li><p>ACC</p>\n<ul>\n<li>累加计数器，存放操作数、运算的结果</li>\n</ul>\n</li>\n<li><p>MQ</p>\n<ul>\n<li>乘商寄存器，进行乘、除法时用得到</li>\n</ul>\n</li>\n<li><p>X</p>\n<ul>\n<li>通用寄存器，存放操作数</li>\n</ul>\n</li>\n<li><p>ALU</p>\n<ul>\n<li>算数逻辑单元，用电路实现各种算数运算、逻辑运算</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>控制器</p>\n<ul>\n<li><p>PC</p>\n<ul>\n<li>程序计数器，存放下一条指令的地址</li>\n</ul>\n</li>\n<li><p>IR</p>\n<ul>\n<li>指令寄存器，存放当前执行的指令</li>\n</ul>\n</li>\n<li><p>CU</p>\n<ul>\n<li>控制单元，分析指令，给出控制信号</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>工作过程</p>\n<ul>\n<li><p>初始：指令、数据存入主存，PC指向第一条指令</p>\n</li>\n<li><p>从主存中取指令放入IR，PC自动加1、CPU分析指令、CU指挥其他部件执行指令</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"计算机性能指标\"><a href=\"#计算机性能指标\" class=\"headerlink\" title=\"计算机性能指标\"></a>计算机性能指标</h1><h2 id=\"计算机的主要性能指标\"><a href=\"#计算机的主要性能指标\" class=\"headerlink\" title=\"计算机的主要性能指标\"></a>计算机的主要性能指标</h2><ul>\n<li><p>机器字长：计算机字长一般为字节的整数倍，2&#x2F;4&#x2F;8倍</p>\n<ul>\n<li><p>计算机进行一次整数运算可处理的二进制位</p>\n<ul>\n<li><p>受到CPU寄存器位数、加法器影順</p>\n</li>\n<li><p>一般情况机器字长等于内部寄存器大小</p>\n</li>\n<li><p>字长越长，表示范围越大，精度越高</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据通路带宽</p>\n<ul>\n<li><p>数据总线一次性所能传送信息的位数</p>\n</li>\n<li><p>此处数据通路是指外部数据总线宽度，与CPU内部的数据总线宽度可能不同</p>\n</li>\n</ul>\n</li>\n<li><p>主存容量</p>\n<ul>\n<li>主存储器的最大容量<ul>\n<li>MAR位数反映存储单元个数，反映最大寻址范围（最大寻址范围不等于实际寻址范围）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>运算速度</p>\n<ul>\n<li><p>吞吐量</p>\n<ul>\n<li><p>单位时间内处理请求的数</p>\n</li>\n<li><p>取决于主存的存取周期</p>\n</li>\n</ul>\n</li>\n<li><p>响应时间</p>\n<ul>\n<li>用户发送请求，然后系统对请求作出响应并且获得所欲结果的等待时间<ul>\n<li>CPU时间+等待时间（磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CPU时钟周期</p>\n<ul>\n<li><p>节拍脉冲或者是T周期，主频倒数</p>\n</li>\n<li><p>CPU的最小时间单位，每个动作至少需要一个时钟周期</p>\n</li>\n</ul>\n</li>\n<li><p>主频</p>\n<ul>\n<li><p>机器内部主时钟的频率，衡量机器速度的重要参数</p>\n</li>\n<li><p>主频倒数是CPU时钟周期</p>\n</li>\n<li><p>同一型号计算机，主频越高，执行指令速度越快</p>\n</li>\n</ul>\n</li>\n<li><p>CPI</p>\n<ul>\n<li>执行一条指令所需要的时钟周期数</li>\n</ul>\n</li>\n<li><p>CPU执行时间</p>\n<ul>\n<li><p>运行一个程序所花时间</p>\n</li>\n<li><p>影响因素</p>\n<ul>\n<li><p>主频</p>\n</li>\n<li><p>每条指令的执行周期数</p>\n</li>\n<li><p>指令条数</p>\n</li>\n</ul>\n</li>\n<li><p>CPU执行时间&#x3D;CPU时钟周期数&#x2F;主频&#x3D;（指令条数*cpi）&#x2F;主频</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>计算能力</p>\n<ul>\n<li><p>MIPS：每秒执行多少条百万指令</p>\n</li>\n<li><p>MFLOPS：每秒执行多少百万次浮点运算</p>\n</li>\n<li><p>GFLOPS：每秒执行多少十亿次浮点运算</p>\n</li>\n<li><p>TFLOPS：每秒执行多少万亿次浮点运算</p>\n</li>\n<li><p>浮点数运算能力可以用来衡量用于科学计算的计算机的系统性</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"专业术语\"><a href=\"#专业术语\" class=\"headerlink\" title=\"专业术语\"></a>专业术语</h2><ul>\n<li><p>系列机</p>\n<ul>\n<li>相同的体系结构，使用基本指令系统的多个不同型号的计算机组成的一个产品系列</li>\n</ul>\n</li>\n<li><p>兼容</p>\n<ul>\n<li>计算机软件与硬件的通用性</li>\n</ul>\n</li>\n<li><p>软件可移植性</p>\n<ul>\n<li>某个系列的计算机中软件，直接或者进行很少的修改然后运行在另一个系列计算机中的可能性</li>\n</ul>\n</li>\n<li><p>固件</p>\n<ul>\n<li><p>将程序固定在ROM中组成的部分称为固件</p>\n<ul>\n<li><p>拥有软件特性的硬件，性能介于硬件与固件之间，是软硬结合产物</p>\n</li>\n<li><p>速度快于软件，灵活性高于硬件</p>\n</li>\n</ul>\n</li>\n<li><p>后期类似这种结合产物还有：段页表</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"传统冯诺依曼结构\"><a href=\"#传统冯诺依曼结构\" class=\"headerlink\" title=\"传统冯诺依曼结构\"></a>传统冯诺依曼结构</h1><h2 id=\"输入设备\"><a href=\"#输入设备\" class=\"headerlink\" title=\"输入设备\"></a>输入设备</h2><ul>\n<li><p>接收信息</p>\n</li>\n<li><p>键盘、鼠标、扫描仪、摄像机</p>\n</li>\n</ul>\n<h2 id=\"输出设备\"><a href=\"#输出设备\" class=\"headerlink\" title=\"输出设备\"></a>输出设备</h2><ul>\n<li><p>将处理结果进行输出（让用户能看懂）</p>\n</li>\n<li><p>显示器、打印机</p>\n</li>\n</ul>\n<h2 id=\"存储器\"><a href=\"#存储器\" class=\"headerlink\" title=\"存储器\"></a>存储器</h2><ul>\n<li><p>主存</p>\n<ul>\n<li><p>功能或特点</p>\n<ul>\n<li><p>CPU可以直接访问</p>\n</li>\n<li><p>按地址存取信息</p>\n<ul>\n<li>相联存情器可根据内容访问（快表）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>结构：存储单元构成，一个存储单元所能存储的代码成为存储字，其长度就是存储字</p>\n</li>\n<li><p>组成</p>\n<ul>\n<li><p>地址寄存器（MAR）：存放地址</p>\n<ul>\n<li>MAR位数与PC长度相等</li>\n</ul>\n</li>\n<li><p>数据存储器（MDR）：主要暂存存储器中读或写的数据</p>\n<ul>\n<li>MDR位数与存储字长相等一般为字节的二次尋的整数倍</li>\n</ul>\n</li>\n<li><p>时序控制逻辑：产生存储器操作的时序信号</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>辅存</p>\n<ul>\n<li>帮助存储主存信息</li>\n</ul>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>cpu：顾寄，主存：南店，辅存：供货商</p>\n</li>\n<li><p>顾客购买商品，只能等到供货商将货物放入商店后，顾客才能购买</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"运算器-1\"><a href=\"#运算器-1\" class=\"headerlink\" title=\"运算器\"></a>运算器</h2><ul>\n<li><p>对数据进行加工处理</p>\n</li>\n<li><p>结构</p>\n<ul>\n<li><p>核心：算数逻辑单元（ALU）</p>\n</li>\n<li><p>累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX）、基址寄存器（BR）等</p>\n</li>\n<li><p>程序状态寄存器（PSW）：保留运算指令和测试指令的结果状态，表征系统状态</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"控制器-1\"><a href=\"#控制器-1\" class=\"headerlink\" title=\"控制器\"></a>控制器</h2><ul>\n<li><p>计算机指挥中心</p>\n</li>\n<li><p>组成结构</p>\n<ul>\n<li><p>程序计数器（PC）</p>\n<ul>\n<li><p>功能</p>\n<ul>\n<li>存放当前欲执行指令的地址，可以地址自动加一生成下一条指令地址</li>\n</ul>\n</li>\n<li><p>结构</p>\n<ul>\n<li>与主存的MAR有着直接通路</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>指令寄存器（IR）</p>\n<ul>\n<li>功能<ul>\n<li>存放当前指令，内容来自MDR</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>控制单元（CU）</p>\n<ul>\n<li>功能<ul>\n<li>分析来自IR的数据，发出微操作命令</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","1.计算机组成原理","1.计算机系统概述"],"tags":["写作"]},{"title":"数据表示和运算","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_2.%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/","content":"<h1 id=\"数制与编码\"><a href=\"#数制与编码\" class=\"headerlink\" title=\"数制与编码\"></a>数制与编码</h1><h2 id=\"进位计数制及其相互转换\"><a href=\"#进位计数制及其相互转换\" class=\"headerlink\" title=\"进位计数制及其相互转换\"></a>进位计数制及其相互转换</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><p>常见种类：十进制、二进制、八进制、十六进制</p>\n</li>\n<li><p>特点：逢X进一（X进制）</p>\n</li>\n</ul>\n<h3 id=\"种类特点\"><a href=\"#种类特点\" class=\"headerlink\" title=\"种类特点\"></a>种类特点</h3><ul>\n<li><p>二进制</p>\n<ul>\n<li><p>计算机使用最多</p>\n<ul>\n<li>0、1组成</li>\n</ul>\n</li>\n<li><p>任意数位的权值为2^i，i为从右起的位数（注意：i是从零开始计数的）</p>\n</li>\n</ul>\n</li>\n<li><p>八进制</p>\n<ul>\n<li><p>0-7组成</p>\n</li>\n<li><p>二进制的一种书写形式，二进制的3位数码编为一组就是八进制数码（3位二进制最大为7）</p>\n</li>\n<li><p>任意数位的权值为8^i，i为从右起的位数（注意：i是从零开始计数的）</p>\n</li>\n</ul>\n</li>\n<li><p>十六进制</p>\n<ul>\n<li><p>o-9</p>\n<ul>\n<li>A～F组成（A～F）分别表示10—15</li>\n</ul>\n</li>\n<li><p>二进制的4位数码编为一组就是十六进制数码（4位二进制最大为15）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进制转换\"><a href=\"#进制转换\" class=\"headerlink\" title=\"进制转换\"></a>进制转换</h3><ul>\n<li><p>二进制转化为八进制&#x2F;十六进制</p>\n<ul>\n<li>只需要将二讲制的3&#x2F;4位编为一组即可</li>\n</ul>\n</li>\n<li><p>八进制与十六进制相互转换</p>\n<ul>\n<li>先换成二进制再转换</li>\n</ul>\n</li>\n<li><p>任意进制转换为十进制</p>\n<ul>\n<li>任意进制数码与权值相乘，然后再将乘积相加</li>\n</ul>\n</li>\n<li><p>十进制转换为任意进制</p>\n<ul>\n<li><p>整数部分：除基取余法</p>\n</li>\n<li><p>小数部分：乘基取余法</p>\n<ul>\n<li>任意二进制小数都可以用十进制表示，但是并不是每个十进制小数都能用二进制表示（如0.3）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"真值和机器数\"><a href=\"#真值和机器数\" class=\"headerlink\" title=\"真值和机器数\"></a>真值和机器数</h2><ul>\n<li><p>真值：带符号的如-1，2，-3，4</p>\n</li>\n<li><p>机器数：常用最高位</p>\n<ul>\n<li>0表示正</li>\n<li>1表示负</li>\n</ul>\n</li>\n<li><p>补充：真值零表示方式</p>\n<ul>\n<li><p>两种表示法</p>\n<ul>\n<li><p>原码表示法：正零00000、负零10000</p>\n</li>\n<li><p>反码表示法：正零00000、负零11111</p>\n</li>\n</ul>\n</li>\n<li><p>唯一表示</p>\n<ul>\n<li><p>补码对真值零表示是唯一的</p>\n</li>\n<li><p>移码对真值零也是唯一的</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1></li>\n</ul>\n<h2 id=\"BCD码\"><a href=\"#BCD码\" class=\"headerlink\" title=\"BCD码\"></a>BCD码</h2><h3 id=\"8421码（最常用）\"><a href=\"#8421码（最常用）\" class=\"headerlink\" title=\"8421码（最常用）\"></a>8421码（最常用）</h3><ul>\n<li>注意：如果两个8421码相加后的和小于9（10进制），需要加6（10进制）进行修正</li>\n</ul>\n<h3 id=\"余3码（无权码）\"><a href=\"#余3码（无权码）\" class=\"headerlink\" title=\"余3码（无权码）\"></a>余3码（无权码）</h3><ul>\n<li>在8421码的基础上加（0011），因为每个数都多3，所以称为余3码<ul>\n<li>8——&gt;1011</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2421码（有权码）\"><a href=\"#2421码（有权码）\" class=\"headerlink\" title=\"2421码（有权码）\"></a>2421码（有权码）</h3><ul>\n<li><p>权值由高到低为2，4，2，1</p>\n</li>\n<li><p>&gt;&#x3D;5的4位二进制数中最高位为1，&lt;5最高位为0</p>\n<ul>\n<li>5——&gt;1011</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符与字符串\"><a href=\"#字符与字符串\" class=\"headerlink\" title=\"字符与字符串\"></a>字符与字符串</h2><ul>\n<li><p>字符串编码ASCI码</p>\n<ul>\n<li>7位二进制编码</li>\n</ul>\n</li>\n<li><p>汉字的表示和编码</p>\n<ul>\n<li><p>每个编码用两个字节表示</p>\n</li>\n<li><p>种类</p>\n<ul>\n<li><p>输入编码</p>\n<ul>\n<li>计算机输入</li>\n</ul>\n</li>\n<li><p>汉字内码</p>\n<ul>\n<li>计算机内部处理</li>\n</ul>\n</li>\n<li><p>汉字字形码</p>\n<ul>\n<li>计算机输出</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>字符串存放</p>\n<ul>\n<li><p>小端模式</p>\n<ul>\n<li>将数据的最高有效字节存放在高地址单元中</li>\n</ul>\n</li>\n<li><p>大端模式</p>\n<ul>\n<li>将数据的最高有效字节存放在低地址单元中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>从低地址到高地址逐个字符存储，常采用”0作为结尾标志</p>\n</li>\n</ul>\n<h2 id=\"校验码\"><a href=\"#校验码\" class=\"headerlink\" title=\"校验码\"></a>校验码</h2><h3 id=\"概念和原理\"><a href=\"#概念和原理\" class=\"headerlink\" title=\"概念和原理\"></a>概念和原理</h3><ul>\n<li><p>概念：能够发现或者自动纠错的数据编码</p>\n</li>\n<li><p>原理：通过添加一些冗余码，实现检验或者纠错编码</p>\n</li>\n</ul>\n<h3 id=\"奇偶校验码\"><a href=\"#奇偶校验码\" class=\"headerlink\" title=\"奇偶校验码\"></a>奇偶校验码</h3><ul>\n<li><p>奇校验码：有效信息位和校验位中1的个数为奇数</p>\n</li>\n<li><p>偶校验码：有效信息位和校验位中1的个数为偶数</p>\n</li>\n<li><p>码距：2</p>\n</li>\n<li><p>&#x2F;但是如果编码中出现偶数位错误，无法检测</p>\n</li>\n</ul>\n<h3 id=\"海明码\"><a href=\"#海明码\" class=\"headerlink\" title=\"海明码\"></a>海明码</h3><ul>\n<li><p>在有效信息位中添加几个校验码形成海明码</p>\n</li>\n<li><p>不仅可以发现错位，还可以对错位进行纠错</p>\n</li>\n<li><p>编码最小码距L越大，检测位数越多，纠错能力越强（纠错能力恒小于等于检测能力）</p>\n<ul>\n<li>先检错，才能纠错</li>\n</ul>\n</li>\n<li><p>补充</p>\n<ul>\n<li><p>海明码有1位纠错，2位检错能力</p>\n</li>\n<li><p>为了区分1位错和2位错，还需添加”全校验位“对整体进行偶校验</p>\n</li>\n<li><p>注意：有的题目位置编号可能是从小到大的，但处理方法雷同</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CRC-循环冗余码\"><a href=\"#CRC-循环冗余码\" class=\"headerlink\" title=\"CRC(循环冗余码)\"></a>CRC(循环冗余码)</h3><ul>\n<li><p>常用于大量的数据传送时的校验</p>\n</li>\n<li><p>接收到循环冗余码后，对生成多项式做模2除法，余数为0则无错误</p>\n</li>\n<li><p>余数不为0，对相应位置取反</p>\n</li>\n<li><p>检错、纠错能力</p>\n<ul>\n<li><p>可检测出所有奇数个错误</p>\n</li>\n<li><p>可检测出所有双比特的错误</p>\n</li>\n<li><p>可检测出所有小于等于校验位长度的连续错误</p>\n</li>\n<li><p>若选择合适的生成多项式，且2^R&gt;&#x3D;K+R+1，则可纠正单比特错</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"定点数的表示与运算\"><a href=\"#定点数的表示与运算\" class=\"headerlink\" title=\"定点数的表示与运算\"></a>定点数的表示与运算</h1><h2 id=\"定点数的表示\"><a href=\"#定点数的表示\" class=\"headerlink\" title=\"定点数的表示\"></a>定点数的表示</h2><h3 id=\"有符号与无符号\"><a href=\"#有符号与无符号\" class=\"headerlink\" title=\"有符号与无符号\"></a>有符号与无符号</h3><ul>\n<li><p>无符号数：整个机器字长的全部二进制位均为数值位，没有符号位</p>\n</li>\n<li><p>有符号数：最高位的0&#x2F;1分别表示正&#x2F;负</p>\n</li>\n</ul>\n<h3 id=\"机器数定点表示\"><a href=\"#机器数定点表示\" class=\"headerlink\" title=\"机器数定点表示\"></a>机器数定点表示</h3><ul>\n<li><p>定点小数</p>\n<ul>\n<li>定义：定点小数是纯小数，约定小数点位置在符号位之后，有效数值部分最高位之前</li>\n</ul>\n</li>\n<li><p>定点整数</p>\n<ul>\n<li>定义：定点整数是纯整数，小数点位置在有效数值部分的最低位之后</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"补充：机器数\"><a href=\"#补充：机器数\" class=\"headerlink\" title=\"补充：机器数\"></a>补充：机器数</h4><ul>\n<li>​    机器数的定义</li>\n</ul>\n<h3 id=\"机器数表示方法\"><a href=\"#机器数表示方法\" class=\"headerlink\" title=\"机器数表示方法\"></a>机器数表示方法</h3><h4 id=\"原码表示法\"><a href=\"#原码表示法\" class=\"headerlink\" title=\"原码表示法\"></a>原码表示法</h4><ul>\n<li><p>最高位为符号，其余各位为表示数的绝对值</p>\n</li>\n<li><p>纯小数的原码</p>\n<ul>\n<li><p>字长为n+1,范围为：-(1-2^(-n))&lt;&#x3D;x&lt;&#x3D;1-2^(-n)</p>\n</li>\n<li><p>关于原点对构</p>\n</li>\n</ul>\n</li>\n<li><p>纯整数的原码</p>\n<ul>\n<li><p>字长为n+1,范围为-(2^n-1)&lt;&#x3D;X&lt;&#x3D;(2n-1)</p>\n</li>\n<li><p>关于原点对称</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"补码表示法\"><a href=\"#补码表示法\" class=\"headerlink\" title=\"补码表示法\"></a>补码表示法</h4><ul>\n<li><p>由于原码表示中加减法计算复杂，补码表示法可以更好地去表示加减法</p>\n</li>\n<li><p>纯小数补码</p>\n<ul>\n<li><p>表示范围-1&lt;&#x3D;X&lt;&#x3D;1-2^（-n）</p>\n</li>\n<li><p>比原码多表示-1</p>\n</li>\n</ul>\n</li>\n<li><p>纯整数补码</p>\n<ul>\n<li><p>表示范围-2^n&lt;&#x3D;X&lt;&#x3D;2^n-1</p>\n</li>\n<li><p>比原码多-2^n</p>\n</li>\n</ul>\n</li>\n<li><p>补码的算数移位</p>\n<ul>\n<li><p>实现除法功能：符号位与数值位一起右移，保持原符号位数值不变</p>\n</li>\n<li><p>变形补码（模4补码）</p>\n<ul>\n<li><p>正：00</p>\n</li>\n<li><p>负：11</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"反码表示法\"><a href=\"#反码表示法\" class=\"headerlink\" title=\"反码表示法\"></a>反码表示法</h4><ul>\n<li><p>原码与补码相互转化的过渡</p>\n</li>\n<li><p>纯小数反码</p>\n<ul>\n<li><p>表示范围：-(1-2^(-n))&lt;&#x3D;X&lt;&#x3D;1-2^(-n)</p>\n</li>\n<li><p>关于点对称</p>\n</li>\n</ul>\n</li>\n<li><p>纯整数反码</p>\n<ul>\n<li><p>表示范围：-(2^n-1)&lt;&#x3D;X&lt;&#x3D;2^n-1</p>\n</li>\n<li><p>关于原点对称</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"移码表示法\"><a href=\"#移码表示法\" class=\"headerlink\" title=\"移码表示法\"></a>移码表示法</h4><ul>\n<li><p>常用来表示浮点数的阶码，只能表示整数</p>\n</li>\n<li><p>最小值-2^n（全0）</p>\n</li>\n<li><p>最大值2^n-1（全1）</p>\n</li>\n<li><p>移码越大，真值就越大</p>\n</li>\n</ul>\n<h3 id=\"不同表示方法间的相互转换\"><a href=\"#不同表示方法间的相互转换\" class=\"headerlink\" title=\"不同表示方法间的相互转换\"></a>不同表示方法间的相互转换</h3><ul>\n<li><p>原码&lt;——&gt;补码</p>\n<ul>\n<li><p>正数：补码与原码表示相同</p>\n</li>\n<li><p>负数：原码符号位不变，数值部分按位取反</p>\n</li>\n</ul>\n</li>\n<li><p>不同机器数的转换关系图</p>\n</li>\n</ul>\n<h2 id=\"定点数的运算\"><a href=\"#定点数的运算\" class=\"headerlink\" title=\"定点数的运算\"></a>定点数的运算</h2><h3 id=\"定点数移位运算\"><a href=\"#定点数移位运算\" class=\"headerlink\" title=\"定点数移位运算\"></a>定点数移位运算</h3><ul>\n<li><p>算数移位</p>\n<ul>\n<li><p>正数</p>\n<ul>\n<li>移位后添零</li>\n</ul>\n</li>\n<li><p>负数</p>\n<ul>\n<li><p>原码</p>\n<ul>\n<li>添零</li>\n</ul>\n</li>\n<li><p>补码</p>\n<ul>\n<li>左0右</li>\n</ul>\n</li>\n<li><p>反码</p>\n<ul>\n<li>全部填1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>符号位不参与运算</p>\n</li>\n</ul>\n</li>\n<li><p>逻辑移位</p>\n<ul>\n<li><p>将操作数看做无符号数</p>\n</li>\n<li><p>左移或者右移都要添零</p>\n</li>\n</ul>\n</li>\n<li><p>循环移位</p>\n<ul>\n<li><p>带进位标志位的循环移位</p>\n</li>\n<li><p>不带进位标志位的移位的循环移位</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"原码定点数的加减法运算\"><a href=\"#原码定点数的加减法运算\" class=\"headerlink\" title=\"原码定点数的加减法运算\"></a>原码定点数的加减法运算</h3><ul>\n<li><p>加法准则</p>\n<ul>\n<li><p>符号相同：绝对值相加，符号不变</p>\n</li>\n<li><p>符号不同：绝对值大的减去绝对值小的，符号取绝对值大的数</p>\n</li>\n</ul>\n</li>\n<li><p>减法准则</p>\n<ul>\n<li><p>1、减数的符号取反</p>\n</li>\n<li><p>2、将其与被减数做原码加法运算</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"补码定点数加减法运算\"><a href=\"#补码定点数加减法运算\" class=\"headerlink\" title=\"补码定点数加减法运算\"></a>补码定点数加减法运算</h3><ul>\n<li><p>1、参与的操作数均为补码</p>\n</li>\n<li><p>2、按照二进制规则运算逢二进一</p>\n</li>\n<li><p>3、符号位与数值位同时参与运算，符号位产生的进位丢掉，结果的符号由运算得出</p>\n</li>\n<li><p>4、补码运算的结果仍然是补码</p>\n</li>\n</ul>\n<h3 id=\"符号扩展\"><a href=\"#符号扩展\" class=\"headerlink\" title=\"符号扩展\"></a>符号扩展</h3><ul>\n<li><p>正数</p>\n<ul>\n<li>在原有的基础上，添零凑位数即可</li>\n</ul>\n</li>\n<li><p>负数</p>\n<ul>\n<li><p>原码</p>\n<ul>\n<li>将原有形式的符号移动到新形式的符号位上，新形式的附加位进行添零处理</li>\n</ul>\n</li>\n<li><p>补码</p>\n<ul>\n<li>加1处理</li>\n</ul>\n</li>\n<li><p>反码</p>\n<ul>\n<li>加1处理</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"溢出概念和判别方法\"><a href=\"#溢出概念和判别方法\" class=\"headerlink\" title=\"溢出概念和判别方法\"></a>溢出概念和判别方法</h3><ul>\n<li><p>上溢：大于最大可以表示正数</p>\n</li>\n<li><p>下溢：小于最小可以表示的负数</p>\n</li>\n<li><p>补码判断溢出方法</p>\n<ul>\n<li><p>一位符号位：参加运算的两个数的符号相同，但是结果符号出现变化，则结果溢出</p>\n</li>\n<li><p>双符号位：（模4补码）</p>\n<ul>\n<li><p>00：正数、无溢出</p>\n</li>\n<li><p>01：正溢出</p>\n</li>\n<li><p>10：负溢出</p>\n</li>\n<li><p>11：负数、无溢出</p>\n</li>\n</ul>\n</li>\n<li><p>一位符号位根据数据位进位判断</p>\n<ul>\n<li>符号位进位与最高位进位相同，则无溢出</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定点数的乘法运算\"><a href=\"#定点数的乘法运算\" class=\"headerlink\" title=\"定点数的乘法运算\"></a>定点数的乘法运算</h3><ul>\n<li><p>原码一位乘法</p>\n<ul>\n<li><p>符号位：由两个数的符号位异或</p>\n</li>\n<li><p>数值：两个数的绝对值相乘之积</p>\n</li>\n<li><p>符号不参与运算</p>\n</li>\n<li><p>部分积2位、乘数0位</p>\n</li>\n<li><p>累加次数n</p>\n</li>\n</ul>\n</li>\n<li><p>补码一位乘法</p>\n<ul>\n<li><p>符号位参与运算</p>\n</li>\n<li><p>部分积2位、乘数1位</p>\n</li>\n<li><p>累加次数n+1</p>\n</li>\n</ul>\n</li>\n<li><p>注：移位</p>\n<ul>\n<li><p>方向：向右</p>\n</li>\n<li><p>次数：n</p>\n</li>\n<li><p>每位次数：1</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定点数的除法运算\"><a href=\"#定点数的除法运算\" class=\"headerlink\" title=\"定点数的除法运算\"></a>定点数的除法运算</h3><ul>\n<li><p>原码除法运算（不恢复余数法）</p>\n<ul>\n<li><p>商符和商值分开运算</p>\n<ul>\n<li>商符由两个操作数异或</li>\n</ul>\n</li>\n<li><p>符号位不参与运算</p>\n</li>\n<li><p>加减次数n+1或n+2</p>\n</li>\n<li><p>若最终余数为负，需要恢复余数</p>\n</li>\n</ul>\n</li>\n<li><p>补码除法运算（加减交替法）</p>\n<ul>\n<li><p>符号位参与运算</p>\n</li>\n<li><p>加减次数n+1</p>\n</li>\n<li><p>商末衡置为一</p>\n</li>\n</ul>\n</li>\n<li><p>注：移位</p>\n<ul>\n<li><p>方向：左</p>\n</li>\n<li><p>次数：n</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h3><ul>\n<li>将所给数字写为二进制，然后按照转换成不同的码的规则进行读取</li>\n</ul>\n<h1 id=\"浮点数的表示与运算\"><a href=\"#浮点数的表示与运算\" class=\"headerlink\" title=\"浮点数的表示与运算\"></a>浮点数的表示与运算</h1><h2 id=\"浮点数的表示\"><a href=\"#浮点数的表示\" class=\"headerlink\" title=\"浮点数的表示\"></a>浮点数的表示</h2><h3 id=\"表示格式\"><a href=\"#表示格式\" class=\"headerlink\" title=\"表示格式\"></a>表示格式</h3><ul>\n<li><p>阶码是整数，阶符与阶码的位数共同反映浮点数的表示范围与小数点的实际位置</p>\n</li>\n<li><p>数符表示浮点数的符号</p>\n</li>\n<li><p>尾数的位数表示浮点数的精度</p>\n</li>\n</ul>\n<h3 id=\"规格化浮点数\"><a href=\"#规格化浮点数\" class=\"headerlink\" title=\"规格化浮点数\"></a>规格化浮点数</h3><ul>\n<li><p>左规：尾数算数左移一位，阶码减一</p>\n</li>\n<li><p>右规：结果出现溢出（双符号位01或10），将尾数算数右移一位，阶码加1</p>\n</li>\n<li><p>左规可以多次，右规只能一次</p>\n</li>\n</ul>\n<h3 id=\"原码规格化\"><a href=\"#原码规格化\" class=\"headerlink\" title=\"原码规格化\"></a>原码规格化</h3><ul>\n<li><p>正数：0.1xxx</p>\n</li>\n<li><p>负数：1.1Xxx</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>基数：4原码规格化形式的尾数最高2位不全为0</p>\n</li>\n<li><p>基数：8原码规格化形式尾数最高3位不全为0</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"补码规格化\"><a href=\"#补码规格化\" class=\"headerlink\" title=\"补码规格化\"></a>补码规格化</h3><ul>\n<li><p>正数：0.1xxX</p>\n</li>\n<li><p>负数：1.0xxxx</p>\n</li>\n</ul>\n<h3 id=\"IEEE754\"><a href=\"#IEEE754\" class=\"headerlink\" title=\"IEEE754\"></a>IEEE754</h3><ul>\n<li><p>整数部分隐含1</p>\n<ul>\n<li><p>短浮点数（组成位数）</p>\n<ul>\n<li><p>数符:1</p>\n</li>\n<li><p>阶码：8</p>\n</li>\n<li><p>尾数数值：23</p>\n</li>\n<li><p>总位数：32</p>\n</li>\n<li><p>偏置值：</p>\n<ul>\n<li><p>7fh(16进制)</p>\n</li>\n<li><p>127(十进制)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>长浮点数（组成位数）</p>\n<ul>\n<li><p>数符：1</p>\n</li>\n<li><p>阶码：11</p>\n</li>\n<li><p>尾数数值：52</p>\n</li>\n<li><p>总位数：64</p>\n</li>\n<li><p>偏置值：</p>\n<ul>\n<li><p>3ffh（16进制）</p>\n</li>\n<li><p>1023（十进制）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>临时浮点数（组成位数）</p>\n<ul>\n<li><p>数符：1</p>\n</li>\n<li><p>阶码：15</p>\n</li>\n<li><p>尾数数值：64</p>\n</li>\n<li><p>总位数：80</p>\n</li>\n<li><p>偏置值：</p>\n<ul>\n<li><p>3ffh（16进制）</p>\n</li>\n<li><p>16383（十进制）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>浮点数范围</p>\n<ul>\n<li><p>单精度浮点数：</p>\n<ul>\n<li>2^(-126)～2^(127)*(2-2^(-23))</li>\n</ul>\n</li>\n<li><p>双精度浮点数：</p>\n<ul>\n<li>2^(-1022)～2^(1023)*(2-2^(-52))</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"定点数与浮点数的区别\"><a href=\"#定点数与浮点数的区别\" class=\"headerlink\" title=\"定点数与浮点数的区别\"></a>定点数与浮点数的区别</h3><ul>\n<li><p>相同字长，浮点数范围更大</p>\n</li>\n<li><p>浮点数精度降低</p>\n</li>\n<li><p>浮点数运算复杂</p>\n</li>\n<li><p>浮点数只有规格化后阶码超出表示范围，才发生溢出</p>\n</li>\n</ul>\n<h2 id=\"浮点数的加减运算\"><a href=\"#浮点数的加减运算\" class=\"headerlink\" title=\"浮点数的加减运算\"></a>浮点数的加减运算</h2><h3 id=\"对阶\"><a href=\"#对阶\" class=\"headerlink\" title=\"对阶\"></a>对阶</h3><ul>\n<li>小阶看齐大阶，阶码小的尾数右移一位，阶加一，直到阶码相等</li>\n</ul>\n<h3 id=\"尾数求和\"><a href=\"#尾数求和\" class=\"headerlink\" title=\"尾数求和\"></a>尾数求和</h3><ul>\n<li>尾数按照定点数加减规则运算</li>\n</ul>\n<h3 id=\"规格化\"><a href=\"#规格化\" class=\"headerlink\" title=\"规格化\"></a>规格化</h3><ul>\n<li><p>最高数值位与符号位不同即为规格化形式</p>\n</li>\n<li><p>左规：尾数左移1位，和的阶码减1</p>\n<ul>\n<li>直到00.1XX或者11.0xxx</li>\n</ul>\n</li>\n<li><p>右规，尾数求和结果溢出（10.XXX或者01.XXX）</p>\n<ul>\n<li>尾数右移一位，和的阶码加1</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"舍入\"><a href=\"#舍入\" class=\"headerlink\" title=\"舍入\"></a>舍入</h3><ul>\n<li><p>0舍1入法</p>\n<ul>\n<li><p>尾数右移时，移去的最高数值位为0，则舍去</p>\n</li>\n<li><p>尾数左移时，移去的最高数值位为1，则尾数末位加1</p>\n</li>\n<li><p>可能会导致溢出，此时需要再一次右规</p>\n</li>\n</ul>\n</li>\n<li><p>恒置1法</p>\n<ul>\n<li>尾数右移，不论最高数值位丢掉的是1还是0，都将尾数末位恒置为1</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"溢出判断\"><a href=\"#溢出判断\" class=\"headerlink\" title=\"溢出判断\"></a>溢出判断</h3><ul>\n<li><p>只有右规后，仍然溢出，此时才是真正溢出</p>\n</li>\n<li><p>上溢出：进入中断处理</p>\n</li>\n<li><p>下溢出：按机器零处理</p>\n</li>\n</ul>\n<h3 id=\"强制类型转换-1\"><a href=\"#强制类型转换-1\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h3><ul>\n<li><p>char——&gt;int</p>\n<ul>\n<li>在前面补0</li>\n</ul>\n</li>\n<li><p>int&lt;——&gt;unsigned</p>\n<ul>\n<li>彼此都可能因为溢出丢失数据</li>\n</ul>\n</li>\n<li><p>int&lt;——&gt;float</p>\n<ul>\n<li><p>float转换为int，可能会出现精度损失和溢出</p>\n</li>\n<li><p>int转换为float，可能会出现数据舍入</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"补充：边界对齐\"><a href=\"#补充：边界对齐\" class=\"headerlink\" title=\"补充：边界对齐\"></a>补充：边界对齐</h3><ul>\n<li><p>现代计算机通常是按字节编址，即每个字节对应1个地址</p>\n</li>\n<li><p>通常也支持按字、按半字、按字节寻址</p>\n</li>\n</ul>\n<h1 id=\"算术逻辑单元（ALU）\"><a href=\"#算术逻辑单元（ALU）\" class=\"headerlink\" title=\"算术逻辑单元（ALU）\"></a>算术逻辑单元（ALU）</h1><p>运算器组成：算术逻辑单元累加器状态寄存器通用寄存器组</p>\n<h2 id=\"串行加法器和并行加法器\"><a href=\"#串行加法器和并行加法器\" class=\"headerlink\" title=\"串行加法器和并行加法器\"></a>串行加法器和并行加法器</h2><h3 id=\"一位全加器\"><a href=\"#一位全加器\" class=\"headerlink\" title=\"一位全加器\"></a>一位全加器</h3><ul>\n<li><p>两个加数输入，以及低位进入输入</p>\n</li>\n<li><p>本位结果和进位输出</p>\n</li>\n</ul>\n<h3 id=\"串行加法器\"><a href=\"#串行加法器\" class=\"headerlink\" title=\"串行加法器\"></a>串行加法器</h3><ul>\n<li><p>只有一个全加器，数据逐位的送入加法器中运算，逐位送回寄存器</p>\n</li>\n<li><p>操作数n位，则进行n次</p>\n</li>\n<li><p>成本低，但是速度慢</p>\n</li>\n</ul>\n<h3 id=\"并行加法器\"><a href=\"#并行加法器\" class=\"headerlink\" title=\"并行加法器\"></a>并行加法器</h3><ul>\n<li><p>多个加法器共同组成，每个全加器都有一个低位送来的进位输入，向高位的进位输出</p>\n</li>\n<li><p>进位方式</p>\n<ul>\n<li><p>串行进位</p>\n<ul>\n<li>将全加器串接在一起，每级进位依赖于前一级进位</li>\n</ul>\n</li>\n<li><p>并行进位</p>\n<ul>\n<li>同时进位，各级进位信号同时形成</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：提高并行加法器速度的关键在于加快进位产生和传递速度</p>\n</li>\n</ul>\n<h2 id=\"算术逻辑单元的功能和结构\"><a href=\"#算术逻辑单元的功能和结构\" class=\"headerlink\" title=\"算术逻辑单元的功能和结构\"></a>算术逻辑单元的功能和结构</h2><ul>\n<li>ALU：算数运算与逻辑运算</li>\n</ul>\n","categories":["计算机408","1.计算机组成原理","2.数据表示和运算"],"tags":["写作"]},{"title":"指令系统","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_4.%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/","content":"<h1 id=\"指令格式\"><a href=\"#指令格式\" class=\"headerlink\" title=\"指令格式\"></a>指令格式</h1><h2 id=\"指令的基本格式（操作码-地址码）\"><a href=\"#指令的基本格式（操作码-地址码）\" class=\"headerlink\" title=\"指令的基本格式（操作码+地址码）\"></a>指令的基本格式（操作码+地址码）</h2><ul>\n<li><p>结构</p>\n<ul>\n<li><p>操作码：指出指令中应该执行什么性质的操作和具有何种功能</p>\n</li>\n<li><p>地址码：给出被操作的信息（指令或者数据）的地址</p>\n</li>\n</ul>\n</li>\n<li><p>长度</p>\n<ul>\n<li><p>单字长指令：长度等于机器字长</p>\n</li>\n<li><p>双字长指令：长度等两倍机器字长</p>\n</li>\n<li><p>半字长指令：长度等于半个机器字长</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>定长指令字结构：所有指令长度相同</p>\n</li>\n<li><p>变长指令字结构：各种指令的长度不同</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>根据操作数地址码数目分类</p>\n<ul>\n<li><p>零地址指令</p>\n<ul>\n<li><p>OР</p>\n</li>\n<li><p>只有操作码OP，没有给出地址</p>\n</li>\n<li><p>指令用途</p>\n<ul>\n<li><p>空操作指令，停机指令，关中断指令</p>\n</li>\n<li><p>零地址的运算类指令仅使用在堆栈计算机中</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>一地址指令</p>\n<ul>\n<li><p>OP、A1</p>\n</li>\n<li><p>指令用途</p>\n<ul>\n<li><p>只有目的操作数的单操作数指令</p>\n<ul>\n<li>加1、减1、求反、求补</li>\n</ul>\n</li>\n<li><p>隐含约定目的地址的双操作数指令</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二地址指令</p>\n<ul>\n<li><p>OP、A1、A2</p>\n</li>\n<li><p>指令用途</p>\n<ul>\n<li><p>算术和逻辑运算指令</p>\n</li>\n<li><p>往往需要两个操作数，分别给出目的操作数和源操作数地址，目的操作数地址还用于保存本次的运算结果</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>三地址指令</p>\n<ul>\n<li><p>OP、A1、A2、A3（结果）</p>\n</li>\n<li><p>指令用途</p>\n<ul>\n<li>算术和逻辑运算指令，相对于二地址指令，结果直接存放在A3中</li>\n</ul>\n</li>\n<li><p>需要访问4次存储器</p>\n<ul>\n<li><p>取指令（1次）</p>\n</li>\n<li><p>取两个操作数（2次）</p>\n</li>\n<li><p>存放结果（1次）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>四地址指令</p>\n<ul>\n<li><p>OP、A1、A2、A3（结果）、A4（下址）</p>\n</li>\n<li><p>指令用途：算术和逻辑运算指令，相对于三地址指令多了下一条执行命令的地址（A4）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"定长操作码指令格式\"><a href=\"#定长操作码指令格式\" class=\"headerlink\" title=\"定长操作码指令格式\"></a>定长操作码指令格式</h2><ul>\n<li><p>优点：定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有和</p>\n</li>\n<li><p>缺点：指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限</p>\n</li>\n</ul>\n<h2 id=\"扩展操作码指令格式\"><a href=\"#扩展操作码指令格式\" class=\"headerlink\" title=\"扩展操作码指令格式\"></a>扩展操作码指令格式</h2><ul>\n<li><p>实现：全部指令的操作码字段位数不固定，分散在指令字的不同位置上</p>\n</li>\n<li><p>优点：丰富了指令的种类</p>\n</li>\n<li><p>缺点：增加了指令译码和分析难度，控制器设计变的复杂</p>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><p>1.短码不能是长码的前缀</p>\n</li>\n<li><p>2.指令操作码不能重复</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"指令的操作类型\"><a href=\"#指令的操作类型\" class=\"headerlink\" title=\"指令的操作类型\"></a>指令的操作类型</h2><h1 id=\"指令寻址方式\"><a href=\"#指令寻址方式\" class=\"headerlink\" title=\"指令寻址方式\"></a>指令寻址方式</h1><h2 id=\"指令寻址和数据寻址\"><a href=\"#指令寻址和数据寻址\" class=\"headerlink\" title=\"指令寻址和数据寻址\"></a>指令寻址和数据寻址</h2><ul>\n<li><p>指令寻址</p>\n<ul>\n<li><p>顺序寻址：通过程序计数器（PC）加1，自动生成下一条指令的地址</p>\n</li>\n<li><p>跳跃寻址</p>\n<ul>\n<li><p>通过转移类指令实现，是否跳跃受到状态寄存器和操作数的控制</p>\n</li>\n<li><p>跳跃到的地址分类</p>\n<ul>\n<li><p>绝对地址：由标记符直接得到</p>\n</li>\n<li><p>相对地址：相对于当前指令地址的偏移量</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li>跳跃的结果是当前指令修改pc值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据寻址</p>\n<ul>\n<li><p>在指令中表示一个操作数的地址</p>\n</li>\n<li><p>结构：操作码+导址特征+形式地址A</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"常见的数据寻址方式\"><a href=\"#常见的数据寻址方式\" class=\"headerlink\" title=\"常见的数据寻址方式\"></a>常见的数据寻址方式</h2><h3 id=\"隐含寻址：不访存\"><a href=\"#隐含寻址：不访存\" class=\"headerlink\" title=\"隐含寻址：不访存\"></a>隐含寻址：不访存</h3><ul>\n<li><p>不显示的给出操作数地址，在指令中隐含操作数地址</p>\n</li>\n<li><p>优点：有利于缩短指令字长</p>\n</li>\n<li><p>缺点：增加存储操作数或隐含地址的硬件</p>\n</li>\n</ul>\n<h3 id=\"立即（数）寻址：不访存\"><a href=\"#立即（数）寻址：不访存\" class=\"headerlink\" title=\"立即（数）寻址：不访存\"></a>立即（数）寻址：不访存</h3><ul>\n<li><p>地址字段给出的不是操作数的地址，而是操作数本身，又称为立即数</p>\n</li>\n<li><p>优点：不需要访问主存，指令执行时间最短</p>\n</li>\n<li><p>缺点：位数限制了立即数的范围</p>\n</li>\n</ul>\n<h3 id=\"直接寻址：访存1次\"><a href=\"#直接寻址：访存1次\" class=\"headerlink\" title=\"直接寻址：访存1次\"></a>直接寻址：访存1次</h3><ul>\n<li><p>指令字中的形式地址就是真实地址</p>\n</li>\n<li><p>优点：访问一次主存，不需要专门计算操作数的地址</p>\n</li>\n<li><p>缺点：形式地址的位数限制了寻址范围，操作数地址不易修改</p>\n</li>\n</ul>\n<h3 id=\"间接寻址：访问多次\"><a href=\"#间接寻址：访问多次\" class=\"headerlink\" title=\"间接寻址：访问多次\"></a>间接寻址：访问多次</h3><ul>\n<li><p>一般问到扩大寻址范围，通常指寄存器间接寻址、访存多次（具体看几次间接寻址）</p>\n</li>\n<li><p>指令的地址字段给出存储地址信息的地址（类似于套娃）</p>\n</li>\n<li><p>优点：扩大了寻址范围，方便编制程序</p>\n</li>\n<li><p>缺点：需要多次访存，访问速度过慢，这种寻址方式不是特别常用</p>\n</li>\n</ul>\n<h3 id=\"寄存器寻址：不访存\"><a href=\"#寄存器寻址：不访存\" class=\"headerlink\" title=\"寄存器寻址：不访存\"></a>寄存器寻址：不访存</h3><ul>\n<li><p>指令字中直接给出操作数所在的寄存器编号</p>\n</li>\n<li><p>优点：不访问主存，执行速度快，支持向量&#x2F;矩阵运身</p>\n</li>\n<li><p>缺点：寄存器价格高昂，寄存器中的寄存器个数有限</p>\n</li>\n</ul>\n<h2 id=\"X86汇编指令入门\"><a href=\"#X86汇编指令入门\" class=\"headerlink\" title=\"X86汇编指令入门\"></a>X86汇编指令入门</h2><h1 id=\"CISC和RISC概念\"><a href=\"#CISC和RISC概念\" class=\"headerlink\" title=\"CISC和RISC概念\"></a>CISC和RISC概念</h1><ul>\n<li><p>基本概念</p>\n<ul>\n<li><p>指令系统</p>\n<ul>\n<li><p>CISC：复杂庞大</p>\n</li>\n<li><p>RISC：精简简单</p>\n</li>\n</ul>\n</li>\n<li><p>指令数目</p>\n<ul>\n<li><p>CISC：大于200条</p>\n</li>\n<li><p>RISC：小于100条</p>\n</li>\n</ul>\n</li>\n<li><p>指令字长</p>\n<ul>\n<li><p>CISC：不固定</p>\n</li>\n<li><p>RISC：定长</p>\n</li>\n</ul>\n</li>\n<li><p>访存指令</p>\n<ul>\n<li><p>CISC：不加限制</p>\n</li>\n<li><p>RISC:只有load和store</p>\n</li>\n</ul>\n</li>\n<li><p>指令执行时间</p>\n<ul>\n<li><p>CISC：相差较大</p>\n</li>\n<li><p>RISC绝大多数在一个周期内完成</p>\n</li>\n</ul>\n</li>\n<li><p>指令的使用频度</p>\n<ul>\n<li><p>CISC：相差很大</p>\n</li>\n<li><p>RISC：绝大多数在一个周期内完成</p>\n</li>\n</ul>\n</li>\n<li><p>通用寄存器的数量</p>\n<ul>\n<li><p>CISC：较少</p>\n</li>\n<li><p>RISC：较多</p>\n</li>\n</ul>\n</li>\n<li><p>目标代码</p>\n<ul>\n<li><p>CISC：难以优化编译生成高效目标代码</p>\n</li>\n<li><p>RISC：采用优化编译程序，生成代码高效</p>\n</li>\n</ul>\n</li>\n<li><p>控制方式</p>\n<ul>\n<li><p>CISC：绝大多数采用微程序控制</p>\n</li>\n<li><p>RISC：绝大多数采用组合逻辑控制</p>\n</li>\n</ul>\n</li>\n<li><p>指令流水线</p>\n<ul>\n<li><p>CISC：可以实现</p>\n</li>\n<li><p>RISC：必须实现</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>RISC优点</p>\n<ul>\n<li><p>采用组合逻辑控制，硬布线使用较少</p>\n</li>\n<li><p>运算速度更快</p>\n</li>\n<li><p>设计方便，可靠性高，机器设计周期短，逻辑简单</p>\n</li>\n<li><p>有利于编译程序代码优化</p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","1.计算机组成原理","4.指令系统"],"tags":["写作"]},{"title":"存储系统","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_3.%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/","content":"<h1 id=\"虚拟存储器和CACHE异同\"><a href=\"#虚拟存储器和CACHE异同\" class=\"headerlink\" title=\"虚拟存储器和CACHE异同\"></a>虚拟存储器和CACHE异同</h1><h2 id=\"相同之处\"><a href=\"#相同之处\" class=\"headerlink\" title=\"相同之处\"></a>相同之处</h2><ul>\n<li><p>目的为了提高系统性能</p>\n</li>\n<li><p>数据分为小信息块，作为基本的传递单位</p>\n</li>\n<li><p>都存在地址映射，替换算法，更新策略</p>\n</li>\n<li><p>按照局部性原理，将活跃的数据放到高速部件中</p>\n</li>\n</ul>\n<h2 id=\"不同之处\"><a href=\"#不同之处\" class=\"headerlink\" title=\"不同之处\"></a>不同之处</h2><ul>\n<li><p>Cache解决系统速度问题苏尼存储器解决主存容量问题</p>\n</li>\n<li><p>Cache全部由硬件实现，是硬件存储器虚拟存储器有OS和硬件共同实现，是逻辑上的存储器</p>\n</li>\n<li><p>Cache对所有程序员透明，虚拟存储器对应用程序员透明，对系统程序员不透明</p>\n</li>\n<li><p>虚拟存储器不命中对系统性能影响更大</p>\n</li>\n<li><p>CPU只能与Cache和主存直接交互</p>\n<ul>\n<li>虚拟存储系统只能先将数据从硬盘调入主存，不能与CPU直接通信</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"存储器概述\"><a href=\"#存储器概述\" class=\"headerlink\" title=\"存储器概述\"></a>存储器概述</h1><h2 id=\"存储器分类\"><a href=\"#存储器分类\" class=\"headerlink\" title=\"存储器分类\"></a>存储器分类</h2><h3 id=\"层次分类\"><a href=\"#层次分类\" class=\"headerlink\" title=\"层次分类\"></a>层次分类</h3><ul>\n<li><p>主存</p>\n<ul>\n<li><p>存放计算机运行时的程序与数据</p>\n</li>\n<li><p>可以被CPU直接访问，也可以与Cache和辅存进行交换数据</p>\n</li>\n<li><p>容量小，速度快，价格高</p>\n</li>\n</ul>\n</li>\n<li><p>辅存</p>\n<ul>\n<li><p>存储当前暂时不用的程序和数据，以及一些永久保留数据</p>\n</li>\n<li><p>不可以与CPU直接交互</p>\n</li>\n<li><p>容量大，速度慢，价格低</p>\n</li>\n</ul>\n</li>\n<li><p>高速缓冲存储器（cache）</p>\n<ul>\n<li><p>位于主存与CPU之间，缓解CPU与主存之间速度差距问题</p>\n</li>\n<li><p>CPU可以直接访问</p>\n</li>\n<li><p>容量小，速度与CPU相匹配，价格高</p>\n<ul>\n<li>高档计算机将他们放在CPU中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"存储介质分类\"><a href=\"#存储介质分类\" class=\"headerlink\" title=\"存储介质分类\"></a>存储介质分类</h3><ul>\n<li><p>磁表面存儲器：磁盘磁带</p>\n</li>\n<li><p>磁芯存储器半导体存储器（MOS型存储器双极型存储器）</p>\n</li>\n<li><p>光存储器：光盘</p>\n</li>\n</ul>\n<h3 id=\"存取方式分类\"><a href=\"#存取方式分类\" class=\"headerlink\" title=\"存取方式分类\"></a>存取方式分类</h3><ul>\n<li><p>随机存储器（RAM）</p>\n<ul>\n<li><p>随机存取，读写方便，使用灵活</p>\n</li>\n<li><p>用途：主存高速缓冲存储器</p>\n</li>\n<li><p>类型：静态RAM（触发器原理）、动态RAM（电容充电原理）</p>\n</li>\n</ul>\n</li>\n<li><p>只读存储器（ROM）</p>\n<ul>\n<li><p>只能读出不能写入</p>\n</li>\n<li><p>用途：与随机存储器构成主存存储固定不变的程序（甚至操作系统的固化）</p>\n</li>\n<li><p>ROM也派生出可以反复面写的类型</p>\n</li>\n</ul>\n</li>\n<li><p>rom与ram都是随机存取，广义上的只读存储器可以通过电擦除写入的，与入速度比读速度慢</p>\n</li>\n</ul>\n<h3 id=\"信息可保存性\"><a href=\"#信息可保存性\" class=\"headerlink\" title=\"信息可保存性\"></a>信息可保存性</h3><ul>\n<li><p>易失性存储器</p>\n<ul>\n<li><p>RAM</p>\n</li>\n<li><p>断电后，仍然可以保持信息</p>\n</li>\n</ul>\n</li>\n<li><p>非易失性存储器存储器</p>\n<ul>\n<li><p>ROM、磁表面存储器、光存储器</p>\n</li>\n<li><p>读出类型</p>\n<ul>\n<li><p>破坏性读出：读出后需要对存储信息再生</p>\n</li>\n<li><p>非破坏性读出：不会对原存储信息破坏</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"存储器的性能指标\"><a href=\"#存储器的性能指标\" class=\"headerlink\" title=\"存储器的性能指标\"></a>存储器的性能指标</h2><ul>\n<li><p>计算机追求目标：大容量，低成本，高速度（联系自身买电脑）</p>\n</li>\n<li><p>存储容量&#x3D;存储字数字长</p>\n</li>\n<li><p>单位成本&#x3D;总成本&#x2F;总容量</p>\n</li>\n<li><p>存储速度：数据传输率&#x3D;数据宽度&#x2F;存储周期</p>\n<ul>\n<li><p>存取时间：存储器启动到完成操作，分为读出时间与写入时间</p>\n</li>\n<li><p>存取周期（读写周期、访问周期）：存储器进行一次完整读写操作需要时</p>\n</li>\n<li><p>主存带宽：数据传输率，每秒主存进出信息的最大数量</p>\n</li>\n<li><p>注：存储周期一般大于存取时间（读与操作后需要内部复原时间）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"存储器的层次化结构\"><a href=\"#存储器的层次化结构\" class=\"headerlink\" title=\"存储器的层次化结构\"></a>存储器的层次化结构</h1><ul>\n<li><p>多级存储系统</p>\n<ul>\n<li><p>存储系统目标：更大更快更便宜</p>\n</li>\n<li><p>Cache——主存层次</p>\n<ul>\n<li>解决CPU和主存速度不匹配问题</li>\n</ul>\n</li>\n<li><p>主存——辅存层次：主存——辅存层次不断发展，衍生出虚拟存储器系统</p>\n<ul>\n<li>解决存储系统容量问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"半导体随机存储器\"><a href=\"#半导体随机存储器\" class=\"headerlink\" title=\"半导体随机存储器\"></a>半导体随机存储器</h1><h3 id=\"半导体存储芯片1\"><a href=\"#半导体存储芯片1\" class=\"headerlink\" title=\"半导体存储芯片1\"></a>半导体存储芯片1</h3><ul>\n<li><p>存储矩阵：大量相同的位存储单元阵列构成</p>\n</li>\n<li><p>译码驱动：地址信号翻译成对应存储单元的选通信号</p>\n</li>\n<li><p>读写电路：完成读写操</p>\n</li>\n<li><p>读&#x2F;写控制线：决定芯片是读还是写</p>\n</li>\n<li><p>片选线：确定那个芯片被选中</p>\n</li>\n<li><p>地址线：单项输入，位数与存储字的个数有关</p>\n</li>\n<li><p>数据线：双向的，位数与读出或写入的数据位数有关</p>\n<ul>\n<li>注：数据线数与地址线数共同反映存储芯片容量大小</li>\n</ul>\n</li>\n<li><p>半导体随机存储器分类（存储原理不同）</p>\n<ul>\n<li><p>SRAM：高速缓存</p>\n</li>\n<li><p>DRAM：主存</p>\n</li>\n</ul>\n</li>\n<li><p>74138译码器</p>\n</li>\n</ul>\n<h2 id=\"SRAM和DRAM\"><a href=\"#SRAM和DRAM\" class=\"headerlink\" title=\"SRAM和DRAM\"></a>SRAM和DRAM</h2><h3 id=\"SRAM\"><a href=\"#SRAM\" class=\"headerlink\" title=\"SRAM\"></a>SRAM</h3><ul>\n<li><p>使用双稳态触发器（六管MOS）记忆信息</p>\n</li>\n<li><p>非破坏性读出，易失性存储器</p>\n</li>\n<li><p>存取速度快，集成度低，功耗大，成本高，常用来组成高速缓冲存储器</p>\n</li>\n<li><p>同时送行列地址</p>\n</li>\n</ul>\n<h3 id=\"DRAM\"><a href=\"#DRAM\" class=\"headerlink\" title=\"DRAM\"></a>DRAM</h3><ul>\n<li><p>利用电荷存储信息</p>\n</li>\n<li><p>破坏性读出，易失性存储器1</p>\n</li>\n<li><p>存取速度慢，集成度高，功耗低，容量大，成本低，常用来组成主存系统</p>\n</li>\n<li><p>分两次送行列地址</p>\n</li>\n<li><p>刷新方法（DRAM特有）</p>\n<ul>\n<li><p>刷新单位是行</p>\n</li>\n<li><p>集中刷新</p>\n<ul>\n<li><p>刷新时间固定存在死区</p>\n</li>\n<li><p>读写不受刷新影响，存取速度快</p>\n</li>\n<li><p>死区不能访问存储器</p>\n</li>\n</ul>\n</li>\n<li><p>分散刷新</p>\n<ul>\n<li><p>将每行刷新分散到各个工作周期中</p>\n</li>\n<li><p>没有死区</p>\n</li>\n<li><p>存取周期边长，降低整机速度</p>\n</li>\n</ul>\n</li>\n<li><p>异步刷新</p>\n<ul>\n<li><p>集中刷新和异步刷新结合</p>\n</li>\n<li><p>缩短了死时间，又提高了整机速度</p>\n</li>\n</ul>\n</li>\n<li><p>透明刷新</p>\n<ul>\n<li>刷新安排在译码阶段，不存在死时间</li>\n</ul>\n</li>\n<li><p>注：</p>\n<ul>\n<li>死区：在刷新的时候，停止对存储器的读写操作，称为死时间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"补充：存储器的读写周期\"><a href=\"#补充：存储器的读写周期\" class=\"headerlink\" title=\"补充：存储器的读写周期\"></a>补充：存储器的读写周期</h3><ul>\n<li><p>RAM读周期：存储芯片进行两次连续读操作时，必须间隔的时间，读周期总是大于等于读出时间</p>\n</li>\n<li><p>RAM写周期：数据总线上的信息能够可靠的写入存储器</p>\n</li>\n</ul>\n<h2 id=\"只读存储器\"><a href=\"#只读存储器\" class=\"headerlink\" title=\"只读存储器\"></a>只读存储器</h2><h3 id=\"ROM特点\"><a href=\"#ROM特点\" class=\"headerlink\" title=\"ROM特点\"></a>ROM特点</h3><ul>\n<li><p>随机存取，非易失性存储器</p>\n</li>\n<li><p>结构简单，位密度比可读写存储器高</p>\n</li>\n</ul>\n<h3 id=\"ROM类型\"><a href=\"#ROM类型\" class=\"headerlink\" title=\"ROM类型\"></a>ROM类型</h3><h4 id=\"掩膜式只读存储器-MROM\"><a href=\"#掩膜式只读存储器-MROM\" class=\"headerlink\" title=\"掩膜式只读存储器(MROM)\"></a>掩膜式只读存储器(MROM)</h4><ul>\n<li><p>可靠性高，集成度高，价格便宜</p>\n</li>\n<li><p>灵活性差</p>\n</li>\n</ul>\n<h4 id=\"一次性可编程只读存储器（PROM）\"><a href=\"#一次性可编程只读存储器（PROM）\" class=\"headerlink\" title=\"一次性可编程只读存储器（PROM）\"></a>一次性可编程只读存储器（PROM）</h4><ul>\n<li>写入内容无法更改</li>\n</ul>\n<h4 id=\"可擦除可编程只读存储器（EPROM）\"><a href=\"#可擦除可编程只读存储器（EPROM）\" class=\"headerlink\" title=\"可擦除可编程只读存储器（EPROM）\"></a>可擦除可编程只读存储器（EPROM）</h4><ul>\n<li><p>可以对内容进行多次改写</p>\n</li>\n<li><p>紫外线擦除UVEPROM</p>\n</li>\n<li><p>电擦除E^2PROM</p>\n</li>\n</ul>\n<h4 id=\"闪速存储器（Flash-Memory）\"><a href=\"#闪速存储器（Flash-Memory）\" class=\"headerlink\" title=\"闪速存储器（Flash  Memory）\"></a>闪速存储器（Flash  Memory）</h4><ul>\n<li><p>可长期保存信息、可重写</p>\n</li>\n<li><p>价格便宜，集成度高</p>\n</li>\n<li><p>擦写速度快</p>\n</li>\n</ul>\n<h4 id=\"固态硬盘（SSD）\"><a href=\"#固态硬盘（SSD）\" class=\"headerlink\" title=\"固态硬盘（SSD）\"></a>固态硬盘（SSD）</h4><ul>\n<li><p>可以长期保存信息，快速擦除，重写</p>\n</li>\n<li><p>相对于传统硬盘，读写速度快，低功耗</p>\n</li>\n<li><p>价格高</p>\n</li>\n</ul>\n<h1 id=\"主存储器和CPU的连接\"><a href=\"#主存储器和CPU的连接\" class=\"headerlink\" title=\"主存储器和CPU的连接\"></a>主存储器和CPU的连接</h1><h2 id=\"连接原理\"><a href=\"#连接原理\" class=\"headerlink\" title=\"连接原理\"></a>连接原理</h2><ul>\n<li>主存储器与CPU连接（数据总线、地址总线、控制总线）</li>\n</ul>\n<h2 id=\"主存容量扩展：位扩并、字扩串\"><a href=\"#主存容量扩展：位扩并、字扩串\" class=\"headerlink\" title=\"主存容量扩展：位扩并、字扩串\"></a>主存容量扩展：位扩并、字扩串</h2><ul>\n<li><p>位扩展</p>\n<ul>\n<li><p>将多个存储芯片并联</p>\n</li>\n<li><p>8片8Kx1位——&gt;8Kx8位存储器</p>\n</li>\n</ul>\n</li>\n<li><p>字扩展</p>\n<ul>\n<li><p>多个存储芯片串联</p>\n</li>\n<li><p>4片16Kx8位——&gt;64Kx8位</p>\n</li>\n</ul>\n</li>\n<li><p>字位同时扩展法</p>\n<ul>\n<li><p>增加存储字数量，增加存储字长</p>\n</li>\n<li><p>并联与串联结合在一起</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"存储芯片的地址分配和片选\"><a href=\"#存储芯片的地址分配和片选\" class=\"headerlink\" title=\"存储芯片的地址分配和片选\"></a>存储芯片的地址分配和片选</h2><ul>\n<li><p>线选法</p>\n<ul>\n<li><p>通过地址线直接对芯片进行选择</p>\n</li>\n<li><p>优点：不需要地址译码器线路简单</p>\n</li>\n<li><p>缺点：地址空间不连续，不能充分利用系统存储空间，造成地址资源浪费</p>\n</li>\n</ul>\n</li>\n<li><p>译码片选法</p>\n<ul>\n<li><p>通过使用地址译码器对芯片进行选择</p>\n</li>\n<li><p>优点：每片芯片的地址范围是唯一确定的，而且是连续的，也便于扩展</p>\n</li>\n<li><p>缺点：对译码电路要求过高</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"存储器与CPU的连接\"><a href=\"#存储器与CPU的连接\" class=\"headerlink\" title=\"存储器与CPU的连接\"></a>存储器与CPU的连接</h2><ul>\n<li><p>选择合理存储芯片</p>\n<ul>\n<li><p>RAM：为用户编程设置的</p>\n</li>\n<li><p>ROM：存放系统程序</p>\n</li>\n</ul>\n</li>\n<li><p>地址线的选择</p>\n<ul>\n<li><p>芯片容量不同地址线也不同</p>\n<ul>\n<li><p>CPU地址线低位与存储芯片的地址线连接</p>\n</li>\n<li><p>CPU地址线高位用于扩充芯片使用</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据线的连接</p>\n<ul>\n<li><p>CPU数据线数与存储芯片线数相等时可以直接连接</p>\n</li>\n<li><p>CPU数据线数与存储芯片线数不等时：必须对存储芯片进行扩位，使其相等</p>\n</li>\n</ul>\n</li>\n<li><p>读&#x2F;写命令线的连接</p>\n<ul>\n<li>高电平为读，低电平为写</li>\n</ul>\n</li>\n<li><p>片选线的连接</p>\n<ul>\n<li>片选线的作用在于选择那一片存储芯片被选中（是CPU与存储芯片连接的关键）</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"双端口RAM和多模块存储器\"><a href=\"#双端口RAM和多模块存储器\" class=\"headerlink\" title=\"双端口RAM和多模块存储器\"></a>双端口RAM和多模块存储器</h1><h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>为了提高CPU访问存储器的速度采用双端口存储器（空间并行）、多模块存储器（时间并行）</p>\n<h2 id=\"双端口RAM\"><a href=\"#双端口RAM\" class=\"headerlink\" title=\"双端口RAM\"></a>双端口RAM</h2><ul>\n<li><p>一个存储器有左，右两个独立端口，分别具有两组相互独立的地址线，数据线，读写控制线</p>\n</li>\n<li><p>冲突</p>\n<ul>\n<li><p>对同一地址单元，两个端口同时写入数据</p>\n</li>\n<li><p>对于同一个地址单元一个端口写一个端口读</p>\n</li>\n</ul>\n</li>\n<li><p>无冲突</p>\n<ul>\n<li><p>对同一个地址单元，两个端口同时读</p>\n</li>\n<li><p>对于同一个地址单元，两个端口不同时写</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多模块存储器\"><a href=\"#多模块存储器\" class=\"headerlink\" title=\"多模块存储器\"></a>多模块存储器</h2><ul>\n<li><p>目的：为了提高访问速度</p>\n</li>\n<li><p>单体多字存储器</p>\n<ul>\n<li><p>按照地址顺序读出数据，存储单元存储m个字，总线宽度也为m个字，一次性并行读出m个字</p>\n</li>\n<li><p>优点：增大了存儲器带宽，提高单体存储器工作速度</p>\n</li>\n</ul>\n</li>\n<li><p>多体并行存储：多体低位交叉编制可以有效的提高存储速度</p>\n<ul>\n<li><p>多个模块构成，每个模块有着相同的容量和存取速度，各模块独既司并行工作又可以交叉工作</p>\n</li>\n<li><p>高位交叉编址</p>\n<ul>\n<li>本质上仍然是顺序存储器</li>\n</ul>\n</li>\n<li><p>低位交叉编址</p>\n<ul>\n<li>可以在不改变每个模块的存取周期的前提下，采用流水线的方式并行存储，可以提高存储器的带宽</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"高速缓冲存储器\"><a href=\"#高速缓冲存储器\" class=\"headerlink\" title=\"高速缓冲存储器\"></a>高速缓冲存储器</h1><h2 id=\"程序访问的局部性原理\"><a href=\"#程序访问的局部性原理\" class=\"headerlink\" title=\"程序访问的局部性原理\"></a>程序访问的局部性原理</h2><ul>\n<li><p>时间局部性：将要使用的信息，可能是现在正在使用的信息</p>\n</li>\n<li><p>空间局部性：将来使用的信息，可能在正在使用信息的存储空间的附近</p>\n</li>\n<li><p>基于局部性原理创造出高速缓冲技术（Cache）</p>\n</li>\n</ul>\n<h2 id=\"CACHE基本工作原理\"><a href=\"#CACHE基本工作原理\" class=\"headerlink\" title=\"CACHE基本工作原理\"></a>CACHE基本工作原理</h2><ul>\n<li><p>通常使用SRAM制造</p>\n</li>\n<li><p>存储主存中最为活跃的信息副本，按照某种策略将这些活跃的信息存入到Cache中</p>\n</li>\n<li><p>CPU发出读请求</p>\n<ul>\n<li><p>Cache命中：直接对Cache进行读操作</p>\n</li>\n<li><p>Cache不命中：CPU访问主存操作，并且将访问数据送入到Cache中</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>cpu与cache之间交换数据的基本单位是字</p>\n</li>\n<li><p>cache与主存之间交换数据的基本单位是cache块</p>\n</li>\n<li><p>注意：某些计算机也可能是同时访间cache和主存</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CACHE与主存的映射方式\"><a href=\"#CACHE与主存的映射方式\" class=\"headerlink\" title=\"CACHE与主存的映射方式\"></a>CACHE与主存的映射方式</h2><ul>\n<li><p>按照一定的规则将主存中的某些数据存入到Cache中</p>\n</li>\n<li><p>直接映射：冲突率高，利用率低，实现简单</p>\n<ul>\n<li><p>主存数据块只能装入Cache中的唯一位置</p>\n</li>\n<li><p>地址结构、主存字块标记、Cache字块地址、字块内地址</p>\n</li>\n</ul>\n</li>\n<li><p>全相联映射：地址变换慢，实现成本高、比较灵活，冲突率低</p>\n<ul>\n<li><p>主存数据库可以放在Cache中的任何位置</p>\n</li>\n<li><p>地址结构、主存字块标记、字块内地址</p>\n</li>\n</ul>\n</li>\n<li><p>组相邻映射</p>\n<ul>\n<li><p>将Cache分为不同的组，主存的数据库可以装入一组内的任何位置</p>\n</li>\n<li><p>地址结构、主存字块标记、组地址、字块内地址</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CACHE中的替换算法\"><a href=\"#CACHE中的替换算法\" class=\"headerlink\" title=\"CACHE中的替换算法\"></a>CACHE中的替换算法</h2><ul>\n<li><p>随机算法</p>\n<ul>\n<li><p>随机确定替换的Cache块</p>\n</li>\n<li><p>优点：实现简单</p>\n</li>\n<li><p>缺点：没有依据局部性原理，命中率低</p>\n</li>\n</ul>\n</li>\n<li><p>先进先出算法（FIFO）</p>\n<ul>\n<li><p>最早调入的行进行萎饰</p>\n</li>\n<li><p>优点：容易实现</p>\n</li>\n<li><p>缺点：没有依据局部性原理</p>\n</li>\n</ul>\n</li>\n<li><p>近期最少使用算法（LRU）：堆线类算法</p>\n<ul>\n<li><p>根据局部性原理，选择近期内最久没有访问的存储行</p>\n</li>\n<li><p>优点：平均命中率高的</p>\n</li>\n<li><p>缺点：需要设置计数器比较存储行</p>\n</li>\n</ul>\n</li>\n<li><p>最不经常使用算法</p>\n<ul>\n<li>一段时间内访问次数最少的存储行换出</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CACHE写策略\"><a href=\"#CACHE写策略\" class=\"headerlink\" title=\"CACHE写策略\"></a>CACHE写策略</h2><ul>\n<li><p>写命中</p>\n<ul>\n<li><p>全写法（写直通法write—throuah）</p>\n<ul>\n<li><p>对Cache写命中后，数据同时写入Cache和主存</p>\n</li>\n<li><p>实现简单，随时保持主存数据正确</p>\n</li>\n<li><p>增加了访存次数，降低了效率</p>\n</li>\n</ul>\n</li>\n<li><p>写回法（write—back）</p>\n<ul>\n<li><p>对Cache命中时，只修改Cache内容，不立即写入主</p>\n</li>\n<li><p>减少了访存次数</p>\n</li>\n<li><p>存在数据不一致的隐患，同时需要设置一个脏位</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>写不命中</p>\n<ul>\n<li><p>写分配法（write—allocate）</p>\n<ul>\n<li><p>加载主存中的块到Cache中，然后更新Cache块</p>\n</li>\n<li><p>试图使用空间局部性原理</p>\n</li>\n<li><p>每次不命中都要从主存中调块</p>\n</li>\n</ul>\n</li>\n<li><p>非写分配法(not-write-allocate）</p>\n<ul>\n<li>写入主存,不进行调块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>非写分配法与全写法搭配</p>\n</li>\n<li><p>写分配法与写回法搭配</p>\n</li>\n</ul>\n</li>\n<li><p>多级Cache（通常为3级）</p>\n<ul>\n<li>可以有效避免频繁写时造成的写缓冲饱和和溢出</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"虚拟存储器\"><a href=\"#虚拟存储器\" class=\"headerlink\" title=\"虚拟存储器\"></a>虚拟存储器</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li><p>将主存或者辅存的地址空间统一编址</p>\n</li>\n<li><p>实地址对应的是主存地址空间</p>\n</li>\n<li><p>使用虚地址需要辅助硬件找出虚地址和实地址之间的关系，并对其对应存储单元装入状态进行判断</p>\n</li>\n<li><p>实际情况：需要使用的先送入主存，暂时不用的放在磁盘中</p>\n</li>\n</ul>\n<h2 id=\"页式虚拟存储器\"><a href=\"#页式虚拟存储器\" class=\"headerlink\" title=\"页式虚拟存储器\"></a>页式虚拟存储器</h2><ul>\n<li><p>以页为基本单位的虚拟存储器称为页式虚拟存储器</p>\n</li>\n<li><p>计算过程</p>\n<ul>\n<li><p>虚拟地址&#x3D;虚页号+页内地址</p>\n</li>\n<li><p>虚页号+页表起始地址&#x3D;页表地址</p>\n<ul>\n<li>根据页表地址查找实页号</li>\n</ul>\n</li>\n<li><p>实页号+页内地址&#x3D;实地址<img src=\"https://api2.mubu.com/v3/document_image/59cfc174-3429-4a42-82a6-c6eccbd049d4-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>优缺点：</p>\n<ul>\n<li><p>优点：页面长度固定、调入方便</p>\n</li>\n<li><p>缺点：零头浪费对页的处理、保护、共享不是特别方便</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"段式虚拟存储器\"><a href=\"#段式虚拟存储器\" class=\"headerlink\" title=\"段式虚拟存储器\"></a>段式虚拟存储器</h2><ul>\n<li><p>按照程序的逻辑结构划分</p>\n</li>\n<li><p>计算过程</p>\n<ul>\n<li><p>虚地址&#x3D;段号+段内地址</p>\n</li>\n<li><p>段号+段表起始地址&#x3D;段表地址</p>\n<ul>\n<li>查询段表数据</li>\n</ul>\n</li>\n<li><p>实地址&#x3D;段表所得数据+段内地址<img src=\"https://api2.mubu.com/v3/document_image/a6eaeec3-7e07-4040-984d-b32e73484a55-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>优缺点</p>\n<ul>\n<li><p>优点：段分界与程序分界相对应易于编译、管理、修改、保护、共享</p>\n</li>\n<li><p>缺点：段长分配不便、存在段间碎片</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"段页式存储器\"><a href=\"#段页式存储器\" class=\"headerlink\" title=\"段页式存储器\"></a>段页式存储器</h2><ul>\n<li><p>先将程序按逻辑分段，再将每段分为固定大小页</p>\n</li>\n<li><p>段长必须是页的整数倍</p>\n</li>\n<li><p>虚地址&#x3D;段号+段内页号+页内地址</p>\n</li>\n<li><p>优缺点</p>\n<ul>\n<li><p>优点：可以按段实现共享和保护，同时也有着页的调用方便</p>\n</li>\n<li><p>缺点：地址变换要两次查表，开销较大</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"快表-TLB）\"><a href=\"#快表-TLB）\" class=\"headerlink\" title=\"快表(TLB）\"></a>快表(TLB）</h2><ul>\n<li><p>根据局部性原理，将一些经常访问的页放入高速缓冲器中构成快表，可以极大提高查询的效率</p>\n</li>\n<li><p>采用相联存储器构成，可以按照内容查询</p>\n</li>\n<li><p>访问顺序：TLB——&gt;页表——&gt;Cache——&gt;主存</p>\n</li>\n<li><p>命中情况</p>\n<ul>\n<li><p>Cache命中，page必然命中，TLB不一定命中</p>\n</li>\n<li><p>Cache不命中，无法退出TLB与page命中情况</p>\n</li>\n<li><p>Page不命中，Cache和主存不会命中，此时要执行调页策略</p>\n</li>\n</ul>\n</li>\n<li><p>注：只要抓住存储数据的来源就可以推导出命中情况</p>\n</li>\n</ul>\n","categories":["计算机408","1.计算机组成原理","3.存储系统"],"tags":["写作"]},{"title":"总线","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_6.%E6%80%BB%E7%BA%BF/","content":"<h1 id=\"总线概述\"><a href=\"#总线概述\" class=\"headerlink\" title=\"总线概述\"></a>总线概述</h1><h2 id=\"总线基本概念\"><a href=\"#总线基本概念\" class=\"headerlink\" title=\"总线基本概念\"></a>总线基本概念</h2><ul>\n<li><p>总线的定义</p>\n<ul>\n<li><p>总线是一组能为多个部件分时共享的公共信息传送线路</p>\n</li>\n<li><p>分时：同一时刻只允许有一个部件向总线发送信息</p>\n</li>\n<li><p>共享：总线上可以挂接多个部件，各个部件之间互相交换的信息可以通过这组线路分时共享</p>\n</li>\n</ul>\n</li>\n<li><p>总线设备</p>\n<ul>\n<li><p>主设备：总线的主设备是指获得总线控制权的设备</p>\n</li>\n<li><p>从设备：总线的从设备是指被主设备访问的设备，只能相应从主设备发来的各种总线命令</p>\n</li>\n</ul>\n</li>\n<li><p>总线特性</p>\n<ul>\n<li><p>机械特性：尺寸形状</p>\n</li>\n<li><p>电气特性：传输方向和有效的电平范围</p>\n</li>\n<li><p>功能特性：每根传输线的功能</p>\n</li>\n<li><p>时间特性：信号和时序的关系</p>\n</li>\n</ul>\n</li>\n<li><p>总线的猝发传输</p>\n<ul>\n<li>一个总线周期内传输存储地址连续的多个数据字的总线传输方式，称为猝发传输</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总线的分类\"><a href=\"#总线的分类\" class=\"headerlink\" title=\"总线的分类\"></a>总线的分类</h2><ul>\n<li><p>片内总线：芯片内部的总线，是CPU芯片内部寄存器与寄存器之间，寄存器与ALU之间的公共连接线</p>\n</li>\n<li><p>系统总线</p>\n<ul>\n<li><p>各个功能部件之间相互连接的总结</p>\n</li>\n<li><p>数据总线</p>\n<ul>\n<li><p>传输各功能部件之间的数据信息</p>\n</li>\n<li><p>双向传输总线</p>\n</li>\n<li><p>位数与机器字长、存储字长有关</p>\n</li>\n</ul>\n</li>\n<li><p>地址总线</p>\n<ul>\n<li><p>数据总线上的源数据或目的数据所在的主存单元或I&#x2F;O端口的地址</p>\n</li>\n<li><p>单向传输总线</p>\n</li>\n<li><p>地址总线的位数与主存地址空间的大小有关</p>\n</li>\n</ul>\n</li>\n<li><p>控制总线</p>\n<ul>\n<li>传输控制信息<ul>\n<li>CPU送出的控制命令和主存返回CPU的反馈信号</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>通信总线</p>\n<ul>\n<li><p>计算机系统之间或计算机系统与其他系统之间传送信息的总线，也被称为外部总线</p>\n</li>\n<li><p>根据时序控制方式分类</p>\n<ul>\n<li><p>同步总线</p>\n</li>\n<li><p>异步总线</p>\n</li>\n</ul>\n</li>\n<li><p>数据传输格式分类</p>\n<ul>\n<li><p>并行总线</p>\n</li>\n<li><p>串行总线</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"系统总线的结构\"><a href=\"#系统总线的结构\" class=\"headerlink\" title=\"系统总线的结构\"></a>系统总线的结构</h2><ul>\n<li><p>单总线结构</p>\n<ul>\n<li><p>将CPU、主存、I&#x2F;O设备都挂载到一组总线上</p>\n</li>\n<li><p>优点：结构简单、成本低、容易接入新设备</p>\n</li>\n<li><p>缺点：带宽低、负载重、多个部件只能争用唯一的总线，并且不支持并发传送操作</p>\n</li>\n</ul>\n</li>\n<li><p>双总线结构</p>\n<ul>\n<li><p>一条是主存总线，用于CPU、主存和通道之间传送数据，另一条是I&#x2F;O总线用于在多个外部设备和通道之间传送数据</p>\n</li>\n<li><p>优点：将低速I&#x2F;O设备从单总线上分离出来，实现了存储总线和&#x2F;0总线分</p>\n</li>\n<li><p>缺点：需要增加通道等硬件设备</p>\n</li>\n</ul>\n</li>\n<li><p>三总线结构</p>\n<ul>\n<li><p>计算机系统各部件之间采用三条独立总线来构成信息通路（主存总线、I&#x2F;O总线、直接内存访问（DMA）总线）</p>\n</li>\n<li><p>优点：提高了I&#x2F;O设备的性能，使其更快的响应命令，提高系统的吞吐量</p>\n</li>\n<li><p>缺点：系统工作效率较低</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总线的性能指标\"><a href=\"#总线的性能指标\" class=\"headerlink\" title=\"总线的性能指标\"></a>总线的性能指标</h2><ul>\n<li><p>总线的传输周期：一次总线操作所需要的时间（申请阶段，寻址阶段，传输阶段和结束阶段），总线传输周期由若干个总线时钟周期构成</p>\n</li>\n<li><p>总线时钟周期：即机器的时钟周期</p>\n</li>\n<li><p>总线的工作频率：总线周期的倒数</p>\n</li>\n<li><p>总线的时钟频率：时钟周期的倒数</p>\n</li>\n<li><p>总线带宽：单位时间内总线可以传输的数据位数</p>\n</li>\n<li><p>总线复用：一种信号线在不同时间传输不同的信息，节约了空间和成本</p>\n</li>\n<li><p>信号线数：地址总线、数据总线、控制总线，三种总线数的总和称为信号线数</p>\n<ul>\n<li>总线带宽：总线本身的最大传输率，是衡量性能的重要指标</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"总线仲裁\"><a href=\"#总线仲裁\" class=\"headerlink\" title=\"总线仲裁\"></a>总线仲裁</h1><h2 id=\"集中仲裁方式\"><a href=\"#集中仲裁方式\" class=\"headerlink\" title=\"集中仲裁方式\"></a>集中仲裁方式</h2><ul>\n<li><p>链式查询方式</p>\n<ul>\n<li><p>一根总线请求线、一根总线忙线、一根总线允许线</p>\n</li>\n<li><p>优点：优先级固定结构简单扩充容易</p>\n</li>\n<li><p>缺点：对于电路故障敏感优先级不可变</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li>越靠近总线控制器的部件优先级越高</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>计数器定时查询方式</p>\n<ul>\n<li><p>使用计数器控制总线使用权</p>\n</li>\n<li><p>优点：设备优先级相等优先次序可以改变</p>\n</li>\n<li><p>缺点增加了控制线数控制较为复杂</p>\n</li>\n</ul>\n</li>\n<li><p>独立请求方式</p>\n<ul>\n<li><p>每个设备均有请求线与总线允许线</p>\n</li>\n<li><p>优点：响应速度快优先次序控制灵活</p>\n</li>\n<li><p>缺点：控制线数多总线控制逻辑更复杂</p>\n</li>\n</ul>\n</li>\n<li><p>对比<img src=\"https://api2.mubu.com/v3/document_image/135886b2-9ce1-4c2b-ad74-600de2b117b8-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<h2 id=\"分布仲裁方式\"><a href=\"#分布仲裁方式\" class=\"headerlink\" title=\"分布仲裁方式\"></a>分布仲裁方式</h2><ul>\n<li>不需要中央仲裁器，每个潜在主模块，都有自己的仲裁号和仲裁器，然后进行仲裁号比较，获胜者仲裁号保留在仲裁总线上</li>\n</ul>\n<h1 id=\"总线操作和定时\"><a href=\"#总线操作和定时\" class=\"headerlink\" title=\"总线操作和定时\"></a>总线操作和定时</h1><h2 id=\"总线传输的4个阶段\"><a href=\"#总线传输的4个阶段\" class=\"headerlink\" title=\"总线传输的4个阶段\"></a>总线传输的4个阶段</h2><ul>\n<li><p>申请分配阶段：设备提出申请</p>\n</li>\n<li><p>寻址阶段：获得使用权的主设备，发出要访问模块的地址以及相关命令，启动本次传输的从模块</p>\n</li>\n<li><p>传输阶段：主模块与从模块，进行双向或者单向数据传送</p>\n</li>\n<li><p>结束阶段：主横块有关信息均从系统总线上撤除，让出总线使用权</p>\n</li>\n</ul>\n<h2 id=\"同步定时方式\"><a href=\"#同步定时方式\" class=\"headerlink\" title=\"同步定时方式\"></a>同步定时方式</h2><ul>\n<li><p>系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系</p>\n</li>\n<li><p>优点：传送速度快拥有较高的传输速率总线控制逻辑简身</p>\n</li>\n<li><p>缺点：主从设备属于强制性同步不能及时进行数据通信的有效性检验可靠性较</p>\n</li>\n<li><p>应用：适用于总线长度较短以及总线所接部件的存取时间比较接近的系统</p>\n</li>\n</ul>\n<h2 id=\"异步定时方式\"><a href=\"#异步定时方式\" class=\"headerlink\" title=\"异步定时方式\"></a>异步定时方式</h2><ul>\n<li><p>没有统一的时钟，完全按照传送双方相互制约的握手信号实现定时控准</p>\n</li>\n<li><p>优点：总线周期长度可变可以保证两个速度相差较大部件或设备的信息传输</p>\n</li>\n<li><p>缺点：控制相对复杂并且速度相对较慢</p>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>不互锁方式：主设备发送请求信号，不必等待从设备信号回答，一段时间便撤销请求信号</p>\n</li>\n<li><p>半互锁方式：主设备发送请求信号，必须接到从设备应答信号才能撤销请求信号。</p>\n</li>\n<li><p>全互锁方式：主设备发送请求信号，从设备应答，主设备撤销请求信号，从设备知晓主设备获得应答信号后撤销应答信号</p>\n<ul>\n<li>套娃</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"总线标准\"><a href=\"#总线标准\" class=\"headerlink\" title=\"总线标准\"></a>总线标准</h1><h2 id=\"常见总线标准\"><a href=\"#常见总线标准\" class=\"headerlink\" title=\"常见总线标准\"></a>常见总线标准</h2><ul>\n<li><p>系统总线</p>\n<ul>\n<li><p>ISA：出的微型计算机总线</p>\n</li>\n<li><p>EISA：ISA的扩展形式</p>\n</li>\n</ul>\n</li>\n<li><p>局部总线</p>\n<ul>\n<li><p>VESA：针对系统高速传送活动图像的大量数据的局部总线</p>\n</li>\n<li><p>PCI：为外围设备使用的总线</p>\n<ul>\n<li><p>即插即用</p>\n</li>\n<li><p>桥连接</p>\n</li>\n</ul>\n</li>\n<li><p>PCI—Express：最新的总线和接口标准用于代替PC1和AGP</p>\n</li>\n<li><p>AGP：视频接口标准用于连接主存和图型存储器</p>\n</li>\n</ul>\n</li>\n<li><p>设备总线</p>\n<ul>\n<li><p>RS-232C：应用于串行二进制交换的数据终端设备（DTE）和数据通信设备（DCE）</p>\n</li>\n<li><p>USB</p>\n<ul>\n<li><p>连接外部设备的I&#x2F;O总线</p>\n</li>\n<li><p>即插即用热插拔串行传输</p>\n</li>\n<li><p>具有很强的连接能力和很好的可扩充性</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>PCMCIA：用于扩展功能的小型插槽即插即用</p>\n</li>\n<li><p>IDE：集成设备电路，又称ATA，是一种IDE接口磁盘驱动器接口类型</p>\n</li>\n<li><p>SCSI：用于计算机和智能设备之间系统级接口的独立处理器标准，是一种智能的通用接口标准</p>\n</li>\n<li><p>SATA：是一种基于行业标准的串行硬件驱动器接口</p>\n</li>\n</ul>\n","categories":["计算机408","1.计算机组成原理","6.总线"],"tags":["写作"]},{"title":"中央处理器","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_5.%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/","content":"<h1 id=\"CPU的功能和基本结构\"><a href=\"#CPU的功能和基本结构\" class=\"headerlink\" title=\"CPU的功能和基本结构\"></a>CPU的功能和基本结构</h1><h2 id=\"CPU的功能\"><a href=\"#CPU的功能\" class=\"headerlink\" title=\"CPU的功能\"></a>CPU的功能</h2><ul>\n<li><p>组成</p>\n<ul>\n<li><p>运算器</p>\n<ul>\n<li><p>协调并控制计算机各部件执行程序的指令序列</p>\n</li>\n<li><p>取指令，分析指令，执行指令</p>\n</li>\n</ul>\n</li>\n<li><p>控制器</p>\n<ul>\n<li>对数据进行加工</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>具体功能</p>\n<ul>\n<li><p>指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制</p>\n</li>\n<li><p>操作控制：一条指令的功能往往由若干操作信号的组合来实现，CPU可以管理这些信号</p>\n</li>\n<li><p>时间控制：对各种操作加以时间上的控制，时间控制要为每条指令按时间顺序提供应有的控制信号</p>\n</li>\n<li><p>数据加工：对数据进行算术和逻辑运算</p>\n</li>\n<li><p>中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CPU的基本结构\"><a href=\"#CPU的基本结构\" class=\"headerlink\" title=\"CPU的基本结构\"></a>CPU的基本结构</h2><ul>\n<li><p>运算器</p>\n<ul>\n<li><p>算术逻辑单元：主要功能是进行算术&#x2F;逻辑运算。</p>\n</li>\n<li><p>暂存寄存器：用于暂存从主存读来的数据。暂存寄存器对应用程序员是透明的。</p>\n</li>\n<li><p>累加寄存器：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。</p>\n</li>\n<li><p>通用寄存器组：用于存放操作数（源、目的操作数及中间结果）和各种地址信息等。</p>\n</li>\n<li><p>程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息</p>\n<ul>\n<li>例如：溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）</li>\n</ul>\n</li>\n<li><p>移位器：对操作数和运算结果进行移位运算</p>\n</li>\n<li><p>计数器：控制乘除运算的操作步数</p>\n</li>\n</ul>\n</li>\n<li><p>控制器</p>\n<ul>\n<li><p>程序计数器（pc）：用于指出下一条指令在主存中的存放地址。</p>\n</li>\n<li><p>指令寄存器：用于保存当前正在执行的指令</p>\n</li>\n<li><p>指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号</p>\n</li>\n<li><p>存储器地址寄存器：用于存放所要访问的主存单元的地址</p>\n</li>\n<li><p>存储器数据寄存器：用于存放向主存写入的信息或者从主存中读出的信息</p>\n</li>\n<li><p>时序系统：用于产生各种时序信号，他们由统一时钟（CLOCK）分频得到</p>\n</li>\n<li><p>微操作信号发生器：根据IR的内容（指令）、PSW的内容以及时序信号，产生控制整个计算机系统所需要的信号</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"指令执行过程\"><a href=\"#指令执行过程\" class=\"headerlink\" title=\"指令执行过程\"></a>指令执行过程</h1><h2 id=\"指令周期\"><a href=\"#指令周期\" class=\"headerlink\" title=\"指令周期\"></a>指令周期</h2><ul>\n<li><p>概念</p>\n<ul>\n<li><p>CPU从主存中每取出一条指令所需要的全部时间称为指令周期，即CPU完成一条指令的时间</p>\n</li>\n<li><p>一个指令周期包含多个机器周期，一个机器周期包含若干个时钟周期，是CPU操作的基本单位</p>\n</li>\n<li><p>每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数可以不等</p>\n</li>\n</ul>\n</li>\n<li><p>基本组成</p>\n<ul>\n<li><p>取指周期：取出指令</p>\n</li>\n<li><p>间址周期：取出有效地划</p>\n</li>\n<li><p>执行周期：取出操作数</p>\n</li>\n<li><p>中断周期：保存程序断点</p>\n</li>\n</ul>\n</li>\n<li><p>不同指令的指令周期</p>\n<ul>\n<li><p>无条件转移指令，不需要访存，所以只有取指周期、执行周其</p>\n</li>\n<li><p>对于间接寻址的指令，首先要进行访存，取出有效地址，根据有效地址取出操作致，所以其具有间址周期</p>\n</li>\n<li><p>当CPU采用中断方式实现主机和&#x2F;0设备的信息交换的时候，CPU在每次指令执行结束前都要发出中断查询信号，所以需要中断周期</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"指令周期的数据流\"><a href=\"#指令周期的数据流\" class=\"headerlink\" title=\"指令周期的数据流\"></a>指令周期的数据流</h2><ul>\n<li><p>取指周期</p>\n<ul>\n<li><p>CU发出控制信号——&gt;控制总线——&gt;主存</p>\n</li>\n<li><p>主存——&gt;数据总线——&gt;MDR——&gt;IR（存放指令）</p>\n</li>\n<li><p>CU发出读命令——&gt;PC内容加1</p>\n</li>\n</ul>\n</li>\n<li><p>间址周期</p>\n<ul>\n<li><p>Ad(IR)(或MDR)——&gt;MAR——&gt;地址总线——&gt;主存</p>\n</li>\n<li><p>CU发出读命令——&gt;控制总线——&gt;主存</p>\n</li>\n<li><p>主存——&gt;数据总线——&gt;MDR（存放有效地址）</p>\n</li>\n</ul>\n</li>\n<li><p>执行周期</p>\n<ul>\n<li>执行周期根据IR中的数据和ALU操作的产生执行结果，不同指令的执行过程不同</li>\n</ul>\n</li>\n<li><p>中断周期</p>\n<ul>\n<li><p>CU控制将SP减1，SP——&gt;MAR——&gt;地址总线——&gt;主存</p>\n</li>\n<li><p>CU发出写命令——&gt;控制总线——&gt;主存</p>\n</li>\n<li><p>PC——&gt;MDR——&gt;数据总线——&gt;主存（程序断点存入主存）</p>\n</li>\n<li><p>CU（中断服务程序的入口地址）——&gt;PC</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"指令执行方案\"><a href=\"#指令执行方案\" class=\"headerlink\" title=\"指令执行方案\"></a>指令执行方案</h2><ul>\n<li><p>单指令周期</p>\n<ul>\n<li><p>所有指令完成时间相同</p>\n</li>\n<li><p>指令串行执行，指令周期取决于最长指令执行时间</p>\n</li>\n<li><p>降低了系统整体运行速度</p>\n</li>\n</ul>\n</li>\n<li><p>多指令周期</p>\n<ul>\n<li><p>不同类型的指令选用不同的执行步骤完历</p>\n</li>\n<li><p>指令串行执行，对于不同指令分配不同的周期</p>\n</li>\n</ul>\n</li>\n<li><p>流水线方案</p>\n<ul>\n<li><p>指令之间并行，将每个时钟周期都利用起来</p>\n</li>\n<li><p>尽量让多个指令并行运行</p>\n</li>\n<li><p>注：cisc可以通过优化实现流水线，risc必须要实现流水线</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数据通路的功能和基本结构\"><a href=\"#数据通路的功能和基本结构\" class=\"headerlink\" title=\"数据通路的功能和基本结构\"></a>数据通路的功能和基本结构</h1><h2 id=\"数据通路的功能\"><a href=\"#数据通路的功能\" class=\"headerlink\" title=\"数据通路的功能\"></a>数据通路的功能</h2><ul>\n<li><p>通路结构图</p>\n</li>\n<li><p>概念：数据在功能部件之间传送的路径</p>\n</li>\n<li><p>功能：实现CPU内部的运算器与寄存器之间的数据交换</p>\n</li>\n</ul>\n<h2 id=\"数据通路的基本结构\"><a href=\"#数据通路的基本结构\" class=\"headerlink\" title=\"数据通路的基本结构\"></a>数据通路的基本结构</h2><ul>\n<li><p>基本机构分类</p>\n<ul>\n<li><p>CPU内部单总线方式</p>\n<ul>\n<li><p>将所有寄存器的输入输出端连接在同一条公共通路上</p>\n</li>\n<li><p>优点：结构简单</p>\n</li>\n<li><p>缺点：存在冲突现象，性能较低</p>\n</li>\n</ul>\n</li>\n<li><p>CPU内部三总线方式</p>\n<ul>\n<li><p>将所有寄存器的输入输出端连接在多个公共通路上</p>\n</li>\n<li><p>优点：执行效率高</p>\n</li>\n<li><p>缺点：实现复杂</p>\n</li>\n</ul>\n</li>\n<li><p>专用数据通路方式</p>\n<ul>\n<li><p>减少使用共享线路，专线专用</p>\n</li>\n<li><p>优点：性能高</p>\n</li>\n<li><p>缺点：实现复杂，硬件量大</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据传送</p>\n<ul>\n<li><p>奇存器之间的数据传送</p>\n<ul>\n<li>寄存器之间的数据传送可以通过CPU内部总线完成</li>\n</ul>\n</li>\n<li><p>主存与CPU之间的数据传送</p>\n<ul>\n<li>主存与CPU之间的数据传送也需要借助CPU内部总线完成</li>\n</ul>\n</li>\n<li><p>执行算数或逻辑运算</p>\n<ul>\n<li>由于ALU本身没有内部存储功能的组合电路，所以相加的操作数，必须在ALU两端同时有效</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>CPU内部单总线方式：实现简单，往往会伴随有性能低下或者其他问题</p>\n</li>\n<li><p>CPU内部三总线方式和专用数据通路方式：性能的提高，往往会伴随着复杂的实现</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"控制器的功能和工作原理\"><a href=\"#控制器的功能和工作原理\" class=\"headerlink\" title=\"控制器的功能和工作原理\"></a>控制器的功能和工作原理</h1><h2 id=\"控制器的结构和功能\"><a href=\"#控制器的结构和功能\" class=\"headerlink\" title=\"控制器的结构和功能\"></a>控制器的结构和功能</h2><ul>\n<li><p>结构</p>\n<ul>\n<li><p>运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据</p>\n</li>\n<li><p>输入设备和输出设备通过接口电路与总线相连接</p>\n</li>\n<li><p>内存储器、输入设备和输出设备从地址总线接收地址信息，控制总线得控制信号，数据总线与其他部件传送数据</p>\n</li>\n</ul>\n</li>\n<li><p>功能</p>\n<ul>\n<li><p>主存中取出指令，产生下一条指令在主存中的地址</p>\n</li>\n<li><p>对指令进行译码或者测试，产生相应的操作控制信号，以便启动规定的动作</p>\n</li>\n<li><p>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"硬布线控制器\"><a href=\"#硬布线控制器\" class=\"headerlink\" title=\"硬布线控制器\"></a>硬布线控制器</h2><ul>\n<li><p>根据产生微操作信号的方式不同，存在硬布线控制器和微程序控制器</p>\n</li>\n<li><p>根据指令要求、当前的时序以及外部和内部的状态，按照时间的顺序发送一些微操作控制信号</p>\n<ul>\n<li>又称为组合逻辑控制器</li>\n</ul>\n</li>\n<li><p>控制单元（SU）信号来源</p>\n<ul>\n<li><p>指令译码器产生的信息</p>\n</li>\n<li><p>时序系统产生的机器周期信号和节拍信后</p>\n</li>\n<li><p>来自执行单元的反馈标志</p>\n</li>\n<li><p>注意：控制单元还接收来自系统总线的控制信号：中断请求dma请求</p>\n</li>\n</ul>\n</li>\n<li><p>硬布线控制器的时序系统及微操作</p>\n<ul>\n<li><p>时钟周期：用时钟信号控制节拍发生器：每个节拍内机器可以完成或几个需要同时执行的操作</p>\n</li>\n<li><p>机器周期：机器周期可视为所有指令执行过程中的一个基准时间</p>\n<ul>\n<li><p>通常我们以存取周期作为基准时间，即从内存中读取一个指令字的最短时间作为机器周期</p>\n</li>\n<li><p>在存储字长等于指令字长的前提下，取指周期可以作为机器周期</p>\n</li>\n</ul>\n</li>\n<li><p>指令周期</p>\n<ul>\n<li><p>取指周期，间址周期，执行周期，中斷周期</p>\n</li>\n<li><p>见导图5.2指令执行过程</p>\n</li>\n</ul>\n</li>\n<li><p>微操作命令分析</p>\n<ul>\n<li>控制单元发出各种操作序列，这些命令必须要按照一定的次序才能使得机器有序的工作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CPU控制方式</p>\n<ul>\n<li><p>同步控制</p>\n<ul>\n<li><p>使用统一的时钟</p>\n</li>\n<li><p>优点：控制电路简单</p>\n</li>\n<li><p>缺点：运行速度慢</p>\n</li>\n</ul>\n</li>\n<li><p>异步控制</p>\n<ul>\n<li><p>不存在基准时标信号，每个部件按照自身的速度工作</p>\n</li>\n<li><p>优点：速度快</p>\n</li>\n<li><p>缺点:电路复杂</p>\n</li>\n</ul>\n</li>\n<li><p>联合控制</p>\n<ul>\n<li><p>同步和异步结合</p>\n</li>\n<li><p>大部分部件同步，小部分由异步</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>硬布线控制器设计</p>\n<ul>\n<li><p>列出微操作命令时间表</p>\n</li>\n<li><p>对微操作信号综合</p>\n</li>\n<li><p>画出微操作命令的逻幅</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"微程序控制器\"><a href=\"#微程序控制器\" class=\"headerlink\" title=\"微程序控制器\"></a>微程序控制器</h2><ul>\n<li><p>基本概念</p>\n<ul>\n<li><p>采用存储逻辑实现，将微操作信号代码化，控制存储器存储微程序，微操作控制信号由微指令产生</p>\n</li>\n<li><p>微命令与微操作</p>\n<ul>\n<li><p>机器指令分解——&gt;微操作序列</p>\n<ul>\n<li>控制部件向执行部件发出的控制命令称为微命令，是构成控制序列的最小单位</li>\n</ul>\n</li>\n<li><p>微命令具有相容和相斥性</p>\n</li>\n<li><p>操作控制字段：用于产生某一步操作需要的各种操作控制信号</p>\n</li>\n<li><p>顺序控制字段：控制产生下一条要执行的微指令地址</p>\n</li>\n</ul>\n</li>\n<li><p>主存储器与控制存储器</p>\n<ul>\n<li><p>主存储器：存储程序和数据，RAM组成</p>\n</li>\n<li><p>控制存储器：存放微程序，ROM组成</p>\n</li>\n</ul>\n</li>\n<li><p>程序和微程序</p>\n<ul>\n<li><p>程序：指令的有序集合</p>\n</li>\n<li><p>—微程序，微命令的有序集合</p>\n</li>\n<li><p>一条指令的功能由一段微程序来实现</p>\n</li>\n</ul>\n</li>\n<li><p>微地址寄存器（CMAR）：用于存放控制存储器读&#x2F;写微指令的地址</p>\n</li>\n<li><p>微指令寄存器（CMDR或者μIR）：用于存放从控制存储器中读出的微指令</p>\n</li>\n</ul>\n</li>\n<li><p>微程序控制器组成和工作过程</p>\n<ul>\n<li><p>基本组成</p>\n<ul>\n<li><p>控制存储器：存放指令对应的微程序，ROM构成</p>\n</li>\n<li><p>微指令寄存器:存放微指令</p>\n</li>\n<li><p>微地址形成部件：产生初始微地址和后继微地址</p>\n</li>\n<li><p>微地址寄存器：接收微地址</p>\n</li>\n</ul>\n</li>\n<li><p>工作过程</p>\n<ul>\n<li><p>取微指令</p>\n<ul>\n<li><p>微程序入口自动送入CMAL</p>\n</li>\n<li><p>CM中读出微指令送入CMDR</p>\n</li>\n</ul>\n</li>\n<li><p>机器指令操作码字段通过微地址形成部件产生微程序的入口地址，并将其送入CMAR</p>\n</li>\n<li><p>从CM中评条取出对应的微指令并执行</p>\n</li>\n<li><p>执行完后，继续从头循环往复</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>微指令编码方式</p>\n<ul>\n<li><p>直接编码法</p>\n<ul>\n<li><p>优点：简单直观不需要译码，速度快，操作并行性好</p>\n</li>\n<li><p>缺点：对控制存储器容量有要求</p>\n</li>\n</ul>\n</li>\n<li><p>字段直接编码法</p>\n<ul>\n<li><p>优点：缩短指令的字长</p>\n</li>\n<li><p>缺点：需要进行译码</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li>互斥的指令放在相同段内，相容指令放在不同段内</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>字段间接编码法</p>\n<ul>\n<li><p>一个字段的微指令由另一个字段中的微指令解释</p>\n</li>\n<li><p>优点：进一步缩短指令字长</p>\n</li>\n<li><p>一缺点：削弱了并行控制能力，该方法只是作为辅助手段</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>微指令地址形成方式</p>\n<ul>\n<li><p>直接由微指令的下地址字段给出</p>\n</li>\n<li><p>根据机器指令的操作码形成</p>\n</li>\n</ul>\n</li>\n<li><p>微指令格式</p>\n<ul>\n<li><p>水平型微指令</p>\n<ul>\n<li><p>优点：微程序短，执行速度快，并行能力强，灵活性高</p>\n</li>\n<li><p>缺点:微指令长,编写微程序麻烦</p>\n</li>\n</ul>\n</li>\n<li><p>垂直型微指令</p>\n<ul>\n<li><p>优点：微指令短，简单，规整，便于编写微程序</p>\n</li>\n<li><p>缺点：微程序长，执行速度慢，效率低下</p>\n</li>\n</ul>\n</li>\n<li><p>混合型指令</p>\n<ul>\n<li>结合二者优点不长不短</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>动态微程序设计和毫微程序设计</p>\n<ul>\n<li><p>动态微程序设计</p>\n<ul>\n<li><p>根据用户要求改变微程序</p>\n</li>\n<li><p>采用EPROM</p>\n</li>\n</ul>\n</li>\n<li><p>毫微程序设计</p>\n<ul>\n<li>主存的每条指令都是放在控制存储器中的微程序解释执行的，通过控制线对硬件进行直接控制</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"硬布线和微程序控制器的优缺点\"><a href=\"#硬布线和微程序控制器的优缺点\" class=\"headerlink\" title=\"硬布线和微程序控制器的优缺点\"></a>硬布线和微程序控制器的优缺点</h2><ul>\n<li><p>硬布线</p>\n<ul>\n<li><p>优点：速度快</p>\n</li>\n<li><p>缺点：不够灵活</p>\n</li>\n<li><p>RISC  CPU</p>\n</li>\n</ul>\n</li>\n<li><p>微程序</p>\n<ul>\n<li><p>优点：规整、灵活、可维护性好</p>\n</li>\n<li><p>缺点：速度慢</p>\n</li>\n<li><p>CISC  CPU</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"指令流水线\"><a href=\"#指令流水线\" class=\"headerlink\" title=\"指令流水线\"></a>指令流水线</h1><h2 id=\"指令流水线的基本概念\"><a href=\"#指令流水线的基本概念\" class=\"headerlink\" title=\"指令流水线的基本概念\"></a>指令流水线的基本概念</h2><ul>\n<li><p>概念：把一个重复的过程分解成若干个子过程，每个子过程可以与其他子过程并行执行</p>\n</li>\n<li><p>优点：只需要增加少量的硬件就能把计算机的运算速度提高几信</p>\n</li>\n<li><p>指令流水的定义</p>\n<ul>\n<li><p>一条指令的执行可以分为多个阶段</p>\n<ul>\n<li><p>取指:根据PC从主存中取出指令送入IR</p>\n</li>\n<li><p>分析：对指令操作码进行译码，按照寻址方式和地址段内容形成有效地址EA，并从有效地址中取出操作数</p>\n</li>\n<li><p>执行：根据操作码字段，完成指令规定功能，将运算结果写到通用寄存器或者主存中</p>\n</li>\n</ul>\n</li>\n<li><p>多条指令的处理方式</p>\n<ul>\n<li><p>顺序执行方式</p>\n<ul>\n<li><p>一条接一条指令执行，传统冯诺依曼机顺序执行方式</p>\n<ul>\n<li>T&#x3D;3nt</li>\n</ul>\n</li>\n<li><p>优点：控制简单，硬件代价小</p>\n</li>\n<li><p>缺点：执行指令速度慢，各功能部件的利用率很低</p>\n</li>\n</ul>\n</li>\n<li><p>一次重叠执行方式</p>\n<ul>\n<li><p>第k条指令的执行阶段和k+1条令的取指阶段并行</p>\n<ul>\n<li>T&#x3D;（1+2nt）</li>\n</ul>\n</li>\n<li><p>优点：程序执行时间缩短了1&#x2F;3，各功能部件利用率提高了</p>\n</li>\n<li><p>缺点：硬件开销代价较大，控制过程也比顺序执行复杂</p>\n</li>\n</ul>\n</li>\n<li><p>二次重叠执行方式</p>\n<ul>\n<li><p>k+1条指令提前到分析第条指令的期间完成，而将分析第k+1条指令与执行第k条指令同时进行</p>\n</li>\n<li><p>优点：时间更短了，利用率更高了</p>\n</li>\n<li><p>缺点：硬件开销更大了，控制过程更复杂了</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>流水线的表示方法</p>\n<ul>\n<li><p>顺序执行方式<img src=\"https://api2.mubu.com/v3/document_image/b79343ea-acf2-453a-8796-cc711dd4a93b-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>一次重叠执行方式<img src=\"https://api2.mubu.com/v3/document_image/8127640a-7476-44f7-8d7e-9088b0a4c2f2-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>二次重叠执行方式<img src=\"https://api2.mubu.com/v3/document_image/825591e0-eb14-40e1-b4d6-242056acd3ac-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>注：</p>\n<ul>\n<li>流水线最重要的是一定要流动起来，如果经常出现断流情况，那么就无法体现流水线的优越性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>流水线方式的特点</p>\n<ul>\n<li><p>一个任务分解成多个子任务</p>\n</li>\n<li><p>每个功能部件后面都要有个锁存器，用于保存本流水段的结果</p>\n</li>\n<li><p>流水线中的各功能段的时间应尽量相等，否则将会堵塞、断流</p>\n</li>\n<li><p>流水线需要装入时间和排空时间</p>\n<ul>\n<li><p>装入时间：第一个任务进入流水线到输出流水线的时间</p>\n</li>\n<li><p>排空时间：最后一个任务进入流水线到输出流水线的时间</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"流水线的分类\"><a href=\"#流水线的分类\" class=\"headerlink\" title=\"流水线的分类\"></a>流水线的分类</h2><ul>\n<li><p>按照流水级别分类</p>\n<ul>\n<li><p>部件功能级流水线：将复杂的算术逻辑运算组成流水线的工作方式</p>\n</li>\n<li><p>处理机级流水线：一条指令解释成多个子过程</p>\n</li>\n<li><p>处理机间流水线：是一种宏流水，每个处理机专门完成一个任务，各个处理机得到的结果存放在与下一个处理机共享的存储器中</p>\n</li>\n</ul>\n</li>\n<li><p>按照功能分类</p>\n<ul>\n<li><p>单功能流水线：完成单一功能</p>\n</li>\n<li><p>多功能流水线：各个流水段之间通过组合可以实现多种功能</p>\n</li>\n</ul>\n</li>\n<li><p>按照连接方式分类</p>\n<ul>\n<li><p>静态流水线：同一时间内，流水线的各段只能按照同一种功能的连接方式工作</p>\n</li>\n<li><p>动态流水线：不同的段完成的运算可能不一样，可以提高效率，但是流水线控制变得很复杂</p>\n</li>\n</ul>\n</li>\n<li><p>按照是否存在反馈信号分类</p>\n<ul>\n<li><p>线性流水线：不存在反馈回路</p>\n</li>\n<li><p>非线性流水线：存在反馈回路，非常适合线性递归运算</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"影响流水线的因素\"><a href=\"#影响流水线的因素\" class=\"headerlink\" title=\"影响流水线的因素\"></a>影响流水线的因素</h2><ul>\n<li><p>结构相关（资源冲突）</p>\n<ul>\n<li><p>概念：同一时刻争抢统一资源</p>\n</li>\n<li><p>解决方法</p>\n<ul>\n<li><p>冲突指令之间，插入暂停周其</p>\n</li>\n<li><p>单独设置数据存储器和指令存储器，但是增加了资源消耗</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据相关（数据冲突）</p>\n<ul>\n<li><p>概念：一个指令的执行必须要等待前一个指令的结果</p>\n</li>\n<li><p>解决方法：</p>\n<ul>\n<li><p>对数据相关的指令进行阻塞时钟周期</p>\n<ul>\n<li><p>硬件阻塞（stall）</p>\n</li>\n<li><p>软件插入NOP指令</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>控制相关（控制冲突）</p>\n<ul>\n<li><p>概念：出现转移指令或者其他改变PC值得指令造成断流</p>\n</li>\n<li><p>解决方法</p>\n<ul>\n<li><p>对转移指令进行分支预测</p>\n<ul>\n<li><p>简单（静态）预测</p>\n</li>\n<li><p>动态预测、准确率较高</p>\n</li>\n</ul>\n</li>\n<li><p>预取转移成功和不成功两个控制流方向上的目标指令</p>\n</li>\n<li><p>加快和提前形成条件码</p>\n</li>\n<li><p>提高转移方向的猜准率</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"流水线的性能指标\"><a href=\"#流水线的性能指标\" class=\"headerlink\" title=\"流水线的性能指标\"></a>流水线的性能指标</h2><ul>\n<li><p>吞吐率</p>\n<ul>\n<li><p>单位时间内流水线完成的任务数量</p>\n</li>\n<li><p>TP&#x3D;n&#x2F;TK</p>\n<ul>\n<li>n是任务数，Tk是处理完n个任务的时间</li>\n</ul>\n</li>\n<li><p>当连续输入的任务n趋向于无穷时，此时为最大吞吐率</p>\n</li>\n</ul>\n</li>\n<li><p>流水线的加速比</p>\n<ul>\n<li><p>不使用流水线与使用流水线的时间比值<img src=\"https://api2.mubu.com/v3/document_image/72d07acd-ea86-4c20-806a-308184700f83-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>连续任务数n趋向于无穷，此时为最大加速比</p>\n</li>\n</ul>\n</li>\n<li><p>流水线效率</p>\n<ul>\n<li><p>完成n个任务使用的时空区的面积与n个任务所用的时间及k个流水段所围成的时空区总面积比<img src=\"https://api2.mubu.com/v3/document_image/6c3fe69b-4979-420e-9c5d-4d91a0ee81d4-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>连续输入任务n趋向于无穷时，最高效率为1</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"超标量流水线的基本概念\"><a href=\"#超标量流水线的基本概念\" class=\"headerlink\" title=\"超标量流水线的基本概念\"></a>超标量流水线的基本概念</h2><ul>\n<li><p>超标量流水线技术</p>\n<ul>\n<li><p>每个时钟周期内可以并发多条独立指令</p>\n</li>\n<li><p>可以编译优化，把可并行执行的指令搭配起来，挖掘指令并行性</p>\n</li>\n</ul>\n</li>\n<li><p>超流水线技才</p>\n<ul>\n<li><p>在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次</p>\n</li>\n<li><p>编译程序解决优化问题</p>\n</li>\n</ul>\n</li>\n<li><p>超长指令字</p>\n<ul>\n<li>使用多个功能部件，利用编译程序挖掘出指令之间的并行性，然后将并行指令组成超长指令字</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"指令周期执行模板\"><a href=\"#指令周期执行模板\" class=\"headerlink\" title=\"指令周期执行模板\"></a>指令周期执行模板</h1><h2 id=\"取指令周期\"><a href=\"#取指令周期\" class=\"headerlink\" title=\"取指令周期\"></a>取指令周期</h2><ul>\n<li><p>PC——&gt;MAR</p>\n<ul>\n<li>现行指令地址——&gt;MAR</li>\n</ul>\n</li>\n<li><p>1——&gt;R</p>\n<ul>\n<li>命令存储器读</li>\n</ul>\n</li>\n<li><p>M(MAR)–&gt;MDR</p>\n<ul>\n<li>现行指令从存储器中读至MDR</li>\n</ul>\n</li>\n<li><p>MDR——&gt;IR</p>\n<ul>\n<li>现行指令——&gt;IR</li>\n</ul>\n</li>\n<li><p>OP（IR）——&gt;CU</p>\n<ul>\n<li>指令的操作码——&gt;CU译码</li>\n</ul>\n</li>\n<li><p>（PC）+1——&gt;PC</p>\n<ul>\n<li>形成下一条指令的地址</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"间址周期\"><a href=\"#间址周期\" class=\"headerlink\" title=\"间址周期\"></a>间址周期</h2><ul>\n<li><p>Ad（IR）——&gt;MAR</p>\n<ul>\n<li>将指令字中的地址码（形式地址）——&gt;MAR</li>\n</ul>\n</li>\n<li><p>1——&gt;R</p>\n<ul>\n<li>命令存储器读</li>\n</ul>\n</li>\n<li><p>M(MAR)——&gt;MDR</p>\n<ul>\n<li>将有效地址从存储器读至MDR</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"指令执行周期\"><a href=\"#指令执行周期\" class=\"headerlink\" title=\"指令执行周期\"></a>指令执行周期</h2><ul>\n<li><p>非访存指令</p>\n<ul>\n<li><p>CLA</p>\n<ul>\n<li>清ACC<ul>\n<li>O——&gt;ACC</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>COM</p>\n<ul>\n<li>取反<img src=\"https://api2.mubu.com/v3/document_image/76aee5be-85ca-4de4-9b90-5ca29a52f703-3224585.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li><p>SHP</p>\n<ul>\n<li>算数右移<ul>\n<li>L(ACC)——&gt;R(ACC)<img src=\"https://api2.mubu.com/v3/document_image/c06f9c2e-07da-408b-9874-c5232d2208d5-3224585.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CSL</p>\n<ul>\n<li>循环左移<ul>\n<li>R(ACC)——&gt;L(ACC)<img src=\"https://api2.mubu.com/v3/document_image/d0471588-8c24-479e-9b9f-ec34e3179f8a-3224585.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>STP</p>\n<ul>\n<li>停机指令<ul>\n<li>0——&gt;G</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>访存指令</p>\n<ul>\n<li><p>加法指令</p>\n<ul>\n<li><p>ADD  X</p>\n<ul>\n<li>加法指令<ul>\n<li>Ad（IR）——&gt;MAR</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>1-&gt;R</p>\n</li>\n<li><p>M(MAR)–&gt;MDR</p>\n</li>\n<li><p>(ACC)+(MDR)——&gt;ACC</p>\n</li>\n</ul>\n</li>\n<li><p>存数指令</p>\n<ul>\n<li><p>STA  X</p>\n<ul>\n<li>Ad(IR)——&gt;MAR</li>\n</ul>\n</li>\n<li><p>1——&gt;W</p>\n</li>\n<li><p>ACC——&gt;MDR</p>\n</li>\n<li><p>MDR——&gt;M（MAR）</p>\n</li>\n</ul>\n</li>\n<li><p>取数指令</p>\n<ul>\n<li><p>LDA  X</p>\n<ul>\n<li>Ad(IR)——&gt;MAR</li>\n</ul>\n</li>\n<li><p>1——&gt;R</p>\n</li>\n<li><p>M(MAR)——&gt;MDR</p>\n</li>\n<li><p>MDR——&gt;ACC</p>\n</li>\n</ul>\n</li>\n<li><p>转移指令</p>\n<ul>\n<li><p>JMP  X</p>\n<ul>\n<li>无条件转移<ul>\n<li>Ad(IR)——&gt;PC</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>BAN  X</p>\n<ul>\n<li>条件转移（负则转）<img src=\"https://api2.mubu.com/v3/document_image/2777fff5-db58-47a0-8852-1624f634f1c2-3224585.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","1.计算机组成原理","5.中央处理器"],"tags":["写作"]},{"title":"计算机系统概述","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/","content":"<h1 id=\"操作系统的基本概念\"><a href=\"#操作系统的基本概念\" class=\"headerlink\" title=\"操作系统的基本概念\"></a>操作系统的基本概念</h1><h2 id=\"操作系统的概念\"><a href=\"#操作系统的概念\" class=\"headerlink\" title=\"操作系统的概念\"></a>操作系统的概念</h2><ul>\n<li><p>控制和管理整个计算机系统的硬件与软件资源；合理地组织、调度计算机的工作与资源</p>\n<ul>\n<li><p>操作系统是系统资源的管理者（软件资源+硬件资源）</p>\n</li>\n<li><p>用QQ与朋友聊天的过程：</p>\n<ul>\n<li><p>1、在各个文件夹中找到QQ安装的位置</p>\n<ul>\n<li>操作系统提供的功能：文件管理</li>\n</ul>\n</li>\n<li><p>2、双击QQ.exe</p>\n<ul>\n<li>操作系统将程序从磁盘放入内存中，功能：存储器管理</li>\n</ul>\n</li>\n<li><p>3、QQ程序正确运行</p>\n<ul>\n<li>对应的进程被处理机（CPU）处理，为该进程分配CPU资源，功能：处理机管理</li>\n</ul>\n</li>\n<li><p>4、开始和朋友视频聊天</p>\n<ul>\n<li>将摄像头设备分配给进程，功能：设备管理</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>为用户和其他软件提供方便接口与环境的程序集合</p>\n<ul>\n<li><p>向上层提供方便易用的服务</p>\n<ul>\n<li><p>硬件只能听得懂二进制指令，对外暴露了不友好的交互接口</p>\n</li>\n<li><p>在硬件之上安装了操作系统，操作系统对外暴露了友好的交互接口</p>\n</li>\n<li><p>封装思想：操作系统把这些硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</p>\n</li>\n</ul>\n</li>\n<li><p>向上层提供方便易用的服务</p>\n<ul>\n<li><p>直接给用户使用</p>\n<ul>\n<li><p>例如：GUI（ 图形化用户接口）——现代操作系统一般都提供</p>\n<ul>\n<li><p>用户可以使用形象的图形界面进行操作，而不需要记忆复杂的命令、参数</p>\n</li>\n<li><p>例：在Windows操作系统中，删除一个文件只需要将文件拖拽到回收站即可</p>\n</li>\n</ul>\n</li>\n<li><p>早期操作系统没有图形化界面，一般使用命令接口进行交互</p>\n<ul>\n<li><p>联机命令接口：</p>\n<ul>\n<li><p>&#x3D;交互式命令接口</p>\n<ul>\n<li>特点：用户说一句，系统跟着做一句</li>\n</ul>\n</li>\n<li><p>1、Win键+R</p>\n</li>\n<li><p>2、输入cmd，回车，打开命令解释器</p>\n</li>\n<li><p>3、尝试使用time命令</p>\n</li>\n</ul>\n</li>\n<li><p>脱机命令接口</p>\n<ul>\n<li><p>&#x3D;批处理命令接口</p>\n<ul>\n<li>特点：用户说一堆，系统跟着做一堆</li>\n</ul>\n</li>\n<li><p>1、执行一个*.bat文件</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>给软件和程序员使用</p>\n<ul>\n<li><p>程序接口</p>\n<ul>\n<li><p>在程序中进行系统调用来使用程序接口</p>\n</li>\n<li><p>普通用户不能直接使用程序接口，只能通过程序代码间接使用</p>\n</li>\n<li><p>例：printf函数使用</p>\n<ul>\n<li><p>底层就用到了操作系统提供的和显示相关的系统调用</p>\n<ul>\n<li><p>系统调用类似于函数调用，是应用程序请求操作系统服务的唯一方式</p>\n</li>\n<li><p>系统调用&#x3D;广义指令</p>\n</li>\n</ul>\n</li>\n<li><p>操作系统收到系统调用请求之后，操作系统才会操作硬件</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>是计算机系统中最基本的系统软件——作为最接近硬件的层次</p>\n<ul>\n<li><p>实现对硬件机器功能的拓展</p>\n<ul>\n<li><p>裸机：没有任何软件支持的计算机</p>\n</li>\n<li><p>功能更强、使用更方便的机器：在裸机上安装操作系统，可以提供资源管理功能和方便用户的服务功能</p>\n</li>\n<li><p>扩充机器（虚拟机）：覆盖了软件的机器</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"操作系统的目标和功能\"><a href=\"#操作系统的目标和功能\" class=\"headerlink\" title=\"操作系统的目标和功能\"></a>操作系统的目标和功能</h2><ul>\n<li><p>管理功能</p>\n<ul>\n<li><p>处理机管理</p>\n<ul>\n<li><p>管理处理机的分配与运行，解决冲突问题，可以理解为对进程的管理</p>\n</li>\n<li><p>进程管理：进程控制、进程同步、进程通信、死锁处理、处理机调度</p>\n</li>\n</ul>\n</li>\n<li><p>存储器管理</p>\n<ul>\n<li><p>为了提高多道程序运行效率，方便用户使用</p>\n</li>\n<li><p>内存分配、地址映射、内存保护、共享和内存扩充</p>\n</li>\n</ul>\n</li>\n<li><p>文件管理</p>\n<ul>\n<li><p>操作系统负责管理文件的系统称为文件系统</p>\n</li>\n<li><p>文件存储空间的管理、目录管理、文件读写管理和保护</p>\n</li>\n</ul>\n</li>\n<li><p>设备管理</p>\n<ul>\n<li><p>完成用户的IO请求，方便用户使用设备，提高设备的利用率</p>\n</li>\n<li><p>缓冲管理、设备分配、设备处理、虚拟设备</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>接口功能</p>\n<ul>\n<li><p>命令接口</p>\n<ul>\n<li><p>联机控制方式</p>\n<ul>\n<li>交互式命令接口，适用于分时或者实时系统，就像人与机器对话一样</li>\n</ul>\n</li>\n<li><p>脱机控制方式</p>\n<ul>\n<li>又称批处理系统，提交一组作业，系统进行处理，用户不能干预作业的运行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>程序接口</p>\n<ul>\n<li><p>有一组系统调用命令组成（也称作系统调用或者广义指令）</p>\n</li>\n<li><p>例如：图形用户界面（GUT）</p>\n</li>\n</ul>\n</li>\n<li><p>操作系统用作扩存机器</p>\n<ul>\n<li><p>操作系统提供了资源管理功能和方便用户使用的各种服务功能，将机器改造为功能更强的机器</p>\n</li>\n<li><p>覆盖了软件的机器成为扩充机器，又称之为虚拟机</p>\n</li>\n</ul>\n</li>\n<li><p>封装思想</p>\n<ul>\n<li>操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"操作系统的特征：\"><a href=\"#操作系统的特征：\" class=\"headerlink\" title=\"操作系统的特征：\"></a>操作系统的特征：</h2><p>对于单处理机来说，宏观上程序是井发的，微观上程序是交替执行的</p>\n<ul>\n<li><p>基本特征：井发、共享、虚拟、异步</p>\n</li>\n<li><p>并发（并发和共享是两个最基本的特征，两者互为存在条件）</p>\n<ul>\n<li><p>两个或者多个事件在同一时间间隔内发生</p>\n</li>\n<li><p>使得系统具有处理和调度多个程序同时执行的能力</p>\n</li>\n<li><p>操作系统的并发是通过分时实现的</p>\n</li>\n<li><p>操作系统是伴随着多道程序技术而出现的，因此操作系统和程序并发是一起诞生的</p>\n</li>\n<li><p>注意：并发是指在一个时间段；并行是指在同一个时刻</p>\n<ul>\n<li>并行是指系统具有同时执行或操作（硬件支持：多流水线或者多处理机）</li>\n</ul>\n</li>\n<li><p>重要考点</p>\n<ul>\n<li><p>单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行</p>\n</li>\n<li><p>多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行</p>\n</li>\n</ul>\n</li>\n<li><p>例：Intel的第八代i3处理器是4核CPU，意味着可以并行地执行4个程序</p>\n<ul>\n<li>即使是4核CPU，只要有4个以上程序需要同时运行，那么并发性依然是必不可少的，因此并发性是操作系统的一个最基本特性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>共享</p>\n<ul>\n<li><p>即资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用</p>\n</li>\n<li><p>互斥共享方式</p>\n<ul>\n<li><p>例如打印机、磁带、摄像头，同一时间段只能供一个进程对资源进行访问</p>\n</li>\n<li><p>这种资源称作：临界资源或者独占资源</p>\n</li>\n</ul>\n</li>\n<li><p>同时访问方式</p>\n<ul>\n<li><p>一段时间内允许多个进程对资源进行访问</p>\n</li>\n<li><p>典型代表：磁盘设备，重入码编写的文件</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>同时是宏观上的，在微观上这些进程可能是交替的对资源进行访问（即分时共享）</p>\n</li>\n<li><p>有时也是微观上同时共享资源，同时打游戏和听歌，微观上同时共享扬声器</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>例：QQ发送文件A，微信发送文件B</p>\n<ul>\n<li><p>1、两个进程正在并发执行（并发性）</p>\n<ul>\n<li>如果失去了并发性，则系统中只有一个程序正在运行，则共享性失去了存在的意义</li>\n</ul>\n</li>\n<li><p>2、需要共享的访问硬盘资源（共享性）</p>\n<ul>\n<li>如果失去了共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>虚拟（没有并发性，就没有虚拟性）</p>\n<ul>\n<li><p>一个物理上的实体变为若干逻辑上的对应物，这种技术也被称为虚拟技术</p>\n</li>\n<li><p>虚拟处理器：采用多道程序并发的方式，让每个终端用户感觉到有多个处理器</p>\n<ul>\n<li>时分复用技术</li>\n</ul>\n</li>\n<li><p>虚拟存储器：将物理存储变为虚拟存储器，逻辑上扩充存储器用量</p>\n<ul>\n<li>空分复用技术</li>\n</ul>\n</li>\n<li><p>也可以将一台IO设备虚拟为多台逻辑上的IO设备，并允许每个用户占用一台逻辑上的IO设备</p>\n</li>\n</ul>\n</li>\n<li><p>异步（没有并发性，就没有异步性）</p>\n<ul>\n<li>多道程序走走停停，进程以不可预知的速度向前走</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统的发展与分类\"><a href=\"#操作系统的发展与分类\" class=\"headerlink\" title=\"操作系统的发展与分类\"></a>操作系统的发展与分类</h1><h2 id=\"手工操作阶段\"><a href=\"#手工操作阶段\" class=\"headerlink\" title=\"手工操作阶段\"></a>手工操作阶段</h2><ul>\n<li><p>程序的装入，运行，结果的输出都需要人为的干预</p>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>用户独占全机</p>\n</li>\n<li><p>人机速度矛盾导致资源利用率低（特别是CPU利用不充分）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"批处理阶段\"><a href=\"#批处理阶段\" class=\"headerlink\" title=\"批处理阶段\"></a>批处理阶段</h2><ul>\n<li><p>为了解决人机矛盾以及CPU和I&#x2F;0设备之间速度不匹配的矛盾</p>\n</li>\n<li><p>单道批处理系统</p>\n<ul>\n<li><p>引入脱机输入&#x2F;输出技术（用外围机+磁带完成），并由监督程序负责作业的输入、输出</p>\n</li>\n<li><p>从磁带输入、输出到另一个磁带的时间变短：内存中始终保存一道作业，作业成批进行</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>自动性：一批作业自动执行，不需要人工干预</p>\n</li>\n<li><p>顺序性：各道作业依次执行</p>\n</li>\n<li><p>单道性：仅有一道程序执行</p>\n</li>\n</ul>\n</li>\n<li><p>优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</p>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序</p>\n</li>\n<li><p>高速CPU有大量时间是在等待I&#x2F;O设备的完成，资源利用率仍然很低</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多道批处理系统</p>\n<ul>\n<li><p>允许多个程序在CPU中交替运行，程序共享各种硬件和软件资源</p>\n</li>\n<li><p>操作系统正式诞生，用于支持多道程序并发进行</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>多道：计算机中同时存放多道相互独立的程序</p>\n</li>\n<li><p>宏观上并行：多道程序都会开始运行，但都没有运行完毕</p>\n</li>\n<li><p>微观上串行：多道程序轮流占有CPU，交替执行</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>多道程序并发执行，共享计算机资源（输入设备、输出设备、CPU）</p>\n</li>\n<li><p>资源利用率高（CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大）</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>响应时间过长，没有人机交互功能</p>\n<ul>\n<li>用户无法调试程序，也无法在程序运行过程中输入一些参数</li>\n</ul>\n</li>\n<li><p>设计复杂，要考虑各种资源调度问题</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分时操作系统\"><a href=\"#分时操作系统\" class=\"headerlink\" title=\"分时操作系统\"></a>分时操作系统</h2><ul>\n<li><p>将处理器运行时间划分为时间片，将时间片分配给不同作业&#x2F;用户从而占用处理机</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>同时性：允许多个终端用户使用同一台计算机</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>交互性：方便进行人机对话，用户采用人机对话方式控制程序运行</p>\n</li>\n<li><p>独立性：多个用户彼此之间独立的操作，互不干扰</p>\n</li>\n<li><p>及时性：用户请求能在很短时间内获得响应</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>用户请求可以被及时响应，解决了人机交互问题</p>\n</li>\n<li><p>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>不能优先处理紧急任务<ul>\n<li>操作系统对各个用户&#x2F;作业是完全公平的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实时操作系统\"><a href=\"#实时操作系统\" class=\"headerlink\" title=\"实时操作系统\"></a>实时操作系统</h2><ul>\n<li><p>保证在规定时间内完成某项任务</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>及时性：规定时间内完成规定任务</p>\n</li>\n<li><p>可靠性：输出的结果正确，系统运行时确保稳定</p>\n</li>\n</ul>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>硬实时系统：必须在绝对严格的规定时间内完成处理</p>\n<ul>\n<li>例：导弹控制系统、自动驾驶系统</li>\n</ul>\n</li>\n<li><p>软实时系统：能接受偶尔违反时间规定</p>\n<ul>\n<li>例：12306火车订票系统</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>能够优先响应一些紧急任务<ul>\n<li>计算机系统接收到外部信号后及时进行处理，并且在严格的时限内处理完事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"网络操作系统\"><a href=\"#网络操作系统\" class=\"headerlink\" title=\"网络操作系统\"></a>网络操作系统</h2><ul>\n<li><p>伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能</p>\n</li>\n<li><p>实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</p>\n</li>\n</ul>\n<p>分布式计算机系统</p>\n<ul>\n<li><p>任意两台计算机之间没有主从之分，互相交换信息，并行工作、协同完成</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>分布性</p>\n</li>\n<li><p>并行性</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>个人计算机操作系统</p>\n<ul>\n<li><p>方便个人使用</p>\n</li>\n<li><p>广泛应用于文字处理，电子表格，游戏</p>\n</li>\n</ul>\n<h1 id=\"操作系统的运行环境\"><a href=\"#操作系统的运行环境\" class=\"headerlink\" title=\"操作系统的运行环境\"></a>操作系统的运行环境</h1><h2 id=\"操作系统的运行机制\"><a href=\"#操作系统的运行机制\" class=\"headerlink\" title=\"操作系统的运行机制\"></a>操作系统的运行机制</h2><ul>\n<li><p>程序运行原理</p>\n<ul>\n<li><p>程序运行的过程其实就是CPU执行一条一条的机器指令的过程</p>\n</li>\n<li><p>过程：</p>\n<ul>\n<li>C语言代码——(通过编译器，翻译)——&gt;机器指令(二进制)：一条高级代码翻译过来可能对应多条机器指令</li>\n</ul>\n</li>\n<li><p>注：指令</p>\n<ul>\n<li><p>处理器（CPU）能识别、执行的最基本命令</p>\n</li>\n<li><p>指的是二进制机器指令</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两种程序</p>\n<ul>\n<li><p>内核程序</p>\n<ul>\n<li>编写操作系统的程序，很多内核程序组成操作系统内核（内核）</li>\n</ul>\n</li>\n<li><p>应用程序</p>\n<ul>\n<li>运行在操作系统之上的程序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两种指令</p>\n<ul>\n<li><p>特权指令</p>\n<ul>\n<li><p>只允许操作系统内核使用的指令</p>\n</li>\n<li><p>注：在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前就能判断出其类型</p>\n</li>\n</ul>\n</li>\n<li><p>非特权指令</p>\n<ul>\n<li>允许应用程序使用的指令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两种处理机状态</p>\n<ul>\n<li><p>核心态</p>\n<ul>\n<li><p>怎么区分CPU正在运行的是内核程序，还是应用程序？</p>\n<ul>\n<li><p>CPU处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令</p>\n</li>\n<li><p>CPU处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令</p>\n</li>\n</ul>\n</li>\n<li><p>怎么区分CPU处于哪种状态？内核态还是用户态</p>\n<ul>\n<li>cpu中有一个寄存器叫程序状态字寄存器（psw），其中有个二进制位，1表示“内态”，0表示“用户态”</li>\n</ul>\n</li>\n<li><p>别名</p>\n<ul>\n<li><p>内核态&#x3D;核心态&#x3D;管态</p>\n</li>\n<li><p>用户态&#x3D;目态</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>用户态</p>\n</li>\n</ul>\n</li>\n<li><p>内核</p>\n<ul>\n<li><p>时钟管理：操作系统对用户提供标准时间，根据时钟对进程进行管理，实现进程切换</p>\n</li>\n<li><p>中断机制：初衷是为了提高多道程序运行环境中的CPU利用率 保护和恢复中断现场的信息，转移控制权到相关程序</p>\n</li>\n<li><p>原语</p>\n<ul>\n<li><p>内核是操作系统最重要、最核心的部分，处于系统的最底层，最接近硬件</p>\n</li>\n<li><p>由很多内核程序组成操作系统的内核</p>\n</li>\n<li><p>运行具有原子性，即只能一气呵成</p>\n</li>\n<li><p>系统控制的数据结构及处理</p>\n<ul>\n<li><p>进程管理：进程状态管理、进程调度和分派、创建和撤销进程控制块</p>\n</li>\n<li><p>存储器管理：存储器的空间分配和回收、内存信息保护程序、代码对换程序</p>\n</li>\n<li><p>设备管理：缓冲区管理设备分配和回收</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内核态、用户态的切换</p>\n<ul>\n<li><p>内核态— &gt;用户态：执行一条特权指令——修改PSW的标志位为“用户态” ，这个动作意味着操作系统将主动让出CPU使用权</p>\n</li>\n<li><p>用户态—&gt;内核态：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权</p>\n<ul>\n<li>为什么触发中断信号：但凡需要操作系统介入的地方，都会触发中断信号</li>\n</ul>\n</li>\n<li><p>内核态和用户态的切换过程</p>\n<ul>\n<li><p>刚开机时，CPU处于内核态，操作系统内核程序在CPU上运行</p>\n</li>\n<li><p>开机完成后，用户启动应用程序</p>\n</li>\n<li><p>操作系统的内核程序就会在适当时间让出CPU，让应用程序在CPU上运行</p>\n<ul>\n<li><p>内核程序如何让出CPU？</p>\n</li>\n<li><p>执行一条特权指令把PSW的标志位设置为用户态</p>\n</li>\n</ul>\n</li>\n<li><p>此时应用程序运行在用户态</p>\n</li>\n<li><p>如果黑客在应用程序中植入一条特权指令</p>\n</li>\n<li><p>CPU发现执行的指令是特权指令，但是CPU处于用户态</p>\n</li>\n<li><p>这个非法事件会引发一个中断信号</p>\n<ul>\n<li>CPU检测到中断信号后，会立即变为核心态，并停止运行当前应用程序，转而运行处理中断信号的内核程序</li>\n</ul>\n</li>\n<li><p>中断使得操作系统再次夺回CPU的控制权</p>\n</li>\n<li><p>操作系统会对引发中断的事件进行处理，处理完之后再把CPU的使用权交给应用程序</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"中断与异常\"><a href=\"#中断与异常\" class=\"headerlink\" title=\"中断与异常\"></a>中断与异常</h2><ul>\n<li><p>中断的作用</p>\n<ul>\n<li><p>让操作系统内核强行夺回CPU使用权的唯一途径</p>\n</li>\n<li><p>使CPU有用户态变为核心态</p>\n<ul>\n<li><p>如果没有中断机制，那么一旦应用程序在CPU上运行，CPU就会一直运行这个应用程序（也就没有并发性）</p>\n</li>\n<li><p>注：访管指令是在用户态使用，将用户态转换为核心态，所以访管指令不是特权指令</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>中断的类型</p>\n<ul>\n<li><p>异常（内中断）</p>\n<ul>\n<li><p>与当前执行的指令有关，中断信号来源于CPU执行指令内部</p>\n</li>\n<li><p>分类：</p>\n<ul>\n<li><p>陷入：由陷入指令引发，是应用程序故意引发的</p>\n<ul>\n<li><p>陷入指令：应用程序自行执行，执行陷入指令后，用户态转换为核心态</p>\n</li>\n<li><p>意味着应用程序主动地将CPU控制权交还给操作系统内核，系统调用就是陷入指令完成的</p>\n</li>\n</ul>\n</li>\n<li><p>故障：由错误条件引发的，可能被内核程序修复</p>\n<ul>\n<li><p>内核程序修复故障后会把CPU使用权还给应用程序，让他继续执行下去</p>\n</li>\n<li><p>如：缺页故障</p>\n</li>\n</ul>\n</li>\n<li><p>终止：由致命错误引起的，内核程序无法修复该错误</p>\n<ul>\n<li><p>因此一般不再将CPU的使用权还给引发终止的应用程序，而是直接终止该应用程序</p>\n</li>\n<li><p>例如：</p>\n<ul>\n<li><p>CPU在用户态执行特权指令</p>\n</li>\n<li><p>执行的指令是非法的</p>\n<ul>\n<li><p>执行除法指令时除数为0</p>\n</li>\n<li><p>非法操作码、指令非法、指令的参数非法</p>\n</li>\n<li><p>地址越界，算术溢出</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>异常不能被屏蔽</p>\n</li>\n</ul>\n</li>\n<li><p>中断（外中断）</p>\n<ul>\n<li><p>与当前执行的指令无关，中断信号来源于CPU指令之外</p>\n</li>\n<li><p>例如：</p>\n<ul>\n<li><p>时钟中断：由时钟部件发来的中断信号</p>\n<ul>\n<li><p>时钟部件每隔一个时间片（如50ms）会给CPU发送一个时钟中断信号</p>\n</li>\n<li><p>时钟中断能够实现多道程序并发运行</p>\n</li>\n</ul>\n</li>\n<li><p>I&#x2F;O中断：当输入输出任务已经完成时，向CPU发送中断信号</p>\n</li>\n</ul>\n</li>\n<li><p>CPU在每条指令执行结束时，都会例行检查是否有外中断信号</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>中断机制的基本原理</p>\n<ul>\n<li><p>检测中断信号</p>\n<ul>\n<li><p>内中断：CPU在执行指令时会检查是否有异常产生</p>\n</li>\n<li><p>外中断：每个指令周期结束时，CPU都会检查是否有外中断信号需要处理</p>\n</li>\n</ul>\n</li>\n<li><p>找到相应的中断处理程序</p>\n<ul>\n<li><p>不同的中断信号，需要用不同的中断处理程序来处理</p>\n</li>\n<li><p>CPU检测到中断信号之后，会根据中断信号的类型去查询中断向量表，以此来找到相应的中断处理程序在内存中的存放位置</p>\n</li>\n<li><p>中断处理程序一定是内核程序，需要运行在内核态</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h2><ul>\n<li><p>什么是系统调用？</p>\n<ul>\n<li><p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组系统调用组成</p>\n<ul>\n<li><p>命令接口：给用户使用</p>\n</li>\n<li><p>程序接口（系统调用）：给应用程序使用</p>\n</li>\n</ul>\n</li>\n<li><p>系统调用是操作系统提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数</p>\n</li>\n<li><p>应用程序可以通过系统调用来请求获得操作系统内核的服务</p>\n</li>\n</ul>\n</li>\n<li><p>系统调用和库函数的区别：</p>\n<ul>\n<li><p>操作系统向上提供系统调用，使得库函数能请求内核服务</p>\n</li>\n<li><p>高级编程语言向上提供库函数，封装系统调用，暴露出更好用的编程接口</p>\n</li>\n<li><p>普通应用程序可直接进行系统调用，也可以使用库函数，有的库函数进行系统调用（创建一个新文件），有的库函数不需要进行系统调用（取绝对值的函数）</p>\n</li>\n</ul>\n</li>\n<li><p>小例子：为什么系统调用是必须的？</p>\n<ul>\n<li><p>同时使用wps和word打印两份资料，两个进程是并发的——&gt;结果：两份资料混在一起</p>\n</li>\n<li><p>如何解决：由操作系统对共享资源进行统一管理，并向上提供系统调用。</p>\n<ul>\n<li>用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求，内核会对各个请求进行协调处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>什么功能要用系统调用实现？</p>\n<ul>\n<li><p>凡是与共享资源有关的操作（如存储分配、I&#x2F;O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提供服务请求，由操作系统内核代为完成</p>\n</li>\n<li><p>这样可以保证系统的稳定性和安全性，防止用户进行非法操作</p>\n</li>\n<li><p>系统调用（按功能分类）</p>\n<ul>\n<li><p>设备功能：完成设备的请求或者释放，设备启动等功能</p>\n</li>\n<li><p>文件管理：完成文件的读、写、创建以及删除功能</p>\n</li>\n<li><p>进程控制：完成进程的创建、撤销、阻塞以及唤醒功能</p>\n</li>\n<li><p>进程通信：完成进程之间的消息传递和信号传递功能</p>\n</li>\n<li><p>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>系统调用的过程：</p>\n<ul>\n<li><p>系统调用</p>\n<ul>\n<li><p>传递系统调用参数</p>\n<ul>\n<li><p>1、运行在用户态的应用程序运行传参指令（将系统调用需要的参数放到某些通用寄存器中），给CPU的寄存器中传递参数1</p>\n<ul>\n<li>参数1指明系统调用类型，如fork</li>\n</ul>\n</li>\n<li><p>2、应用程序可能继续向CPU的寄存器传递参数</p>\n<ul>\n<li>参数的个数取决于系统调用类型所需要的参数个数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>执行陷入指令（用户态）</p>\n<ul>\n<li>3、应用程序执行陷入指令（trap指令&#x2F;访管指令），引发内中断信号<ul>\n<li>该中断由陷入指令引发，因此转入相应的中断处理程序——即系统调用的入口程序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>执行相应的内核请求程序对系统调用进行处理（核心态）</p>\n<ul>\n<li><p>4、通过运行系统调用入口程序中的指令，会检查CPU寄存器中的参数，判断用户需要哪种系统调用服务</p>\n</li>\n<li><p>5、系统调用入口程序会根据所需的系统调用类型，调用与系统调用类型对应的处理程序</p>\n</li>\n<li><p>6、该处理程序运行时，有可能根据其它参数具体的执行哪种服务</p>\n</li>\n</ul>\n</li>\n<li><p>返回应用程序</p>\n<ul>\n<li>7、处理程序执行完成后，CPU又会转为用户态，继续执行应用程序</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>程序员通过高级语言代码调用库函数，有的库函数中有可能封装了系统调用的具体细节</p>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><p>陷入指令（非特权指令）是在用户态执行的，执行陷入指令后立即引发一个内中断，使CPU进入核心态</p>\n</li>\n<li><p>发出系统调用请求是在用户态，对系统调用的相应处理是在核心态下进行的</p>\n</li>\n<li><p>别名：陷入指令 &#x3D; trap指令 &#x3D; 访管指令</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统的体系结构（内核如何设计）\"><a href=\"#操作系统的体系结构（内核如何设计）\" class=\"headerlink\" title=\"操作系统的体系结构（内核如何设计）\"></a>操作系统的体系结构（内核如何设计）</h1><h2 id=\"操作系统分为\"><a href=\"#操作系统分为\" class=\"headerlink\" title=\"操作系统分为\"></a>操作系统分为</h2><ul>\n<li><p>内核</p>\n<ul>\n<li><p>与硬件关联较紧密的模块</p>\n<ul>\n<li><p>时钟管理</p>\n<ul>\n<li>利用时钟中断实现计时功能</li>\n</ul>\n</li>\n<li><p>中断处理</p>\n<ul>\n<li>负责实现中断机制</li>\n</ul>\n</li>\n<li><p>原语（设备驱动、CPU切换等）：</p>\n<ul>\n<li><p>原语是一种特殊的程序</p>\n</li>\n<li><p>处于操作系统最底层，是最接近硬件的部分</p>\n</li>\n<li><p>具有原子性。这段程序的运行必须是一气呵成的，不可被中断</p>\n</li>\n<li><p>运行时间短、调用频繁</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>不会直接涉及硬件</p>\n<ul>\n<li><p>对系统资源进行管理的功能</p>\n<ul>\n<li><p>进程管理、存储器管理、设备管理等功能</p>\n</li>\n<li><p>这些管理工作更多的是对数据结构的操作</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>非内核</p>\n<ul>\n<li><p>如GUI</p>\n</li>\n<li><p>Ubuntu、CentOS的开发团队的主要工作是实现非内核功能，而内核都是用Linux内核</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"大内核\"><a href=\"#大内核\" class=\"headerlink\" title=\"大内核\"></a>大内核</h2><ul>\n<li><p>将操作系统的主要功能模块进行集中，从而用以提供高性能的系统服务</p>\n</li>\n<li><p>内容：内核中所有模块都运行在内核态</p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>性能高</p>\n<ul>\n<li><p>CPU状态转换次数少</p>\n</li>\n<li><p>各个管理模块之间共享信息，能够有效利用相互之间的有效特性</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>内核代码庞大，结构混乱，难以维护</li>\n</ul>\n</li>\n<li><p>应用：Linux、Unix</p>\n</li>\n</ul>\n<h2 id=\"微内核\"><a href=\"#微内核\" class=\"headerlink\" title=\"微内核\"></a>微内核</h2><ul>\n<li><p>背景：随着计算机体系结构的不断发展，操作系统提供的服务越来越多，接口形式越来越复杂</p>\n</li>\n<li><p>内容：将内核中最基本的功能（如：进程管理）保留在内核，将不需要在核心态执行的功能（对系统资源进行管理）转移到用户态执行，降低内核设计的复杂性</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>内核功能少，结构清晰，方便维护</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>性能低，需要频繁的在核心态和用户态之间进行切换</li>\n</ul>\n</li>\n<li><p>应用：Windows NT</p>\n</li>\n</ul>\n","categories":["计算机408","2.操作系统","1.计算机系统概述"],"tags":["写作"]},{"title":"进程管理","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_2.%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","content":"<h1 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h1><h2 id=\"进程的概念和特征\"><a href=\"#进程的概念和特征\" class=\"headerlink\" title=\"进程的概念和特征\"></a>进程的概念和特征</h2><ul>\n<li><p>进程的概念</p>\n<ul>\n<li><p>为了更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性</p>\n</li>\n<li><p>程序：是静态的，是存放在瓷盘中的可执行文件，是一系列的指令集和</p>\n</li>\n<li><p>进程：</p>\n<ul>\n<li><p>是动态的，是程序的一次执行过程；同一个程序多次执行会对应多个进程</p>\n</li>\n<li><p>进程是一次程序及其数据在处理机上顺序执行时所发生的活动</p>\n</li>\n<li><p>进程是具有独立功能的程序在一个数据集合上运行的过程，是资源分配和调度的独立单位（没有引入线程）</p>\n</li>\n</ul>\n</li>\n<li><p>如何区分进程？</p>\n<ul>\n<li>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的进程ID（PID）</li>\n</ul>\n</li>\n<li><p>进程控制块（PCB ） ：为了更好的描述进程的基本情况和运行状态，进而控制和管理进程</p>\n<ul>\n<li><p>PCB是进程存在的唯一标志</p>\n</li>\n<li><p>操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中</p>\n</li>\n<li><p>当进程被创建时，操作系统会为其创建PCB；当进程结束时，会回收PCB</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程（进程实体）的组成</p>\n<ul>\n<li><p>进程控制块PCB</p>\n<ul>\n<li><p>进程描述信息</p>\n<ul>\n<li><p>进程标识符PID</p>\n</li>\n<li><p>用户标识符UID</p>\n</li>\n</ul>\n</li>\n<li><p>进程控制和管理信息</p>\n<ul>\n<li><p>CPU、磁盘、网络流量使用情况统计</p>\n</li>\n<li><p>进程当前状态：就绪态、阻塞态、运行态</p>\n</li>\n</ul>\n</li>\n<li><p>资源分配清单</p>\n<ul>\n<li><p>正在使用哪种文件</p>\n</li>\n<li><p>正在使用哪种内存区域</p>\n</li>\n<li><p>正在使用哪种I&#x2F;O设备</p>\n</li>\n</ul>\n</li>\n<li><p>处理机相关信息</p>\n<ul>\n<li>如PSW、PC等各寄存器的值（用于实现进程切换）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>程序段：包括程序的指令序列——CPU从内存中一条条的执行指令</p>\n</li>\n<li><p>数据段：包含运行过程中产生的各种数据</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>PCB：给操作系统使用的</p>\n</li>\n<li><p>程序段、数据段：给进程自己使用的，与进程自己的运行逻辑有关</p>\n</li>\n<li><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>\n<ul>\n<li><p>操作系统是以进程为单位，为各个进程分配资源</p>\n</li>\n<li><p>调度：操作系统决定让哪个进程上CPU运行</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：程序运行过程</p>\n<ul>\n<li><p>高级语言程序——&gt;生成可执行文件（*.exe），存放在硬盘中，即一系列指令序列——&gt;把程序（程序实体）放入内存</p>\n<ul>\n<li><p>程序的实体</p>\n<ul>\n<li><p>PCB：一个程序开始运行前，需要创建对应的进程，也就是创建相应的PCB</p>\n</li>\n<li><p>程序段：包括程序的指令序列——CPU从内存中一条条的执行指令</p>\n</li>\n<li><p>数据段：包含运行过程中产生的各种数据</p>\n</li>\n</ul>\n</li>\n<li><p>进程是动态的，进程实体（进程映像）是静态的</p>\n</li>\n<li><p>进程实体反映了进程在某一时刻的状态</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的特征</p>\n<ul>\n<li><p>动态性：动态性是进程最基本特征，是程序的一次执行过程，是动态的产生、变化、消亡</p>\n<ul>\n<li>进程有着创建、活动、暂停、终止等过程，具有生命周期</li>\n</ul>\n</li>\n<li><p>并发性：多个进程实体同时存在内存中，引入进程的目的就是为了程序与其他程序并发执行</p>\n</li>\n<li><p>独立性：进程实体是一个能独立运行，独立获得资源和独立接受调度的基本单位</p>\n<ul>\n<li>没有建立PCB的程序，都不能作为一个独立单位参与运行</li>\n</ul>\n</li>\n<li><p>异步性：</p>\n<ul>\n<li><p>进程相互制约，进程以独立的、不可预知的速度向前推进</p>\n</li>\n<li><p>所以操作系统中一定要配置相应的进程同步机制</p>\n</li>\n<li><p>异步性会导致并发程序执行结果的不确定性</p>\n</li>\n</ul>\n</li>\n<li><p>结构性：每个进程都配置一个PCB对其进行描述（进程实体）</p>\n<ul>\n<li><p>进程控制段PCB</p>\n</li>\n<li><p>程序段</p>\n</li>\n<li><p>数据段</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程的状态与转换\"><a href=\"#进程的状态与转换\" class=\"headerlink\" title=\"进程的状态与转换\"></a>进程的状态与转换</h2><ul>\n<li><p>状态</p>\n<ul>\n<li><p>三种基本状态：进程的整个生命周期中，大部分时间都处于三种基本状态</p>\n<ul>\n<li><p>就绪态：已经具备运行条件，但由于没有空闲CPU，所以暂时不能运行</p>\n<ul>\n<li><p>无处理机资源，有其他资源：已经具备运行条件，但由于没有空闲CPU，所以暂时不能运行</p>\n</li>\n<li><p>系统中可能有多个进程都处于就绪态</p>\n</li>\n</ul>\n</li>\n<li><p>运行态：进程占用CPU、并在CPU上运行</p>\n<ul>\n<li><p>有处理机资源，有其他资源</p>\n</li>\n<li><p>当CPU空闲时，操作系统就会选择一个就绪态程序，让它上处理机运行</p>\n</li>\n<li><p>CPU会执行该进程对应的程序（执行相应的指令序列）</p>\n</li>\n<li><p>单CPU情况下，同一时刻只有一个进程处于运行态；多CPU情况下，可能有多个进程处于运行态</p>\n</li>\n</ul>\n</li>\n<li><p>阻塞态：因等待某个事件而暂时不能运行（如等待某种系统资源的分配、或等待其他进程的响应）</p>\n<ul>\n<li><p>无处理机资源、无其他资源</p>\n</li>\n<li><p>在所等待的事件发生之前，该进程无法继续往下执行，此时操作系统会让该进程下CPU，并让它进入阻塞态</p>\n</li>\n<li><p>当CPU空闲时，又会选择另一个处于就绪态的进程上CPU运行</p>\n</li>\n<li><p>当进程等待的事件发生时，该进程就进入就绪态</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>创建态：进程正在被创建，尚未进入就绪态，操作系统为进程分配资源、初始化PCB</p>\n</li>\n<li><p>结束态：进程正在从系统中消失（包括正常结束或者异常终止）</p>\n<ul>\n<li><p>一个进程可以执行exit系统调用，请求操作系统终止该进程</p>\n</li>\n<li><p>进程进入终止态时，操作系统会让该进程下CPU，并回收内存空间等资源，同时回收该进程的PCB</p>\n</li>\n</ul>\n</li>\n<li><p>注：进程PCB中，会有一个变量state来表示进程的当前状态</p>\n<ul>\n<li>如：1表示创建态、2表示就绪态、3表示运行态</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>状态间的相互转化</p>\n<ul>\n<li><p>创建态（新建态）——&gt;就绪态：系统完成创建进程的一系列工作</p>\n</li>\n<li><p>就绪态——&gt;运行态：处于就绪态的进程获得处理机资源（进程被调度），进入运行态</p>\n</li>\n<li><p>运行态——&gt;阻塞态：进程用系统调用的方式请求某种系统资源，此时运行态进入阻塞态</p>\n<ul>\n<li><p>是进程自身作出的主动行为</p>\n</li>\n<li><p>系统调用请求：操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式</p>\n</li>\n</ul>\n</li>\n<li><p>运行态——&gt;就绪态：处于运行态的进程时间片用完后（或处理机被抢占），让出处理机进入就绪态</p>\n</li>\n<li><p>阻塞态——&gt;就绪态：进程等待其他资源的获得，如I&#x2F;O资源、或者中断结束</p>\n<ul>\n<li><p>不是进程自身能控制的，是一种被动行为</p>\n</li>\n<li><p>申请的资源被分配，或等待的事件发生</p>\n</li>\n</ul>\n</li>\n<li><p>运行态——&gt;结束态：程序运行结束，或运行过程中遇到不可修复的错误</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>进程不能从就绪态直接转换为阻塞态</p>\n</li>\n<li><p>因为进入阻塞态是系统自动请求的，必然需要进程在运行时才能发出这种请求</p>\n</li>\n<li><p>进程不能从阻塞态直接转换为运行态</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的组织方式（各个进程PCB的组织方式）</p>\n<ul>\n<li><p>为了对同一个状态下的各个进程进行统一管理，操作系统会对各个进程的PCB组织起来</p>\n</li>\n<li><p>链接方式</p>\n<ul>\n<li><p>执行指针：执行当前处于运行态（执行态）的进程</p>\n<ul>\n<li>单CPU计算机中，同一时刻只会有一个进程处于运行态</li>\n</ul>\n</li>\n<li><p>就绪队列指针：指向当前处于就绪态的进程</p>\n<ul>\n<li>通常会把优先级高的队列放在队头</li>\n</ul>\n</li>\n<li><p>阻塞队列指针：指向当前处于阻塞态的进程</p>\n<ul>\n<li>很多操作系统还会根据阻塞原因不同，再分为多个阻塞队列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>索引方式</p>\n<ul>\n<li><p>执行指针：执行当前处于运行态（执行态）的进程</p>\n</li>\n<li><p>就绪表指针：指向就绪索引表</p>\n<ul>\n<li>就绪索引表的表项指向当前处于就绪态的进程</li>\n</ul>\n</li>\n<li><p>阻塞表指针：指向阻塞索引表</p>\n<ul>\n<li>阻塞索引表的表项指向当前处于阻塞态的进程</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程控制\"><a href=\"#进程控制\" class=\"headerlink\" title=\"进程控制\"></a>进程控制</h2><ul>\n<li><p>进程的创建</p>\n<ul>\n<li><p>分配进程标识号，申请PCB （PCB是有限的）</p>\n</li>\n<li><p>为进程分配资源，为程序和数据以及用户栈分配必要的内存空间</p>\n</li>\n<li><p>初始化PCB，包括初始化标志信息、初始化处理机状态信息、初始化处理机控制信息、设置进程的优先级</p>\n</li>\n<li><p>若进程就结队列可以接纳新进程，进程就进入就绪态</p>\n</li>\n</ul>\n</li>\n<li><p>进程的终止</p>\n<ul>\n<li><p>结束分类</p>\n<ul>\n<li><p>正常结束：进程的任务已经完成并且准备退出运行</p>\n</li>\n<li><p>异常结束：进程正在运行，出现了某些异常事件，导致程序无法继续运行（存储区越界、保护错、非法指令、特权指令错、IO故障等）</p>\n</li>\n<li><p>外界干预：进程应外界请求终止运行</p>\n</li>\n</ul>\n</li>\n<li><p>结束过程</p>\n<ul>\n<li><p>根据被终止进程的标识符，检索PCB ，读取进程状态</p>\n</li>\n<li><p>若进程处于运行态，终止运行，剥夺处理机</p>\n</li>\n<li><p>终止进程之下的子进程</p>\n</li>\n<li><p>该进程拥有的全部资源还给父进程或者操作系统</p>\n</li>\n<li><p>将PCB从队列中删除</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程的阻塞和唤醒</p>\n<ul>\n<li><p>阻塞原语执行过程：阻塞是一种自主行为，自我阻塞</p>\n<ul>\n<li><p>找到要被阻塞进程标识号对应的PCB</p>\n</li>\n<li><p>若该进程处于运行态，保护其现场，将其状态转换为阻塞态，停止运行</p>\n</li>\n<li><p>将PCB插入相应时间的等待队列！</p>\n</li>\n</ul>\n</li>\n<li><p>唤醒原语的执行过程：唤醒是被相互有联系的其他进程进行唤醒</p>\n<ul>\n<li><p>找到等待队列中进程相应的PCB</p>\n</li>\n<li><p>将其从等待队列中移出，置其状态为就绪态</p>\n</li>\n<li><p>将PCB插入就绪队列，等待调度程序调度</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程切换</p>\n<ul>\n<li><p>进程切换是在内核态下完成的</p>\n</li>\n<li><p>过程</p>\n<ul>\n<li><p>保存处理机上下文，包括程序计数器和其他寄存器</p>\n</li>\n<li><p>更新PCB信息</p>\n</li>\n<li><p>把讲程的PCB移入相应的队列，如就绪、在某时间阻塞等队列</p>\n</li>\n<li><p>选择另一个进程执行，更新其PCB</p>\n</li>\n<li><p>更新内存管理的数据结构</p>\n</li>\n<li><p>恢复处理机上下文</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程的组织\"><a href=\"#进程的组织\" class=\"headerlink\" title=\"进程的组织\"></a>进程的组织</h2><ul>\n<li><p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度基本单位，由以下三部分构成</p>\n</li>\n<li><p>进程控制块</p>\n<ul>\n<li><p>进程描述信息</p>\n<ul>\n<li><p>进程标识符：标志进程</p>\n</li>\n<li><p>用户标识符：进程归属的用户，主要为共享和保护服务</p>\n</li>\n</ul>\n</li>\n<li><p>进程控制和管理信息</p>\n<ul>\n<li><p>进程当前状态：描述进程状态信息</p>\n</li>\n<li><p>进程优先级：描述进程枪战处理机优先级</p>\n</li>\n<li><p>代码运行入口地址</p>\n</li>\n<li><p>程序的外存地址</p>\n</li>\n<li><p>进入内存时间</p>\n</li>\n<li><p>处理机占用时间</p>\n</li>\n<li><p>信号量使用</p>\n</li>\n</ul>\n</li>\n<li><p>资源分配清单</p>\n<ul>\n<li><p>用以说明有关内存地址空间或者虚拟地址空间状况，所打开的文件的列表和所使用的的输入&#x2F;输出设备信息 </p>\n</li>\n<li><p>代码段指针、数据段指针、堆栈段指针、文件描述符、键盘、鼠标</p>\n</li>\n</ul>\n</li>\n<li><p>处理机相关信息</p>\n<ul>\n<li><p>处理机中各寄存器的值</p>\n</li>\n<li><p>通用寄存路值、地址寄存器值、控制寄存器值，标志寄存器值，状态字</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>程序段：能被进程调度程序调度到CPU执行的程序代码段</p>\n</li>\n<li><p>数据段：进程对应的程序加工处理的原始数据或者程序执行时产生的中间或者最终结果</p>\n</li>\n<li><p>进程的组织方式</p>\n<ul>\n<li><p>链接方式</p>\n<ul>\n<li><p>按照进程状态将PCB分为多个队列</p>\n</li>\n<li><p>操作系统持有指向各个队列的指针</p>\n</li>\n</ul>\n</li>\n<li><p>索引方式</p>\n<ul>\n<li><p>根据进程状态的不同，建立几张索引表</p>\n</li>\n<li><p>操作系统持有指向各个索引表的指针</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程的通信\"><a href=\"#进程的通信\" class=\"headerlink\" title=\"进程的通信\"></a>进程的通信</h2><ul>\n<li><p>概念：两个进程之间产生数据交互</p>\n</li>\n<li><p>为什么进程通信需要操作系统支持？</p>\n<ul>\n<li><p>进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。</p>\n</li>\n<li><p>为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p>\n</li>\n</ul>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>共享存储：</p>\n<ul>\n<li><p>操作系统负责为通信进程提供可共享使用的存储空间和同步互斥工具</p>\n<ul>\n<li><p>共享空间：通过“增加页表项&#x2F;段表项”即可将同一片共享内存区映射到各个进程的地址空间中</p>\n</li>\n<li><p>为避免出错，各个进程对共享空间的访问应该是互斥的</p>\n<ul>\n<li>各个进程可使用操作系统内核提供的同步互斥工具（如P、V操作）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据交换则由用户自己安排读&#x2F;写指令完成</p>\n<ul>\n<li>多个进程可以同时读，不能同时写</li>\n</ul>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>低级方式：基于数据结构共享</p>\n<ul>\n<li><p>比如共享空间里只能放一个长度为10的数组。</p>\n</li>\n<li><p>这种共享方式速度慢、限制多，是一种低级通信方式</p>\n</li>\n</ul>\n</li>\n<li><p>高级方式：基于存储区共享</p>\n<ul>\n<li><p>操作系统在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。</p>\n</li>\n<li><p>这种共享方式速度很快，是一种高级通信方式。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>消息传递</p>\n<ul>\n<li><p>讲程间的数据交换是以格式化的消息为单位的，进程通过系统提供的发送消息和接收消息的两个原语进行数据交换</p>\n<ul>\n<li><p>格式化消息包括</p>\n<ul>\n<li><p>消息头</p>\n<ul>\n<li><p>发送进程ID</p>\n</li>\n<li><p>接收进程ID</p>\n</li>\n<li><p>消息长度等格式化的信息</p>\n</li>\n</ul>\n</li>\n<li><p>消息体</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>直接通信方式：消息发送进程要指明接收进程的ID</p>\n<ul>\n<li>发送进程直接发送消息给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息</li>\n</ul>\n</li>\n<li><p>间接通信方式：通过信箱中间实体间接地进行通信，又称信箱通信方式</p>\n<ul>\n<li><p>发送进程把消息发送给某个中间实体，接收进程从中间实体中获得消息</p>\n</li>\n<li><p>可以多个进程往同一个信箱send消息，也可以多个进程从同一个信箱中receive消息</p>\n</li>\n<li><p>例如电子邮件系统</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>管道通信</p>\n<ul>\n<li><p>“管道”是一个特殊的共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的内存缓冲区</p>\n</li>\n<li><p>发送进程以字符流形式将大量数据送入写管道，接收讲程从管道中接收数据</p>\n<ul>\n<li><p>当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走</p>\n</li>\n<li><p>当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞</p>\n</li>\n</ul>\n</li>\n<li><p>半双工通信，不可以同时读和写。如果要实现双向同时通信，需要设置两个管道</p>\n</li>\n<li><p>功能：互斥、同步、确定对方存在</p>\n<ul>\n<li><p>互斥：由操作系统实现，不能两个进程同时访问（不能同时读写）</p>\n</li>\n<li><p>同步：写进程写完之后，睡眠等待读进程读走，读进程读完之后，睡眠等待写进程写入，唤醒写进程</p>\n</li>\n<li><p>确定对方存在：只有确定了对方已存在时，才能进行通信</p>\n</li>\n</ul>\n</li>\n<li><p>管道中的数据被读取后会马上被丢弃，就彻底消失了</p>\n<ul>\n<li><p>因此，当多个进程读同一个管道时，可能会错乱</p>\n</li>\n<li><p>两种解决方案：</p>\n<ul>\n<li><p>一个管道允许多个写进程，一个读进程（2014年408真题高教社官方答案）</p>\n</li>\n<li><p>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 的方案）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>写进程往管道写数据，即便管道没被写满，只要管道没空，读进程就可以从管道读数据</p>\n</li>\n<li><p>读进程从管道读数据，即便管道没被读空，只要管道没满，写进程就可以往管道写数据</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线程概念和多线程模型\"><a href=\"#线程概念和多线程模型\" class=\"headerlink\" title=\"线程概念和多线程模型\"></a>线程概念和多线程模型</h2><ul>\n<li><p>线程基本概念</p>\n<ul>\n<li><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位</p>\n</li>\n<li><p>减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</p>\n</li>\n<li><p>引入线程后，进程只作为系统资源的分配单元，线程作为处理机的分配单元</p>\n<ul>\n<li>系统资源（除CPU）是分配给进程的，而不是分配给线程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>为什么引入线程</p>\n<ul>\n<li><p>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</p>\n</li>\n<li><p>传统的进程是程序执行流的最小单位</p>\n</li>\n<li><p>引入线程后，线程成为了程序执行流的最小单位</p>\n</li>\n</ul>\n</li>\n<li><p>线程与进程的比较</p>\n<ul>\n<li><p>资源分配</p>\n<ul>\n<li>进程是资源分配的基本单位</li>\n</ul>\n</li>\n<li><p>调度</p>\n<ul>\n<li><p>传统中进程是资源和独立调度的基本单位</p>\n</li>\n<li><p>引入线程后，进程是独立调度的基本单位，线程是资源分配的基本单位</p>\n<ul>\n<li>不同进程的线程切换会引起进程切换</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>并发性</p>\n<ul>\n<li><p>传统进程机制中，只能进程间并发进行</p>\n</li>\n<li><p>引入线程后，进程可以并发执行，多个线程之间也可以并发执行，提高了系统的吞吐量</p>\n</li>\n</ul>\n</li>\n<li><p>系统开销</p>\n<ul>\n<li>同一进程的线程切换要比进程切换开销小的多（并发所带来的系统开销减小）</li>\n</ul>\n</li>\n<li><p>地址空间和其他资源</p>\n<ul>\n<li>进程的地址空间之间相互独立，统一进程的各线程之间共享进程的资源，某进程的线程对其他进程不可见</li>\n</ul>\n</li>\n<li><p>通信方面</p>\n<ul>\n<li><p>进程间通信需要进程同步和互斥手段的辅助，保证数据的一致性</p>\n</li>\n<li><p>线程间可以直接读&#x2F;写进程程序段来进行通信</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程属性</p>\n<ul>\n<li><p>线程是处理机的独立调度单位</p>\n</li>\n<li><p>多CPU计算机中，各个线程可占用不同的CPU</p>\n</li>\n<li><p>每个线程都有一个线程ID、线程控制块（TCB）</p>\n</li>\n<li><p>线程也有生命周期，有阻塞、就绪、运行等状态</p>\n</li>\n<li><p>不拥有系统资源（按进程分配）</p>\n</li>\n<li><p>同一进程的不同线程共享该进程拥有的全部资源</p>\n</li>\n<li><p>切换同进程内的线程，不会引起进程切换，系统开销很小</p>\n</li>\n<li><p>切换不同进程中的线程，会引起进程切换，系统开销较大</p>\n</li>\n<li><p>不同的线程可以执行相同的程序，同一个服务程序被不同用户调用时，操作系统将其创建为不同线程</p>\n</li>\n<li><p>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线程的实现方式\"><a href=\"#线程的实现方式\" class=\"headerlink\" title=\"线程的实现方式\"></a>线程的实现方式</h2><ul>\n<li><p>用户级线程</p>\n<ul>\n<li><p>背景：早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的</p>\n<ul>\n<li><p>从代码的角度看，线程其实就是一段代码逻辑</p>\n</li>\n<li><p>线程库完成了对线程的管理工作（如调度）</p>\n</li>\n<li><p>很多编程语言提供了强大的线程库，可以实现线程的创建、销毁、调度等功能。</p>\n</li>\n</ul>\n</li>\n<li><p>有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在</p>\n</li>\n<li><p>1、线程的管理工作是由应用程序通过线程库来实现的</p>\n<ul>\n<li>所有的线程管理工作都由应用程序负责（包括线程切换）</li>\n</ul>\n</li>\n<li><p>2、线程切换不需要变态</p>\n<ul>\n<li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预</li>\n</ul>\n</li>\n<li><p>3、操作系统不能意识到线程的存在</p>\n<ul>\n<li><p>在用户看来，是有多个线程，“用户级线程”就是“从用户视角看能看到的线程”</p>\n</li>\n<li><p>在操作系统来看，意识不到线程的存在</p>\n</li>\n</ul>\n</li>\n<li><p>4、优缺点：</p>\n<ul>\n<li><p>优点：开销小，效率高</p>\n<ul>\n<li>用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>\n</ul>\n</li>\n<li><p>缺点：并发度低</p>\n<ul>\n<li><p>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高</p>\n</li>\n<li><p>多个线程不可在多核处理机上并行运行</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内核级线程</p>\n<ul>\n<li><p>线程的管理工作全部由内核完成（由操作系统支持的线程）</p>\n</li>\n<li><p>重点：操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位</p>\n</li>\n<li><p>1、线程的管理工作是由操作系统内核来实现的</p>\n</li>\n<li><p>2、线程切换需要变态</p>\n<ul>\n<li><p>线程的切换是由操作系统来实现的，所以肯定需要变态</p>\n</li>\n<li><p>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</p>\n</li>\n</ul>\n</li>\n<li><p>3、操作系统能意识到线程的存在</p>\n<ul>\n<li><p>操作系统会为每个内核级线程建立相应的TCB（线程控制块），通过TCB对线程进行管理。</p>\n</li>\n<li><p>“内核级线程”就是“从操作系统内核视角看能看到的线程”</p>\n</li>\n</ul>\n</li>\n<li><p>4、优缺点：</p>\n<ul>\n<li><p>优点：并发能力强</p>\n<ul>\n<li><p>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强</p>\n</li>\n<li><p>多线程可在多核处理机上并行执行</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：成本高，开销大</p>\n<ul>\n<li>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多线程模型\"><a href=\"#多线程模型\" class=\"headerlink\" title=\"多线程模型\"></a>多线程模型</h2><ul>\n<li><p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p>\n</li>\n<li><p>一对一（有内核级线程的优缺点）</p>\n<ul>\n<li><p>每个用户级线程映射到一个内核级线程上</p>\n</li>\n<li><p>每个用户进程有与用户级线程同数量的内核级线程</p>\n</li>\n<li><p>优点：并发能力强</p>\n<ul>\n<li><p>当一个线程被阻塞后，别的线程还可以继续执行，并发能力强</p>\n</li>\n<li><p>多线程可在多核处理机上并行执行</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：成本高，开销大</p>\n<ul>\n<li>一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多对一（有用户级线程的优缺点）</p>\n<ul>\n<li><p>经多个用户级线程映射到一个内核级线程，线程管理在用户空间完成，用户级线程对操作系统不可见</p>\n</li>\n<li><p>且一个进程只被分配一个内核级线程</p>\n</li>\n<li><p>优点：开销小，效率高</p>\n<ul>\n<li>用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>\n</ul>\n</li>\n<li><p>缺点：并发度低</p>\n<ul>\n<li><p>一个线程阻塞全部线程都会阻塞</p>\n</li>\n<li><p>多个线程不能并行运行在多处理机上</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多对多</p>\n<ul>\n<li><p>多个线程映射到多个内核线程上</p>\n<ul>\n<li>n用户级线程映射到 m 个内核级线程（n &gt;&#x3D; m），每个用户级线程对应 m 个内核级线程</li>\n</ul>\n</li>\n<li><p>既可以提高并发性，又适当的降低了开销</p>\n<ul>\n<li><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞）</p>\n</li>\n<li><p>克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</p>\n</li>\n</ul>\n</li>\n<li><p>用户级线程和内核级线程区别</p>\n<ul>\n<li><p>内核级线程才是处理机分配的单位</p>\n<ul>\n<li>进程是按内核级线程分配给各个CPU的，不能按用户级线程分配给CPU</li>\n</ul>\n</li>\n<li><p>内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑（用户级线程）都阻塞时，这个进程才会阻塞</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"处理机调度\"><a href=\"#处理机调度\" class=\"headerlink\" title=\"处理机调度\"></a>处理机调度</h1><h2 id=\"调度的概念\"><a href=\"#调度的概念\" class=\"headerlink\" title=\"调度的概念\"></a>调度的概念</h2><ul>\n<li><p>调度的基本概念：合理的对进程进行处理机分配</p>\n<ul>\n<li>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序</li>\n</ul>\n</li>\n<li><p>调度的层次</p>\n<ul>\n<li><p>作业调度（高级调度） ：从辅存（外存）的作业后备队列中选择作业送入内存，并创建进程</p>\n<ul>\n<li><p>每个作业只调入一次，调出一次</p>\n</li>\n<li><p>作业调入时会创立PCB，调出时才撤销PCB</p>\n</li>\n<li><p>产生背景：内存空间有限，有时无法将用户提交的作业全部放入内存，需要选择将哪些作业放入内存</p>\n</li>\n<li><p>简易理解：好几个程序需要启动，到底先启动哪个</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>作业：一个具体的任务</p>\n</li>\n<li><p>用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程调度（低级调度） ：按照某种策略或者方法从就绪队列中选取一个进程，将处理机分配给它 （最基本的调度，频率很高）</p>\n<ul>\n<li><p>最基本的调度：在一般的操作系统中都必须配置进程调度</p>\n</li>\n<li><p>频率很高：一般几十毫秒一次</p>\n</li>\n</ul>\n</li>\n<li><p>中级调度（内存调度） ：按照某种策略决定将哪个处于挂起状态的进程重新调入内存</p>\n<ul>\n<li><p>作用：提高内存利用率和系统吞吐量</p>\n</li>\n<li><p>将暂时不能运行的进程调至外存，使其进入挂起态。将外存上已经具备运行条件的进程调入内存，修改其状态为就绪态</p>\n</li>\n<li><p>产生背景：内存不够时，可将某些进程的数据调出外存；等内存空闲或者进程需要运行时再重新调入内存</p>\n</li>\n<li><p>暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列</p>\n</li>\n<li><p>一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>补充知识：进程的挂起态与七状态模型</p>\n<ul>\n<li><p>挂起状态（挂起态）：暂时调到外存等待的进程状态</p>\n<ul>\n<li><p>分类：</p>\n<ul>\n<li><p>就绪挂起：</p>\n</li>\n<li><p>阻塞挂起：</p>\n</li>\n</ul>\n</li>\n<li><p>注：有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列</p>\n</li>\n</ul>\n</li>\n<li><p>七状态模型<img src=\"https://api2.mubu.com/v3/document_image/fe881be2-87e3-4046-a69b-c05a4e4644e8-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>区分挂起、阻塞</p>\n<ul>\n<li><p>相同点：暂时不能获得CPU的服务</p>\n</li>\n<li><p>不同点：</p>\n<ul>\n<li><p>挂起：将进程映像调到外存</p>\n</li>\n<li><p>阻塞：进程映像还在内存中</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>三级调度的联系、对比</p>\n<ul>\n<li><p>作业调度（高级调度）</p>\n<ul>\n<li><p>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</p>\n</li>\n<li><p>为进程活动做准备</p>\n</li>\n<li><p>调度发生在：外存——&gt;内存（面向作业）</p>\n</li>\n<li><p>发生频率：低</p>\n</li>\n<li><p>对进程状态的影响：无——&gt;创建态——&gt;就绪态</p>\n</li>\n</ul>\n</li>\n<li><p>内存调度（中级调度）</p>\n<ul>\n<li><p>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</p>\n</li>\n<li><p>将挂起进程激活，中级调度处于作业调度和进程调度之间</p>\n</li>\n<li><p>调度发生在：外存——&gt;内存（面向进程）</p>\n</li>\n<li><p>发生频率：中</p>\n</li>\n<li><p>对进程状态的影响：挂起态——&gt;就绪态（阻塞挂起——&gt;阻塞态）</p>\n</li>\n</ul>\n</li>\n<li><p>进程调度（低级调度）：进程调度是最基本的，不可或缺的</p>\n<ul>\n<li><p>按照某种规则，从就绪队列中选择一个进程为其分配处理机</p>\n</li>\n<li><p>使进程正常活动起来</p>\n</li>\n<li><p>调度发生在：内存——&gt;CPU</p>\n</li>\n<li><p>发生频率：高</p>\n</li>\n<li><p>对进程状态的影响：就绪态——&gt;运行态</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程调度的时机\"><a href=\"#进程调度的时机\" class=\"headerlink\" title=\"进程调度的时机\"></a>进程调度的时机</h2><ul>\n<li><p>进程调度（低级调度）：就是按照某种算法从就绪队列中选择一个进程为其分配处理机</p>\n</li>\n<li><p>需要进行进程调度与切换的情况</p>\n<ul>\n<li><p>当前运行的进程主动放弃处理器（发生引起调度条件且当前进程无法继续进行）</p>\n<ul>\n<li><p>进程正常终止</p>\n</li>\n<li><p>运行过程中发生异常而终止</p>\n</li>\n<li><p>进程主动请求阻塞（如 等待I&#x2F;O）</p>\n</li>\n<li><p>注：有的系统中，只允许进程主动放弃处理机</p>\n</li>\n</ul>\n</li>\n<li><p>当前运行的进程被动放弃处理机（中断处理结束或者自陷处理结束后，返回被中断进程的用户态程序执行现场前，置上请求调度标志）</p>\n<ul>\n<li><p>分给进程的时间片用完</p>\n</li>\n<li><p>有更紧急的事需要处理（如 I&#x2F;O中断）</p>\n</li>\n<li><p>有更高优先级的进程进入就绪队列</p>\n</li>\n<li><p>注：有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>什么时候不能进行进程调度</p>\n<ul>\n<li><p>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</p>\n</li>\n<li><p>进程在操作系统内核程序临界区中不能进行进程调度，但是进程在普通临界区中是可以进行调度、切换的</p>\n<ul>\n<li><p>进程在操作系统内核程序临界区中不能进行调度与切换</p>\n<ul>\n<li><p>内核程序临界区：一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）。</p>\n</li>\n<li><p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p>\n</li>\n<li><p>例如：如果还没退出临界区（还没解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度</p>\n</li>\n</ul>\n</li>\n<li><p>进程处于普通临界区时可以进行处理机调度</p>\n<ul>\n<li><p>普通程序临界区：用来访问I&#x2F;O设备的。为避免CPU空闲，允许进程调度和切换</p>\n</li>\n<li><p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换</p>\n</li>\n<li><p>例如：在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲</p>\n</li>\n</ul>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源</p>\n</li>\n<li><p>临界区：访问临界资源的那段代码</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程调度的切换与过程\"><a href=\"#进程调度的切换与过程\" class=\"headerlink\" title=\"进程调度的切换与过程\"></a>进程调度的切换与过程</h2><ul>\n<li><p>狭义的调度与切换的区别</p>\n<ul>\n<li><p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）</p>\n</li>\n<li><p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</p>\n</li>\n<li><p>广义的进程调度包含了选择一个进程和进程切换两个步骤</p>\n</li>\n</ul>\n</li>\n<li><p>进程切换的过程需要做什么</p>\n<ul>\n<li><p>对原来运行进程各种数据的保存</p>\n</li>\n<li><p>对新的进程各种数据的恢复</p>\n<ul>\n<li>如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低</p>\n<ul>\n<li>系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"进程调度方式\"><a href=\"#进程调度方式\" class=\"headerlink\" title=\"进程调度方式\"></a>进程调度方式</h2><ul>\n<li><p>非剥夺调度方式（非抢占式）</p>\n<ul>\n<li><p>如果想将处理机分配给一个更高优先级的进程，必须要等待当前占用处理机的进程释放处理机后才能将处理机分配给更高优先级进程</p>\n</li>\n<li><p>实现简单、开销小、但是无法及时处理紧急任务、适合大多数批处理系统</p>\n</li>\n<li><p>不适用于分时系统，和大多数实时系统</p>\n</li>\n</ul>\n</li>\n<li><p>剥夺调度方式（抢占式）</p>\n<ul>\n<li><p>如果有更高级进程请求处理机，操作系统暂停正在执行的进程（剥夺当前进程的CPU使用权），将处理机分配给更高级进程</p>\n</li>\n<li><p>提高系统吞吐率和响应效率、可以优先处理更紧急的进程、可实现让各进程按时间片轮流执行的功能（通过时钟中断）</p>\n</li>\n<li><p>适合于分时操作系统、实时操作系统</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"调度的基本准则\"><a href=\"#调度的基本准则\" class=\"headerlink\" title=\"调度的基本准则\"></a>调度的基本准则</h2><ul>\n<li><p>CPU利用率：CPU “忙碌”的时间占总时间的比例</p>\n<ul>\n<li>例如：某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。在此过程中，CPU利用率、打印机利用率分别是多少？<img src=\"https://api2.mubu.com/v3/document_image/e096c8f3-4354-4d7c-9376-5a2e1abfb6ca-3224585.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li><p>系统吞吐量：单位时间内CPU完成作业的数量，调度算法和方式会对吞吐量造成较大影响</p>\n<ul>\n<li>例如：某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为？<img src=\"https://api2.mubu.com/v3/document_image/5bd01f08-058f-4eda-9355-21fb94557485-3224585.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li><p>周转时间：作业提交到作业完成的时间</p>\n<ul>\n<li><p>周转时间&#x3D;作业完成时间 - 作业提交时间</p>\n<ul>\n<li><p>包括四个部分：</p>\n<ul>\n<li><p>作业在外存后备队列上等待作业调度（高级调度）的时间</p>\n</li>\n<li><p>进程在就绪队列上等待进程调度（低级调度）的时间</p>\n</li>\n<li><p>进程在CPU上执行的时间</p>\n</li>\n<li><p>进程等待I&#x2F;O操作完成的时间</p>\n</li>\n</ul>\n</li>\n<li><p>后三项在一个作业的整个处理过程中，可能发生多次</p>\n</li>\n<li><p>对于用户来说，更关心自己的单个作业的周转时间</p>\n</li>\n</ul>\n</li>\n<li><p>平均周转时间&#x3D;总周转时间&#x2F;N个作业</p>\n<ul>\n<li><p>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值</p>\n</li>\n<li><p>有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的</p>\n</li>\n</ul>\n</li>\n<li><p>带权周转时间&#x3D;作业周转时间&#x2F;作业实际运行时间</p>\n<ul>\n<li><p>带权周转时间必然 ≥ 1</p>\n</li>\n<li><p>带权周转时间与周转时间都是越小越好</p>\n</li>\n<li><p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高</p>\n</li>\n<li><p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高</p>\n</li>\n</ul>\n</li>\n<li><p>平均带权周转时间&#x3D;总带权周转时间&#x2F;N个作业</p>\n</li>\n</ul>\n</li>\n<li><p>等待时间：作业（进程）等待处理机的时间，衡量一个算法优劣，只需要简单的考察等待时间</p>\n<ul>\n<li><p>等待时间越长，用户满意度越低</p>\n</li>\n<li><p>平均等待时间：各个作业（进程）等待处理时间的平均值</p>\n</li>\n<li><p>进程的等待时间：完成时间 - 到达时间 - 运行时间 - I&#x2F;O操作时间</p>\n<ul>\n<li><p>进程建立后等待被服务的时间之和，在等待I&#x2F;O完成的期间其实进程也是在被服务的，所以不计入等待时间</p>\n</li>\n<li><p>作业调入内存后，建立对应的进程。等待被服务的时候（不包括被CPU服务、被I&#x2F;O设备服务）</p>\n</li>\n</ul>\n</li>\n<li><p>作业的等待时间：</p>\n<ul>\n<li><p>不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</p>\n</li>\n<li><p>进程的等待时间 + 作业在后备队列等待被服务（调度）</p>\n</li>\n</ul>\n</li>\n<li><p>一个作业总共需要被CPU服务多久，被I&#x2F;O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业&#x2F;进程的等待时间</p>\n</li>\n</ul>\n</li>\n<li><p>响应时间：从用户提交请求到系统首次产生响应所用的时间</p>\n</li>\n</ul>\n<h2 id=\"典型调度算法\"><a href=\"#典型调度算法\" class=\"headerlink\" title=\"典型调度算法\"></a>典型调度算法</h2><ul>\n<li><p>先来先服务算法</p>\n<ul>\n<li><p>算法思想：从“公平”的角度考虑</p>\n</li>\n<li><p>算法规则：先来的先分配处理机</p>\n</li>\n<li><p>适用于：</p>\n<ul>\n<li><p>作业调度：哪个作业先到达后备队列</p>\n</li>\n<li><p>进程调度：哪个进程先到达就绪队列</p>\n</li>\n</ul>\n</li>\n<li><p>优点：算法简单、对长作业有利、有利于CPU繁忙型作业（计算型）</p>\n</li>\n<li><p>缺点：效率低、不利于短作业、不利于IO繁忙型作业</p>\n</li>\n<li><p>不会导致饥饿（饥饿：长期得不到服务）</p>\n</li>\n<li><p>非抢占式的算法</p>\n</li>\n<li><p>计算先来先服务调度算法的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间：选择已到达且等待时间最久的<img src=\"https://api2.mubu.com/v3/document_image/3d93d574-32dc-44e4-bb8f-f46413714000-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>短作业优先算法</p>\n<ul>\n<li><p>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均平均带权周转时间</p>\n</li>\n<li><p>算法规则：优先选择预计运行时间最短的进程</p>\n</li>\n<li><p>适用于：</p>\n<ul>\n<li><p>进程调度：短进程优先（SPF）</p>\n</li>\n<li><p>作业调度：短作业优先（SJF）</p>\n</li>\n</ul>\n</li>\n<li><p>优点：平均等待时间、平均周转时间最短</p>\n</li>\n<li><p>缺点：对长作业不利、产生饥饿现象、没有考虑作业的紧追性、用户可能可以缩短作业预估时间，使得无法做到短作业优先</p>\n</li>\n<li><p>会导致饥饿</p>\n<ul>\n<li>如果源源不断地有短作业&#x2F;进程到来，就会导致长进程一直得不到服务，就会饿死</li>\n</ul>\n</li>\n<li><p>SJF和SPF（短进程优先算法）是非抢占式的算法。但是也有抢占式的版本——最短剩余时间优先算法</p>\n</li>\n<li><p>计算短作业&#x2F;进程优点调度算法：选择已到达且运行时间最短的<img src=\"https://api2.mubu.com/v3/document_image/0474597f-0ae3-4591-8d7c-8ed54b6ffbf8-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>最短剩余时间优先算法（抢占式的短作业优先）的计算：</p>\n<ul>\n<li><p>需要调度的时机：</p>\n<ul>\n<li><p>新进程加入就绪队列</p>\n</li>\n<li><p>进程完成时</p>\n</li>\n</ul>\n</li>\n<li><p>如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行的进程重新回到就绪队列<img src=\"https://api2.mubu.com/v3/document_image/f68b662a-487a-4007-bea7-43647fffc23e-3224585.jpg\" alt=\"img\"><img src=\"https://api2.mubu.com/v3/document_image/a3f98eac-b51f-46c3-bb59-7207ef02d442-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>1、如果题目中未特别说明，“短作业&#x2F;进程优先算法”默认是非抢占式的</p>\n</li>\n<li><p>2.1、很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”</p>\n<ul>\n<li><p>严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少</p>\n</li>\n<li><p>应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”；</p>\n</li>\n<li><p>或者说“在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”</p>\n</li>\n<li><p>如果不加上述前提条件，则应该说“抢占式的短作业&#x2F;进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”</p>\n</li>\n</ul>\n</li>\n<li><p>2.2、虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</p>\n</li>\n<li><p>2.3、如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>高响应比调度算法</p>\n<ul>\n<li><p>背景：FCFS对短作业不友好、SJF对长作业不友好，造成饥饿</p>\n</li>\n<li><p>算法思想：要综合考虑作业&#x2F;进程的等待时间和要求服务的时间（考虑等待时间，兼顾运行时间）</p>\n</li>\n<li><p>算法规则：在每次调度时先计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务</p>\n<ul>\n<li>响应比&#x3D;（等待时间+要求服务时间）&#x2F;要求服务时间 &#x3D; 1+等待时间&#x2F;要求服务时间</li>\n</ul>\n</li>\n<li><p>优先</p>\n<ul>\n<li><p>等待时间相同情况下，要求服务时间越短响应比越大，有利于短作业进程（SJF优点）</p>\n</li>\n<li><p>要求服务时间相同，作业响应比由其等待时间决定，等待时间越长响应比越高，实现先来先服务（FCFS优点）</p>\n</li>\n<li><p>对于长作业，作业的响应比可以随等待时间的增加而提高，等待时间足够长时，其响应比可以升到很高，从而避免长作业饥饿</p>\n</li>\n</ul>\n</li>\n<li><p>适用于：</p>\n<ul>\n<li><p>作业调度</p>\n</li>\n<li><p>进程调度</p>\n</li>\n</ul>\n</li>\n<li><p>不会导致饥饿</p>\n</li>\n<li><p>非抢占式的算法</p>\n<ul>\n<li>因此只有当前运行的作业&#x2F;进程主动放弃处理机时，才需要调度，才需要计算响应比</li>\n</ul>\n</li>\n<li><p>高响应比优先算法的计算：</p>\n<ul>\n<li><p>由于是非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常&#x2F;异常完成，或主动阻塞），才需要进行调度</p>\n</li>\n<li><p>调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机<img src=\"https://api2.mubu.com/v3/document_image/8855183e-42c2-4a50-bb42-21d8ca103377-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>总结：先来先服务算法、短作业优先算法、高响应比优先的共同点</p>\n<ul>\n<li><p>主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标</p>\n</li>\n<li><p>不关心“响应时间”，不区分任务的紧急程度，因此对于用户来说交互性很差，不适合用于交互式系统</p>\n</li>\n<li><p>一般适合用于早期的批处理系统</p>\n</li>\n<li><p>FCFS算法常结合其他的算法使用</p>\n</li>\n</ul>\n</li>\n<li><p>时间片轮转算法</p>\n<ul>\n<li><p>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p>\n</li>\n<li><p>算法规则：</p>\n<ul>\n<li><p>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如 100ms）</p>\n</li>\n<li><p>若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队</p>\n</li>\n</ul>\n</li>\n<li><p>时间片的选择</p>\n<ul>\n<li><p>时间片影响因素：系统响应时间、就绪队列中的进程数目和系统的处理能力</p>\n</li>\n<li><p>时间片不能过大：变成先来先服务，并且增大进程响应时间</p>\n<ul>\n<li><p>进程响应时间：用户发出命令到第一次上处理机的时间</p>\n</li>\n<li><p>比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应可能需要等9秒。也就是说，如果用户在自己进程的时间片外通过键盘发出调试命令，可能需要等待9秒才能被系统响应</p>\n</li>\n</ul>\n</li>\n<li><p>时间片不能过短：进程调度、切换是有时间代价的（保存、恢复运行环境），会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少</p>\n<ul>\n<li>一般来说，设计时间片时要让切换进程的开销占比不超过1%</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>适用于：</p>\n<ul>\n<li>进程调度：只有作业放入内存建立了相应的进程后，才能被分配处理机时间片</li>\n</ul>\n</li>\n<li><p>优点：公平、响应快、适用于分时操作系统</p>\n</li>\n<li><p>缺点：有一定开销（高频率的进程切换）、不区分任务的紧急程度</p>\n</li>\n<li><p>不会导致饥饿</p>\n</li>\n<li><p>抢占式：</p>\n<ul>\n<li><p>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此属于抢占式</p>\n</li>\n<li><p>由时钟装置发出时钟中断来通知CPU时间片已到</p>\n</li>\n</ul>\n</li>\n<li><p>时间片轮转的计算：轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）</p>\n<ul>\n<li><p>到达时间：进程加入队列</p>\n</li>\n<li><p>运行时间结束，时间片没有用完：进程主动放弃处理机，下一进程上处理机</p>\n</li>\n<li><p>每经过一个时间片：当前运行的进程进队尾， 队头的进程上处理机</p>\n</li>\n<li><p>时间片大小为2：<img src=\"https://api2.mubu.com/v3/document_image/2f620062-b36c-4a75-a0f8-f59b48ba4f92-3224585.jpg\" alt=\"img\"><img src=\"https://api2.mubu.com/v3/document_image/375674f0-5bae-4318-92f2-fcf1baa5720e-3224585.jpg\" alt=\"img\"><img src=\"https://api2.mubu.com/v3/document_image/b38afb3b-02d8-4c98-a289-f0b17aa1889f-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>时间片大小为5<img src=\"https://api2.mubu.com/v3/document_image/f8b598ba-0465-4e2e-ac7e-bbd127258d4b-3224585.jpg\" alt=\"img\"><img src=\"https://api2.mubu.com/v3/document_image/7191d812-2057-46a5-9912-1de9093b0f47-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优先级调度算法</p>\n<ul>\n<li><p>算法思想：实时操作系统需要根据任务的紧急程度来决定处理顺序</p>\n</li>\n<li><p>算法规则：调度时选择优先级最高的作业&#x2F;进程</p>\n</li>\n<li><p>适用于：</p>\n<ul>\n<li><p>作业调度</p>\n</li>\n<li><p>进程调度</p>\n</li>\n<li><p>I&#x2F;O调度</p>\n</li>\n</ul>\n</li>\n<li><p>优点：用优先级区分紧急程度或重要程度，适用于实时操作系统。可灵活地调整对各种作业&#x2F;进程的偏好程度</p>\n</li>\n<li><p>缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</p>\n</li>\n<li><p>会导致饥饿</p>\n</li>\n<li><p>有抢占式的，也有非抢占式的</p>\n<ul>\n<li><p>非抢占式：只需在进程主动放弃处理机时进行调度。等待当前进程运行完成，然后将处理机分配给更高优先级进程</p>\n</li>\n<li><p>抢占式：需在就绪队列变化时，检查是否会发生抢占。发生抢占时，立即停止当前运行进程，将处理机分配给更高优先级进程</p>\n</li>\n</ul>\n</li>\n<li><p>非抢占的优先级调度的计算：在当前进程主动放弃处理机时发生，选择当前已到达且优先级最高的进程<img src=\"https://api2.mubu.com/v3/document_image/e232ea8e-eb09-4e2a-956d-e246eb2127e9-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>抢占式的优先级调度的计算：当前进程主动放弃处理机、或者当就绪队列发生改变（新进程到达）时发生，选择当前已到达且优先级最高的进程<img src=\"https://api2.mubu.com/v3/document_image/112e705a-7591-46a4-a19c-703b680271bd-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>就绪队列：未必只有一个，可以按照不同优先级来组织。或者把优先级高的进程排在更靠近队头的位置</p>\n</li>\n<li><p>分类：根据优先级是否可以动态改变</p>\n<ul>\n<li><p>静态优先级：进程创建后无法对优先级进行修改</p>\n</li>\n<li><p>动态优先级：可以根据进程运行状态，对进程优先级进行动态调整</p>\n<ul>\n<li><p>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</p>\n</li>\n<li><p>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</p>\n</li>\n<li><p>如果发现一个进程频繁地进行I&#x2F;O操作，则可适当提升其优先级</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优先级设置原则（什么进程优先级应该高）</p>\n<ul>\n<li><p>系统进程&gt;用户进程</p>\n</li>\n<li><p>交互型进程（前台进程）&gt;非交互型进程（后台进程）</p>\n</li>\n<li><p>I&#x2F;O进程（I&#x2F;O繁忙型）&gt;计算型进程（cpu繁忙型）</p>\n<ul>\n<li><p>I&#x2F;O设备和CPU可以并行工作</p>\n</li>\n<li><p>如果优先让I&#x2F;O繁忙型进程优先运行的话，则越有可能让I&#x2F;O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>总结：</p>\n<ul>\n<li><p>FCFS优点是公平</p>\n</li>\n<li><p>SJF 算法的优点是能尽快处理完短作业，平均等待&#x2F;周转时间等参数很优秀</p>\n</li>\n<li><p>时间片轮转调度算法可以让各个进程得到及时的响应</p>\n</li>\n<li><p>优先级调度算法可以灵活地调整各种进程被服务的机会</p>\n</li>\n</ul>\n</li>\n<li><p>多级反馈队列调度算法（融合前面几种算法的优点）</p>\n<ul>\n<li><p>实现思想：对其他调度算法的折中权衡</p>\n</li>\n<li><p>实现规则</p>\n<ul>\n<li><p>设置多个就绪队列，为每个队列设置不同的优先级，优先级依次递减</p>\n</li>\n<li><p>每个队列中的时间片各不相同，时间片依次递增</p>\n</li>\n<li><p>每个队列按照先来先服务原则进行进程排队，若规定时间片内没有完成，就将进程放入下一级队列 </p>\n</li>\n<li><p>只有到高级队列为空的时候，低等级队列才能开始调度</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>对各类型进程相对公平（FCFS的优点）</p>\n</li>\n<li><p>每个新到达的进程都可以很快就得到响应（RR时间片轮转的优点）</p>\n</li>\n<li><p>短进程只用较少的时间就可完成（SPF的优点）</p>\n</li>\n<li><p>不必实现估计进程的运行时间（避免用户作假）</p>\n</li>\n<li><p>可灵活地调整对各类进程的偏好程度</p>\n<ul>\n<li><p>比如CPU密集型进程、I&#x2F;O密集型进程</p>\n</li>\n<li><p>可以将因I&#x2F;O而阻塞的进程重新放回原队列，这样I&#x2F;O型进程就可以保持较高优先级</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>应用于：</p>\n<ul>\n<li><p>终端型作业用户：短作业优先</p>\n</li>\n<li><p>短批处理作业用户：周转时间较短</p>\n</li>\n<li><p>长批处理作业用户：讲过前面几个队列得到部分执行，不会长期得不到处理</p>\n</li>\n</ul>\n</li>\n<li><p>会导致饥饿</p>\n</li>\n<li><p>抢占式</p>\n<ul>\n<li>在 k 级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回 k 级队列队尾</li>\n</ul>\n</li>\n<li><p>多级反馈队列的计算：<img src=\"https://api2.mubu.com/v3/document_image/ae02f86c-dd89-4eec-ab83-e84c750b09d2-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>总结：时间片轮转、优先级调度、多级反馈队列</p>\n<ul>\n<li>适用于交互式系统：更注重系统的响应时间、公平性、平衡性</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h1><h2 id=\"进程同步、进程互斥\"><a href=\"#进程同步、进程互斥\" class=\"headerlink\" title=\"进程同步、进程互斥\"></a>进程同步、进程互斥</h2><ul>\n<li><p>进程同步</p>\n<ul>\n<li><p>并发性带来了异步性，有时需要通过进程同步解决这种异步问题</p>\n<ul>\n<li>异步性：各并发执行的进程以各自独立的、不可预知的速度向前推进</li>\n</ul>\n</li>\n<li><p>进程同步：直接制约关系，为了完成某种过任务而建立的多个进程，进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序</p>\n</li>\n</ul>\n</li>\n<li><p>进程互斥</p>\n<ul>\n<li><p>背景：</p>\n<ul>\n<li><p>进程的“并发”带来了“共享”</p>\n</li>\n<li><p>各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I&#x2F;O设备）</p>\n</li>\n<li><p>两种资源共享方式</p>\n<ul>\n<li><p>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源</p>\n</li>\n<li><p>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程“同时”对它们进行访问</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>对临界资源的访问，需要互斥的进行。即同一时间段内只能允许一个进程访问该资源</p>\n<ul>\n<li><p>临界资源：一次只允许一个进程使用的资源（打印机等物理设备，特殊变量，数据）</p>\n</li>\n<li><p>进程互斥（间接制约关系）：当一个进程访问某临界资源时，另一个想要访问该临界资源的进程（不能访问）必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源</p>\n</li>\n</ul>\n</li>\n<li><p>临界资源的访问过程</p>\n<ul>\n<li><p>进入区：检查进程是否可以进入临界区</p>\n<ul>\n<li>若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区</li>\n</ul>\n</li>\n<li><p>临界区：访问临界资源的代码</p>\n</li>\n<li><p>退出区：将正在访问临界区的标志清除</p>\n<ul>\n<li>可理解为解锁</li>\n</ul>\n</li>\n<li><p>剩余区：代码中的其余部分</p>\n</li>\n</ul>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><p>临界区是进程中访问临界资源的代码段</p>\n</li>\n<li><p>进入区和退出区是实现互斥的代码段</p>\n</li>\n</ul>\n</li>\n<li><p>需要遵循的原则（为实现对临界资源的互斥访问，同时保证系统整体性能）</p>\n<ul>\n<li><p>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区（保证系统性能）</p>\n</li>\n<li><p>忙则等待：已有进程进入临界区后，其他试图进入临界区的进程必须等待（保证互斥访问）</p>\n</li>\n<li><p>有限等待：对于请求访问临界区的进程，在有限时间内进入临界区（保证不饥饿）</p>\n</li>\n<li><p>让权等待：进程不能进入临界区的时候，应当立即释放处理机（防止进程忙等待）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"实现临界区互斥的基本方法\"><a href=\"#实现临界区互斥的基本方法\" class=\"headerlink\" title=\"实现临界区互斥的基本方法\"></a>实现临界区互斥的基本方法</h2><ul>\n<li><p>软件实现方法</p>\n<ul>\n<li><p>单标志法</p>\n<ul>\n<li><p>算法思想：</p>\n<ul>\n<li><p>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程</p>\n</li>\n<li><p>也就是说每个进程进入临界区的权限只能被另一个进程赋予</p>\n</li>\n</ul>\n</li>\n<li><p>两个程序进程交替进入临界区</p>\n<ul>\n<li><p>turn 的初值为 0，即刚开始只允许 0 号进程进入临界区</p>\n</li>\n<li><p>若 P1 先上处理机运行，则会一直卡在 ⑤</p>\n</li>\n<li><p>直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行</p>\n</li>\n<li><p>代码 ① 不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即使切换回 P1，P1依然会卡在 ⑤</p>\n</li>\n<li><p>只有 P0 在退出区将 turn 改为 1（表达谦让） 后，P1才能进入临界区</p>\n</li>\n</ul>\n</li>\n<li><p>特点：只能轮流访问，如果允许P0进入临界区，而P0不访问临界区，虽然此时临界区空闲，也不允许P1访问</p>\n</li>\n<li><p>优点：实现简单</p>\n</li>\n<li><p>缺点：可能会违背空闲让进，造成资源无法充分利用</p>\n</li>\n</ul>\n</li>\n<li><p>双标志法先检查</p>\n<ul>\n<li><p>算法思想：</p>\n<ul>\n<li><p>设置一个布尔型数组 flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] &#x3D; ture”意味着 0 号进程 P0 现在想要进入临界区</p>\n</li>\n<li><p>每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区</p>\n</li>\n</ul>\n</li>\n<li><p>每个进程访问临界区资源前，先检查临界资源是否被访问，如果空闲才能进入</p>\n<ul>\n<li>若按照 ①⑤②⑥③⑦….的顺序执行，P0 和 P1 将会同时访问临界区（P0上锁前，P1检查）</li>\n</ul>\n</li>\n<li><p>优点：不用交替进入可以连续使用</p>\n</li>\n<li><p>缺点：两个进程可能同时进入临界区，违背忙则等待（导致同时访问）</p>\n<ul>\n<li>原因：进入区的“检查”和“上锁” 两个处理不是一气呵成的，“检查”后并且“上锁”前可能发生进程切换</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>双标志法后检查</p>\n<ul>\n<li><p>算法思想：</p>\n<ul>\n<li><p>双标志先检查法的问题：先“检查”后“上锁”，但是这两个操作又无法一气呵成</p>\n</li>\n<li><p>先标志后检查法：先“上锁”后“检查”</p>\n</li>\n</ul>\n</li>\n<li><p>先设置自己标志，表明自己想要进入，检查对方标志，如果对方也要进入，那么就等待否则就进入</p>\n<ul>\n<li>若按照 ①⑤②⑥….的顺序执行，P0 和 P1 将都无法进入临界区（P0上锁后但检查前，P1上锁）</li>\n</ul>\n</li>\n<li><p>优点：不会导致两个进程都进入临界区</p>\n</li>\n<li><p>缺点：双方可能争抢完之后互相谦让，违背了“空闲让进”（导致无进程访问）和“有限等待”（导致饥饿现象）</p>\n<ul>\n<li>原因：进入区的“上锁” 和“检查”两个处理不是一气呵成的，“上锁”后并且“检查”前可能发生进程切换</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>皮特森算法（Peterson）</p>\n<ul>\n<li><p>算法思想：</p>\n<ul>\n<li><p>结合双标志法、单标志法的思想</p>\n</li>\n<li><p>如果双方都争着想进入临界区，那可以让进程尝试谦让</p>\n</li>\n</ul>\n</li>\n<li><p>防止两个进程无限期等待，在双标志算法的基础上增加一个标志位，从而防止饥饿</p>\n<ul>\n<li><p>在进入区：</p>\n<ul>\n<li><p>\\1. 主动争取</p>\n</li>\n<li><p>\\2. 主动谦让</p>\n</li>\n<li><p>\\3. 检查对方是否也想使用，且最后一次是不是自己表达谦让</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点：解决了空闲让进、忙则等待、有限等待（饥饿现象）</p>\n</li>\n<li><p>缺点：未遵循让权等待（导致进程忙等），算法复杂</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>硬件实现方法</p>\n<ul>\n<li><p>中断屏蔽法</p>\n<ul>\n<li><p>对中断进行屏蔽</p>\n<ul>\n<li><p>与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断</p>\n</li>\n<li><p>也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况</p>\n</li>\n</ul>\n</li>\n<li><p>优点：简单、高效</p>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>不适用于多处理机（单个处理机不会发生进程切换，但有可能多个处理机同时访问临界资源）</p>\n</li>\n<li><p>只适用于操作系统内核进程，不适用于用户进程（因为开&#x2F;关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）</p>\n</li>\n<li><p>限制了处理机交替执行程序的能力（降低了并发性），执行效率降低</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>硬件指令法</p>\n<ul>\n<li><p>TestAndSet（TS指令&#x2F;TSL指令）</p>\n<ul>\n<li><p>硬件实现，执行的过程不允许被中断</p>\n<ul>\n<li><p>先记录下此时临界区是否已经被上锁（记录在 old 变量上）</p>\n</li>\n<li><p>再将上锁标记 lock 设置为 true</p>\n</li>\n<li><p>最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区</p>\n</li>\n<li><p>代码：</p>\n<ul>\n<li><p>若刚开始 lock 是 false，则 TSL 返回的 old 值为 false。此时while 循环条件不满足，直接跳过循环，进入临界区</p>\n</li>\n<li><p>若刚开始 lock 是 true，则执行 TLS 后 old 返回的值为 true。此时while 循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Swap指令（Exchange 指令&#x2F;XCHG指令）</p>\n<ul>\n<li><p>硬件实现</p>\n<ul>\n<li><p>先将最初临界区的状态设置为已经被上锁</p>\n</li>\n<li><p>再通过不断检查是否已经被上锁，将当前上锁标记（lock）赋值给是否已经被上锁（old）</p>\n</li>\n<li><p>最后只有当访问临界区的进程在退出区“解锁”后，上锁标记（lock&#x3D;0），此时将lock赋值给old，则可跳出循环，进入临界区</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>TSL 指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作</p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>适用于任意数目的进程</p>\n</li>\n<li><p>适用于多处理机环境（只要不是中断屏蔽，就适用于多处理机）</p>\n</li>\n<li><p>简单、容易验证正确性</p>\n<ul>\n<li>无需像软件实现方法那样严格检查是否会有逻辑漏洞</li>\n</ul>\n</li>\n<li><p>支持进程内有多个临界区，每个临界区均设立一个布尔变量</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>不满足“让权等待”原则，从而导致“忙等”</p>\n<ul>\n<li>暂时无法进入临界区的进程会占用CPU并循环执行TSL&#x2F;Swap指令</li>\n</ul>\n</li>\n<li><p>不满足“有限等待”原则，可能会导致饥饿现象</p>\n<ul>\n<li>从等待进程中随机选择一个进入临界区，有的进程可能一直选不上</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h2><ul>\n<li><p>背景：</p>\n<ul>\n<li><p>进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法）</p>\n</li>\n<li><p>进程互斥的三种硬件实现方式（中断屏蔽方法、TS&#x2F;TSL指令、Swap&#x2F;XCHG指令）</p>\n</li>\n<li><p>1.在双标志先检查法中，进入区的“检查”、“上锁” 操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题</p>\n</li>\n<li><p>2.所有的解决方案都无法实现“让权等待”</p>\n</li>\n</ul>\n</li>\n<li><p>概念：</p>\n<ul>\n<li><p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步</p>\n</li>\n<li><p>信号量：就是一个变量 ，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量</p>\n</li>\n<li><p>原语：</p>\n<ul>\n<li><p>一种特殊的程序段，其执行只能一气呵成，不可被中断</p>\n</li>\n<li><p>原语是由关中断&#x2F;开中断指令实现的</p>\n</li>\n<li><p>软件解决方案的主要缺点是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题</p>\n</li>\n</ul>\n</li>\n<li><p>一对原语：wait(S) 原语和 signal(S) 原语</p>\n<ul>\n<li><p>原语可以理解为我们自己写的函数，函数名分别为 wait和 signal</p>\n</li>\n<li><p>括号里的信号量 S 其实就是函数调用时传入的一个参数</p>\n</li>\n<li><p>wait、signal 原语常简称为 P、V操作。因此，wait(S)、signal(S) 两个操作可以分别写为 P(S)、V(S)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>整型信号量</p>\n<ul>\n<li><p>wait：资源-1</p>\n<ul>\n<li>signal&#x3D;资源+1</li>\n</ul>\n</li>\n<li><p>用一个整型变量作为信号量，数值表示某种资源数</p>\n<ul>\n<li><p>整型信号量与普通整型变量的区别：对信号量只能执行初始化、P、V三种操作</p>\n</li>\n<li><p>“检查”和“上锁”一气呵成，避免了并发、异步导致的问题</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：没有遵循让权等待机制，会导致进程处于“忙等”状态</p>\n</li>\n</ul>\n</li>\n<li><p>记录型信号量</p>\n<ul>\n<li><p>记录型信号量不存在“忙等”现象，除了需要一个用于代表资源树木的整型变量value外，在增加一个进程链表L，用于链接所有等待该资源的进程</p>\n<ul>\n<li><p>如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量 S 的等待队列（即阻塞队列）中</p>\n</li>\n<li><p>释放资源后，若还有别的进程在等待这种资源，则使用wakeup 原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态</p>\n</li>\n<li><p>S.value表示某种资源数，S.L指向等待该资源的队列</p>\n<ul>\n<li><p>S.value+1后&lt;&#x3D;0,说明有进程在等待该资源</p>\n<ul>\n<li><p>S.value&#x3D;0, 资源恰好分配完</p>\n</li>\n<li><p>S.value&#x3D;-1, 有1个进程在等待</p>\n</li>\n<li><p>S.value&#x3D;-2, 有2个进程在等待</p>\n</li>\n</ul>\n</li>\n<li><p>S.value+1后&gt;0,说明已没有进程在等待该资源</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在记录型信号量中P、S原语实现系统资源的申请和释放</p>\n<ul>\n<li><p>P操作中，一定是先S.value–，之后可能需要执行block原语</p>\n<ul>\n<li><p>对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.value–，表示资源数减1</p>\n</li>\n<li><p>当S.value &lt; 0 时表示该类资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（当前运行的进程从运行态——&gt;阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中</p>\n</li>\n<li><p>该机制遵循了“让权等待”原则，不会出现“忙等”现象</p>\n</li>\n</ul>\n</li>\n<li><p>V操作中，一定是先S.value++，之后可能需要执行wakeup原语</p>\n<ul>\n<li><p>对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数加1</p>\n</li>\n<li><p>若加1后仍是 S.value &lt;&#x3D; 0，表示依然有进程在等待该类资源，因此应调用 wakeup 原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态——&gt;就绪态）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注意：要能够自己推断在什么条件下需要执行block或wakeup</p>\n</li>\n</ul>\n</li>\n<li><p>用记录型信号量实现进程互斥、进程同步</p>\n<ul>\n<li><p>信号量机制：</p>\n<ul>\n<li><p>一个信号量对应一种资源</p>\n</li>\n<li><p>信号量的值 &#x3D; 这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源）</p>\n<ul>\n<li>多个资源的问题，有多少资源就把信号量初值设为多少</li>\n</ul>\n</li>\n<li><p>P( S )：申请一个资源S，如果资源不够就阻塞等待</p>\n</li>\n<li><p>V( S )：释放一个资源S，如果有进程在等待该资源，则唤醒一个进程</p>\n</li>\n</ul>\n</li>\n<li><p>利用信号量实现互斥</p>\n<ul>\n<li><p>通过设置S的值，初值为1，可以实现进程对临界资源的互斥访问<img src=\"https://api2.mubu.com/v3/document_image/bd3fe44e-37f4-4436-975a-c5b0ca74c61e-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>实现过程：</p>\n<ul>\n<li><p>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</p>\n</li>\n<li><p>设置互斥信号量 mutex，初值为 1</p>\n</li>\n<li><p>在进入区 P(mutex)——申请资源</p>\n</li>\n<li><p>在退出区 V(mutex)——释放资源</p>\n</li>\n</ul>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><p>对不同的临界资源需要设置不同的互斥信号量</p>\n</li>\n<li><p>P、V操作必须成对出现</p>\n<ul>\n<li><p>缺少P(mutex) 就不能保证临界资源的互斥访问</p>\n</li>\n<li><p>缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>利用信号量实现同步</p>\n<ul>\n<li><p>进程同步：让本来异步并发的进程互相配合，有序推进</p>\n<ul>\n<li><p>P1、P2 并发执行，由于存在异步性，因此二者交替推进的次序是不确定的</p>\n</li>\n<li><p>若 P2 的“代码4”要基于 P1 的“代码1”和“代码2”的运行结果才能执行，就必须保证“代码4”一定是在“代码2”之后才会执行</p>\n</li>\n</ul>\n</li>\n<li><p>设S为进程P1和P2同步的公共信号量，初值为0 ，通过设置S的值可以使得P1与P2按照一定顺序执行<img src=\"https://api2.mubu.com/v3/document_image/d8b70337-ac00-450a-8c01-1290648106f4-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>实现过程：</p>\n<ul>\n<li><p>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</p>\n</li>\n<li><p>设置同步信号量 S, 初始为 0</p>\n<ul>\n<li><p>信号量S代表“某种资源”，刚开始是没有这种资源的</p>\n</li>\n<li><p>P2需要使用这种资源，而又只能由P1产生这种资源</p>\n</li>\n</ul>\n</li>\n<li><p>在进程1中，在“前操作”之后执行 V(S)</p>\n</li>\n<li><p>在进程2中，在“后操作”之前执行 P(S)</p>\n</li>\n<li><p>注：技巧口诀：前V后P</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>利用信号量实现前驱关系</p>\n<ul>\n<li><p>通过设置不同的进程运行结束后，产生不同的信号量，从而可以使得目标进程运行，从而实现前驱关系</p>\n</li>\n<li><p>进程 P1 中有句代码 S1，P2 中有句代码 S2 ，P3中有句代码S3 …… P6 中有句代码S6<img src=\"https://api2.mubu.com/v3/document_image/86f6184f-ee6b-44f3-8756-400b40ec3478-3224585.jpg\" alt=\"img\"><img src=\"https://api2.mubu.com/v3/document_image/1272c05b-8c6d-4f3a-8bf7-5f0e64944f78-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>实现过程：</p>\n<ul>\n<li><p>要为每一对前驱关系各设置一个同步信号量</p>\n</li>\n<li><p>在进程1中，在“前操作”之后对相应的同步信号量执行 V 操作</p>\n</li>\n<li><p>在进程2中，在“后操作”之前对相应的同步信号量执行 P 操作</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"经典同步问题\"><a href=\"#经典同步问题\" class=\"headerlink\" title=\"经典同步问题\"></a>经典同步问题</h2><ul>\n<li><p>生产者-消费者问题</p>\n<ul>\n<li><p>问题描述：</p>\n<ul>\n<li><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）</p>\n</li>\n<li><p>生产者、消费者共享一个初始为空、大小为n的缓冲区</p>\n</li>\n</ul>\n</li>\n<li><p>同步互斥关系</p>\n<ul>\n<li><p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待：缓冲区没满——&gt;生产者生产</p>\n</li>\n<li><p>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待：缓冲区没空——&gt;消费者消费</p>\n</li>\n<li><p>缓冲区是临界资源，各进程必须互斥地访问：互斥关系</p>\n</li>\n</ul>\n</li>\n<li><p>PV操作题目分析步骤：</p>\n<ul>\n<li><p>1、关系分析：找出题目中描述的各个进程，分析它们之间的同步、互斥关系<img src=\"https://api2.mubu.com/v3/document_image/e3cfdfd5-4f0d-45d6-b210-dad47ad98ee5-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>2、整理思路：根据各进程的操作流程确定P、V操作的大致顺序</p>\n</li>\n<li><p>3、设置信号量：并根据题目条件确定信号量初值（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现：</p>\n<ul>\n<li><p>生产者：生产一个产品——&gt;将产品放入缓冲区</p>\n<ul>\n<li><p>涉及到缓冲区（临界资源），对缓冲区需要互斥访问——P、V操作之间</p>\n</li>\n<li><p>将产品放入缓冲区之前——P操作，增加一个空缓冲区</p>\n</li>\n<li><p>将产品放入缓冲区之后——V操作，减少一个非空缓冲区</p>\n</li>\n</ul>\n</li>\n<li><p>消费者：将产品取出缓冲区——&gt;消耗一个产品</p>\n<ul>\n<li><p>涉及到缓冲区（临界资源），对缓冲区需要互斥访问——P、V操作之间</p>\n</li>\n<li><p>将产品从缓冲区取出之前——P操作，减少一个非空闲缓冲区</p>\n</li>\n<li><p>将产品从缓冲区取出之后——V操作，增加一个空闲缓冲区</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>思考：改变P、V操作的顺序</p>\n<ul>\n<li><p>实现互斥的P操作一定要在实现同步的P操作之后</p>\n<ul>\n<li><p>若此时缓冲区内已经放满产品，则 empty&#x3D;0，full&#x3D;n。按①②③ 的顺序执行会发生死锁</p>\n<ul>\n<li><p>则生产者进程执行①， 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞</p>\n</li>\n<li><p>由于生产者阻塞，因此只能切换回消费者进程</p>\n</li>\n<li><p>消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞</p>\n</li>\n<li><p>造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”</p>\n</li>\n</ul>\n</li>\n<li><p>若缓冲区中没有产品，即full&#x3D;0，empty&#x3D;n。按③④① 的顺序执行也会发生死锁</p>\n<ul>\n<li><p>1、B申请访问临界资源</p>\n</li>\n<li><p>2、B申请非空闲缓冲区，发生阻塞</p>\n</li>\n<li><p>3、A申请访问临界资源，发生阻塞</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两个V操作顺序可以交换</p>\n<ul>\n<li>V操作不会导致进程阻塞——只会释放信号量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>难点分析：</p>\n<ul>\n<li><p>两对同步和一对异步操作</p>\n<ul>\n<li><p>两进程中“前V后P”</p>\n<ul>\n<li><p>生产者每次要消耗（P）一个空闲缓冲区，并产生（V）一个非空闲缓冲区</p>\n</li>\n<li><p>消费者每次要消耗（P）一个非空闲缓冲区，并产生（V）一个空闲缓冲区</p>\n</li>\n</ul>\n</li>\n<li><p>一个进程中P、V包夹临界区</p>\n<ul>\n<li>往缓冲区放入&#x2F;取走产品需要互斥</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>设置信号量</p>\n<ul>\n<li><p>设置初值为1的互斥信号量</p>\n</li>\n<li><p>设置初值为0的同步信号量（非空闲缓冲区）</p>\n</li>\n<li><p>设置一个信号量，初始值即为资源的数量的同步信号量（空闲缓冲区）</p>\n</li>\n</ul>\n</li>\n<li><p>P、V操作的先后顺序（死锁问题）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多生产者-多消费者</p>\n<ul>\n<li><p>问题描述：</p>\n<ul>\n<li><p>桌子上有一只盘子，每次只能向其中放入一个水果</p>\n</li>\n<li><p>爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果</p>\n</li>\n<li><p>只有盘子空时，爸爸或妈妈才可向盘子中放一个水果</p>\n</li>\n<li><p>仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果</p>\n</li>\n</ul>\n</li>\n<li><p>同步互斥关系</p>\n<ul>\n<li><p>对缓冲区（盘子）的访问要互斥地进行</p>\n</li>\n<li><p>盘子中是苹果，女儿取苹果</p>\n</li>\n<li><p>盘子中是橘子，儿子取橘子</p>\n</li>\n<li><p>盘子为空时，父亲放入苹果</p>\n</li>\n<li><p>盘子为空时，母亲放入橘子</p>\n</li>\n</ul>\n</li>\n<li><p>PV操作题目分析步骤：</p>\n<ul>\n<li><p>1、关系分析：找出题目中描述的各个进程，分析它们之间的同步、互斥关系</p>\n</li>\n<li><p>2、整理思路：根据各进程的操作流程确定P、V操作的大致顺序</p>\n</li>\n<li><p>3、设置信号量：设置需要的信号量，并根据题目条件确定信号量初值（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现：</p>\n<ul>\n<li><p>互斥信号量的定义：<img src=\"https://api2.mubu.com/v3/document_image/b06ec065-9c2f-40c3-840c-6a8f33a17da7-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>4个进程实现：<img src=\"https://api2.mubu.com/v3/document_image/a7564596-ddad-42a6-9272-c691ffec8d7c-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>父亲：准备一个苹果——&gt;将苹果放入盘子里</p>\n<ul>\n<li><p>对临界资源的访问需要互斥进行，所以在临界区前后分别P、V</p>\n</li>\n<li><p>将苹果放入缓冲区之前——P操作，盘子中还可以放的数目-1</p>\n</li>\n<li><p>将苹果放入缓冲区之后——V操作，盘子中的苹果数+1</p>\n</li>\n</ul>\n</li>\n<li><p>母亲：准备一个橘子——&gt;将橘子放入盘子里</p>\n<ul>\n<li><p>对临界资源的访问需要互斥进行，所以在临界区前后分别P、V</p>\n</li>\n<li><p>将橘子放入缓冲区之前——P操作，盘子中还可以放的数目-1</p>\n</li>\n<li><p>将橘子放入缓冲区之后——V操作，盘子中的橘子数+1</p>\n</li>\n</ul>\n</li>\n<li><p>女儿：从盘子中取出苹果——&gt;吃掉苹果</p>\n<ul>\n<li><p>对临界资源的访问需要互斥进行，所以在临界区前后分别P、V</p>\n</li>\n<li><p>从缓冲区中取出苹果之前——P操作，盘子中的苹果数-1</p>\n</li>\n<li><p>从缓冲区中取出苹果之后——V操作，盘子中还可以放的数目+1</p>\n</li>\n</ul>\n</li>\n<li><p>儿子：从盘子中取出橘子——&gt;吃掉橘子</p>\n<ul>\n<li><p>对临界资源的访问需要互斥进行，所以在临界区前后分别P、V</p>\n</li>\n<li><p>从缓冲区中取出苹果之前——P操作，盘子中的苹果数-1</p>\n</li>\n<li><p>从缓冲区中取出苹果之后——V操作，盘子中还可以放的数目+1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>可以不设置互斥变量mutex（具体问题具体分析）</p>\n<ul>\n<li><p>不会发生多个进程同时访问盘子的现象</p>\n</li>\n<li><p>原因：</p>\n<ul>\n<li><p>本题中的缓冲区大小为在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1</p>\n</li>\n<li><p>因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区</p>\n</li>\n</ul>\n</li>\n<li><p>通俗解释：盘子里只存在的三种情况</p>\n<ul>\n<li><p>一个苹果：apple&#x3D;1，orange&#x3D;0，plate&#x3D;0</p>\n</li>\n<li><p>一个橘子：apple&#x3D;0，orange&#x3D;1，plate&#x3D;0</p>\n</li>\n<li><p>没有水果：apple&#x3D;0，orange&#x3D;0，plate&#x3D;1</p>\n</li>\n</ul>\n</li>\n<li><p>如果缓冲区容量为2，则需要设置互斥变量mutex</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>吸烟者问题</p>\n<ul>\n<li><p>问题描述：</p>\n<ul>\n<li><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。</p>\n</li>\n<li><p>供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p>\n</li>\n</ul>\n</li>\n<li><p>同步互斥关系</p>\n<ul>\n<li><p>桌子可以抽象为容量为1的缓冲区，要互斥访问</p>\n</li>\n<li><p>桌上有组合一——&gt;第一个抽烟者取走东西</p>\n</li>\n<li><p>桌上有组合二——&gt;第二个抽烟者取走东西</p>\n</li>\n<li><p>桌上有组合三——&gt;第三个抽烟者取走东西</p>\n</li>\n<li><p>发出完成信号——&gt;供应者将下一个组合放到桌上</p>\n</li>\n</ul>\n</li>\n<li><p>PV操作题目分析步骤：</p>\n<ul>\n<li><p>1、关系分析：找出题目中描述的各个进程，分析它们之间的同步、互斥关系</p>\n</li>\n<li><p>2、整理思路：根据各进程的操作流程确定P、V操作的大致顺序</p>\n</li>\n<li><p>3、设置信号量：设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现：</p>\n<ul>\n<li><p>互斥信号量的定义：<img src=\"https://api2.mubu.com/v3/document_image/e3763230-7d5a-4848-8701-250de5cef7b6-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>4个进程实现：<img src=\"https://api2.mubu.com/v3/document_image/c9c0f4b0-6554-42f1-aca9-dd899db5572e-3224585.jpg\" alt=\"img\"><img src=\"https://api2.mubu.com/v3/document_image/0f7d6a63-489a-4424-af7b-e83215ec5018-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>提供者：将组合放到桌上</p>\n<ul>\n<li><p>if</p>\n<ul>\n<li><p>将组合一放到桌上之后——V操作，桌子上组合一的数量+1</p>\n</li>\n<li><p>将组合二放到桌上之后——V操作，桌子上组合一的数量+1</p>\n</li>\n<li><p>将组合三放到桌上之后——V操作，桌子上组合一的数量+1</p>\n</li>\n</ul>\n</li>\n<li><p>将组合从桌上拿走之后——P操作，抽烟完成-1</p>\n</li>\n</ul>\n</li>\n<li><p>吸烟者1：从桌上拿走组合一，卷烟，抽掉</p>\n<ul>\n<li><p>将组合一从桌上拿走之前——P操作，桌子上组合一的数量-1</p>\n</li>\n<li><p>将组合一从桌上拿走之后——V操作，抽烟完成+1</p>\n</li>\n</ul>\n</li>\n<li><p>吸烟者2：从桌上拿走组合二，卷烟，抽掉</p>\n<ul>\n<li><p>将组合一从桌上拿走之前——P操作，桌子上组合一的数量-1</p>\n</li>\n<li><p>将组合一从桌上拿走之后——V操作，抽烟完成+1</p>\n</li>\n</ul>\n</li>\n<li><p>吸烟者3：从桌上拿走组合三，卷烟，抽掉</p>\n<ul>\n<li><p>将组合一从桌上拿走之前——P操作，桌子上组合一的数量-1</p>\n</li>\n<li><p>将组合一从桌上拿走之后——V操作，抽烟完成+1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拓展</p>\n<ul>\n<li>每次随机地让一个吸烟者吸烟：rand()%3+1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>读者-写者问题</p>\n<ul>\n<li><p>问题描述：</p>\n<ul>\n<li><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误</p>\n</li>\n<li><p>因此要求：</p>\n<ul>\n<li><p>①允许多个读者可以同时对文件执行读操作</p>\n</li>\n<li><p>②只允许一个写者往文件中写信息</p>\n</li>\n<li><p>③任一写者在完成写操作之前不允许其他读者或写者工作</p>\n</li>\n<li><p>④写者执行写操作前，应让已有的读者和写者全部退出</p>\n</li>\n</ul>\n</li>\n<li><p>原因：</p>\n<ul>\n<li><p>两个写进程同时共享数据，可能导致数据错误覆盖的问题</p>\n</li>\n<li><p>与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据</p>\n</li>\n<li><p>读进程与写进程同时共享数据，可能导致读出的数据不一致的问题</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>同步互斥关系（两类进程：写进程、读进程）</p>\n<ul>\n<li><p>互斥关系</p>\n<ul>\n<li><p>写进程—写进程</p>\n</li>\n<li><p>写进程—读进程</p>\n</li>\n</ul>\n</li>\n<li><p>同步关系</p>\n<ul>\n<li>读进程—读进程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>PV操作题目分析步骤：</p>\n<ul>\n<li><p>1、关系分析：找出题目中描述的各个进程，分析它们之间的同步、互斥关系</p>\n</li>\n<li><p>2、整理思路：根据各进程的操作流程确定P、V操作的大致顺序</p>\n</li>\n<li><p>3、设置信号量：设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现：</p>\n<ul>\n<li><p>写者：写文件</p>\n<ul>\n<li>写文件时，对临界资源的访问需要互斥进行，所以在临界区前后分别P、V（共享文件）</li>\n</ul>\n</li>\n<li><p>读者：读文件</p>\n<ul>\n<li><p>由读文件时的第一个进程加锁P(共享文件)，读文件时的最后一个进程解锁V(共享文件)</p>\n</li>\n<li><p>对count变量进行互斥访问（对count 变量的检查和赋值要一气呵成）</p>\n<ul>\n<li>若两个读进程并发执行，则 count&#x3D;0时两个进程也许都能满足 if 条件，都会执行P(rw)，从而使第二个读进程阻塞</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>潜在问题：写进程饥饿问题</p>\n<ul>\n<li><p>只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的</p>\n</li>\n<li><p>改良：读写公平法<img src=\"https://api2.mubu.com/v3/document_image/4c531678-9782-4534-b91b-1580f0e26125-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。也称为“读写公平法”</p>\n</li>\n</ul>\n</li>\n<li><p>参考思路：</p>\n<ul>\n<li><p>核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数</p>\n</li>\n<li><p>可以用count 的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理</p>\n</li>\n<li><p>另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量（P、V(mutex)）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>哲学家进餐问题</p>\n<ul>\n<li><p>问题描述：</p>\n<ul>\n<li><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人</p>\n</li>\n<li><p>只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待</p>\n</li>\n<li><p>饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考</p>\n</li>\n</ul>\n</li>\n<li><p>PV操作题目分析步骤：</p>\n<ul>\n<li><p>1、关系分析：系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系</p>\n</li>\n<li><p>2、整理思路：这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓</p>\n</li>\n<li><p>3、设置信号量：定义互斥信号量数组chopstick[5]&#x3D;{1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5</p>\n</li>\n</ul>\n</li>\n<li><p>错误代码实现：</p>\n<ul>\n<li><p>哲学家：吃饭——&gt;思考</p>\n<ul>\n<li><p>吃饭之前——P操作，左筷子-1</p>\n</li>\n<li><p>吃饭之前——P操作，右筷子-1</p>\n</li>\n<li><p>吃饭之后——V操作，左筷子+1</p>\n</li>\n<li><p>吃饭之后——V操作，右筷子+1</p>\n</li>\n</ul>\n</li>\n<li><p>错误原因：</p>\n<ul>\n<li><p>每个哲学家吃饭前依次拿起左、右两支筷子</p>\n</li>\n<li><p>每位哲学家循环等待右边的人放下筷子，如果右边的人都没有放下筷子（发生阻塞），产生“死锁”</p>\n</li>\n<li><p>死锁结果：5个哲学家并发地拿起了自己左手边的筷子</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>防止死锁发生的方法</p>\n<ul>\n<li><p>最多允许四个哲学家同时进餐</p>\n<ul>\n<li>这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</li>\n</ul>\n</li>\n<li><p>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反</p>\n<ul>\n<li><p>用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况</p>\n</li>\n<li><p>从而保证了有的科学家一根筷子也拿不起来</p>\n</li>\n</ul>\n</li>\n<li><p>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子</p>\n<ul>\n<li><p>问题：</p>\n<ul>\n<li><p>即使有的科学家左右两只筷子都在，也暂时无法取得</p>\n<ul>\n<li>各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子</li>\n</ul>\n</li>\n<li><p>并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子</p>\n<ul>\n<li>假如哲学家拿起筷子后正在吃饭，其他哲学家也可以获得筷子，但是其实这个哲学家并没有放下筷子，所以相邻的哲学家不能同时拿起筷子</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>难点分析：</p>\n<ul>\n<li><p>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是</p>\n</li>\n<li><p>每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"管程\"><a href=\"#管程\" class=\"headerlink\" title=\"管程\"></a>管程</h2><ul>\n<li><p>为什么引入管程</p>\n<ul>\n<li><p>信号量机制存在的问题：编写程序困难、易出错（非常注重P、V操作顺序）</p>\n<ul>\n<li>缓冲区已经放满时，如果按①②③顺序执行，就会发生死锁</li>\n</ul>\n</li>\n<li><p>设计一种机制，让程序员写程序时不需要再关注复杂的P、V操作，让写代码更轻松</p>\n</li>\n<li><p>管程：一种高级同步机制</p>\n</li>\n</ul>\n</li>\n<li><p>定义</p>\n<ul>\n<li>一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程</li>\n</ul>\n</li>\n<li><p>组成</p>\n<ul>\n<li><p>局部于管程的共享结构数据说明（将变量封装起来）</p>\n</li>\n<li><p>对该数据结构进行操作的一组过程（函数）</p>\n</li>\n<li><p>对局部于管程的共享数据设置初始值的语句</p>\n</li>\n<li><p>管程有一个名字</p>\n</li>\n</ul>\n</li>\n<li><p>基本特性</p>\n<ul>\n<li><p>局部于管程的数据只能被局部于管程内的过程所访问</p>\n</li>\n<li><p>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</p>\n</li>\n<li><p>每次仅允许一个进程在管程内执行某个内部过程</p>\n</li>\n</ul>\n</li>\n<li><p>拓展1：用管程解决生产者—消费者问题</p>\n<ul>\n<li><p>目的：更方便地实现进程互斥和同步</p>\n<ul>\n<li><p>管程中设置条件变量和等待&#x2F;唤醒操作，以解决同步问题</p>\n</li>\n<li><p>由编译器负责实现各进程互斥地进入管程中的过程</p>\n</li>\n</ul>\n</li>\n<li><p>每次仅允许一个进程在管程内执行某个内部过程</p>\n<ul>\n<li><p>例1：两个生产者进程并发执行，依次调用了insert 过程</p>\n</li>\n<li><p>例2：两个消费者进程先执行，生产者进程后执行</p>\n</li>\n</ul>\n</li>\n<li><p>需要在管程中定义共享数据（如生产者消费者问题的缓冲区）</p>\n</li>\n<li><p>需要在管程中定义用于访问这些共享数据的“入口”——其实就是一些函数</p>\n<ul>\n<li>如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品</li>\n</ul>\n</li>\n<li><p>只有通过这些特定的“入口”才能访问共享数据</p>\n</li>\n<li><p>管程中有很多“入口”，但是每次只能开放其中一个“入口”，并且只能让一个进程或线程进入</p>\n<ul>\n<li><p>如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。</p>\n</li>\n<li><p>注意：这种互斥特性是由编译器负责实现的，程序员不用关心</p>\n</li>\n</ul>\n</li>\n<li><p>可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题</p>\n<ul>\n<li><p>可以让一个进程或线程在条件变量上等待（此时，该进程应先释放管程的使用权，也就是让出“入口”）</p>\n</li>\n<li><p>可以通过唤醒操作将等待在条件变量上的进程或线程唤醒</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拓展2：Java中类似于管程的机制</p>\n<ul>\n<li><p>Java 中，如果用关键字 synchronized 来描述一个函数，那么这个函数同一时间段内只能被一个线程调用</p>\n</li>\n<li><p>每次只能有一个线程进入insert 函数，如果多个线程同时调用 insert 函数，则后来者需要排队等待</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><h2 id=\"死锁的概念\"><a href=\"#死锁的概念\" class=\"headerlink\" title=\"死锁的概念\"></a>死锁的概念</h2><ul>\n<li><p>什么是死锁</p>\n<ul>\n<li><p>在并发环境下，多个进程因为竞争资源造成的一种僵局，没有外力作用，这些进程都无法向前继续推进</p>\n</li>\n<li><p>例如：每位哲学家都在等待自己右边的人放下筷子，这些哲学家进程都因等待筷子资源而被阻塞。即发生“死锁”</p>\n</li>\n<li><p>每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”</p>\n</li>\n</ul>\n</li>\n<li><p>进程死锁、饥饿、死循环的区别</p>\n<ul>\n<li><p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p>\n</li>\n<li><p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象</p>\n<ul>\n<li>比如：在短进程优先（SPF）算法中，若有源源不断的短进程到来，则长进程将一直得不到处理机，从而发生长进程“饥饿”</li>\n</ul>\n</li>\n<li><p>死循环：某进程执行过程中一直跳不出某个循环的现象</p>\n<ul>\n<li>有时是因为程序逻辑 bug 导致的，有时是程序员故意设计的</li>\n</ul>\n</li>\n<li><p>共同点：</p>\n<ul>\n<li>都是进程无法顺利向前推进的现象（故意设计的死循环除外）</li>\n</ul>\n</li>\n<li><p>区别：</p>\n<ul>\n<li><p>死锁：至少有两个或两个以上的进程同时发生死锁；进程一定处于阻塞态；操作系统资源分配不合理</p>\n</li>\n<li><p>饥饿：可能只有一个进程发生饥饿；进程既可能是阻塞态(长期得不到I&#x2F;O设备)，也可能是就绪态(长期得不到处理机)；操作系统资源分配不合理</p>\n</li>\n<li><p>死循环：可能只有一个进程发生死循环；进程可以处于运行态；代码逻辑错误</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>死锁产生的必要条件（四个条件同时满足，死锁才有可能发生）</p>\n<ul>\n<li><p>互斥条件：对必须互斥使用的资源的争抢</p>\n<ul>\n<li><p>如哲学家的筷子、打印机设备</p>\n</li>\n<li><p>像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）</p>\n</li>\n</ul>\n</li>\n<li><p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</p>\n</li>\n<li><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</p>\n</li>\n<li><p>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</p>\n<ul>\n<li><p>发生死锁时一定有循环等待，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）</p>\n</li>\n<li><p>如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件<img src=\"https://api2.mubu.com/v3/document_image/ea2ebcc8-9414-486a-bece-c4a40b81f2bb-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>死锁产生的原因（什么时候会发生死锁）</p>\n<ul>\n<li><p>对系统资源的竞争</p>\n<ul>\n<li><p>各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁</p>\n</li>\n<li><p>对可剥夺的资源（CPU）的竞争是不会引起死锁的</p>\n</li>\n</ul>\n</li>\n<li><p>进程推进顺序非法</p>\n<ul>\n<li><p>请求和释放资源的顺序不当，也同样会导致死锁</p>\n</li>\n<li><p>例如，并发执行的进程P1、P2 分别申请并占有了资源 R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁</p>\n</li>\n</ul>\n</li>\n<li><p>信号量的使用不当也会造成死锁</p>\n<ul>\n<li><p>如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁</p>\n</li>\n<li><p>可以把互斥信号量、同步信号量也看做是一种抽象的系统资源</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>死锁的处理策略</p>\n<ul>\n<li><p>死锁预防（静态策略）</p>\n<ul>\n<li><p>分类</p>\n<ul>\n<li><p>破坏互斥条件：允许资源共享访问</p>\n<ul>\n<li><p>例如：SPOOLing技术。操作系统可以采用 SPOOLing技术把独占设备在逻辑上改造成共享设备。用SPOOLing技术将打印机改造为共享设备<img src=\"https://api2.mubu.com/v3/document_image/ad026a13-c7a0-437c-9053-3d627ea17690-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>实际上，某些资源只能被互斥访问，并且某些情况下必须保护互斥性</p>\n</li>\n<li><p>很多时候都无法破坏互斥条件</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>破坏不剥夺条件</p>\n<ul>\n<li><p>方案一：当某个进程请求新的资源得不到满足时，立即释放保持的所有资源，待以后需要时再重新申请</p>\n</li>\n<li><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级</p>\n<ul>\n<li>比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>实现复杂</p>\n</li>\n<li><p>释放已获得的资源可能造成前一阶段工作的失效。因此一般只适用于易保存和恢复状态的资源，如CPU的寄存器及内存资源</p>\n</li>\n<li><p>反复地申请和释放资源会增加系统开销，降低系统吞吐量</p>\n</li>\n<li><p>方案一还有的缺点：一直释放资源，可能会导致进程饥饿</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>破坏请求并保持条件</p>\n<ul>\n<li><p>采用静态分配方法：一次性申请完所需要的全部资源</p>\n</li>\n<li><p>优点：实现简单</p>\n</li>\n<li><p>缺点：资源被严重浪费（资源利用率低）、可能导致进程饥饿</p>\n<ul>\n<li>有些资源可能只需要用很短的时间，但是进程的整个运行期间都需要一直保持着所有资源</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>破坏循环等待条件</p>\n<ul>\n<li><p>采用顺序资源法：给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</p>\n<ul>\n<li><p>一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源</p>\n</li>\n<li><p>在任何时间，每个进程之间正在使用的互斥资源中总有一个编号是最大的，这个进程在这一步时不可能被阻塞，所以任何时间都至少有一个进程没有被阻塞（不会导致死锁）</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>进程编号必须稳定：不方便增加新的设备，因为可能需要重新分配所有的编号</p>\n</li>\n<li><p>可能会导致资源浪费：进程实际使用资源的顺序可能和编号递增顺序不一致</p>\n</li>\n<li><p>不利于用户编程：必须按规定次序申请资源</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>破坏四个必要条件中的一个或几个，防止死锁</p>\n</li>\n<li><p>资源分配保守，宁可资源闲置</p>\n</li>\n<li><p>一次性请求所有资源，资源剥夺，资源按序分配</p>\n</li>\n<li><p>优点：适用于突发式处理的进程，不必进行剥夺</p>\n</li>\n<li><p>缺点：效率低，进程初始化时间长，剥夺次数过多，不变灵活申请新资源</p>\n</li>\n</ul>\n</li>\n<li><p>避免死锁（动态策略）</p>\n<ul>\n<li><p>安全序列</p>\n<ul>\n<li><p>如果系统按照这种序列分配资源，则每个进程都能顺利完成</p>\n</li>\n<li><p>只要能找出一个安全序列，系统就是安全状态</p>\n</li>\n<li><p>安全序列可能有多个</p>\n</li>\n</ul>\n</li>\n<li><p>系统的不安全状态，与死锁的关系</p>\n<ul>\n<li><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态</p>\n</li>\n<li><p>处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态</p>\n<ul>\n<li><p>意味着之后可能所有进程都无法顺利的执行下去</p>\n</li>\n<li><p>如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>避免系统进入不安全状态——银行家算法</p>\n<ul>\n<li><p>目的：避免死锁</p>\n</li>\n<li><p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</p>\n</li>\n<li><p>把算法的应用范围拓展为多种资源：把单维的数字拓展为多维的向量</p>\n</li>\n<li><p>安全性算法步骤：</p>\n<ul>\n<li><p>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收</p>\n</li>\n<li><p>不断重复上述过程，看最终是否能让所有进程都加入安全序列</p>\n</li>\n</ul>\n</li>\n<li></li>\n</ul>\n</li>\n<li><p>寻找可能的安全序列</p>\n</li>\n<li><p>优点：不必进行剥夺</p>\n</li>\n<li><p>缺点：必须知道将来的资源需求，进程不能被长时间阻塞</p>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>系统安全状态</p>\n<ul>\n<li>按照某种方式分配资源后，是否会导致死锁，如果会导致死锁，那么就是不安全状态，反之就是安全状态</li>\n</ul>\n</li>\n<li><p>银行家算法</p>\n<ul>\n<li>思想：通过计算当前资源的不同分配方式，从而预测系统是否会进入不安全状态<ul>\n<li>就像是银行贷款，是否会导致银行没有足够的资金对外出借</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>死锁的检测及解除</p>\n<ul>\n<li><p>死锁的检测（定期检查）：用于检测系统状态，以确定系统中是否发生了死锁</p>\n<ul>\n<li><p>用某种数据结构来保存资源的请求和分配信息</p>\n<ul>\n<li><p>数据结构资源分配图</p>\n<ul>\n<li><p>两种结点</p>\n<ul>\n<li><p>进程结点：对应一个进程</p>\n<ul>\n<li>一般用圆表示</li>\n</ul>\n</li>\n<li><p>资源结点：对应一类资源，一类资源可能有多个</p>\n<ul>\n<li>一般用矩形表示，矩形中的小圆代表该类资源的数量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两种边</p>\n<ul>\n<li><p>进程结点——&gt;资源结点：表示进程想申请几个资源（每条边代表一个）</p>\n</li>\n<li><p>资源结点——&gt;进程结点：表示已经为进程分配了几个资源（每条边代表一个）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>提供一种算法，利用上述信息来检测系统是否已进入死锁状态</p>\n<ul>\n<li><p>死锁与可完全简化图的关系</p>\n<ul>\n<li><p>如果最终能消除所有边，就称这个图是可完全简化的（一定没有发生死锁）</p>\n</li>\n<li><p>如果最终不能消除所有边（图不可完全简化），此时就是发生了死锁</p>\n</li>\n<li><p>最终还连着边的那些进程就是处于死锁状态的进程</p>\n</li>\n</ul>\n</li>\n<li><p>检测死锁的算法：</p>\n<ul>\n<li><p>1、在资源分配图中，找出既不阻塞又不是孤点的进程 Pi，即申请&lt;空闲；消去它所有的请求边和分配变，使之称为孤立的结点</p>\n<ul>\n<li><p>即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。如下图中，R1没有空闲资源，R2有一个空闲资源。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源。</p>\n</li>\n<li><p>在下图中，P1 是满足这一条件的进程结点，于是将P1的所有边消去。</p>\n</li>\n</ul>\n</li>\n<li><p>2、进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程，即其他进程申请&lt;空闲</p>\n<ul>\n<li>在下图中，P2 就满足这样的条件。根据 1）中的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>死锁的解除：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来</p>\n<ul>\n<li><p>哪些进程：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程</p>\n</li>\n<li><p>解除死锁的主要方法：</p>\n<ul>\n<li><p>资源剥夺法：挂起进程，剥夺该进程的资源再分配</p>\n<ul>\n<li><p>挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程</p>\n</li>\n<li><p>缺点：被挂起的进程可能长时间得不到资源而饥饿</p>\n</li>\n</ul>\n</li>\n<li><p>撤销进程法（或称终止进程法）：终止进程，剥夺该进程的资源再分配</p>\n<ul>\n<li><p>强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源</p>\n</li>\n<li><p>优点：实现简单</p>\n</li>\n<li><p>缺点：资源被严重浪费（资源利用率低）、导致饥饿</p>\n<ul>\n<li>因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程回退法：进程回退，自愿释放该进程的资源再分配</p>\n<ul>\n<li><p>让一个或多个死锁进程回退到足以避免死锁的地步，进程回退时自愿释放资源而非被剥夺</p>\n</li>\n<li><p>要求系统要记录进程的历史信息，设置还原点</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何确定对哪个死锁进程进行解除：</p>\n<ul>\n<li><p>进程优先级</p>\n</li>\n<li><p>已执行多长时间：执行时间短的优先解除死锁</p>\n</li>\n<li><p>还要多久能完成：还需时间长的优先解除</p>\n</li>\n<li><p>进程已经使用了多少资源：已使用资源多的优先解除（大量资源被释放）</p>\n</li>\n<li><p>进程是交互式的还是批处理式的：交互性进程优先解除（保证用户体验感）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>宽松，只要允许就分配资源</p>\n</li>\n<li><p>优点：不延长初始化时间，允许对死锁进行现场处理</p>\n</li>\n<li><p>缺点：通过剥夺解除死锁，造成损失</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","2.操作系统","2.进程管理"],"tags":["写作"]},{"title":"内存管理","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","content":"<h1 id=\"内存管理概念\"><a href=\"#内存管理概念\" class=\"headerlink\" title=\"内存管理概念\"></a>内存管理概念</h1><h2 id=\"内存管理的基本原理和要求\"><a href=\"#内存管理的基本原理和要求\" class=\"headerlink\" title=\"内存管理的基本原理和要求\"></a>内存管理的基本原理和要求</h2><ul>\n<li><p>什么是内存，有何作用</p>\n<ul>\n<li><p>概念：可存放数据，程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾</p>\n</li>\n<li><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方？</p>\n<ul>\n<li>给内存的存储单元编地址（内存地址从0开始，每个地址对应一个存储单元）</li>\n</ul>\n</li>\n<li><p>存储单元、内存地址的概念和联系</p>\n<ul>\n<li><p>计算内存地址长度：即需要多少个二进制位才能表示相应数目的存储单元</p>\n<ul>\n<li>内存中可以存放 4*2^30个字节</li>\n<li>如果是按字节编址的话，需要 2^32个地址才能一一标识，所以地址需要用 32 个二进制位来表示（0~ 2^32 -1）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>按字节编址  vs  按字编址</p>\n<ul>\n<li><p>如果计算机“按字节编址”，则每个存储单元大小为 1字节，即 1B，即 8个二进制位</p>\n</li>\n<li><p>如果字长为16位的计算机“按字编址”，则每个存储单元大小为 1个字；每个字的大小为 16 个二进制位</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程运行的基本原理</p>\n<ul>\n<li><p>指令的基本原理</p>\n<ul>\n<li><p>指令：操作码+若干参数（可能包含地址参数）</p>\n</li>\n<li><p>源代码通过编译，转化为指令</p>\n<ul>\n<li>指令的工作基于“地址”。每个地址对应一个数据的存储单元</li>\n</ul>\n</li>\n<li><p>CPU通过访问内存中的程序段，执行CPU能识别的指令</p>\n</li>\n<li><p>这些指令告诉CPU去内存的数据段（哪个地址）读&#x2F;写数据，并且该数据做什么样的处理</p>\n<ul>\n<li><p>将内存中的数据段读入CPU寄存器，或将CPU寄存器中的数据写入内存的数据段</p>\n</li>\n<li><p>有的系统中，寄存器和内存可能统一编址</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>逻辑地址空间(相对地址)   vs  物理地址空间(绝对地址)</p>\n<ul>\n<li><p>如果进程不是从地址#0 开始存放的，指令中的地址参数如何转换为实际存放地址（物理地址）</p>\n</li>\n<li><p>逻辑地址空间：</p>\n<ul>\n<li><p>即相对地址（相对于进程的起始地址而言的地址），链接程序依次按照各个概块的相对地址构成统一的从0号单元开始编址的逻辑地址空间</p>\n</li>\n<li><p>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址）</p>\n</li>\n<li><p>C语言程序经过编译、链接处理后，生成装入模块，即可执行文件（可执行文件中指令指明的是逻辑地址(相对地址)）</p>\n</li>\n</ul>\n</li>\n<li><p>物理地址空间</p>\n<ul>\n<li><p>内存中物理单元的集合，是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取</p>\n</li>\n<li><p>将装入模块（可执行文件）装入内存后，需要将指令中的逻辑地址转换为物理地址（绝对地址）</p>\n<ul>\n<li>逻辑地址转换为物理地址的三种方式，即三种装入方式</li>\n</ul>\n</li>\n<li><p>地址重定位：逻辑地址转换成物理地址的过程</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>从写程序到程序运行</p>\n<ul>\n<li><p>编辑源代码文件</p>\n</li>\n<li><p>编译：解译程序将用户源代码编译成若干目标模块，把高级语言翻译为机器语言</p>\n</li>\n<li><p>链接：由链接程序将编译后的形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块</p>\n</li>\n<li><p>装入：由装入程序将装入模块装入到内存运行</p>\n</li>\n</ul>\n</li>\n<li><p>三种链接方式</p>\n<ul>\n<li><p>静态链接：程序运行之前，将库函数连接成一个完整的可执行程序（装入模块），之后不再拆开<img src=\"https://api2.mubu.com/v3/document_image/d86a40e0-e91f-45aa-81bb-52ea5017ccdf-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>装入时动态链接：将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接的方式（将所有目标模块进行链接）<img src=\"https://api2.mubu.com/v3/document_image/53b08ac3-1665-4036-8899-8091f57f5d36-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>运行时动态链接：对于某些目标模块的链接，程序需要时才会对其链接（只链接部分模块，用不到的模块不需要装入内存）</p>\n<ul>\n<li>优点：便于修改和更新，便于实现对目标模块的共享</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>三种转入方式</p>\n<ul>\n<li><p>绝对装入</p>\n<ul>\n<li><p>前提：编译时，如果知道程序将放到内存中的哪个位置，编译程序将直接产生绝对地址的目标代码</p>\n</li>\n<li><p>概念：装入时按照装入模块中的地址（实际的内存地址），将程序和数据装入内存</p>\n</li>\n<li><p>即，编译、链接后得到的装入模块的指令直接就使用了绝对地址</p>\n</li>\n<li><p>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时转换为绝对地址</p>\n</li>\n<li><p>优点：不要要对程序和数据的地址进行修改</p>\n</li>\n<li><p>缺点：只适用于单道程序环境</p>\n</li>\n</ul>\n</li>\n<li><p>可重定位装入（静态重定位）</p>\n<ul>\n<li><p>装入模块中采用相对地址，装入时对地址进行“重定位”，将逻辑地址变为物理地址（地址变换是在装入时一次完成的），然后将程序和数据装入内存</p>\n</li>\n<li><p>装入时对目标程序中指令和数据的更改过程称为重定位，地址变换通常是在装入时一次完成的，又按称为静态重定位</p>\n</li>\n<li><p>即编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址</p>\n</li>\n<li><p>如果装入的起始物理地址为x，则所有地址相关的参数都 + x</p>\n</li>\n<li><p>特点：作业装入必须要一次性全部装入，并自运行中作业不能在内存中移动，也不能再申请内存空间</p>\n</li>\n<li><p>适用于早期的多道批处理操作系统</p>\n</li>\n</ul>\n</li>\n<li><p>动态运行时装入（动态重定位）</p>\n<ul>\n<li><p>装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，当程序真正执行时才进行转换，因此装入内存后所有的地址依然是逻辑地址</p>\n</li>\n<li><p>装入时依然保持使用逻辑地址，需要一个重定位寄存器的支持</p>\n<ul>\n<li>重定位寄存器：存放装入模块存放的起始位置</li>\n</ul>\n</li>\n<li><p>物理地址 &#x3D; 逻辑地址 + 重定位寄存器中的数据</p>\n</li>\n<li><p>特点：允许程序在内存中发生移动</p>\n<ul>\n<li><p>可将程序分配到不连续的存储区中</p>\n</li>\n<li><p>在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</p>\n</li>\n<li><p>便于程序段的共享</p>\n</li>\n<li><p>可以向用户提供一个比存储空间大得多的地址空间（地址空间大于存储空间）</p>\n</li>\n</ul>\n</li>\n<li><p>适用于现代操作系统</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"内存管理的功能\"><a href=\"#内存管理的功能\" class=\"headerlink\" title=\"内存管理的功能\"></a>内存管理的功能</h2><ul>\n<li><p>内存空间的分配与回收：操作系统完成主存储器空间的分配和管理</p>\n<ul>\n<li><p>分配：内存中很多地方都可以存放进程，如何为进程分配内存空间，如何标记内存空间是否已分配</p>\n</li>\n<li><p>回收：当进程运行结束之后，如何将进程占用的内存空间回收</p>\n</li>\n</ul>\n</li>\n<li><p>内存空间的扩充：利用虚拟存确技术或者自动覆盖技术，从逻辑上扩充内存</p>\n<ul>\n<li><p>覆盖技术</p>\n</li>\n<li><p>交换技术</p>\n</li>\n<li><p>虚拟存储技术</p>\n</li>\n</ul>\n</li>\n<li><p>地址转换：将逻辑地址转换为物理地址</p>\n<ul>\n<li><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址</p>\n</li>\n<li><p>而逻辑地址到物理地址的转换（这个过程称为地址重定位，即三种装入方式）应该由操作系统负责</p>\n</li>\n</ul>\n</li>\n<li><p>存储保护：保护各道作业在各自存储空间运行，互不干扰</p>\n<ul>\n<li><p>方法1：在CPU中设置上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的数据比较，判断是有越界</p>\n</li>\n<li><p>方法2：采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查。重定位寄存器中包含最小物理地址值，界地址寄存器包含逻辑地址的最大值</p>\n<ul>\n<li><p>越界检查过程：</p>\n<ul>\n<li><p>界地址寄存器：逻辑地址是否小于界地址寄存器中的数据</p>\n</li>\n<li><p>重定位寄存器：逻辑地址+重定位寄存器中的数据&#x3D;物理地址</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"覆盖与交换\"><a href=\"#覆盖与交换\" class=\"headerlink\" title=\"覆盖与交换\"></a>覆盖与交换</h2><ul>\n<li><p>覆盖</p>\n<ul>\n<li><p>思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调用内存</p>\n</li>\n<li><p>将用户空间分为一个固定区和若干覆盖区，活跃部分放在固定区，即将访问的段放在覆盖区</p>\n<ul>\n<li><p>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p>\n</li>\n<li><p>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</p>\n</li>\n</ul>\n</li>\n<li><p>特点：打破了必须将一个讲程的全部信息装入主存后才能运行的限制，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存</p>\n</li>\n<li><p>缺点：对用户不透明，增加了用户编程负担</p>\n<ul>\n<li><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖</p>\n</li>\n<li><p>覆盖技术只用于早期的操作系统</p>\n</li>\n</ul>\n</li>\n<li><p>适用于程序大小超过物理内存总和</p>\n</li>\n</ul>\n</li>\n<li><p>交换</p>\n<ul>\n<li><p>思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p>\n</li>\n<li><p>换出：将处于等待状态的程序从内存中转移到辅存</p>\n<ul>\n<li>使进程处于挂起状态（分为就绪挂起、阻塞挂起）</li>\n</ul>\n</li>\n<li><p>换入：把准备好竞争CPU运行的程序从辅存转移到内存</p>\n<ul>\n<li>中级调度（内存调度）：就是将哪个处于挂起状态的进程重新调入内存</li>\n</ul>\n</li>\n<li><p>1、在外存（磁盘）的什么位置保存被换出的进程</p>\n<ul>\n<li><p>结构：把磁盘空间分为文件区和对接区两部分<img src=\"https://api2.mubu.com/v3/document_image/9136a4b8-c517-41b4-87b8-9c6ea81a287b-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式</p>\n</li>\n<li><p>对换区空间只占磁盘空间的小部分，被换出的进程数据（例如PCB）就存放在对换区，主要追求换入换出速度（对换直接影响系统的整体速度），因此通常对换区采用连续分配方式</p>\n<ul>\n<li>对换区的I&#x2F;O速度比文件区更快</li>\n</ul>\n</li>\n<li><p>注意：PCB会常驻内存，不会被换出外存</p>\n</li>\n</ul>\n</li>\n<li><p>2、什么时候进程交换</p>\n<ul>\n<li><p>交换通常在许多进程运行且内存吃紧时进行进程交换，而系统负荷降低就暂停</p>\n</li>\n<li><p>例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出</p>\n</li>\n</ul>\n</li>\n<li><p>3、优先换出哪些进程</p>\n<ul>\n<li>阻塞进程、优先级低的进程、进程在内存的驻留时间较短的进程（防止饥饿）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>交换存在的问题</p>\n<ul>\n<li><p>备份存储，使用快速硬盘，要求存储空间足够大，并且能够对内存映像进行直接访问</p>\n</li>\n<li><p>转移时间和所交换的内存空间成正比</p>\n</li>\n<li><p>只有内存空闲状态才能将进程换出</p>\n</li>\n<li><p>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来会很快</p>\n</li>\n<li><p>交换通常在有许多进程运行且内存吃紧时开始启动，连负荷降低就暂停</p>\n</li>\n<li><p>普通的交换使用不多，但交换策路的某些变体在许多系统中仍发挥作用</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"连续分配管理方式\"><a href=\"#连续分配管理方式\" class=\"headerlink\" title=\"连续分配管理方式\"></a>连续分配管理方式</h2><p>连续分配：为用户进程分配的必须是一个连续的内存空间）</p>\n<ul>\n<li><p>单一连续分配</p>\n<ul>\n<li><p>内存分为系统区和用户区</p>\n<ul>\n<li><p>系统区仅供操作系统使用，通常在低地址部分</p>\n</li>\n<li><p>用户区为用户提供</p>\n<ul>\n<li>内存中只能有一道用户程序，用户程序独占整个用户区空间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>实现简单，无外部碎片</p>\n</li>\n<li><p>采用覆盖技术，不需要额外技术支持</p>\n</li>\n<li><p>无须进行内存保护，不会出现越界异常</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>只适用于单用户，单任务的操作系统，不支持多道程序并发运行</p>\n</li>\n<li><p>存在内部碎片（分配给某个进程的内存区域中有一部分没用上），存储器利用率低</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>固定分区分配</p>\n<ul>\n<li><p>背景：为了在内存中装入多道程序，且这些程序之间不会相互干扰</p>\n</li>\n<li><p>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</p>\n</li>\n<li><p>种类</p>\n<ul>\n<li><p>分区大小相等：用一台计算机去控制多个相同对象的场合，缺乏灵活性</p>\n</li>\n<li><p>分区大小不等：划分为多个较小的分区，适量的中等分区和少量大分区</p>\n</li>\n</ul>\n</li>\n<li><p>实现各个分区的分配与回收</p>\n<ul>\n<li><p>操作系统建立一个数据结构——分区说明表</p>\n<ul>\n<li><p>每个表项对应一个分区，通常按分区大小排列</p>\n</li>\n<li><p>每个表项包括对应分区的大小、起始地址、状态（是否已分配）</p>\n</li>\n</ul>\n</li>\n<li><p>用数据结构的数组（或链表）即可表示这个表</p>\n</li>\n<li><p>将程序装入内存时：</p>\n<ul>\n<li>由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>适用于多道程序的存储，无外部碎片</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>有可能程序太大，无法放入任何一个分区；此时又不得不采用覆盖技术来解决，又会降低性能</p>\n</li>\n<li><p>存在内部碎片，主存利用率低</p>\n</li>\n<li><p>不能实现多进程共享一个主存区</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>动态分区分配</p>\n<ul>\n<li><p>不会预先划分内存分区，在进程装入内存的时候，根据内存的大小动态的建立分区，使分区的大小正好适合进程的需要，因此用户区的分区大小和数目是可变的</p>\n</li>\n<li><p>1、系统要用什么样的数据结构记录内存的使用情况</p>\n<ul>\n<li><p>空闲分区表：</p>\n<ul>\n<li>每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息</li>\n</ul>\n</li>\n<li><p>空闲分区链：</p>\n<ul>\n<li>每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>2、当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</p>\n<ul>\n<li>使用动态分区分配算法选择分区进行分配</li>\n</ul>\n</li>\n<li><p>3、如何进行分区的分配与回收操作</p>\n<ul>\n<li><p>分配操作：</p>\n<ul>\n<li><p>1.进程所占内存 &lt; 分区大小：修改分区大小（原-进程大小）和起始地址（原+进程大小）</p>\n</li>\n<li><p>2.进程所占内存&#x3D;分区大小：删除对应表项，或删除对应结点</p>\n</li>\n</ul>\n</li>\n<li><p>回收操作：</p>\n<ul>\n<li><p>1.回收区的后面有一个相邻的空闲分区（合并两个相邻的空闲分区）：修改分区大小（原+进程大小）和起始地址（原-进程大小）</p>\n</li>\n<li><p>2.回收区的前面有一个相邻的空闲分区（合并两个相邻的空闲分区）：修改分区大小（原+进程大小）和起始地址（不变）</p>\n</li>\n<li><p>3.回收区的前、后各有一个相邻的空闲分区（三个相邻的空闲分区合并为一个）：删除起始地址靠后的表项，修改起始地址靠前表项的分区大小（三个分区大小之和）和起始地址（不变）</p>\n</li>\n<li><p>4.回收区的前、后都没有相邻的空闲分区：增加空闲分区表表项</p>\n</li>\n</ul>\n</li>\n<li><p>注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>分区大小可以根据进程的实际情况进行分配</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>存在外部碎片，最后导致主存利用率下降；不存在内部碎片</p>\n<ul>\n<li><p>采用紧凑技术可以缓解这种缺陷（解决外部碎片）——进程挪位</p>\n</li>\n<li><p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上</p>\n</li>\n<li><p>外部碎片：内存中的某些空闲分区由于太小而难以利用</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>什么是换入&#x2F;换出？</p>\n</li>\n<li><p>什么是中级调度（内存调度）？</p>\n</li>\n<li><p>动态分区分配应使用哪种装入方式：动态重定位</p>\n</li>\n<li><p>“紧凑”之后需要做什么处理：修改进程的起始地址，存放在PCB中，进程上CPU运行之前，将进程的起始地址放到重定位寄存器（基址寄存器）中</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动态分配算法\"><a href=\"#动态分配算法\" class=\"headerlink\" title=\"动态分配算法\"></a>动态分配算法</h2><ul>\n<li><p>首次适应算法</p>\n<ul>\n<li><p>算法思想：从低地址开始查找，找到第一个能满足大小的空闲分区</p>\n</li>\n<li><p>实现：</p>\n<ul>\n<li><p>空闲分区以地址递增的次序排列</p>\n</li>\n<li><p>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>\n</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排序</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n</li>\n</ul>\n</li>\n<li><p>最佳适应算法</p>\n<ul>\n<li><p>算法思想：动态分区分配是一种连续分配方式，为了保留大片的空闲区，优先使用更小的空闲区</p>\n</li>\n<li><p>实现：</p>\n<ul>\n<li><p>空闲分区按容量递增次序链接</p>\n</li>\n<li><p>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>\n</li>\n</ul>\n</li>\n<li><p>优点：可以尽可能多地留下大片的空闲区</p>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>性能较差：回收分区后可能需要对空闲分区队列重新排序</p>\n</li>\n<li><p>产生最多的外部碎片：对很小的内存进行分配，会留下更小的内存块，这些更小的内存块难以利用，产生很多的外部碎片</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>最坏适应算法（最大适应算法）</p>\n<ul>\n<li><p>算法思想：优先使用最大的连续空闲区</p>\n<ul>\n<li>为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</li>\n</ul>\n</li>\n<li><p>实现：</p>\n<ul>\n<li><p>空闲分区按容量递减次序链接</p>\n</li>\n<li><p>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>\n</li>\n</ul>\n</li>\n<li><p>算法优化：</p>\n<ul>\n<li><p>如果第一个空闲分区满足就要求，就可直接分配</p>\n</li>\n<li><p>如果第一个空闲分区不满足要求，说明无空闲分区满足要求</p>\n</li>\n</ul>\n</li>\n<li><p>优点：可以减少难以利用的小碎片</p>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>导致很快没有较大的内存块，不利于大进程</p>\n</li>\n<li><p>算法开销大，性能很差（排序）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>邻近适应算法</p>\n<ul>\n<li><p>算法思想：分配内存时从上次查找结束的位置开始继续查找</p>\n<ul>\n<li>首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题</li>\n</ul>\n</li>\n<li><p>实现：</p>\n<ul>\n<li><p>空闲分区以地址递增的顺序排列（可排成一个循环链表）</p>\n</li>\n<li><p>每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>\n</li>\n</ul>\n</li>\n<li><p>优点：算法开销小</p>\n</li>\n<li><p>缺点：会使高地址的大分区也被用完（有最坏(大)适应算法的缺点）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"非连续分配管理方式\"><a href=\"#非连续分配管理方式\" class=\"headerlink\" title=\"非连续分配管理方式\"></a>非连续分配管理方式</h2><p>为进程分配的是分散的内存空间</p>\n<ul>\n<li><p>基本分页存储管理方式</p>\n<ul>\n<li><p>设计思想</p>\n<ul>\n<li><p>将内存空间分为一个个大小相等的分区，每个分区就是一个页框（主存的基本单位）。每个页框有一个编号，即“页框号”，页框号从0开始</p>\n<ul>\n<li><p>页框&#x3D;页帧&#x3D;内存块&#x3D;物理块&#x3D;物理页面</p>\n</li>\n<li><p>页框号&#x3D;页帧号&#x3D;内存块号&#x3D;物理块号&#x3D;物理页号</p>\n</li>\n</ul>\n</li>\n<li><p>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，页号也是从0开始</p>\n</li>\n<li><p>分页存储与固定分区技术很像，但是其分页相对于分区又很小，分页管理不会产生外部碎片，产生的内部碎片也非常的小</p>\n</li>\n</ul>\n</li>\n<li><p>概念定义</p>\n<ul>\n<li><p>地址空间</p>\n<ul>\n<li><p>逻辑地址空间</p>\n</li>\n<li><p>物理地址空间：指令在内存中连续存放</p>\n</li>\n</ul>\n</li>\n<li><p>页（页面）vs 页框（页帧、物理页）</p>\n<ul>\n<li><p>不同点</p>\n<ul>\n<li><p>页：进程的逻辑地址空间的块</p>\n</li>\n<li><p>页框：内存的物理地址空间的块</p>\n</li>\n</ul>\n</li>\n<li><p>相同点：从0开始</p>\n</li>\n</ul>\n</li>\n<li><p>页号（页面号）vs 页框号（页帧号、物理页号）</p>\n<ul>\n<li><p>不同点</p>\n<ul>\n<li><p>页号：逻辑地址空间的块的编号</p>\n</li>\n<li><p>页框号：物理地址空间的块的编号</p>\n</li>\n</ul>\n</li>\n<li><p>相同点：从0开始</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分页存储的定义：</p>\n<ul>\n<li><p>操作系统以页框为单位为各个进程分配内存空间</p>\n</li>\n<li><p>进程的每个页面分别放入一个页框中，也就是说，进程的页面与内存的页框是一一对应的关系</p>\n</li>\n<li><p>各个页面不必连续存放，可以放到不相邻的各个页框中</p>\n</li>\n<li><p>注（小优化）：</p>\n<ul>\n<li><p>进程的最后一个页面可能没有一个页框那么大</p>\n</li>\n<li><p>也就是说，分页存储有可能产生内部碎片</p>\n</li>\n<li><p>因此页框不能太大，否则可能产生过大的内部碎片造成浪费</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分页存储的基本概念</p>\n<ul>\n<li><p>页面和页面大小</p>\n<ul>\n<li><p>进程中的块&#x3D;页</p>\n</li>\n<li><p>内存中的块&#x3D;页框（页帧）</p>\n</li>\n<li><p>进程申请主存空间，为每个页面分配主存中可用页框，即页与页框一一对应</p>\n</li>\n</ul>\n</li>\n<li><p>页面大小要适中</p>\n<ul>\n<li><p>页面太小：进程页面数过多，页表过程，增加内存占用，降低硬件地址转换效率</p>\n</li>\n<li><p>页面太大：页内碎片过多，降低内存利用率</p>\n</li>\n</ul>\n</li>\n<li><p>地址结构</p>\n<ul>\n<li>页号（有多少页的编号）+页内偏移（页内存了多少东西）</li>\n</ul>\n</li>\n<li><p>页表</p>\n<ul>\n<li><p>为了便于在内存中找到进程的每个页面对应的物理块</p>\n</li>\n<li><p>系统为每个进程建立一张页表</p>\n</li>\n<li><p>进程的每个页面对应一个页表项</p>\n</li>\n<li><p>页表一般放在内存中</p>\n</li>\n<li><p>每个页表项的长度是相同的</p>\n</li>\n<li><p>页表项：页号+物理内存中的块号（不要与地址结构搞混）</p>\n<ul>\n<li>页表项的物理内存块号+地址结构中的页内偏移&#x3D;物理地址</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>问题1：每个页表项占多少字节</p>\n<ul>\n<li><p>计算过程</p>\n<ul>\n<li><p>计算机中内存块的数量：内存大小&#x2F;页面大小</p>\n</li>\n<li><p>内存块号所占的bit数：2^n&#x3D;内存块数量，求n</p>\n</li>\n<li><p>表示块号至少需要几个字节：n&#x2F;8向上取整</p>\n</li>\n</ul>\n</li>\n<li><p>页表项所占字节数&#x3D;块号所占字节数</p>\n<ul>\n<li>页号不占用字节（存储空间）：连续存放，隐含</li>\n</ul>\n</li>\n<li><p>i号页表项的存放地址&#x3D;X+3i</p>\n<ul>\n<li>若每个页表项占3B，且都是连续存放</li>\n</ul>\n</li>\n<li><p>存储整个页表：</p>\n<ul>\n<li>3*(n+1)，页号从0开始</li>\n</ul>\n</li>\n<li><p>求某个内存块的起始地址：</p>\n<ul>\n<li>内存块的起始地址&#x3D;块号*内存块大小</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>问题2：如何实现地址转换（逻辑地址转为物理地址）</p>\n<ul>\n<li><p>特点：进程的各个页面是离散存放的，但页面内部是连续存放的</p>\n</li>\n<li><p>思想</p>\n<ul>\n<li><p>1.确定逻辑地址A对应的页号P</p>\n</li>\n<li><p>2.找到页号P对应的块号（查询页表），计算P号页面在内存中的起始地址</p>\n</li>\n<li><p>3.确定逻辑地址A的页内偏移量W</p>\n</li>\n<li><p>物理地址&#x3D;P号页面在内存中的起始地址+页内偏移量W</p>\n</li>\n</ul>\n</li>\n<li><p>计算过程</p>\n<ul>\n<li><p>页号&#x3D;逻辑地址&#x2F;页面长度（取除法的整数部分）</p>\n</li>\n<li><p>页内偏移量&#x3D;逻辑地址%页面长度（取余法的余数部分）</p>\n</li>\n<li><p>页面在内存中的起始地址&#x3D;页号对应块号*内存大小</p>\n</li>\n<li><p>物理地址&#x3D;页面在内存中的起始地址+页内偏移量</p>\n</li>\n</ul>\n</li>\n<li><p>小优化：页面大小是2的整数次幂</p>\n<ul>\n<li><p>原因1：计算机硬件可以快速的将逻辑地址拆分为页号和页内偏移量——逻辑地址拆分更迅速</p>\n<ul>\n<li><p>例：如果计算机用32位二进制数表示逻辑地址，页面大小是4KB</p>\n<ul>\n<li><p>则一个页面的逻辑地址范围是0~4095，也就是后12位</p>\n</li>\n<li><p>所以前20位表示页号，后12位表示页面偏移量</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>原因2：计算机硬件可以很快找到页号和页面偏移量所对应的物理地址——物理地址的计算更迅速</p>\n<ul>\n<li>例：如果页号为2，页内偏移量为1<ul>\n<li>则这个页面的物理地址&#x3D;物理块号（页号对应的块号*内存块大小）拼接上页内偏移量</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>逻辑地址结构</p>\n<ul>\n<li><p>如果有 K 位表示“页内偏移量W”，则说明该系统中一个页面的大小是 2^K个内存单元</p>\n</li>\n<li><p>如果有 M 位表示“页号W”，则说明在该系统中，一个进程最多允许有 2^M 个页面</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>基本地址变换机构</p>\n<ul>\n<li><p>是什么：在基本分页存储管理中用于实现逻辑地址到物理地址转换的一组硬件机构<img src=\"https://api2.mubu.com/v3/document_image/c05183c3-da02-4fd1-9206-af9442ae9774-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>逻辑地址中需要包括的信息</p>\n<ul>\n<li><p>页号</p>\n</li>\n<li><p>页内偏移量</p>\n</li>\n<li><p>页面在内存中存放的位置</p>\n</li>\n</ul>\n</li>\n<li><p>硬件：页表寄存器（PTR）</p>\n<ul>\n<li><p>存放：</p>\n<ul>\n<li><p>页表在内存中的起始地址F</p>\n</li>\n<li><p>页表长度M</p>\n</li>\n</ul>\n</li>\n<li><p>注：进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中</p>\n</li>\n</ul>\n</li>\n<li><p>页面大小为L，逻辑地址A到物理地址E的变换过程：</p>\n<ul>\n<li><p>1、进程切换相关的内核程序恢复进程运行环境</p>\n<ul>\n<li><p>进程运行环境的相关信息保存在PCB中</p>\n</li>\n<li><p>内核程序会将PCB中的相关信息（页表起始地址F、页表长度M）放到页表寄存器中</p>\n</li>\n<li><p>内核程序会将PCB中的相关信息（下一条指令的逻辑地址A）放到程序计数器中</p>\n</li>\n</ul>\n</li>\n<li><p>2、根据逻辑地址A计算出页号P、页内偏移量W</p>\n<ul>\n<li><p>页号P：逻辑地址前m位</p>\n</li>\n<li><p>页内偏移量W：逻辑地址后n位</p>\n</li>\n</ul>\n</li>\n<li><p>3、对页号的合法性检查</p>\n<ul>\n<li><p>如果页号P&gt;&#x3D;页表长度，说明逻辑地址非法，导致越界中断（内中断）</p>\n</li>\n<li><p>如果页号&lt;页表长度，说明逻辑地址合法</p>\n</li>\n</ul>\n</li>\n<li><p>4、查询页表，找到页号对应的页表项——第一次访问内存：查询页表中某个页表项内容</p>\n<ul>\n<li>页号对应的页表项（内存块号）&#x3D;页号*(页表项长度)+页表始址</li>\n</ul>\n</li>\n<li><p>5、用内存块号和页内偏移量得出物理地址</p>\n<ul>\n<li>内存块号是前n位，页内偏移量是后b位</li>\n</ul>\n</li>\n<li><p>6、访问目标内存单元——第二次访问内存</p>\n</li>\n</ul>\n</li>\n<li><p>计算方式</p>\n<ul>\n<li><p>1、计算页号（逻辑地址对页面大小取整）、页内偏移量（逻辑地址对页面大小取余）</p>\n<ul>\n<li><p>手算：页号P&#x3D;A&#x2F;L，页内偏移量W&#x3D;A%L</p>\n</li>\n<li><p>机算：页号P&#x3D;前m位，页内偏移量W&#x3D;后n位</p>\n</li>\n</ul>\n</li>\n<li><p>2、比较页号P和页表长度M，若P&gt;&#x3D;M产生越界中断</p>\n<ul>\n<li>页号从0开始</li>\n</ul>\n</li>\n<li><p>3、页表中页号P对应的页表项地址&#x3D;页表始址F+页号P*页表项长度</p>\n<ul>\n<li>取出该页表项中的内容，即为内存块号</li>\n</ul>\n</li>\n<li><p>4、计算物理地址E，使用E去访问内存</p>\n<ul>\n<li><p>手算：E&#x3D;b*L+W</p>\n</li>\n<li><p>机算：E&#x3D;内存块号和页内偏移量用二进制表示，然后拼接起来</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>概念区分</p>\n<ul>\n<li><p>页表项长度：每个页表项所占的存储空间</p>\n</li>\n<li><p>页表长度：这个页表中有多少个页表项</p>\n</li>\n<li><p>页面大小：一个页面占多大存储空间</p>\n</li>\n</ul>\n</li>\n<li><p>例题：若页面大小L 为 1K 字节，页号2对应的内存块号 b &#x3D; 8，将逻辑地址 A&#x3D;2500 转换为物理地址E。</p>\n<ul>\n<li><p>等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号 b &#x3D; 8，将逻辑地址 A&#x3D;2500 转换为物理地址E。</p>\n<ul>\n<li><p>按字节寻址：每个地址占一个字节</p>\n</li>\n<li><p>页内偏移量占10位：页面大小&#x3D;2^10&#x3D;1K</p>\n</li>\n<li><p>综上：页面大小L&#x3D;1K字节</p>\n</li>\n</ul>\n</li>\n<li><p>1、求页号、页面偏移量</p>\n<ul>\n<li><p>页号P&#x3D;A&#x2F;L&#x3D;2500&#x2F;1024&#x3D;2</p>\n</li>\n<li><p>页内偏移量W&#x3D;A%L&#x3D;452</p>\n</li>\n</ul>\n</li>\n<li><p>2、由于页号2存在，所以没有越界，且存放的内存块号b&#x3D;8</p>\n</li>\n<li><p>3、物理地址E&#x3D;b*L+W&#x3D;8x1024+425&#x3D;8644</p>\n</li>\n</ul>\n</li>\n<li><p>分页存储管理（页式管理）中的地址是一维的</p>\n<ul>\n<li><p>只要确定了每个页面的大小，逻辑地址结构就确定了</p>\n</li>\n<li><p>因此，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要知道这两个部分各占多少位</p>\n</li>\n</ul>\n</li>\n<li><p>页表项的大小</p>\n<ul>\n<li><p>页表项大小的设计应当尽量一页正好能装下所有的页表项</p>\n</li>\n<li><p>目的：方便页表的查询</p>\n</li>\n<li><p>原因：各页表项（和进程页表）按顺序连续地存放在内存中，如果一个页表项的大小为3字节，查找下一个页框的页表项时，不能直接使用X+3*M（跨页框查询）</p>\n</li>\n</ul>\n</li>\n<li><p>分页管理存在的问题</p>\n<ul>\n<li><p>地址变换过程必须足够快，否则访存速率会降低</p>\n</li>\n<li><p>页表不能太大，否则会降低内存利用率</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>具有快表的地址交换机构</p>\n<ul>\n<li><p>可优化方向：如果页表放在内存中，取地址访问一次内存，按照地址取出数据访问一次内存，共需要两次访问内存</p>\n</li>\n<li><p>优化：地址变换机构中增加一个且有并性查找能力的高速缓冲寄存器（快表），所以只需要访问一次高速缓存和一次内存</p>\n<ul>\n<li>快表既可以按照地址查找也可以按照内容查找</li>\n</ul>\n</li>\n<li><p>快表，又称联想寄存器（TLB）</p>\n<ul>\n<li><p>是一种访问速度比内存快很多的高速缓存（TLB不是内存！）</p>\n</li>\n<li><p>用来存放最近访问的页表项的副本，可以加速地址变换的速度。</p>\n</li>\n<li><p>与此对应，内存中的页表常称为慢表</p>\n</li>\n<li><p>TLB与高速缓存区别：TLB （一个硬件）中只存放页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p>\n<ul>\n<li>即，TLB是只存放页表项的高速缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>存储设备</p>\n<ul>\n<li><p>内存：将CPU要访问的数据放在内存中，缓和CPU与硬盘读取速度的矛盾</p>\n</li>\n<li><p>高速缓存：内存虽然已经比硬盘快很多了，但是CPU的处理速度还是比高速缓存快的多，所以将最近有可能被频繁访问的数据放到高速缓存中</p>\n<ul>\n<li><p>CPU先访问高速缓存，找到所需要的数据，就不再访问内存</p>\n</li>\n<li><p>由于高速缓存的内存空间很小，所以不可能将整个快表全都放进高速缓存中</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>访问一个逻辑地址的访存次数</p>\n<ul>\n<li><p>基本地址变换机构</p>\n<ul>\n<li>两次访存</li>\n</ul>\n</li>\n<li><p>具有快表的地址变换机构</p>\n<ul>\n<li><p>快表命中，只需一次访存</p>\n</li>\n<li><p>快表末命中，需要两次访存</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>变换过程</p>\n<ul>\n<li><p>查找图示<img src=\"https://api2.mubu.com/v3/document_image/38531f73-f4c2-41fe-bb6b-eeb4f2344018-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>1、进程上处理机运行（进程切换）后，系统会清空快表（一个硬件）的内容</p>\n</li>\n<li><p>2、越界检查</p>\n</li>\n<li><p>3、查询快表，是否命中</p>\n</li>\n<li><p>4、若快表命中，直接从快表中找到该页号对应的内存块号，与页内偏移量拼接成物理地址</p>\n</li>\n<li><p>5、若快表不命中，再按照正常方式从页表中查询相应页表项，并将该页表项存入快表中（按照一定策略）</p>\n</li>\n</ul>\n</li>\n<li><p>变换过程——文字</p>\n<ul>\n<li><p>1、CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较</p>\n</li>\n<li><p>2、如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可</p>\n</li>\n<li><p>3、 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p>\n</li>\n</ul>\n</li>\n<li><p>性能：</p>\n<ul>\n<li><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到 90% 以上。</p>\n<ul>\n<li><p>局部性原理：</p>\n<ul>\n<li><p>时间局部性：程序中存在大量的循环</p>\n<ul>\n<li><p>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行</p>\n</li>\n<li><p>如果某个数据被访问过，不久之后该数据很可能再次被访问</p>\n</li>\n</ul>\n</li>\n<li><p>空间局部性：很多数据在内存中都是连续存放的</p>\n<ul>\n<li><p>程序对应的指令，很有可能集中存放一个或几个页面中</p>\n</li>\n<li><p>程序中定义的变量，很有可能集中存放在一个或几个页面中</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>例题：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？</p>\n<ul>\n<li><p>(1+100) * 0.9 + (1+100+100) * 0.1 &#x3D; 111 us</p>\n</li>\n<li><p>若支持快表和慢表同时查找，平均耗时应该是 (1+100) * 0.9 + (100+100) * 0.1 &#x3D;110.9 us<img src=\"https://api2.mubu.com/v3/document_image/7542c512-c73d-48ac-b6ab-1f8bf0fa8b30-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>若未采用快表机制，则访问一个逻辑地址需要 100+100 &#x3D; 200us</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>有无快表的对比<img src=\"https://api2.mubu.com/v3/document_image/38677fac-d419-456d-acf9-a28636ae3423-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>两级页表</p>\n<ul>\n<li><p>单级页表存在的问题，如何解决</p>\n<ul>\n<li><p>问题：</p>\n<ul>\n<li><p>1、页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</p>\n</li>\n<li><p>2、没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</p>\n</li>\n</ul>\n</li>\n<li><p>解决：</p>\n<ul>\n<li><p>解决问题1：两级页表</p>\n</li>\n<li><p>解决问题2：虚拟存储技术（在需要访问页面时才把页面调入内存）</p>\n<ul>\n<li><p>在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p>\n</li>\n<li><p>若想访问的页面不在内存中，则产生缺页中断（内中断&#x2F;异常），然后将目标页面从外存调入内存</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两级页表的原理、逻辑地址结构</p>\n<ul>\n<li><p>原理：</p>\n<ul>\n<li><p>将页表进行分组，使得每一个内存块刚好可以放入一个分组（各个分组离散地放入各个内存块中）</p>\n</li>\n<li><p>为离散分配的页表再建立一张页表，称为页目录表（&#x3D;外层页表&#x3D;顶层页表）</p>\n</li>\n</ul>\n</li>\n<li><p>地址结构<img src=\"https://api2.mubu.com/v3/document_image/9e10c503-67bf-4c88-adea-db5e476bb15b-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>页目录表包括</p>\n<ul>\n<li><p>页号：二级页表的页号</p>\n</li>\n<li><p>内存块号：二级页表的块号</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>地址变换过程（逻辑地址转换为物理地址）</p>\n<ul>\n<li><p>1、按照地址结构将逻辑地址拆分成三部分</p>\n</li>\n<li><p>2、从PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p>\n</li>\n<li><p>3、根据二级页号查二级页表，找到最终想访问的内存块号</p>\n</li>\n<li><p>4、结合页内偏移量得到物理地址</p>\n</li>\n</ul>\n</li>\n<li><p>两级页表问题需要注意的几个小细节</p>\n<ul>\n<li><p>1、若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说各级页表的大小不能超过一个页面</p>\n<ul>\n<li><p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？</p>\n<ul>\n<li><p>页面大小 &#x3D; 4KB &#x3D;212B，按字节编址，因此页内偏移量为12位</p>\n</li>\n<li><p>页号 &#x3D; 40 - 12 &#x3D; 28 位</p>\n</li>\n<li><p>页面大小 &#x3D; 2^12B，页表项大小 &#x3D; 4B ，则每个页面可存放 2^12 &#x2F; 4 &#x3D; 2^10 个页表项</p>\n</li>\n<li><p>因此各级页表最多包含 2^10 个页表项，因此每一级的页表对应页号应为10位</p>\n</li>\n<li><p>所以28位的页号至少要分为三级</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>2、两级页表的访存次数分析（假设没有快表机构）——3次访存</p>\n<ul>\n<li><p>第一次访存：访问内存中的页目录表</p>\n</li>\n<li><p>第二次访存：访问内存中的二级页表</p>\n</li>\n<li><p>第三次访存：访问目标内存单元</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本分段存储管理方式\"><a href=\"#基本分段存储管理方式\" class=\"headerlink\" title=\"基本分段存储管理方式\"></a>基本分段存储管理方式</h2><ul>\n<li><p>出发点</p>\n<ul>\n<li><p>分页是从计算机角度考虑设计的，目的是为了内存的利用率，提高计算机性能，分页通过硬件机制实现，对用户完全透明</p>\n</li>\n<li><p>分段是从用户和程序员的角度提出，满足方便编程，信息保护和共享，动态增长及动态链接等多方面的需要</p>\n</li>\n</ul>\n</li>\n<li><p>分段</p>\n<ul>\n<li><p>如何分段：</p>\n<ul>\n<li>按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</li>\n</ul>\n</li>\n<li><p>内存分配规则：</p>\n<ul>\n<li>以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<ul>\n<li><p>由于是按逻辑功能模块划分，用户编程更方便，程序的可读性更高</p>\n</li>\n<li><p>LOAD 1, [D] | <A>;  &#x2F;&#x2F;将分段D中A单元内的值读入寄存器1</p>\n<ul>\n<li><p>写程序时使用的段名 [D]、[X] 会被编译程序翻译成对应段号</p>\n<ul>\n<li><p>用户编程时，使用段名操作各个段</p>\n</li>\n<li><p>CPU执行时，使用段号</p>\n</li>\n</ul>\n</li>\n<li><p><A>单元（助记符）、<B>单元会被编译程序翻译成段内地址</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>地址结构</p>\n<ul>\n<li><p>段号S+段内偏移量W</p>\n<ul>\n<li><p>段号的位数决定了每个进程最多可以分几个段</p>\n</li>\n<li><p>段内地址位数决定了每个段的最大长度是多少</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>段表</p>\n<ul>\n<li><p>背景：</p>\n<ul>\n<li><p>程序分多个段，各段离散地装入内存</p>\n</li>\n<li><p>为了保证程序能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”</p>\n</li>\n</ul>\n</li>\n<li><p>段表结构</p>\n<ul>\n<li>段号、段长、段基址（该段在内存中的起始地址）</li>\n</ul>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><p>各个段表项的长度是相同的</p>\n<ul>\n<li><p>段长的位数&#x3D;段内地址的位数</p>\n</li>\n<li><p>基址&#x3D;能表示整个物理内存地址空间的位数</p>\n</li>\n</ul>\n</li>\n<li><p>段号是隐含的，不占存储空间</p>\n</li>\n</ul>\n</li>\n<li><p>段表内容&#x3D;段号+段长+本段在主存中的地址</p>\n</li>\n</ul>\n</li>\n<li><p>地址变换机构</p>\n<ul>\n<li><p>变换过程<img src=\"https://api2.mubu.com/v3/document_image/e3c5de56-9ced-48bf-b50b-f2fa221dcc70-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>1、根据逻辑地址A得到段号S和段内偏移量W</p>\n</li>\n<li><p>2、判断段号是否越界</p>\n<ul>\n<li>比较段号S和段表长度M，若S&gt;&#x3D;M，则产生越界中断，否则继续执行</li>\n</ul>\n</li>\n<li><p>3、查询段表，找到相应的段表项</p>\n<ul>\n<li>段号S对应的段表项地址&#x3D;段表始址F+段号S*段表项长度</li>\n</ul>\n</li>\n<li><p>4、检查段内地址（W）是否超过段长（C）</p>\n<ul>\n<li>若W≥C，则产生越界中断，否则继续执行</li>\n</ul>\n</li>\n<li><p>5、计算得到物理地址E&#x3D;b+W</p>\n<ul>\n<li><p>段表项中该段的始址b</p>\n</li>\n<li><p>段内地址W</p>\n</li>\n</ul>\n</li>\n<li><p>6、用得到的物理地址E去访问内存</p>\n</li>\n</ul>\n</li>\n<li><p>分段、分页管理的对比</p>\n<ul>\n<li><p>区别：</p>\n<ul>\n<li><p>分页：</p>\n<ul>\n<li><p>页是信息的物理单位</p>\n</li>\n<li><p>目的是为了实现离散分配，提高内存利用率</p>\n</li>\n<li><p>系统行为，对用户是不可见的</p>\n</li>\n<li><p>页的大小固定且由系统决定</p>\n</li>\n<li><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址</p>\n<ul>\n<li><p>一个进程的地址空间是连续的</p>\n</li>\n<li><p>例如：LOAD 1, <A>;</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分段：</p>\n<ul>\n<li><p>段是信息的逻辑单位</p>\n</li>\n<li><p>目的是更好地满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息</p>\n</li>\n<li><p>分段对用户是可见的</p>\n</li>\n<li><p>段的长度是不固定的，决定于用户编写的程序</p>\n</li>\n<li><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要显式地给出段名，也要给出段内地址</p>\n<ul>\n<li><p>一个进程的地址空间是不连续的，被分为一个个的段</p>\n</li>\n<li><p>例如：LOAD 1, [D] | <A>;</p>\n</li>\n</ul>\n</li>\n<li><p>分段更容易实现共享和保护</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>段的共享与保护</p>\n<ul>\n<li><p>共享：</p>\n<ul>\n<li><p>功能段：可以存在一个段，用来判断缓冲区此时是否可访问</p>\n<ul>\n<li>用于允许所有生产者、消费者进程共享访问</li>\n</ul>\n</li>\n<li><p>如何实现两个进程共享的使用一个段：两个进程的段表项指向相同的基址</p>\n</li>\n<li><p>共享的对象：纯代码（可重入代码）</p>\n<ul>\n<li><p>纯代码：不能被修改的代码</p>\n<ul>\n<li>不属于临界资源，是可以共享的，两个进程可以并发访问</li>\n</ul>\n</li>\n<li><p>可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</p>\n</li>\n</ul>\n</li>\n<li><p>对比：分页不是按照逻辑结构划分的，所以很难实现共享</p>\n</li>\n</ul>\n</li>\n<li><p>保护机制</p>\n<ul>\n<li><p>如何实现：段表项中添加一个数据，是否允许其它进程访问</p>\n</li>\n<li><p>对比：分页不是按照逻辑结构划分</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分段存储需要两次访存</p>\n<ul>\n<li><p>1、查询内存中的段表</p>\n</li>\n<li><p>2、查询目标内存单元</p>\n</li>\n<li><p>与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"段页式管理方式\"><a href=\"#段页式管理方式\" class=\"headerlink\" title=\"段页式管理方式\"></a>段页式管理方式</h2><ul>\n<li><p>分段与分页优缺点</p>\n<ul>\n<li><p>分页管理</p>\n<ul>\n<li><p>优点：内存空间利用率高，不会产生外部碎片，只会有少量的内部碎片</p>\n</li>\n<li><p>缺点：不方便按照逻辑模块实现信息的共享和保护</p>\n</li>\n</ul>\n</li>\n<li><p>分段管理</p>\n<ul>\n<li><p>优点：很方便按照逻辑模块实现信息的共享和保护</p>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>如果段长过大，为其分配很大的连续空间会很不方便</p>\n</li>\n<li><p>段式管理会产生外部碎片（虽然也可以使用“紧凑”技术解决，但是需要付出时间代价）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分段和分页的结合——段页式管理方式</p>\n<ul>\n<li><p>将进程先按照逻辑模块分段，然后将各个段分页（如每个页面4KB）</p>\n</li>\n<li><p>再将内存空间分为大小相等的内存块（页框、页帧、物理块号&#x3D;进程页面大小4KB）</p>\n</li>\n<li><p>将进程的各个页面被放到内存块中</p>\n</li>\n</ul>\n</li>\n<li><p>段页式的逻辑地址结构</p>\n<ul>\n<li><p>段号S+页号P+页内偏移量W</p>\n<ul>\n<li><p>段号的位数决定了每个进程最多可以分几个段</p>\n</li>\n<li><p>页号位数决定了每个段最大有多少页</p>\n</li>\n<li><p>页内偏移量决定了页面大小、内存块大小是多少</p>\n</li>\n</ul>\n</li>\n<li><p>段页式管理的地址结构是二维的</p>\n<ul>\n<li><p>“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址</p>\n</li>\n<li><p>将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>段表、页表</p>\n<ul>\n<li><p>段表：段号、页表长度、页表存放块号</p>\n<ul>\n<li><p>根据块号即可算出页表存放的内存地址</p>\n</li>\n<li><p>每个段表项长度相等，段号是隐含的</p>\n</li>\n<li><p>每个段对应一个段表项</p>\n</li>\n<li><p>一个进程对应一个段表</p>\n</li>\n</ul>\n</li>\n<li><p>页表：页号、内存块号</p>\n<ul>\n<li><p>每个页对应一个页表项</p>\n</li>\n<li><p>每个页表项长度相等，页号是隐含的</p>\n</li>\n<li><p>一个进程可能对应多个页表</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>硬件：段表寄存器</p>\n<ul>\n<li><p>段表始址F</p>\n</li>\n<li><p>段表长度M</p>\n</li>\n</ul>\n</li>\n<li><p>如何实现地址转换</p>\n<ul>\n<li><p>1、根据逻辑地址得到段号S、页号P、页内偏移量M</p>\n</li>\n<li><p>2、判断段号是否越界。</p>\n<ul>\n<li>若S≥M，则产生越界中断，否则继续执行</li>\n</ul>\n</li>\n<li><p>3、查询段表，找到对应的段表项——第一次访存</p>\n<ul>\n<li>段表项的存放地址为F+S*段表项长度</li>\n</ul>\n</li>\n<li><p>4、检查页号是否越界</p>\n<ul>\n<li><p>（每个页对应的页表大小不同）</p>\n</li>\n<li><p>若页号≥页表长度，则发生越界中断，否则继续执行</p>\n</li>\n</ul>\n</li>\n<li><p>5、根据页表存放块号和页号查询页表，找到对应页表项——第二次访存</p>\n</li>\n<li><p>6、根据内存块号、页内偏移量得到最终的物理地址</p>\n</li>\n<li><p>7、访问目标内存单元——第三次访存</p>\n</li>\n</ul>\n</li>\n<li><p>访存次数：3次</p>\n<ul>\n<li><p>1、访问段表</p>\n</li>\n<li><p>2、访问页表</p>\n</li>\n<li><p>3、访问目标内存单元</p>\n</li>\n<li><p>优化：也可引入快表机构</p>\n<ul>\n<li>用段号和页号作为查询快表的关键字。若快表命中则仅需一次访存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"虚拟内存管理\"><a href=\"#虚拟内存管理\" class=\"headerlink\" title=\"虚拟内存管理\"></a>虚拟内存管理</h1><h2 id=\"虚拟内存的基本概念\"><a href=\"#虚拟内存的基本概念\" class=\"headerlink\" title=\"虚拟内存的基本概念\"></a>虚拟内存的基本概念</h2><ul>\n<li><p>传统存储管理方式的特征、缺点</p>\n<ul>\n<li><p>一次性：作业必须一次性全部装入内存后，才能开始运行</p>\n<ul>\n<li><p>作业很大无法装入则无法运行</p>\n</li>\n<li><p>大量作业要求运行时，由于内存不足，只能一部分作业先运行，导致多道程序度下降</p>\n</li>\n</ul>\n</li>\n<li><p>驻留性：作业装入内存后，一直驻留在内存中，任何部分不会被换出</p>\n</li>\n</ul>\n</li>\n<li><p>局部性原理</p>\n<ul>\n<li><p>时间局部性</p>\n<ul>\n<li><p>一条指令执行后，不就之后指令可能被再次执行，数据被访问后，不久后数据可能再次被访问</p>\n</li>\n<li><p>原因：程序中存在着大量的循环操作</p>\n</li>\n<li><p>解决：将最近使用的指令和数据存储在高速缓冲存储器中</p>\n</li>\n</ul>\n</li>\n<li><p>空间局部性</p>\n<ul>\n<li><p>一旦程序访问了某个存储单元，不久之后附近的存储单元也将被访问</p>\n</li>\n<li><p>原因：指令通常是顺序存放，顺序执行的，数据一般也是以向量、数组、表等形式簇聚存储的</p>\n</li>\n<li><p>解决：使用较大的高速缓存，将预取机制集成到高速缓存控制逻辑中实现</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>虚拟存储器的定义和特征</p>\n<ul>\n<li><p>基于局部性原理，程序的一部分装入内存，一部分留在外存，需要的时候将外存内容调入内存，就好像产生了一个巨大的内存空间</p>\n<ul>\n<li><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</p>\n</li>\n<li><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>\n</li>\n<li><p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</p>\n</li>\n</ul>\n</li>\n<li><p>注：虚拟内存的最大容量、虚拟内存的实际容量</p>\n<ul>\n<li><p>虚拟内存的最大容量由计算机的地址结构（CPU寻址范围）确定的</p>\n</li>\n<li><p>虚拟内存的实际容量 &#x3D; min（内存和外存容量之和，CPU寻址范围）</p>\n</li>\n<li><p>例题：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。</p>\n<ul>\n<li><p>虚拟内存的最大容量为 232 B &#x3D; 4GB</p>\n</li>\n<li><p>虚拟内存的实际容量 &#x3D; min (232B, 512MB+2GB) &#x3D; 2GB+512MB</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特征</p>\n<ul>\n<li><p>多次性：作业在运行时，分多次调入内存运行</p>\n</li>\n<li><p>对换性：作业不必一直驻留内存，允许作业在运行过程中进行换进换出</p>\n</li>\n<li><p>虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于实际的内存容量</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>虚拟内存技术的实现</p>\n<ul>\n<li><p>建立在离散分配的内存管理方式上</p>\n<ul>\n<li>如果采用连续分配方式，进程所占的连续存储空间会越来越大，且需要预留大量存储空间，所以不方便实现</li>\n</ul>\n</li>\n<li><p>实现方式</p>\n<ul>\n<li><p>请求分页存储管理</p>\n</li>\n<li><p>请求分段存储管理</p>\n</li>\n<li><p>请求段页式存储管理</p>\n</li>\n</ul>\n</li>\n<li><p>虚拟内存的和传统的非连续分配存储管理方式的主要区别</p>\n<ul>\n<li><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</p>\n<ul>\n<li>操作系统要提供请求调页（或请求调段）功能</li>\n</ul>\n</li>\n<li><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>\n<ul>\n<li>操作系统要提供页面置换（或段置换）的功能</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>硬件支持</p>\n<ul>\n<li><p>一定容量的内存和外存</p>\n</li>\n<li><p>页表机制（或者段表机制）</p>\n</li>\n<li><p>中断机构</p>\n</li>\n<li><p>地址变换机构</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"请求分页管理方式\"><a href=\"#请求分页管理方式\" class=\"headerlink\" title=\"请求分页管理方式\"></a>请求分页管理方式</h2><ul>\n<li><p>系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能</p>\n</li>\n<li><p>页表机制</p>\n<ul>\n<li><p>区别1：请求分页管理中，为了实现“请求调页”</p>\n<ul>\n<li><p>操作系统需要知道每个页面是否已经调入内存</p>\n</li>\n<li><p>如果还没调入，那么也需要知道该页面在外存中存放的位置</p>\n</li>\n</ul>\n</li>\n<li><p>区别2：当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面</p>\n<ul>\n<li><p>有的页面没有被修改过，就不用再浪费时间写回外存</p>\n</li>\n<li><p>有的页面修改过，就需要将外存中的旧数据覆盖，因此操作系统也需要记录各个页面</p>\n</li>\n</ul>\n</li>\n<li><p>组成</p>\n<ul>\n<li><p>页号</p>\n</li>\n<li><p>物理块号</p>\n</li>\n<li><p>状态位P：是否已调入内存</p>\n</li>\n<li><p>访问字段A：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考</p>\n</li>\n<li><p>修改位M：页面调入内存后是否被修改过</p>\n</li>\n<li><p>外存地址：页面在外存中的存放位置（通常是物理块号）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺页中断机构</p>\n<ul>\n<li><p>当访问页面不在内存时，就会产生缺页中断</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>指令执行期间产生中断，而不是指令执行之后产生中断和处理中然后由操作系统的缺页中断处理程序处理中断</p>\n</li>\n<li><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列</p>\n</li>\n<li><p>如果内存中有空闲块，则可以将这个空闲块分配给缺页进程，将目标页面从外存放入内存中，并修改页表中相应的页表项</p>\n</li>\n<li><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若淘汰的页面在内存期间被修改过，则要将其写回外存。若淘汰的页面未修改过就不用写回外存</p>\n</li>\n<li><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p>\n</li>\n<li><p>一条指令在执行期间，可能产生多次缺页中断</p>\n<ul>\n<li>一条指令可能会访问多个内存单元，将A复制到B，如果A、B不处于同一个页面，就有可能发送两次缺页中断</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>地址变换机构</p>\n<ul>\n<li><p>新增步骤</p>\n<ul>\n<li><p>1、请求调页（查到页表项时，对页面是否在内存进行判断）</p>\n</li>\n<li><p>2、页面置换（需要调入页面，但没有空闲内存块时进行页面置换）</p>\n</li>\n<li><p>3、需要修改请求页表中新增的表项</p>\n</li>\n</ul>\n</li>\n<li><p>如何实现地址转换</p>\n<ul>\n<li><p>在快表中的页面一定是在内存中的</p>\n<ul>\n<li>若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面</li>\n</ul>\n</li>\n<li><p>在慢表中，找到对应页表项后，若对应页面未调入内存，则产生缺页中断，之后由操作系统的缺页中断处理程序进行处理</p>\n</li>\n</ul>\n</li>\n<li><p>细节：</p>\n<ul>\n<li><p>1、只有“写指令”才需要修改“修改位”。并且一般来说只需修改快表中的数据</p>\n<ul>\n<li><p>修改位：内存中的数据被修改过，才改变</p>\n</li>\n<li><p>只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数</p>\n</li>\n</ul>\n</li>\n<li><p>2、和普通的中断处理一样，缺页中断处理依然需要保留CPU现场</p>\n</li>\n<li><p>3、需要用某种“页面置换算法”来决定一个换出页面</p>\n</li>\n<li><p>4、换入&#x2F;换出页面都需要启动慢速的I&#x2F;O操作，如果换入&#x2F;换出太频繁，会有很大的开销</p>\n</li>\n<li><p>5、页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中</p>\n</li>\n<li><p>6、访问一个逻辑地址时，若发生缺页，则地址变换步骤是：</p>\n<ul>\n<li>查快表(未命中)——查慢表(发现未调入内存)——调页(调入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h2><ul>\n<li><p>最佳置换算法（OPT）</p>\n<ul>\n<li><p>选择永不使用或者最长时间内不再访问的页面进行淘汰，但是现实中是无法预知的<img src=\"https://api2.mubu.com/v3/document_image/3611414e-4452-4a26-8dbe-c54a19daea90-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>实现：选择目前在内存中且将会在最后被访问的页面，进行淘汰</p>\n</li>\n<li><p>结果：整个过程缺页中断发生了9次，页面置换发生了6次</p>\n<ul>\n<li>缺页时未必发生页面置换，也就是说如果还有可用的空闲内存块，就不用进行页面置换。</li>\n</ul>\n</li>\n<li><p>缺页率：缺页次数&#x2F;访问页面总次数&#x3D;9&#x2F;20&#x3D;45%</p>\n</li>\n<li><p>优点：缺页率最小，性能最好</p>\n</li>\n<li><p>缺点：最佳置换算法是无法实现的</p>\n<ul>\n<li>操作系统无法提前预判页面访问序列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>先进先出页面置换算法（FIFO）</p>\n<ul>\n<li><p>优先淘汰最早进入的页面</p>\n</li>\n<li><p>实现：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可</p>\n<ul>\n<li>队列的最大长度取决于系统为进程分配了多少个内存块</li>\n</ul>\n</li>\n<li><p>优点：实现简单</p>\n</li>\n<li><p>缺点：算法性能差，Belady异常</p>\n</li>\n<li><p>Belady异常：增大分配的物理块数但是故障数不减反增</p>\n<ul>\n<li><p>只有先进先出算法会出现</p>\n</li>\n<li><p>原因：先进入的页面有可能最经常被访问</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>最近最久未使用（LRU）置换算法</p>\n<ul>\n<li><p>选择最近最长时间没有被访问的页面进行淘汰，每个页面设置一个访问字段，用来标识上次被访问到现在经历的时间</p>\n</li>\n<li><p>优点：性能好</p>\n</li>\n<li><p>缺点：实现复杂、需要寄存器和栈的硬件支持、LRU是堆栈类算法</p>\n</li>\n</ul>\n</li>\n<li><p>时钟（CLOCK）置换算法（最近未用算法）</p>\n<ul>\n<li><p>增加访问位，优先淘汰最近没有被访问过的页面</p>\n<ul>\n<li><p>访问位&#x3D;1，说明最近被访问过</p>\n</li>\n<li><p>访问位&#x3D;0，说明最近没有被访问过</p>\n</li>\n</ul>\n</li>\n<li><p>实现</p>\n<ul>\n<li><p>为每个页面设置一个使用位（访问位），再将内存中的页面都通过链接指针链接成一个循环队列</p>\n</li>\n<li><p>当需要淘汰一个页面时，只需检查存放在内存块中的页的访问位，如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面</p>\n</li>\n<li><p>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描时访问位应该均为0），因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描</p>\n</li>\n</ul>\n</li>\n<li><p>优点：性能接近于最佳置换算法、实现简单、开销小</p>\n</li>\n<li><p>缺点：未考虑页面是否被修改过</p>\n</li>\n</ul>\n</li>\n<li><p>改进型CLOCK算法</p>\n<ul>\n<li><p>在使用位（访问位）的基础上增加修改位，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存，使得性能提升</p>\n<ul>\n<li><p>修改位&#x3D;0，表示页面没有被修改过</p>\n</li>\n<li><p>修改位&#x3D;1，表示页面被修改过</p>\n</li>\n</ul>\n</li>\n<li><p>扫描过程</p>\n<ul>\n<li><p>为每个页面设置一个使用位（访问位）和修改位，再将内存中的页面都通过链接指针链接成一个循环队列</p>\n</li>\n<li><p>第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p>\n<ul>\n<li>第一优先级：最近没访问，且没修改的页面</li>\n</ul>\n</li>\n<li><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。且本轮将所有扫描过的帧访问位设为0</p>\n<ul>\n<li>第二优先级：最近没访问，但修改过的页面</li>\n</ul>\n</li>\n<li><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p>\n<ul>\n<li>第三优先级：最近访问过，但没修改的页面</li>\n</ul>\n</li>\n<li><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换</p>\n<ul>\n<li>第四优先级：最近访问过，且修改过的页面</li>\n</ul>\n</li>\n<li><p>注：由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</p>\n</li>\n</ul>\n</li>\n<li><p>优点：相对于未改进型，节省了时间</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"页面分配策略\"><a href=\"#页面分配策略\" class=\"headerlink\" title=\"页面分配策略\"></a>页面分配策略</h2><ul>\n<li><p>驻留集：请求分页存储管理中给一个进程的分配的物理块的集合</p>\n<ul>\n<li><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小</p>\n</li>\n<li><p>驻留集大小的考虑因素</p>\n<ul>\n<li><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少</p>\n</li>\n<li><p>驻留集太大，会导致多道程序并发度下降，资源利用率降低</p>\n</li>\n<li><p>所以应该选择一个合适的驻留集大小</p>\n</li>\n</ul>\n</li>\n<li><p>根据驻留集大小是否改变分类</p>\n<ul>\n<li><p>固定分配：驻留集大小不变</p>\n<ul>\n<li>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变</li>\n</ul>\n</li>\n<li><p>可变分配：驻留集大小可变</p>\n<ul>\n<li>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>根据置换时，置换的范围分类</p>\n<ul>\n<li><p>局部置换：发生缺页时只能选进程自己的物理块进行置换</p>\n</li>\n<li><p>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>页面分配、置换策略</p>\n<ul>\n<li><p>固定分配局部置换</p>\n<ul>\n<li><p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变</p>\n</li>\n<li><p>若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</p>\n</li>\n<li><p>缺点：很难在刚开始就确定应为每个进程分配多少个物理块才算合理</p>\n<ul>\n<li>采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>可变分配全局置换</p>\n<ul>\n<li><p>刚开始会为每个进程分配一定数量的物理块，在整个运行期间物理块数可以改变。操作系统会保持一个空闲物理块队列。</p>\n</li>\n<li><p>当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程</p>\n<ul>\n<li>未锁定：系统会锁定一些页面，这些页面中的内容不能置换出外存（例如：重要的内核数据可以设为“锁定”）</li>\n</ul>\n</li>\n<li><p>采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出</p>\n</li>\n<li><p>缺点：被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程（被调出页的进程）拥有的物理块会减少，缺页率会增加</p>\n</li>\n<li><p>优点：最容易实现，动态调整物理块分配</p>\n</li>\n<li><p>缺点：如果盲目分配物理块，就会导致多道程序并发能力下降</p>\n</li>\n</ul>\n</li>\n<li><p>可变分配局部置换</p>\n<ul>\n<li><p>刚开始会为每个进程分配一定数量的物理块</p>\n</li>\n<li><p>当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存</p>\n</li>\n<li><p>如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块</p>\n</li>\n<li><p>优点：保持了系统的多道程序并发能力</p>\n</li>\n<li><p>缺点：增大了开销，实现复杂</p>\n</li>\n</ul>\n</li>\n<li><p>不存在固定分配全局置换</p>\n<ul>\n<li>如果使用全局置换，意味着进程拥有的物理块数量必然会改变，因此不可能是固定分配</li>\n</ul>\n</li>\n<li><p>区别</p>\n<ul>\n<li><p>可变分配全局置换：只要缺页就给分配新物理块（物理块数只会增加）</p>\n</li>\n<li><p>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块（物理块数有可能增加，有可能减少）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>调入页面的时机（一般情况下两种策略同时使用）</p>\n<ul>\n<li><p>预调页策略：运行前调入</p>\n<ul>\n<li><p>将预计不久被访问的页面调入，成功率约为50%</p>\n</li>\n<li><p>根据局部性原理（主要指空间局部性），即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元</p>\n</li>\n<li><p>如果提前调入的页面中大多数都没被访问过，则是低效的</p>\n</li>\n<li><p>主要用于进程的首次调入，由程序员指出应该先调入哪些部分</p>\n</li>\n</ul>\n</li>\n<li><p>请求调页策略：进程时调入</p>\n<ul>\n<li><p>当进程提出缺页的时候，再按照一定策略进行调页</p>\n</li>\n<li><p>特点：一次调入一页，这种策略调入的页面一定会被访问到，调入&#x2F;调出页面次数很多时，会产生较大的I&#x2F;O开销</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>从何处调入页</p>\n<ul>\n<li><p>外存分为对换区和文件区</p>\n<ul>\n<li><p>对换区：读&#x2F;写 速度更快，采用连续分配方式</p>\n</li>\n<li><p>文件区：读&#x2F;写 速度更慢，采用离散分配方式</p>\n</li>\n<li><p>运行前将相关数据从文件区复制到对换区</p>\n</li>\n</ul>\n</li>\n<li><p>1、系统拥有足够的对换空间</p>\n<ul>\n<li><p>页面的调入、调出都是在内存与对换区之间进行，速度快</p>\n</li>\n<li><p>在进程运行前，需将进程相关的数据从文件区复制到对换区</p>\n</li>\n</ul>\n</li>\n<li><p>2、系统缺少足够的对换区空间</p>\n<ul>\n<li><p>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可</p>\n</li>\n<li><p>对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入</p>\n<ul>\n<li>原理：读速度比写速度块</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UNIX方式</p>\n<ul>\n<li><p>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入</p>\n</li>\n<li><p>若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>抖动</p>\n<ul>\n<li><p>刚换出的页面又要换入内存，刚刚换入的页面马上又要换出外存</p>\n</li>\n<li><p>原因</p>\n<ul>\n<li><p>分配的物理块数不足（主要原因）</p>\n</li>\n<li><p>置换算法不当</p>\n</li>\n</ul>\n</li>\n<li><p>解决：适当分配物理块数</p>\n<ul>\n<li>为了研究为应该为每个进程分配多少个物理块，提出了进程“工作集”的概念</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>工作集</p>\n<ul>\n<li><p>某段时间内，进程要访问的页面集合</p>\n</li>\n<li><p>操作系统会根据“窗口尺寸”来算出工作集</p>\n</li>\n<li><p>例如：某进程的页面访问序列如下，窗口尺寸为 4，各时刻的工作集为</p>\n<ul>\n<li><p>访问序列：24，15，18，23，24，17，18，24，18，17，17，15</p>\n</li>\n<li><p>1、工作集大小可能小于窗口尺寸</p>\n<ul>\n<li>工作集：一个窗口尺寸内，进程实际访问的不同页面的个数</li>\n</ul>\n</li>\n<li><p>2、实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块</p>\n<ul>\n<li>如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</p>\n</li>\n<li><p>拓展：根据进程近期访问的页面集合（工作集）来设计一种页面置换算法</p>\n<ul>\n<li><p>原因：基于局部性原理可知，进程最近访问的页面与不久之后会访问的页面是有相关性的</p>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>落入工作集的页面需要调入驻留集中，落在工作集外面的页面可以从驻留集中换出</p>\n</li>\n<li><p>若还有空闲物理块，可以再调入一进程到内存以增加多道程序并发度</p>\n</li>\n<li><p>若所有进程的工作集之和超过了可用物理块的总数，操作系统就会暂停一个进程，并将其页面调出并将其物理块分配给其他进程</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","2.操作系统","3.内存管理"],"tags":["写作"]},{"title":"输入输出管理","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/","content":"<h1 id=\"I-x2F-O管理概述\"><a href=\"#I-x2F-O管理概述\" class=\"headerlink\" title=\"I&#x2F;O管理概述\"></a>I&#x2F;O管理概述</h1><h2 id=\"I-x2F-O设备的基本概念与分类\"><a href=\"#I-x2F-O设备的基本概念与分类\" class=\"headerlink\" title=\"I&#x2F;O设备的基本概念与分类\"></a>I&#x2F;O设备的基本概念与分类</h2><ul>\n<li><p>什么是I&#x2F;O设备</p>\n<ul>\n<li><p>可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件</p>\n</li>\n<li><p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作</p>\n</li>\n<li><p>Write操作：向外部设备写出数据</p>\n</li>\n<li><p>Read操作：从外部设备读入数据</p>\n</li>\n</ul>\n</li>\n<li><p>按使用特性分类</p>\n<ul>\n<li><p>人机交互类外部设备：数据传输速度慢（打印机，鼠标，键盘）</p>\n</li>\n<li><p>存储设备：数据传输速度快（移动硬盘，光盘）</p>\n</li>\n<li><p>网络通信设备：数据传输速度介于上述二者之间（调制解调器）</p>\n</li>\n</ul>\n</li>\n<li><p>按传输速率分类</p>\n<ul>\n<li><p>低速设备（鼠标，键盘）</p>\n</li>\n<li><p>中速设备（激光打印机）</p>\n</li>\n<li><p>高速设备（磁盘）</p>\n</li>\n</ul>\n</li>\n<li><p>按信息交换的单元分类</p>\n<ul>\n<li><p>块设备：传输速率较高，可寻址，即对它可随机地读&#x2F;写任一块（磁盘）</p>\n</li>\n<li><p>字符设备：传输速率较慢，不可寻址，在输入&#x2F;输出时常采用中断驱动方式（鼠标、键盘）</p>\n</li>\n</ul>\n</li>\n<li><p>I&#x2F;O设备：</p>\n<ul>\n<li><p>机械部件</p>\n<ul>\n<li><p>看得见摸得着的</p>\n</li>\n<li><p>主要用来执行具体I&#x2F;O操作</p>\n</li>\n</ul>\n</li>\n<li><p>电子部件（I&#x2F;O控制器、设备控制器）</p>\n<ul>\n<li>通常是一块插入主板扩充槽的印刷电路板</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IO控制器\"><a href=\"#IO控制器\" class=\"headerlink\" title=\"IO控制器\"></a>IO控制器</h2><ul>\n<li><p>定义</p>\n<ul>\n<li><p>CPU无法直接控制I&#x2F;O设备的机械部件，作为中介，用于实现CPU对设备的控制</p>\n</li>\n<li><p>I&#x2F;O控制器，又称设备控制器</p>\n</li>\n<li><p>CPU可控制I&#x2F;O控制器，又由I&#x2F;O控制器来控制设备的机械部件</p>\n</li>\n</ul>\n</li>\n<li><p>功能</p>\n<ul>\n<li><p>接收和识别CPU发出的命令</p>\n<ul>\n<li>I&#x2F;O控制器中有控制寄存器，用于存放命令和参数</li>\n</ul>\n</li>\n<li><p>向CPU报告设备的状态</p>\n<ul>\n<li>I&#x2F;O控制器中有状态寄存器，用于记录I&#x2F;O设备的当前状态</li>\n</ul>\n</li>\n<li><p>数据交换</p>\n<ul>\n<li><p>I&#x2F;O控制器中有数据寄存器</p>\n<ul>\n<li><p>输出时，数据寄存器用于暂存CPU发来的数据，之后再通过控制器传送给设备</p>\n</li>\n<li><p>输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取出数据</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>地址识别</p>\n<ul>\n<li><p>类似于内存的地址，为了区分设备控制器中的各个寄存器，给各个寄存器设置一个地址</p>\n</li>\n<li><p>I&#x2F;O控制器通过CPU提供的地址来查找寄存器</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>组成</p>\n<ul>\n<li><p>CPU与控制器的接口</p>\n<ul>\n<li><p>用于实现CPU与控制器之间的通信</p>\n</li>\n<li><p>CPU通过控制线发出命令</p>\n</li>\n<li><p>通过地址线指明要操作的设备</p>\n</li>\n<li><p>通过数据线来取出（输入）数据，或放入（输出）数据</p>\n</li>\n</ul>\n</li>\n<li><p>I&#x2F;O逻辑</p>\n<ul>\n<li>负责接收和识别CPU的各种命令（如地址译码），并负责对设备发出命令</li>\n</ul>\n</li>\n<li><p>控制器与设备的接口</p>\n<ul>\n<li>用于实现控制器与设备之间的通信</li>\n</ul>\n</li>\n<li><p>值得注意的小细节：</p>\n<ul>\n<li><p>一个I&#x2F;O控制器可能会对应多个设备</p>\n</li>\n<li><p>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制&#x2F;状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两种寄存器编址方式</p>\n<ul>\n<li><p>内存映像I&#x2F;O：控制器中的寄存器与内存地址统一编址</p>\n<ul>\n<li>优点：简化了指令，可以采用对内存进行操作的指令来对控制器进行操作</li>\n</ul>\n</li>\n<li><p>寄存器独立编址：控制器中的寄存器使用单独的地址</p>\n<ul>\n<li>缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"I-x2F-O控制方式\"><a href=\"#I-x2F-O控制方式\" class=\"headerlink\" title=\"I&#x2F;O控制方式\"></a>I&#x2F;O控制方式</h2><ul>\n<li><p>用什么样的方式控制I&#x2F;O设备的数据读&#x2F;写</p>\n</li>\n<li><p>程序直接控制方式</p>\n<ul>\n<li><p>完成一次读&#x2F;写操作的流程</p>\n<ul>\n<li><p>CPU向控制器发出命令</p>\n<ul>\n<li>CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪）</li>\n</ul>\n</li>\n<li><p>将I&#x2F;O状态信息读入CPU寄存器</p>\n</li>\n<li><p>检查状态</p>\n<ul>\n<li>轮询检查控制器的状态（其实就是在不断地执行程序的循环，若状态位一直是1，说明设备还没准备好要输入的数据，于是CPU会不断地轮询）</li>\n</ul>\n</li>\n<li><p>输入设备准备好数据后将数据传给控制器，并报告自身状态</p>\n</li>\n<li><p>控制器将输入的数据放到数据寄存器中，并将状态改为0（已就绪）</p>\n</li>\n<li><p>将数据寄存器中的内容读入CPU寄存器</p>\n<ul>\n<li>CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器</li>\n</ul>\n</li>\n<li><p>把CPU寄存器中的内容放入内存</p>\n</li>\n<li><p>若还要继续读入数据，则CPU继续发出读指令</p>\n</li>\n</ul>\n</li>\n<li><p>流程图<img src=\"https://api2.mubu.com/v3/document_image/b91e3406-21a6-40cd-8998-81487d0695d5-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>CPU干预频率：频繁</p>\n<ul>\n<li><p>I&#x2F;O操作开始之前、完成之后需要CPU介入</p>\n</li>\n<li><p>并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查</p>\n</li>\n</ul>\n</li>\n<li><p>数据传送的单元：每次读&#x2F;写一个字</p>\n</li>\n<li><p>数据的流向</p>\n<ul>\n<li><p>读操作（数据输入）：I&#x2F;O设备—&gt;CPU寄存器—&gt;内存</p>\n</li>\n<li><p>写操作（数据输出）：内存—&gt;CPU寄存器—&gt;I&#x2F;O设备</p>\n</li>\n<li><p>每个字的读&#x2F;写都需要CPU的帮助</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现简单，在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态 ，CPU利用率低</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>中断驱动方式</p>\n<ul>\n<li><p>背景：</p>\n<ul>\n<li><p>引入中断机制</p>\n</li>\n<li><p>由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行</p>\n</li>\n<li><p>当I&#x2F;O完成后，控制器会向CPU发出一个中断信号</p>\n</li>\n<li><p>CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断</p>\n</li>\n<li><p>中断程序：CPU从I&#x2F;O控制器读一个字的数据传送到CPU寄存器，再写入主存</p>\n</li>\n<li><p>CPU恢复等待I&#x2F;O的进程（或其他进程）的运行环境，然后继续执行</p>\n</li>\n</ul>\n</li>\n<li><p>完成一次读&#x2F;写操作的流程</p>\n<ul>\n<li><p>CPU向控制器发出命令，且将该I&#x2F;O进程阻塞</p>\n<ul>\n<li>CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪）</li>\n</ul>\n</li>\n<li><p>检查I&#x2F;O控制器的I&#x2F;O状态信息</p>\n</li>\n<li><p>检查状态</p>\n<ul>\n<li>若状态位是0，I&#x2F;O操作完成，控制器会向CPU发出一个中断信号</li>\n</ul>\n</li>\n<li><p>注意：中断处理带来的影响</p>\n<ul>\n<li><p>CPU会在每个指令周期的末尾检查中断</p>\n</li>\n<li><p>如果中断发生的频率太高，也会降低系统性能。</p>\n<ul>\n<li>中断处理过程中需要保存、恢复进程的运行环境，需要一定时间开销的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CPU干预频率</p>\n<ul>\n<li><p>每次I&#x2F;O操作开始之前、完成之后需要CPU介入</p>\n</li>\n<li><p>等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行，CPU不再进行轮询检查</p>\n</li>\n</ul>\n</li>\n<li><p>数据传送的单元：每次读&#x2F;写一个字</p>\n</li>\n<li><p>数据的流向</p>\n<ul>\n<li><p>读操作（数据输入）：I&#x2F;O设备—&gt;CPU寄存器—&gt;内存</p>\n</li>\n<li><p>写操作（数据输出）：内存—&gt;CPU寄存器—&gt;I&#x2F;O设备</p>\n</li>\n<li><p>每个字的读&#x2F;写都需要CPU的帮助</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成，CPU不再需要不停地轮询</p>\n</li>\n<li><p>CPU和I&#x2F;O设备可并行工作，CPU利用率得到明显提升</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU，频繁的中断处理会消耗较多的CPU时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DMA方式（直接存储器存取）</p>\n<ul>\n<li><p>背景：</p>\n<ul>\n<li><p>数据的传送单位是块</p>\n</li>\n<li><p>数据的流向是从设备直接放入内存，或者从内存直接到设备，不再需要CPU作为中介</p>\n</li>\n<li><p>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</p>\n</li>\n</ul>\n</li>\n<li><p>完成一次读&#x2F;写操作的流程</p>\n<ul>\n<li><p>CPU向DMA控制器发出命令，且将该I&#x2F;O进程阻塞</p>\n<ul>\n<li>CPU指明此次要进行的操作（如：读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）</li>\n</ul>\n</li>\n<li><p>DMA控制器会根据CPU提出的要求完成数据的读&#x2F;写工作，整块数据的传输完成后，向CPU发出中断信号</p>\n</li>\n</ul>\n</li>\n<li><p>DMA控制器</p>\n<ul>\n<li><p>数据寄存器（DR）：用于暂存从设备到内存或者从内存到设备的数据</p>\n</li>\n<li><p>内存地址寄存器（MAR）：</p>\n<ul>\n<li><p>在输入时，MAR 表示数据应放到内存中的什么位置</p>\n</li>\n<li><p>输出时， MAR 表示要输出的数据放在内存中的什么位置</p>\n</li>\n</ul>\n</li>\n<li><p>数据计数器（DC）：表示剩余要读&#x2F;写的字节数</p>\n</li>\n<li><p>命令&#x2F;状态寄存器（CR）：用于存放CPU发来的I&#x2F;O命令，或设备的状态信息</p>\n</li>\n</ul>\n</li>\n<li><p>CPU干预频率</p>\n<ul>\n<li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li>\n</ul>\n</li>\n<li><p>数据传送的单元</p>\n<ul>\n<li>每次读&#x2F;写一个或多个连续的块（读写前在磁盘中是连续的，且读入内存后在内存中也是连续的）</li>\n</ul>\n</li>\n<li><p>数据的流向（不再需要经过CPU）</p>\n<ul>\n<li><p>读操作（数据输入）：I&#x2F;O设备—&gt;内存</p>\n</li>\n<li><p>写操作（数据输出）：内存—&gt;I&#x2F;O设备</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>数据传输以块为单位</p>\n</li>\n<li><p>CPU介入频率进一步降低</p>\n<ul>\n<li>数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加</li>\n</ul>\n</li>\n<li><p>CPU和I&#x2F;O设备的并行性得到提升</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块</p>\n</li>\n<li><p>如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I&#x2F;O指令，进行多次中断处理才能完成</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>通道控制方式</p>\n<ul>\n<li><p>完成一次读&#x2F;写操作的流程</p>\n<ul>\n<li><p>CPU向通道发出I&#x2F;O指令，CPU切换到其他进程</p>\n<ul>\n<li>指明通道程序在内存中的位置，并指明要操作的是哪个I&#x2F;O设备</li>\n</ul>\n</li>\n<li><p>通道执行内存中的通道程序</p>\n<ul>\n<li>其中指明了要读入&#x2F;写出多少数据，读&#x2F;写的数据应放在内存的什么位置等信息</li>\n</ul>\n</li>\n<li><p>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理</p>\n</li>\n</ul>\n</li>\n<li><p>通道</p>\n<ul>\n<li><p>一种硬件，可以理解为是削弱版的CPU</p>\n</li>\n<li><p>通道可以识别并执行一系列通道指令</p>\n</li>\n</ul>\n</li>\n<li><p>CPU干预频率：极低</p>\n<ul>\n<li>通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读&#x2F;写后才需要发出中断信号，请求CPU干预</li>\n</ul>\n</li>\n<li><p>数据传送的单元</p>\n<ul>\n<li>每次读&#x2F;写一组数据块</li>\n</ul>\n</li>\n<li><p>数据的流向（在通道的控制下进行）</p>\n<ul>\n<li><p>读操作（数据输入）：I&#x2F;O设备—&gt;内存</p>\n</li>\n<li><p>写操作（数据输出）：内存—&gt;I&#x2F;O设备</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>实现复杂，需要专门的通道硬件支持</li>\n</ul>\n</li>\n<li><p>DMA与通道的区别</p>\n<ul>\n<li><p>DMA需要CPU来控制传输的数据块大小、传输的内存位置、而通道方式中这些信息是由通道控制的</p>\n</li>\n<li><p>DMA控制器对应一台设备与内存传递数据，通道可以控制多台设备与内存的数据交换</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"I-x2F-O子系统的层次结构\"><a href=\"#I-x2F-O子系统的层次结构\" class=\"headerlink\" title=\"I&#x2F;O子系统的层次结构\"></a>I&#x2F;O子系统的层次结构</h2><ul>\n<li><p>层次划分</p>\n<ul>\n<li><p>用户层I&#x2F;O软件：</p>\n<ul>\n<li><p>实现与用户交互的接口，用户可以直接调用在用户层提供的，与I&#x2F;O操作有关的库函数，对设备进行操作</p>\n</li>\n<li><p>用户层软件将用户请求翻译成格式化的I&#x2F;O请求，并通过“系统调用”请求操作系统内核的服务</p>\n</li>\n<li><p>注：Windows 操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用（Windows API）</p>\n</li>\n</ul>\n</li>\n<li><p>设备独立性软件（设备无关性软件）</p>\n<ul>\n<li><p>向上层提供统一的调用接口</p>\n</li>\n<li><p>设备的保护：不同用户对设备的访问权限不一样</p>\n</li>\n<li><p>差错处理：对一些设备的错误进行处理</p>\n</li>\n<li><p>设备的分配与回收</p>\n</li>\n<li><p>数据缓冲区管理：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>\n</li>\n<li><p>建立逻辑设备名到物理设备名的映射关系：逻辑设备名&#x3D;设备类型</p>\n<ul>\n<li><p>用户或用户层软件发出I&#x2F;O操作系统调用的系统调用时，需要指明此次要操作的I&#x2F;O设备的逻辑设备名</p>\n</li>\n<li><p>设备独立性软件需要通过“逻辑设备表（LUT）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序</p>\n</li>\n<li><p>逻辑设备表（LUT）</p>\n<ul>\n<li><p>管理逻辑设备表（LUT）的两种方式</p>\n<ul>\n<li><p>整个系统只设置一张LUT</p>\n<ul>\n<li>所有用户不能使用相同的逻辑设备名，因此只适用于单用户操作系统</li>\n</ul>\n</li>\n<li><p>为每个用户设置一张LUT</p>\n<ul>\n<li><p>各个用户使用的逻辑设备名可以重复，适用于多用户操作系统</p>\n</li>\n<li><p>系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>不同类型的I&#x2F;O设备需要有不同的驱动程序处理</p>\n<ul>\n<li>内部的电子部件（I&#x2F;O控制器）有可能不同</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的</p>\n</li>\n</ul>\n</li>\n<li><p>设备驱动程序</p>\n<ul>\n<li><p>与硬件直接相关，负责实现系统对设备发出的操作命令，驱动I&#x2F;0设备工作的驱动程序</p>\n</li>\n<li><p>主要负责对硬件设备的具体控制，将上层发出的一系列命令转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器；检查设备状态等</p>\n</li>\n<li><p>注：直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的</p>\n</li>\n</ul>\n</li>\n<li><p>中断处理程序</p>\n<ul>\n<li><p>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行</p>\n</li>\n<li><p>使用过程：</p>\n<ul>\n<li><p>用户通过调用用户层软件提供的库函数发出的I&#x2F;O请求</p>\n</li>\n<li><p>—&gt;用户层软件通过“系统调用”请求设备独立性软件层的服务</p>\n</li>\n<li><p>—&gt;设备独立性软件层根据LUT调用设备对应的驱动程序</p>\n</li>\n<li><p>—&gt;驱动程序向I&#x2F;O控制器发出具体命令</p>\n</li>\n<li><p>—&gt;等待I&#x2F;O完成的进程应该被阻塞，因此需要进程切换，而进程切换必然需要中断处理</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>硬件设备</p>\n<ul>\n<li>执行I&#x2F;O操作，I&#x2F;O设备通常包括一个机械部件和一个电子部件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"I-x2F-O核心子系统\"><a href=\"#I-x2F-O核心子系统\" class=\"headerlink\" title=\"I&#x2F;O核心子系统\"></a>I&#x2F;O核心子系统</h1><h2 id=\"I-x2F-O核心子系统-1\"><a href=\"#I-x2F-O核心子系统-1\" class=\"headerlink\" title=\"I&#x2F;O核心子系统\"></a>I&#x2F;O核心子系统</h2><ul>\n<li><p>包括的层次</p>\n<ul>\n<li><p>设备独立性软件</p>\n<ul>\n<li><p>I&#x2F;O调度</p>\n<ul>\n<li>用某种算法确定处理各个I&#x2F;O请求的顺序</li>\n</ul>\n</li>\n<li><p>设备保护</p>\n<ul>\n<li><p>不同的用户对各个文件有不同的访问权限</p>\n<ul>\n<li><p>在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB</p>\n</li>\n<li><p>当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>假脱机（SPOOLing技术）：一般来说在用户层软件实现</p>\n</li>\n<li><p>设备分配与回收</p>\n</li>\n<li><p>缓冲区管理（缓冲与高速缓存）</p>\n</li>\n</ul>\n</li>\n<li><p>设备驱动程序</p>\n</li>\n<li><p>中断处理程序</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SPOOLING技术（假脱机技术）\"><a href=\"#SPOOLING技术（假脱机技术）\" class=\"headerlink\" title=\"SPOOLING技术（假脱机技术）\"></a>SPOOLING技术（假脱机技术）</h2><ul>\n<li><p>目的</p>\n<ul>\n<li>缓解CPU与I&#x2F;O的速度差异矛盾</li>\n</ul>\n</li>\n<li><p>是什么</p>\n<ul>\n<li><p>通俗解释：如果设备被占用，我们就先把数据暂存一下，等到设备空闲了就把这些数据输送到设备中</p>\n<ul>\n<li><p>即使CPU在忙碌，也可以提前将数据输入到磁带</p>\n</li>\n<li><p>即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带</p>\n</li>\n</ul>\n</li>\n<li><p>脱机：脱离主机的控制进行的输入&#x2F;输出操作</p>\n</li>\n<li><p>假脱机：用软件的方式模拟脱机技术</p>\n</li>\n</ul>\n</li>\n<li><p>实现原理</p>\n<ul>\n<li><p>输入井和输出井——在磁盘上</p>\n<ul>\n<li><p>输入井，模拟脱机输入时的磁带，用来收容I&#x2F;O设备的数据</p>\n</li>\n<li><p>输出井，模拟输出时的磁盘，用于收容用户进程输出的数据</p>\n</li>\n</ul>\n</li>\n<li><p>输入缓冲区和输出缓冲区——在内存上</p>\n<ul>\n<li><p>输入缓冲区：在输入进程的控制下，暂存由输入设备送来的数据</p>\n</li>\n<li><p>输出缓冲区：在输出进程的控制下，暂存从输出井送来的设备</p>\n</li>\n</ul>\n</li>\n<li><p>输入进程和输出进程</p>\n<ul>\n<li><p>输入进程：</p>\n<ul>\n<li><p>模拟脱机输入时的外围控制机</p>\n</li>\n<li><p>将用户要求的数据从输入设备通过输入缓冲区送到输入井中，当CPU空闲时，直接将输出井中的数据送入内存</p>\n</li>\n</ul>\n</li>\n<li><p>输出进程：</p>\n<ul>\n<li><p>模拟脱机输出时的外围控制机</p>\n</li>\n<li><p>把用户要求输出的数据先从内存送到输出井中，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：要实现SPOOLing技术，必须要有多道程序技术的支持</p>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>提高了I&#x2F;O速度</p>\n</li>\n<li><p>独占设备变成了共享设备</p>\n</li>\n<li><p>实现了虚拟设备功能</p>\n</li>\n</ul>\n</li>\n<li><p>共享打印机的原理分析</p>\n<ul>\n<li><p>设备分类</p>\n<ul>\n<li><p>独占设备：一个时段只能分配给一个进程（如打印机）</p>\n</li>\n<li><p>共享设备：可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用</p>\n</li>\n<li><p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）</p>\n</li>\n</ul>\n</li>\n<li><p>假脱机管理进程为每个进程做的两件事：</p>\n<ul>\n<li><p>在磁盘输出井中为进程申请一个空闲缓冲区（在磁盘上的），并将要打印的数据送入其中</p>\n</li>\n<li><p>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（存放空闲缓冲区的地址，即用户打印数据存放位置），再将该表挂到假脱机文件队列上</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印</p>\n</li>\n<li><p>依次处理完全部的打印任务</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"设备分配与回收\"><a href=\"#设备分配与回收\" class=\"headerlink\" title=\"设备分配与回收\"></a>设备分配与回收</h2><ul>\n<li><p>设备分配时应考虑的因素</p>\n<ul>\n<li><p>设备的具有属性</p>\n<ul>\n<li><p>独占式使用设备</p>\n<ul>\n<li>一个时段只能分配给一个进程（如打印机）</li>\n</ul>\n</li>\n<li><p>分时共享使用设备</p>\n<ul>\n<li><p>可同时分配给多个进程使用（如磁盘）</p>\n</li>\n<li><p>各进程往往是宏观上同时共享使用设备，而微观上交替使用</p>\n</li>\n</ul>\n</li>\n<li><p>SPOOLing方式使用设备</p>\n<ul>\n<li>采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>设备分配算法</p>\n<ul>\n<li><p>先来先服务</p>\n</li>\n<li><p>优先级高者优先</p>\n</li>\n<li><p>短任务优先</p>\n</li>\n</ul>\n</li>\n<li><p>设备分配中的安全性</p>\n<ul>\n<li><p>安全分配方式</p>\n<ul>\n<li><p>为进程分配一个设备后就将进程阻塞，本次I&#x2F;O完成后才将进程唤醒</p>\n</li>\n<li><p>即一个时段内每个进程只能使用一个设备</p>\n</li>\n<li><p>优点：破坏了“请求和保持”条件，不会死锁</p>\n</li>\n<li><p>缺点：CPU和I&#x2F;O设备串行工作</p>\n</li>\n</ul>\n</li>\n<li><p>不安全分配方式</p>\n<ul>\n<li><p>进程发出I&#x2F;O请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求</p>\n</li>\n<li><p>只有某个I&#x2F;O请求得不到满足时才将进程阻塞</p>\n</li>\n<li><p>即一个进程可以同时使用多个设备</p>\n</li>\n<li><p>优点：进程的计算任务和I&#x2F;O任务可以并行处理，使进程迅速推进</p>\n</li>\n<li><p>缺点：可能产生死锁（需要使用死锁避免、死锁的检测和解除）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>静态分配与动态分配</p>\n<ul>\n<li><p>进程运行前为其分配全部所需资源，运行结束后归还资源</p>\n<ul>\n<li>破坏了“请求和保持”条件，不会发生死锁</li>\n</ul>\n</li>\n<li><p>进程运行过程中动态申请设备资源</p>\n</li>\n</ul>\n</li>\n<li><p>设备分配管理中的数据结构</p>\n<ul>\n<li><p>通道、控制器、设备之间的关系：一个通道可控制多个设备控制器，每个设备控制器可控制多个设备</p>\n</li>\n<li><p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p>\n<ul>\n<li><p>设备类型：打印机、扫描仪、键盘</p>\n</li>\n<li><p>设备标识符：即物理设备名，系统中的每个设备的物理设备名唯一</p>\n</li>\n<li><p>设备状态：忙碌&#x2F;空闲&#x2F;故障</p>\n</li>\n<li><p>指向控制器表的指针：每个设备由一个控制器控制，该指针可找到相应控制器的信息</p>\n</li>\n<li><p>重复执行次数或时间：当重复执行多次I&#x2F;O操作后仍不成功，才认为此次I&#x2F;O失败</p>\n</li>\n<li><p>设备队列的队首指针：指向正在等待该设备的进程队列（由进程PCB组成队列）</p>\n<ul>\n<li>阻塞原因不同，阻塞队列不同</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>控制器控制表（COCT）：每个设备控制器都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理</p>\n<ul>\n<li><p>通道标识符：各个控制器的唯一ID</p>\n</li>\n<li><p>通道状态：忙碌&#x2F;空闲&#x2F;故障</p>\n</li>\n<li><p>与通道连接的控制器表首址：可通过该指针找到该通道管理的所有控制器相关信息（COCT）</p>\n</li>\n<li><p>通道队列的队首指针：指向正在等待该通道的进程队列（由进程PCB组成队列）</p>\n</li>\n<li><p>通道队列的队尾指针：</p>\n</li>\n</ul>\n</li>\n<li><p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目</p>\n<ul>\n<li><p>表目：</p>\n<ul>\n<li><p>设备类型：打印机、扫描仪、键盘</p>\n</li>\n<li><p>设备标识符：即物理设备名</p>\n</li>\n<li><p>DCT（设备控制表）</p>\n</li>\n<li><p>驱动程序入口</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>设备分配的步骤</p>\n<ul>\n<li><p>根据进程请求的物理设备名查找SDT（系统设备表）</p>\n</li>\n<li><p>根据SDT找到DCT（设备控制表）</p>\n<ul>\n<li><p>若设备忙碌则将进程PCB挂到设备等待队列中</p>\n</li>\n<li><p>不忙碌则将设备分配给进程</p>\n</li>\n</ul>\n</li>\n<li><p>根据DCT找到COCT（控制器控制表）</p>\n<ul>\n<li><p>若控制器忙碌则将进程PCB挂到控制器等待队列中</p>\n</li>\n<li><p>不忙碌则将控制器分配给进程</p>\n</li>\n</ul>\n</li>\n<li><p>根据COCT找到CHCT（通道控制表）</p>\n<ul>\n<li><p>若通道忙碌则将进程PCB挂到通道等待队列中</p>\n</li>\n<li><p>不忙碌则将通道分配给进程</p>\n</li>\n</ul>\n</li>\n<li><p>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送</p>\n</li>\n</ul>\n</li>\n<li><p>设备分配步骤的改进方法</p>\n<ul>\n<li><p>缺点：使用物理设备名</p>\n<ul>\n<li><p>底层细节对用户不透明，不方便编程</p>\n</li>\n<li><p>若该物理设备更换，则程序无法运行</p>\n</li>\n<li><p>若进程请求的物理设备正在忙碌，无法请求同类型的设备</p>\n</li>\n</ul>\n</li>\n<li><p>改进：</p>\n<ul>\n<li><p>建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p>\n</li>\n<li><p>步骤：</p>\n<ul>\n<li><p>根据进程请求的逻辑设备名（设备类型）查找SDT（系统设备表）</p>\n</li>\n<li><p>查找SDT，找到用户进程指定类型的、并且空闲的设备的DCT，将其分配给该进程</p>\n<ul>\n<li><p>操作系统在逻辑设备表（LUT）中新增一个表项</p>\n</li>\n<li><p>逻辑设备表：</p>\n<ul>\n<li><p>建立了逻辑设备名与物理设备名之间的映射关系</p>\n</li>\n<li><p>若用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统直接查找LUT表（若查找到，不再需要查找SDT），即可将空闲的物理设备分配给该进程，并且也能知道该设备的驱动程序入口地址</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>根据DCT（设备控制表）找到COCT（控制器控制表）</p>\n<ul>\n<li><p>若控制器忙碌则将进程PCB挂到控制器等待队列中</p>\n</li>\n<li><p>不忙碌则将控制器分配给进程</p>\n</li>\n</ul>\n</li>\n<li><p>根据COCT找到CHCT（通道控制表）</p>\n<ul>\n<li><p>若通道忙碌则将进程PCB挂到通道等待队列中</p>\n</li>\n<li><p>不忙碌则将通道分配给进程</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓冲区管理（高速缓存与缓冲区）\"><a href=\"#缓冲区管理（高速缓存与缓冲区）\" class=\"headerlink\" title=\"缓冲区管理（高速缓存与缓冲区）\"></a>缓冲区管理（高速缓存与缓冲区）</h2><ul>\n<li><p>缓冲区是什么</p>\n<ul>\n<li><p>一个存储区域</p>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>由专门的硬件寄存器组成</p>\n<ul>\n<li>成本较高，容量也较小，一般仅用在对速度要求非常高的场合</li>\n</ul>\n</li>\n<li><p>利用内存作为缓冲区</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缓存区的作用</p>\n<ul>\n<li><p>缓和CPU与I&#x2F;O之间的速度差异矛盾</p>\n<ul>\n<li>CPU速度比I&#x2F;O速度快的多</li>\n</ul>\n</li>\n<li><p>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</p>\n<ul>\n<li><p>没有缓存区：如果是字符型设备，每输出一个字符，就要向CPU发送一次中断信号</p>\n</li>\n<li><p>有缓冲区：每输出一块字符，才向CPU发送一次中断信号</p>\n</li>\n</ul>\n</li>\n<li><p>解决基本数据单元大小（数据粒度）不匹配的问题</p>\n<ul>\n<li>输出进程每次可以生成一块数据，I&#x2F;O设备每次只能输出一个字符</li>\n</ul>\n</li>\n<li><p>提高CPU和I&#x2F;O设备之间的并行性</p>\n<ul>\n<li><p>CPU可以把要输出的数据快速地放入缓冲区，之后就可以做别的事</p>\n</li>\n<li><p>慢速的I&#x2F;O设备可以慢慢从缓冲区取走数据</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>单缓冲</p>\n<ul>\n<li><p>缓冲区只有一个，用户进程的工作区（在内存中）用于接收输入&#x2F;输出数据（一般也默认工作区大小与缓冲区相同）<img src=\"https://api2.mubu.com/v3/document_image/ed4c44d3-5177-4da8-b5ca-3ded661ed869-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>缓冲区的使用</p>\n<ul>\n<li><p>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</p>\n</li>\n<li><p>当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</p>\n</li>\n</ul>\n</li>\n<li><p>题型：</p>\n<ul>\n<li><p>计算每处理一块数据平均需要多久？</p>\n</li>\n<li><p>技巧：</p>\n<ul>\n<li>假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间</li>\n</ul>\n</li>\n<li><p>做法：假设初始状态为工作区满，缓冲区空</p>\n</li>\n<li><p>若T&gt;C，平均用时&#x3D; T+M</p>\n<ul>\n<li>CPU处理完数据后，需要等待缓冲区中冲满数据，然后将缓存区中的数据传送到工作区</li>\n</ul>\n</li>\n<li><p>若T&lt;C，平均用时&#x3D; C+M</p>\n<ul>\n<li>缓冲区中冲满数据后，需要CPU处理完数据，然后将缓存区中的数据传送到工作区</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>双缓冲</p>\n<ul>\n<li><p>缓冲区有两个</p>\n</li>\n<li><p>题型：</p>\n<ul>\n<li><p>计算每处理一块数据平均需要多久？</p>\n</li>\n<li><p>做法：假设工作区空，其中一个缓冲区满，另一个缓冲区空</p>\n</li>\n<li><p>若T&gt;C+M，平均用时&#x3D; T</p>\n<ul>\n<li>将满缓冲区1中的数据传送到工作区，同时开始向空缓冲区2中输入数据，缓冲区1中为空时，CPU处理数据，此时缓存区2仍未充满，直到T时，缓存区2才充满数据</li>\n</ul>\n</li>\n<li><p>若T&lt;C+M，平均用时&#x3D; C+M，不适用假设</p>\n<ul>\n<li>CPU处理完一个缓冲区数据的时间（传输M+处理C）足够向另一个缓冲区输入数据，所以每处理一个数据块平均耗时C+M</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>单缓冲区和双缓冲区的区别</p>\n<ul>\n<li><p>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输</p>\n<ul>\n<li>A的缓冲区用于存放要发送的数据，B的缓冲区就只能存放要接收的数据</li>\n</ul>\n</li>\n<li><p>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输</p>\n<ul>\n<li>管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>循环缓冲</p>\n<ul>\n<li><p>将多个大小相等的缓冲区链接成一个循环队列</p>\n<ul>\n<li><p>橙色表示已充满数据的缓冲区，绿色表示空缓冲区</p>\n</li>\n<li><p>in 指针，指向第一个可以冲入数据的空缓冲区</p>\n</li>\n<li><p>out 指针，指向第一个可以取出数据的满缓冲区</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缓冲池</p>\n<ul>\n<li><p>由系统中共用的缓冲区组成</p>\n</li>\n<li><p>缓冲池中的缓冲区分类</p>\n<ul>\n<li><p>按使用状况分类</p>\n<ul>\n<li><p>空缓冲队列</p>\n</li>\n<li><p>输入队列：装满输入数据的缓冲队列</p>\n</li>\n<li><p>输出队列：装满输出数据的缓冲队列</p>\n</li>\n</ul>\n</li>\n<li><p>按功能分类</p>\n<ul>\n<li><p>hin</p>\n<ul>\n<li>用于收容输入数据的工作缓冲区</li>\n</ul>\n</li>\n<li><p>sout</p>\n<ul>\n<li>用于提取输出数据的工作缓冲区</li>\n</ul>\n</li>\n<li><p>sin</p>\n<ul>\n<li>用于提取输入数据的工作缓冲区</li>\n</ul>\n</li>\n<li><p>hout</p>\n<ul>\n<li>用于收容输出数据的工作缓冲区</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进程请求数据的过程</p>\n<ul>\n<li><p>输入进程请求输入数据</p>\n<ul>\n<li><p>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）</p>\n</li>\n<li><p>冲满数据后将缓冲区挂到输入队列队尾</p>\n</li>\n</ul>\n</li>\n<li><p>计算进程想要取得一块输入数据</p>\n<ul>\n<li><p>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”</p>\n</li>\n<li><p>缓冲区读空后挂到空缓冲区队列</p>\n</li>\n</ul>\n</li>\n<li><p>计算进程想要将准备好的数据冲入缓冲区</p>\n<ul>\n<li><p>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”</p>\n</li>\n<li><p>数据冲满后将缓冲区挂到输出队列队尾</p>\n</li>\n</ul>\n</li>\n<li><p>输出进程请求输出数据</p>\n<ul>\n<li><p>从输出队列中取得一块冲满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”</p>\n</li>\n<li><p>缓冲区读空后挂到空缓冲区队列</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>磁盘高速缓存</p>\n<ul>\n<li><p>使用磁盘高速缓存技术可以提高磁盘的I&#x2F;O速度，对高速缓存复制的访问要比原始数据访问更高效</p>\n</li>\n<li><p>磁盘高速缓存，逻辑上属于磁盘，物理上属于驻留在内存中的盘块</p>\n</li>\n<li><p>在内存中的两种形式</p>\n<ul>\n<li><p>在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定</p>\n</li>\n<li><p>把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I&#x2F;O时共享</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>高速缓存与缓冲区对比</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>都介于高速设备和低速设备之间</li>\n</ul>\n</li>\n<li><p>不同</p>\n<ul>\n<li><p>存放数据</p>\n<ul>\n<li><p>高速缓存：存放的是低速设备上的某些数据的复制数据</p>\n</li>\n<li><p>缓冲区：存放的是低速设备传递给高速设备的数据，这些数据在低速设备上不一定有备份，这些数据再从缓冲区传送到高速设备</p>\n</li>\n</ul>\n</li>\n<li><p>目的</p>\n<ul>\n<li><p>高速缓存：高速缓存存放的是高速设备经常要访问的数据，如高速缓存中数据不在，高速设备就要访问低速设备</p>\n</li>\n<li><p>高速设备和低速设备的通信都要经过缓冲区，高速设备永远不会去直接访问低速设备</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","2.操作系统","5.输入输出管理"],"tags":["写作"]},{"title":"绪论","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_1%E7%BB%AA%E8%AE%BA/","content":"<h1 id=\"数据结构的基本概念和术语\"><a href=\"#数据结构的基本概念和术语\" class=\"headerlink\" title=\"数据结构的基本概念和术语\"></a>数据结构的基本概念和术语</h1><h2 id=\"数据、数据元素、数据对象、数据类型\"><a href=\"#数据、数据元素、数据对象、数据类型\" class=\"headerlink\" title=\"数据、数据元素、数据对象、数据类型\"></a>数据、数据元素、数据对象、数据类型</h2><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">数据</td>\n<td>信息的载体，符号的集合</td>\n</tr>\n<tr>\n<td align=\"left\">数据元素</td>\n<td>数据的基本单位，一个整体</td>\n</tr>\n<tr>\n<td align=\"left\">数据对象</td>\n<td>具有相同性质的数据元素的集合</td>\n</tr>\n<tr>\n<td align=\"left\">数据类型</td>\n<td>数据对象、关系、操作<br />分类：原子类型(值不可再分)、结构类型(值可再分)、抽象数据类型(对数据进行抽象)</td>\n</tr>\n</tbody></table>\n<h2 id=\"数据结构三要素\"><a href=\"#数据结构三要素\" class=\"headerlink\" title=\"数据结构三要素\"></a>数据结构三要素</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解释</th>\n<th>分类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据结构</td>\n<td>带有逻辑结构和存储结构的数据元素的集合</td>\n<td></td>\n</tr>\n<tr>\n<td>逻辑结构</td>\n<td>逻辑关系，与存储无关，独立于计算机</td>\n<td>线性结构：线性表、栈、队列、数组<br />非线性结构：集合、树、图</td>\n</tr>\n<tr>\n<td>存储结构</td>\n<td>在计算机中的表示，用计算机语言实现的逻辑结构</td>\n<td>顺序存储、链式存储<br />链式存储、索引存储</td>\n</tr>\n<tr>\n<td>数据的运算</td>\n<td>运算的定义（逻辑结构）：指出功能<br />运算的实现（存储结构）：指出操作步骤</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"存储结构的分类\"><a href=\"#存储结构的分类\" class=\"headerlink\" title=\"存储结构的分类\"></a>存储结构的分类</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解析</th>\n<th>优缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>顺序存储</td>\n<td>逻辑相邻时，物理相邻</td>\n<td>优点：随机存取、占用空间少<br />缺点：产生外部碎片</td>\n</tr>\n<tr>\n<td>链式存储</td>\n<td>借助指针表示逻辑关系</td>\n<td>优点：无碎片<br />缺点：指针占存储空间、只能顺序存取</td>\n</tr>\n<tr>\n<td>索引存储</td>\n<td>附加索引表</td>\n<td>优点：检索速度快<br />缺点：索引表占存储空间、增删数据时修改索引表</td>\n</tr>\n<tr>\n<td>散列存储</td>\n<td>根据关键字计算存储地址</td>\n<td>优点：检索、增删快<br />缺点：若散列函数不好，则解决冲突会增加时间和空间开销</td>\n</tr>\n</tbody></table>\n<h1 id=\"算法和算法评价\"><a href=\"#算法和算法评价\" class=\"headerlink\" title=\"算法和算法评价\"></a>算法和算法评价</h1><p>算法：对特定问题求解步骤的一种描述，指令的有限序列</p>\n<h2 id=\"算法重要特性\"><a href=\"#算法重要特性\" class=\"headerlink\" title=\"算法重要特性\"></a>算法重要特性</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>有穷性</td>\n<td>有穷步、有穷时间</td>\n</tr>\n<tr>\n<td>确定性</td>\n<td>每条指令有唯一的含义</td>\n</tr>\n<tr>\n<td>可行性</td>\n<td>基本运算执行有限次</td>\n</tr>\n<tr>\n<td>输入</td>\n<td>输入个数≥0</td>\n</tr>\n<tr>\n<td>输出</td>\n<td>输出个数≥1</td>\n</tr>\n</tbody></table>\n<h2 id=\"优秀算法的标准\"><a href=\"#优秀算法的标准\" class=\"headerlink\" title=\"优秀算法的标准\"></a>优秀算法的标准</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>正确性</td>\n<td>能解决问题</td>\n</tr>\n<tr>\n<td>可读性</td>\n<td>能被人读懂</td>\n</tr>\n<tr>\n<td>健壮性</td>\n<td>能处理非法数据</td>\n</tr>\n<tr>\n<td>效率与低存储量需求</td>\n<td>执行时间短、执行所需空间小</td>\n</tr>\n</tbody></table>\n<h2 id=\"算法效率的度量\"><a href=\"#算法效率的度量\" class=\"headerlink\" title=\"算法效率的度量\"></a>算法效率的度量</h2><p>算法效率的度量：通过时间复杂度和空间复杂度来描述</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解析</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>时间复杂度</td>\n<td>语句的执行次数，一般为嵌套的循环次数</td>\n</tr>\n<tr>\n<td>空间复杂度</td>\n<td>算法运行中临时占用的存储空间（辅助空间[^1]）<br />原地工作：算法所需的辅助空间为常量，与问题规模无关，即O(1)</td>\n</tr>\n<tr>\n<td>计算规则</td>\n<td>加法：max(f,g)、乘法：f(n)·g(n)</td>\n</tr>\n</tbody></table>\n","categories":["计算机408","3.数据结构","1.绪论"],"tags":["写作"]},{"title":"文件管理","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_4.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","content":"<h1 id=\"文件系统基础\"><a href=\"#文件系统基础\" class=\"headerlink\" title=\"文件系统基础\"></a>文件系统基础</h1><h2 id=\"初识文件管理\"><a href=\"#初识文件管理\" class=\"headerlink\" title=\"初识文件管理\"></a>初识文件管理</h2><ul>\n<li><p>文件的属性</p>\n<ul>\n<li><p>名称：主要是为了方便用户找到文件，同一目录下不允许有重名文件</p>\n</li>\n<li><p>标识符：文件的唯一标签，通常为数字，是对人不可读的一种内部名称</p>\n<ul>\n<li>对于不同目录下的文件，文件名并不能唯一确定文件，所以需要标识符区分</li>\n</ul>\n</li>\n<li><p>类型：文件的类型</p>\n<ul>\n<li>被支持的不同类型的文件系统所使用</li>\n</ul>\n</li>\n<li><p>位置：文件存放路径（用户使用）、在外存中的地址（操作系统使用，用户不可见）</p>\n<ul>\n<li>指向设备和设备上文件的指针</li>\n</ul>\n</li>\n<li><p>大小：文件当前的大小</p>\n</li>\n<li><p>保护：对文件进行保护的访问控制信息</p>\n</li>\n<li><p>时间，日期和用户标识：文件创建、修改和上次访问的相关信息，用于保护和跟踪文件的使用</p>\n</li>\n</ul>\n</li>\n<li><p>文件内部的数据怎么组织起来</p>\n<ul>\n<li><p>无结构文件：由一些二进制或字符流组成，又称“流式文件”，如文本文件</p>\n</li>\n<li><p>有结构文件：由一组相似的记录组成，又称“记录式文件”，如数据库表</p>\n<ul>\n<li>有结构文件由一条记录组成<ul>\n<li>记录是一组相关数据项的集合<ul>\n<li>数据项是文件系统中最基本的数据单位</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>文件之间应该怎样组织起来</p>\n<ul>\n<li><p>通过目录将文件合理有序的组织起来</p>\n</li>\n<li><p>目录其实也是一种特殊的有结构文件（由记录组成）</p>\n</li>\n</ul>\n</li>\n<li><p>操作系统应该向上提供哪些功能</p>\n<ul>\n<li><p>创建文件：create 系统调用</p>\n</li>\n<li><p>读文件：将文件数据读入内存，才能让CPU处理</p>\n</li>\n<li><p>写文件：将更改过的文件数据写回外存</p>\n</li>\n<li><p>删除文件： delete 系统调用，将文件数据从外存中删除</p>\n</li>\n<li><p>打开文件：读&#x2F;写文件之前，需要“打开文件”</p>\n</li>\n<li><p>关闭文件：读&#x2F;写文件结束之后，需要“关闭文件”</p>\n</li>\n</ul>\n</li>\n<li><p>从上往下看，文件应如何存放在外存</p>\n<ul>\n<li>文件在物理上怎么存放，怎么组织</li>\n</ul>\n</li>\n<li><p>文件共享：使多个用户可以共享使用一个文件</p>\n</li>\n<li><p>文件保护：如何保证不同的用户对文件有不同的操作权限</p>\n</li>\n</ul>\n<h2 id=\"文件的逻辑结构：在用户看来，文件内部的数据是如何组织的\"><a href=\"#文件的逻辑结构：在用户看来，文件内部的数据是如何组织的\" class=\"headerlink\" title=\"文件的逻辑结构：在用户看来，文件内部的数据是如何组织的\"></a>文件的逻辑结构：在用户看来，文件内部的数据是如何组织的</h2><ul>\n<li><p>无结构文件</p>\n<ul>\n<li><p>文件内部的数据就是一系列二进制流或字符流组成，又称“流式文件”</p>\n<ul>\n<li>如：Windows 操作系统中的 .txt 文件</li>\n</ul>\n</li>\n<li><p>文件内部的数据其实就是一系列字符流，没有明显的结构特性</p>\n</li>\n</ul>\n</li>\n<li><p>有结构文件（记录式文件）</p>\n<ul>\n<li><p>定义：</p>\n<ul>\n<li><p>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成</p>\n<ul>\n<li>如：数据库表文件</li>\n</ul>\n</li>\n<li><p>一般来说，每条记录有一个数据项可作为关键字（作为识别不同记录的ID）</p>\n</li>\n</ul>\n</li>\n<li><p>根据每条记录的长度（占用的存储空间）是否相等分类</p>\n<ul>\n<li><p>定长记录：</p>\n<ul>\n<li><p>每条记录的长度都相同</p>\n</li>\n<li><p>各数据项都处在记录中相同的位置，具有相同的顺序和长度</p>\n</li>\n</ul>\n</li>\n<li><p>可变长记录：</p>\n<ul>\n<li>每条记录的长度不相同</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>根据有结构文件中的各条记录在逻辑上如何组织，可以分为三类</p>\n<ul>\n<li><p>顺序文件</p>\n<ul>\n<li><p>文件的记录是一个接一个排列，记录通常是定长的（可以是变长的），可以顺序存储或者链表存储</p>\n</li>\n<li><p>各个记录在物理上可以顺序存储或链式存储</p>\n<ul>\n<li><p>顺序存储：逻辑上相邻的记录物理上也相邻（类似于顺序表）</p>\n</li>\n<li><p>链式存储：逻辑上相邻的记录物理上不一定相邻（类似于链表）</p>\n</li>\n</ul>\n</li>\n<li><p>根据记录是否按照关键字顺序排列</p>\n<ul>\n<li><p>串结构：记录之间的顺序与关键字无关，通常按照记录存入的时间决定记录的顺序</p>\n</li>\n<li><p>顺序结构：记录之间的顺序按关键字顺序排列</p>\n</li>\n</ul>\n</li>\n<li><p>查找文件时</p>\n<ul>\n<li><p>链式存储</p>\n<ul>\n<li>无论是定长&#x2F;可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</li>\n</ul>\n</li>\n<li><p>顺序存储</p>\n<ul>\n<li><p>可变长记录（需要显式地给出记录长度）</p>\n<ul>\n<li>无法实现随机存取。每次只能从第一个记录记录依次往后查找</li>\n</ul>\n</li>\n<li><p>定长记录</p>\n<ul>\n<li><p>可实现随机存取。记录长度为L，则第i个记录存放的相对位置是i*L</p>\n</li>\n<li><p>若采用串结构，无法快速找到某关键字对应的记录</p>\n</li>\n<li><p>若采用顺序结构，可以快速找到某关键字对应的记录（折半查找）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>批量处理时，顺序文件的效率是所有逻辑文件中效率最高的</p>\n</li>\n<li><p>但是增加、删除操作比较困难（如果是串结构，则相对简单）</p>\n</li>\n</ul>\n</li>\n<li><p>索引文件</p>\n<ul>\n<li><p>背景：快速查找到第i个可变长文件</p>\n<ul>\n<li><p>定长记录文件</p>\n<ul>\n<li>按照公式A&#x3D;i*L可以直接得到文件地址（第i条记录，L是文件长度）</li>\n</ul>\n</li>\n<li><p>变长记录文件</p>\n<ul>\n<li><p>直找前i-1条记录后，才能查找第i条记录</p>\n</li>\n<li><p>通过建立索引表后可以有效提高查找速度</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实现：</p>\n<ul>\n<li><p>建立一张索引表以加快文件检索速度，每条记录对应一个索引项</p>\n</li>\n<li><p>索引表的各个表项在物理上需要连续存放</p>\n</li>\n<li><p>文件中的这些记录在物理上可以离散地存放</p>\n</li>\n</ul>\n</li>\n<li><p>原理：</p>\n<ul>\n<li><p>索引表本身是定长记录的顺序文件，因此可以快速找到第 i 个记录对应的索引项</p>\n</li>\n<li><p>可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找</p>\n</li>\n<li><p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改</p>\n<ul>\n<li>但是由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合</li>\n</ul>\n</li>\n<li><p>可以用不同的数据项建立多个索引表</p>\n<ul>\n<li>根据“学号”、“姓名”分别建立两张索引表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>索引顺序文件</p>\n<ul>\n<li><p>背景：索引表可能占据较大的存储空间</p>\n</li>\n<li><p>定义：</p>\n<ul>\n<li><p>顺序和索引两种组织形式的结合</p>\n</li>\n<li><p>索引文件将顺序文件中的所有记录分成若干组，在索引表中为每组中的第一条记录建立一个索引项</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>索引顺序文件的索引项也不需要按关键字顺序排列，这样可以极大地方便新表项的插入</p>\n</li>\n<li><p>检索效率高，平均查找次数&#x3D;（组的个数+每个组中的记录的个数）&#x2F;2</p>\n</li>\n</ul>\n</li>\n<li><p>优化：</p>\n<ul>\n<li>多级索引表：记录过多，进一步提高检索效率</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>直接文件或散列文件</p>\n<ul>\n<li><p>给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址</p>\n</li>\n<li><p>这种映射结构不同于顺序文件或者索引文件，没有顺序的特性</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><ul>\n<li><p>对用户来说好处</p>\n<ul>\n<li><p>实际上就是Windows操作系统的文件夹</p>\n</li>\n<li><p>文件之间的组织结构清晰，易于查找</p>\n</li>\n<li><p>编程时也可以很方便的用文件路径找到一个文件</p>\n</li>\n</ul>\n</li>\n<li><p>文件控制块（FCB）</p>\n<ul>\n<li><p>目录文件：</p>\n<ul>\n<li><p>本身就是一种有结构文件，由一条条记录组成</p>\n</li>\n<li><p>每条记录对应一个在该放在该目录下的文件</p>\n</li>\n<li><p>目录文件中的一条记录就是一个文件控制块（FCB）</p>\n</li>\n<li><p>FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项</p>\n</li>\n</ul>\n</li>\n<li><p>用来存放控制文件需要的各种信息的数据结构，实现“按名存取”</p>\n</li>\n<li><p>包含信息</p>\n<ul>\n<li><p>基本信息：文件名，文件的物理位置，逻辑结构、物理结构等</p>\n<ul>\n<li>最重要的是文件名和文件存放的物理地址，实现文件名和文件之间的映射，实现“按名存取”</li>\n</ul>\n</li>\n<li><p>存取控制信息：文件存取权限</p>\n</li>\n<li><p>使用信息：文件建立时间、修改时间</p>\n</li>\n</ul>\n</li>\n<li><p>对文件目录进行的操作：</p>\n<ul>\n<li><p>搜索：用户使用给一个文件时，需要搜索目录，找到该文件对应的目录项</p>\n</li>\n<li><p>创建文件：创建一个新文件时，需要在目录中增加一个目录项</p>\n</li>\n<li><p>删除文件：删除一个文件时，需要在目录中删除相应的目录项</p>\n</li>\n<li><p>显示目录：用户可以请求显示目录的内容，显示该用户目录中的所有文件及属性</p>\n</li>\n<li><p>修改目录：某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>目录结构分类</p>\n<ul>\n<li><p>单级目录结构</p>\n<ul>\n<li><p>整个文件系统只建立一张目录表，每个文件占一个目录项</p>\n</li>\n<li><p>优点：实现了按名存取</p>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>文件不允许重名</p>\n</li>\n<li><p>不适用于多用户的操作系统</p>\n</li>\n<li><p>查找速度慢</p>\n</li>\n<li><p>不便于文件共享</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>两级目录结构</p>\n<ul>\n<li><p>将文件分为主文件目录和用户文件目录</p>\n<ul>\n<li><p>主文件目录：记录用户名及相应用户文件目录所在的存储位置</p>\n</li>\n<li><p>用户文件目录：目录项记录该用户文件的FCB信息</p>\n</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>允许不同用户文件重名</p>\n</li>\n<li><p>可以在目录上实现访问限制（检查登录的用户名是否匹配）</p>\n<ul>\n<li>在一定程度上保证了文件的安全</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺点：缺乏灵活性，不能对文件分类</p>\n</li>\n</ul>\n</li>\n<li><p>多级目录结构</p>\n<ul>\n<li><p>将两级目录结构的层次关系加以推广，就形成了多级目录结构，即树形目录结构</p>\n</li>\n<li><p>实现</p>\n<ul>\n<li><p>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串</p>\n</li>\n<li><p>各级目录之间用“&#x2F;”隔开</p>\n</li>\n</ul>\n</li>\n<li><p>绝对路径：从根目录出发的路径</p>\n<ul>\n<li><p>例如：绝对路径是 “&#x2F;照片&#x2F;2015-08&#x2F;自拍.jpg”，整个过程需要3次读磁盘I&#x2F;O操作</p>\n<ul>\n<li><p>从外存读入根目录的目录表</p>\n</li>\n<li><p>找到“照片”目录的存放位置后，从外存读入对应的目录表</p>\n</li>\n<li><p>再找到“2015-08”目录的存放位置，再从外存读入对应目录表</p>\n</li>\n<li><p>最后才找到文件“自拍.jpg”的存放位置</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>相对路径：从当前目录出发</p>\n<ul>\n<li><p>例如：“照片”是当前目录，”自拍.jpg”的相对路径为：“.&#x2F;2015-08&#x2F;自拍.jpg”，整个过程需要1次读磁盘I&#x2F;O操作</p>\n<ul>\n<li><p>从当前路径出发，只需要查询内存中的“照片”目录表，即可知道”2015-08”目录表的存放位置</p>\n</li>\n<li><p>从外存调入该目录，即可知道“自拍.jpg”存放的位置</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>有效的对文件进行分类，文件结构层次清晰</p>\n</li>\n<li><p>能够有效的进行文件管理和保护</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>不便于实现文件的共享（树形目录结构）</p>\n</li>\n<li><p>按照路径名访问中间结点，增加了磁盘访问次数，降低了查询速度</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>无环图目录结构</p>\n<ul>\n<li><p>在树形目录结构基础上增加了一些指向同一结点的有向边，使整个目录称为一个有向无环图</p>\n</li>\n<li><p>共享文件：</p>\n<ul>\n<li><p>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）</p>\n</li>\n<li><p>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点</p>\n</li>\n<li><p>用户提出删除结点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点</p>\n</li>\n<li><p>只有共享计数器减为0时，才删除结点</p>\n</li>\n<li><p>注意：</p>\n<ul>\n<li><p>共享文件不同于复制文件</p>\n</li>\n<li><p>在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点：有利于实现文件共享</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>索引结点</p>\n<ul>\n<li><p>在查找各级目录的过程中只需要用到“文件名”，因此可以考虑让目录表“瘦身”来提升效率</p>\n</li>\n<li><p>实现：</p>\n<ul>\n<li>将除了文件名之外的文件描述信息都放到索引结点，目录表中只有文件名和索引结点的指针</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>提升文件检索速度<ul>\n<li>目录项所占磁盘数减少，读取磁盘的次数就大大减少了</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>索引结点分为</p>\n<ul>\n<li><p>磁盘索引结点：存放在外存中的索引结点</p>\n</li>\n<li><p>内存索引结点：存放在内存中的索引结点</p>\n<ul>\n<li>增加了的信息：文件是否被修改、有几个进程正在访问该文件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件保护\"><a href=\"#文件保护\" class=\"headerlink\" title=\"文件保护\"></a>文件保护</h2><ul>\n<li><p>口令保护</p>\n<ul>\n<li><p>为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”</p>\n</li>\n<li><p>口令存放位置：文件对应的 FCB 或索引结点中</p>\n<ul>\n<li>用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>保存口令的空间开销不多，验证口令的时间开销也很小</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>正确的“口令”存放在系统内部，不够安全</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>加密保护</p>\n<ul>\n<li><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密</p>\n</li>\n<li><p>实现：</p>\n<ul>\n<li><p>使用密码对文件进行加密，将加密结果存储在系统中</p>\n</li>\n<li><p>访问文件时，使用密码对文件进行解密，解密结果即为文件内容</p>\n</li>\n</ul>\n</li>\n<li><p>优点：保密性强，不需要在系统中存储“密码”</p>\n</li>\n<li><p>缺点：加密&#x2F;解密要花费一定时间</p>\n</li>\n<li><p>注：口令和密码都是防止文件被他人存取或者窃取，没有控制用户对文件的访问类型</p>\n</li>\n</ul>\n</li>\n<li><p>访问控制</p>\n<ul>\n<li><p>根据用户身份进行控制，为每个文件和目录增加一个访问控制列表，规定每个用户名及其所允许的访问类型</p>\n</li>\n<li><p>实现：</p>\n<ul>\n<li>在每个文件的FCB（或索引结点）中增加一个访问控制列表（ ACL），该表中记录了各个用户可以对该文件执行哪些操作</li>\n</ul>\n</li>\n<li><p>访问类型：</p>\n<ul>\n<li><p>读：从文件中读数据</p>\n</li>\n<li><p>写：向文件中写数据</p>\n</li>\n<li><p>执行：将文件装入内容并执行</p>\n</li>\n<li><p>添加：将新信息添加到文件结尾部分</p>\n</li>\n<li><p>删除：删除文件，释放空间</p>\n</li>\n<li><p>列表清单：列出文件名和文件属性</p>\n</li>\n<li><p>还可以对文件重命名、复制、编辑等加以控制</p>\n</li>\n</ul>\n</li>\n<li><p>精简的访问列表：</p>\n<ul>\n<li><p>以“组”为单位，标记各“组”用户可以对文件执行哪些操作</p>\n</li>\n<li><p>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限</p>\n</li>\n<li><p>通过将用户移入某个分组，实现用户拥有某个权限</p>\n</li>\n</ul>\n</li>\n<li><p>Windows访问控制：拒绝项优于允许项</p>\n</li>\n<li><p>优点：实现灵活，可以实现复杂的文件保护功能</p>\n</li>\n<li><p>缺点：长度无法预计，且可能导致复杂空间管理</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件共享\"><a href=\"#文件共享\" class=\"headerlink\" title=\"文件共享\"></a>文件共享</h2><ul>\n<li><p>让多个用户共享地使用同一个文件</p>\n<ul>\n<li><p>多个用户共享同一个文件，意味着系统中只有“一份”文件数据</p>\n</li>\n<li><p>只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化</p>\n</li>\n<li><p>如果是复制的话，系统中有多份文件</p>\n</li>\n</ul>\n</li>\n<li><p>基于索引节点的共享方式（硬链接）</p>\n<ul>\n<li><p>文件目录中的多个索引结点指针指向同一个索引结点</p>\n</li>\n<li><p>文件目录中只设置文件名及指向相应索引节点的指针，在索引节点中还有一个链接计数count，用于表示链接到本索引节点（即文件）上的用户目录项的数目</p>\n</li>\n<li><p>某个用户删除该文件时，只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减 1</p>\n<ul>\n<li><p>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空</p>\n</li>\n<li><p>当 count &#x3D; 0 时系统负责删除文件</p>\n</li>\n</ul>\n</li>\n<li><p>优点：硬链接的查找速度要比软链接快</p>\n</li>\n</ul>\n</li>\n<li><p>利用符号链实现文件共享（软链接）</p>\n<ul>\n<li><p>建立一个LINK文件，文件中存放共享文件的存放路径，FCB（或索引结点）中添加一个指向LINK文件的指针</p>\n<ul>\n<li>B用户共享A用户的文件F时候，系统创建一个LINK类型的新文件，取名G，然后将文件G写入用户B的目录中，G中只含有被链接文件F的路径名</li>\n</ul>\n</li>\n<li><p>软链接就是把到达共享文件的路径记录下来，当要访问文件时，根据路径寻找文件</p>\n</li>\n<li><p>删除文件时，直接删除共享文件，LINK文件依然存在，只是通过LINK文件中的路径查找共享文件时会失败（找不到对应目录项）</p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>文件在网路上共享时只需要提供该文件所在机器的网络地址及该机器中的文件路径</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>由于是根据文件路径名查找文件，因此会增加时间开销</p>\n</li>\n<li><p>增加了启动磁盘的频率（因为要查询多级目录）</p>\n</li>\n<li><p>符号链的索引节点也会耗费一定的硬盘空间</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"文件系统的实现——操作系统对磁盘块的管理\"><a href=\"#文件系统的实现——操作系统对磁盘块的管理\" class=\"headerlink\" title=\"文件系统的实现——操作系统对磁盘块的管理\"></a>文件系统的实现——操作系统对磁盘块的管理</h1><h2 id=\"文件的物理结构-x2F-文件分配方式\"><a href=\"#文件的物理结构-x2F-文件分配方式\" class=\"headerlink\" title=\"文件的物理结构&#x2F;文件分配方式\"></a>文件的物理结构&#x2F;文件分配方式</h2><ul>\n<li><p>对非空闲磁盘块的管理，即文件数据怎么存放在外存中</p>\n</li>\n<li><p>连续分配</p>\n<ul>\n<li><p>文件块、磁盘块的定义</p>\n<ul>\n<li><p>类似于内存分页，磁盘中的存储单元也会被分为一个个块&#x2F;磁盘块&#x2F;物理块</p>\n</li>\n<li><p>很多操作系统中，磁盘块的大小与内存块、页面的大小相同</p>\n</li>\n<li><p>内存与磁盘之间的数据交换（即读&#x2F;写操作、磁盘I&#x2F;O）都是以块为单位进行的，即每次读入一块，或每次写出一块</p>\n</li>\n<li><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p>\n</li>\n<li><p>同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。</p>\n</li>\n<li><p>于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式</p>\n</li>\n<li><p>操作系统为文件分配存储空间都是以块为单位的</p>\n</li>\n<li><p>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射</p>\n</li>\n</ul>\n</li>\n<li><p>定义：每个文件在磁盘上占有一组连续的块<img src=\"https://api2.mubu.com/v3/document_image/6c37a2d2-8ac1-4e71-b7f4-048823978a49-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>实现从逻辑地址到物理地址的映射：</p>\n<ul>\n<li><p>操作系统找到该文件对应的目录项（FCB）</p>\n</li>\n<li><p>（逻辑块号，块内地址）——&gt;（物理块号，块内地址）</p>\n<ul>\n<li><p>检查逻辑块号是否合法（逻辑块号 ≥ 长度就不合法）</p>\n</li>\n<li><p>物理块号 &#x3D; 起始块号 + 逻辑块号</p>\n</li>\n<li><p>块内地址保持不变</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>访存次数：1次</p>\n</li>\n<li><p>文件目录：文件名、起始块号、长度（占几个块）<img src=\"https://api2.mubu.com/v3/document_image/0f57a584-97bb-4773-b93a-c5b8e1993aff-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>支持顺序访问和直接访问（即随机访问）</p>\n<ul>\n<li>可以根据逻辑块数，算出对应的物理块数</li>\n</ul>\n</li>\n<li><p>存取速度快（访问磁盘需要的寻道数和寻道时间最小）</p>\n<ul>\n<li><p>读取某个磁盘块时，需要移动磁头</p>\n</li>\n<li><p>访问的同一个文件中的两个磁盘块相隔越远，移动磁头所需时间就越长</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>文件长度不方便扩展</p>\n<ul>\n<li>若文件A后面没有相邻的空闲块：需要将文件A全部迁移到连续空闲块足够的区域</li>\n</ul>\n</li>\n<li><p>存储空间利用率低，会产生外部碎片</p>\n<ul>\n<li>连续空闲块较小时，则无法分配给文件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>链接分配</p>\n<ul>\n<li><p>定义</p>\n<ul>\n<li><p>采用离散分配方式，为文件分配离散的磁盘块</p>\n<ul>\n<li>消除了外部碎片</li>\n</ul>\n</li>\n<li><p>实现从逻辑地址到物理地址的映射：</p>\n<ul>\n<li><p>操作系统找到该文件对应的目录项（FCB）</p>\n</li>\n<li><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存</p>\n</li>\n<li><p>除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的</p>\n</li>\n</ul>\n</li>\n<li><p>访存次数：n次</p>\n</li>\n<li><p>文件目录：文件名、起始块号、结束块号<img src=\"https://api2.mubu.com/v3/document_image/08f13025-f782-45ae-930f-8c6c6d6e14f2-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>方便文件拓展</p>\n<ul>\n<li>可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB</li>\n</ul>\n</li>\n<li><p>没有外部碎片，外存利用率高</p>\n<ul>\n<li>所有的空闲磁盘块都可以被利用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>只支持顺序访问，不支持随机访问，查找效率低</p>\n</li>\n<li><p>指向下一个盘块的指针也需要耗费少量的存储空间</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>隐式链接</p>\n<ul>\n<li><p>除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的</p>\n</li>\n<li><p>实现从逻辑地址到物理地址的映射：</p>\n<ul>\n<li><p>操作系统找到该文件对应的目录项（FCB）</p>\n</li>\n<li><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存</p>\n</li>\n<li><p>根据磁盘块中的指针，读取下一个磁盘块</p>\n</li>\n</ul>\n</li>\n<li><p>访存次数：n次</p>\n</li>\n<li><p>文件目录：文件名、起始块号、结束块号<img src=\"https://api2.mubu.com/v3/document_image/08f13025-f782-45ae-930f-8c6c6d6e14f2-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>方便文件拓展</p>\n<ul>\n<li>可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB</li>\n</ul>\n</li>\n<li><p>没有外部碎片，外存利用率高</p>\n<ul>\n<li>所有的空闲磁盘块都可以被利用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>只支持顺序访问，不支持随机访问，查找效率低</p>\n</li>\n<li><p>指向下一个盘块的指针也需要耗费少量的存储空间</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>显示链接</p>\n<ul>\n<li><p>把用于链接文件各物理块的指针显式地存放在一张表中，即文件分配表（FAT)</p>\n</li>\n<li><p>实现从逻辑地址到物理地址的映射：</p>\n<ul>\n<li><p>操作系统找到该文件对应的目录项（FCB）</p>\n</li>\n<li><p>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存</p>\n</li>\n<li><p>根据文件分配表（FAT）的指针，读取下一个磁盘块，直到找到 i 号逻辑块对应的物理块号</p>\n</li>\n</ul>\n</li>\n<li><p>访问次数：1次</p>\n<ul>\n<li>逻辑块号转换成物理块号的过程不需要读磁盘操作，访问的一直是一个磁盘块中的数据</li>\n</ul>\n</li>\n<li><p>文件目录：文件名、起始块号<img src=\"https://api2.mubu.com/v3/document_image/b7645279-d1ba-49f5-af25-692bd991aa99-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>文件分配表（FAT）：物理块号、下一块</p>\n<ul>\n<li><p>一个磁盘仅设置一张FAT</p>\n</li>\n<li><p>开机时，将FAT读入内存，并常驻内存</p>\n</li>\n<li><p>物理块号字段是隐含的：FAT 的各个表项在物理上连续存储，且每一个表项长度相同</p>\n</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>支持顺序访问，也支持随机访问</p>\n<ul>\n<li>想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1号逻辑块</li>\n</ul>\n</li>\n<li><p>访问速度加快，减少了访问磁盘次数</p>\n</li>\n<li><p>不会产生外部碎片，便于扩展</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>文件分配表的需要占用一定的存储空间</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>索引分配</p>\n<ul>\n<li><p>背景：索引分配解决了链接分配不能直接访问的问题</p>\n</li>\n<li><p>采用离散分配方式，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块</p>\n<ul>\n<li><p>索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系</p>\n</li>\n<li><p>索引表存放的磁盘块称为索引块，文件数据存放的磁盘块称为数据块</p>\n</li>\n</ul>\n</li>\n<li><p>文件目录：文件名、索引块（文件的索引块是几号磁盘块）<img src=\"https://api2.mubu.com/v3/document_image/8e2022bd-d6af-48d1-9bd8-3c0f3a59de56-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>索引表：逻辑块号（可以隐含）、物理块号<img src=\"https://api2.mubu.com/v3/document_image/691b8174-ea98-4793-b7f0-53d3a7f184ed-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>实现从逻辑地址到物理地址的映射：</p>\n<ul>\n<li><p>操作系统找到该文件对应的目录项（FCB）</p>\n</li>\n<li><p>从目录项中找到索引表存放位置，将索引表从外存读入内存</p>\n</li>\n<li><p>并查找索引表即可知i号逻辑块在外存中的存放位置</p>\n</li>\n</ul>\n</li>\n<li><p>访问次数：m级要访存m+1次</p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>支持顺序访问，也支持随机访问</p>\n<ul>\n<li>想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1号逻辑块</li>\n</ul>\n</li>\n<li><p>访问速度加快，减少了访问磁盘次数</p>\n</li>\n<li><p>不会产生外部碎片，便于扩展</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li>文件分配表的需要占用一定的存储空间</li>\n</ul>\n</li>\n<li><p>优化机制——如果一个磁盘块装不下文件的整张索引表</p>\n<ul>\n<li><p>链接方案：</p>\n<ul>\n<li><p>索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放</p>\n</li>\n<li><p>各个索引块之间是用指针链接起来的，因此若想要访问文件的最后一个逻辑块，就必须先顺序地读入前 255 个索引块</p>\n</li>\n</ul>\n</li>\n<li><p>多层索引：</p>\n<ul>\n<li><p>第一层索引块指向第二层索引块，第二层索引块指向文件块</p>\n</li>\n<li><p>若采用多层索引，则各层索引表大小不能超过一个磁盘块</p>\n</li>\n<li><p>读磁盘次数：</p>\n<ul>\n<li><p>采用二层索引，访问目标数据块，需要3次磁盘I&#x2F;O</p>\n</li>\n<li><p>采用K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要K + 1 次读磁盘操作</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>混合索引：</p>\n<ul>\n<li>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表）<img src=\"https://api2.mubu.com/v3/document_image/9b4de86a-8ef7-49aa-abc7-e3610a66136a-3224585.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li><p>重要考点：</p>\n<ul>\n<li><p>要会根据多层索引、混合索引的结构计算出文件的最大长度（Key：各级索引表最大不能超过一个块）</p>\n</li>\n<li><p>要能自己分析访问某个数据块所需要的读磁盘次数（Key：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件——顶级索引块是否已调入内存）</p>\n</li>\n</ul>\n</li>\n<li><p>易混淆难点：随机访问</p>\n<ul>\n<li><p>可以根据记录号直接算出该记录对应的逻辑地址 （逻辑块号，块内地址）</p>\n</li>\n<li><p>定长记录的顺序文件支持随机访问</p>\n</li>\n<li><p>不定长记录的顺序文件不支持随机访问</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注：文件的逻辑结构  VS  文件的物理结构</p>\n<ul>\n<li><p>文件的逻辑结构</p>\n<ul>\n<li><p>无结构文件</p>\n</li>\n<li><p>有结构文件</p>\n<ul>\n<li><p>顺序文件</p>\n<ul>\n<li><p>顺序存储</p>\n</li>\n<li><p>链式存储</p>\n</li>\n</ul>\n</li>\n<li><p>索引文件</p>\n</li>\n<li><p>索引顺序文件</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>文件的物理结构</p>\n<ul>\n<li><p>连续分配</p>\n</li>\n<li><p>链接分配</p>\n</li>\n<li><p>索引分配</p>\n</li>\n</ul>\n</li>\n<li><p>逻辑结构（从用户视角看）：</p>\n<ul>\n<li>用户用逻辑地址访问文件</li>\n</ul>\n</li>\n<li><p>物理结构（从操作系统视角看）</p>\n<ul>\n<li><p>二进制数据，每个磁盘块可存储1KB，被操作系统拆分为若干个块，逻辑块号相邻</p>\n</li>\n<li><p>根据逻辑上相邻的块，物理块是否相邻，可分类</p>\n<ul>\n<li><p>连续分配：逻辑上相邻的块，物理上也相邻</p>\n</li>\n<li><p>链接分配：逻辑上相邻的块，物理上用链接指针表示先后关系</p>\n</li>\n<li><p>索引分配：操作系统为每个文件维护一张索引表，其中记录了逻辑块号——&gt;物理块号 的映射关系</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>易混淆点：</p>\n<ul>\n<li><p>顺序文件采用顺序存储&#x2F;链式存储</p>\n<ul>\n<li><p>顺序文件：各个记录可以顺序存储或链式存储</p>\n</li>\n<li><p>顺序存储：各条记录相邻的存放</p>\n</li>\n<li><p>链式存储：各条记录离散着存放，用指针表示先后关系</p>\n</li>\n</ul>\n</li>\n<li><p>链式存储的顺序文件采用连续分配</p>\n<ul>\n<li><p>连续分配：逻辑上相邻的块物理上也相邻</p>\n</li>\n<li><p>文件内部各条记录链式存储：由创建文件的用户自己设计的</p>\n</li>\n<li><p>文件整体用链接分配：由操作系统决定</p>\n</li>\n</ul>\n</li>\n<li><p>逻辑结构：索引文件</p>\n<ul>\n<li><p>从用户视角来看，整个文件依然是连续存放的</p>\n</li>\n<li><p>如：前1MB存放索引项，后续部分存放记录</p>\n</li>\n</ul>\n</li>\n<li><p>索引文件采用索引分配</p>\n<ul>\n<li><p>索引文件的索引表：用户自己建立的，映射：关键字——&gt;记录存放的逻辑地址</p>\n</li>\n<li><p>索引分配的索引表：操作系统建立的，映射：逻辑块号——&gt;物理块号</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件存储空间管理——对空闲磁盘块的管理，即\"><a href=\"#文件存储空间管理——对空闲磁盘块的管理，即\" class=\"headerlink\" title=\"文件存储空间管理——对空闲磁盘块的管理，即\"></a>文件存储空间管理——对空闲磁盘块的管理，即</h2><ul>\n<li><p>存储空间的划分与初始化</p>\n<ul>\n<li><p>文件卷</p>\n<ul>\n<li><p>存储空间的划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）</p>\n</li>\n<li><p>存储空间的初始化：将各个文件卷划分为目录区、文件区</p>\n<ul>\n<li><p>目录区：主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息</p>\n</li>\n<li><p>文件区：存放文件数据</p>\n</li>\n</ul>\n</li>\n<li><p>有的系统支持超大型文件，可支持由多个物理磁盘组成一个文件卷</p>\n</li>\n</ul>\n</li>\n<li><p>目录区域文件区</p>\n<ul>\n<li><p>文件存储设备分成许多大小相同的物理块，以块为单位交换信息</p>\n</li>\n<li><p>文件存储设备管理的实质是对空闲块的组织和管理，包括空闲块的组织、分配与回收等问题</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>几种管理方法</p>\n<ul>\n<li><p>空闲表法：</p>\n<ul>\n<li><p>属于连续分配方式，系统为空闲区建立一张空闲盘块表，每个空闲区第一个盘块号，该区的空闲盘块数等信息</p>\n</li>\n<li><p>空闲盘块表：第一个空闲盘块号、空闲盘块数<img src=\"https://api2.mubu.com/v3/document_image/a9835b6c-ffe6-4cee-b201-7554e280e1c7-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>适用于 连续分配方式</p>\n</li>\n<li><p>如何分配磁盘块：</p>\n<ul>\n<li><p>为一个文件分配连续的存储空间</p>\n</li>\n<li><p>可采用首次适应、最佳适应、最坏适应等算法来决定文件分配的区间</p>\n</li>\n</ul>\n</li>\n<li><p>如何回收磁盘块</p>\n<ul>\n<li><p>回收区的前后都没有相邻空闲区：直接回收</p>\n</li>\n<li><p>回收区的前后都是空闲区：删除回收区和回收区后的表项，修改回收区之前的表项</p>\n</li>\n<li><p>回收区前面是空闲区：删除回收区的表项，修改回收区之前的表项</p>\n</li>\n<li><p>回收区后面是空闲区：删除回收区的后面的表项，修改回收区的表项</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>空闲链表法：将所有的空闲盘区拉成一条空闲链，根据构成链所有的基本元素不同，可以把链表分成两种形式</p>\n<ul>\n<li><p>空闲盘块链：以盘块为单位组成一条空闲链</p>\n<ul>\n<li><p>定义</p>\n<ul>\n<li><p>空闲盘块中存储着下一个空闲盘块的指针</p>\n</li>\n<li><p>操作系统保存着链头、链尾指针</p>\n</li>\n</ul>\n</li>\n<li><p>如何分配：</p>\n<ul>\n<li>若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针</li>\n</ul>\n</li>\n<li><p>如何回收：</p>\n<ul>\n<li>回收的盘块依次挂到链尾，并修改空闲链的链尾指针</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>适用于离散分配的物理结构</p>\n</li>\n<li><p>为文件分配多个盘块时可能要重复多次操作</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>空闲盘区链：以盘区为单位组成一条空闲链</p>\n<ul>\n<li><p>连续的空闲盘块组成一个空闲盘区</p>\n</li>\n<li><p>空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针</p>\n</li>\n<li><p>如何分配：</p>\n<ul>\n<li><p>若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件</p>\n</li>\n<li><p>若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据</p>\n</li>\n</ul>\n</li>\n<li><p>如何回收：</p>\n<ul>\n<li><p>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中</p>\n</li>\n<li><p>若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>适用于离散分配、连续分配</p>\n</li>\n<li><p>为一个文件分配多个盘块时效率更高</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>位示图法</p>\n<ul>\n<li><p>位示图：</p>\n<ul>\n<li><p>每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配</p>\n</li>\n<li><p>位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块</p>\n</li>\n<li><p>因此可以用（字号，位号）对应一个盘块号，当然有的题目中也描述为（行号，列号）</p>\n</li>\n</ul>\n</li>\n<li><p>对应关系——盘块号、字号、位号从0开始，n表示字长</p>\n<ul>\n<li><p>二进制对应盘块号：</p>\n<ul>\n<li>(字号, 位号)&#x3D;(i, j) 的二进制位对应的盘块号 b &#x3D; ni + j</li>\n</ul>\n</li>\n<li><p>盘块号对应二进制</p>\n<ul>\n<li>b号盘块对应的字号 i &#x3D; b&#x2F;n，位号 j &#x3D; b%n</li>\n</ul>\n</li>\n<li><p>注意题目条件：盘块号、字号、位号到底是从0开始还是从1开始</p>\n</li>\n</ul>\n</li>\n<li><p>如何分配：文件需要K个块</p>\n<ul>\n<li><p>顺序扫描位示图，找到K个相邻或不相邻的“0”</p>\n</li>\n<li><p>根据字号、位号算出对应的盘块号，将相应盘块分配给文件</p>\n</li>\n<li><p>将相应位设置为“1”</p>\n</li>\n</ul>\n</li>\n<li><p>如何回收：</p>\n<ul>\n<li><p>根据回收的盘块号计算出对应的字号、位号</p>\n</li>\n<li><p>将相应二进制位设为“0”</p>\n</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>适用于连续分配、离散分配</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>成组链接法</p>\n<ul>\n<li><p>背景：空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大</p>\n</li>\n<li><p>UNIX系统中采用了成组链接法对磁盘空闲块进行管理</p>\n</li>\n<li><p>定义：</p>\n<ul>\n<li><p>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存</p>\n</li>\n<li><p>并且要保证内存与外存中的“超级块”数据一致</p>\n</li>\n<li><p>把顺序的n个空闲扇区地址保存在第一个空闲扇区内，其后一个空闲扇区内则保存另一顺序空闲扇区的地址</p>\n</li>\n</ul>\n</li>\n<li><p>如何分配：需要100个空闲块</p>\n<ul>\n<li><p>检查第一个分组的块数是否足够。100&#x3D;100，是足够的。</p>\n</li>\n<li><p>分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</p>\n</li>\n</ul>\n</li>\n<li><p>如何回收：假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块</p>\n<ul>\n<li>需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件的基本操作\"><a href=\"#文件的基本操作\" class=\"headerlink\" title=\"文件的基本操作\"></a>文件的基本操作</h2><ul>\n<li><p>创建文件（create系统调用）</p>\n<ul>\n<li><p>提供的3个主要参数：</p>\n<ul>\n<li><p>\\1. 所需的外存空间大小（如：一个盘块，即1KB）</p>\n</li>\n<li><p>\\2. 文件存放路径（“D:&#x2F;Demo”）</p>\n</li>\n<li><p>\\3. 文件名（这个地方默认为“新建文本文档.txt”）</p>\n</li>\n</ul>\n</li>\n<li><p>Create 系统调用的实现：</p>\n</li>\n<li><p>\\1. 在外存中分配空间</p>\n</li>\n<li><p>2.在目录文件中创建该文件对应的目录项</p>\n<ul>\n<li>目录项中包含了文件名、文件在外存中的存放位置等信息</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>删除文件（delete系统调用）</p>\n<ul>\n<li><p>提供的2个主要参数：</p>\n<ul>\n<li><p>\\1. 文件存放路径（“D:&#x2F;Demo”）</p>\n</li>\n<li><p>\\2. 文件名（“test.txt”）</p>\n</li>\n</ul>\n</li>\n<li><p>Delete 系统调用的实现：</p>\n</li>\n<li><p>\\1. 找到相应的目录文件，从目录中找到文件名对应的目录项</p>\n</li>\n<li><p>\\2. 根据该目录项的记录（文件名、存放位置、文件大小），回收文件占用的磁盘块</p>\n</li>\n<li><p>\\3. 从目录表中删除文件对应的目录项</p>\n</li>\n</ul>\n</li>\n<li><p>读文件（read系统调用）</p>\n<ul>\n<li><p>将文件数据读入内存</p>\n</li>\n<li><p>提供的4个主要参数：</p>\n<ul>\n<li><p>\\1. 文件存放路径（“D:&#x2F;Demo”）</p>\n</li>\n<li><p>\\2. 文件名（“test.txt”）——在支持“打开文件”操作的系统中，只需要提供文件的索引号</p>\n</li>\n<li><p>3.所需的内存空间大小（如：一个盘块，即1KB）</p>\n</li>\n<li><p>4.读入的数据要放在内存中的什么位置</p>\n</li>\n</ul>\n</li>\n<li><p>进程的“打开文件表”：</p>\n<ul>\n<li><p>读指针：要读入的数据存放在外存中的什么位置</p>\n</li>\n<li><p>写指针：读入的数据要放在内存中的什么位置</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>写文件（write系统调用）</p>\n<ul>\n<li><p>将文件数据读入外存</p>\n</li>\n<li><p>提供的4个主要参数：</p>\n<ul>\n<li><p>\\1. 文件存放路径（“D:&#x2F;Demo”）</p>\n</li>\n<li><p>\\2. 文件名（“test.txt”）——在支持“打开文件”操作的系统中，只需要提供文件的索引号</p>\n</li>\n<li><p>3.所需的内存空间大小（如：一个盘块，即1KB）</p>\n</li>\n<li><p>4.写回外存的数据放在内存中的什么位置</p>\n</li>\n</ul>\n</li>\n<li><p>进程的“打开文件表”：</p>\n<ul>\n<li><p>读指针：要写回的数据存放在内存中的什么位置</p>\n</li>\n<li><p>写指针：写回的数据要放在外存中的什么位置</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>打开文件（open系统调用）</p>\n<ul>\n<li><p>提供的3个主要参数：</p>\n<ul>\n<li><p>\\1. 文件存放路径（“D:&#x2F;Demo”）</p>\n</li>\n<li><p>\\2. 文件名（“test.txt”）</p>\n</li>\n<li><p>\\3. 要对文件的操作类型（如：r 只读；rw 读写等）</p>\n</li>\n</ul>\n</li>\n<li><p>open 系统调用的实现：</p>\n<ul>\n<li><p>\\1. 找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限</p>\n</li>\n<li><p>\\2. 将目录项复制到内存中的“打开文件表”中，并将对应表目的编号返回给用户。之后用户使用打开文件表的编号（索引号、文件描述符）来指明要操作的文件。</p>\n</li>\n</ul>\n</li>\n<li><p>系统的打开文件表（整个系统只有一张）</p>\n<ul>\n<li><p>方便实现某些文件管理的功能</p>\n<ul>\n<li><p>例如：在Windows系统中，我们尝试删除某个txt文件，如果此时该文件已被某个“记事本”进程打开，则系统会提示我们“暂时无法删除该文件”</p>\n</li>\n<li><p>其实系统在背后做的事就是先检查了系统打开文件表，确认此时是否有进程正在使用该文件</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>用户进程的“打开文件表”</p>\n<ul>\n<li><p>读&#x2F;写指针记录了该进程对文件的读&#x2F;写操作进行到的位置</p>\n</li>\n<li><p>如果打开文件时声明的是“只读”，则该进程不能对文件进行写操作</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>关闭文件（close系统调用）</p>\n<ul>\n<li><p>将进程打开文件表中的对应表项删除</p>\n</li>\n<li><p>系统的打开文件表——打开计数器</p>\n<ul>\n<li><p>记录此时有多少个进程打开了此文件</p>\n</li>\n<li><p>系统打开文件的打开计数器减1，若打开计数器为0，则删除系统表的表项</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"文件系统层次结构\"><a href=\"#文件系统层次结构\" class=\"headerlink\" title=\"文件系统层次结构\"></a>文件系统层次结构</h2><ul>\n<li><p>功能：</p>\n<ul>\n<li><p>用户调用接口：</p>\n<ul>\n<li>文件系统需要向上层的用户提供一些简单易用的功能接口。这层就是用于处理用户发出的系统调用请求</li>\n</ul>\n</li>\n<li><p>文件目录系统：</p>\n<ul>\n<li>用户是通过文件路径来访问文件的，因此这一层需要根据用户给出的文件路径找到相应的FCB或索引结点。所有和目录、目录项相关的管理工作都在本层完成，如：管理活跃的文件目录表、管理打开文件表等</li>\n</ul>\n</li>\n<li><p>存取控制验证：</p>\n<ul>\n<li>为了保证文件数据的安全，还需要验证用户是否有访问权限。这一层主要完成了文件保护相关功能</li>\n</ul>\n</li>\n<li><p>逻辑文件系统关于文件信息缓冲区：</p>\n<ul>\n<li>用户指明想要访问文件记录号，这一层需要将记录号转换为对应的逻辑地址</li>\n</ul>\n</li>\n<li><p>物理文件系统：</p>\n<ul>\n<li>这一层需要把上一层提供的文件逻辑地址转换为实际的物理地址</li>\n</ul>\n</li>\n<li><p>辅助分配模块：</p>\n<ul>\n<li>负责文件存储空间的管理，即负责分配和回收存储空间</li>\n</ul>\n</li>\n<li><p>设备管理程序模块：</p>\n<ul>\n<li>直接与硬件交互，负责和硬件直接相关的一些管理工作。如：分配设备、分配设备缓冲区、磁盘调度、启动设备、释放设备等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>例子：用户请求删除文件</p>\n<ul>\n<li><p>1.用户需要通过操作系统提供的接口发出上述请求——用户接口</p>\n</li>\n<li><p>2.由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——文件目录系统</p>\n</li>\n<li><p>3.不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——存取控制模块（存取控制验证层）</p>\n</li>\n<li><p>4.验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——逻辑文件系统与文件信息缓冲区</p>\n</li>\n<li><p>5.知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——物理文件系统</p>\n</li>\n<li><p>6.要删除这条记录，必定要对磁盘设备发出请求——设备管理程序模块</p>\n</li>\n<li><p>7.删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——辅助分配模块</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"目录实现\"><a href=\"#目录实现\" class=\"headerlink\" title=\"目录实现\"></a>目录实现</h2><ul>\n<li><p>线性列表</p>\n<ul>\n<li><p>使用存储文件名和数据块指针的线性表</p>\n</li>\n<li><p>优点：实现简单</p>\n</li>\n<li><p>缺点：耗费时间</p>\n</li>\n</ul>\n</li>\n<li><p>哈希表</p>\n<ul>\n<li><p>根据文件名得到一个值，然后返回一个指向线性列表中元素的指针</p>\n</li>\n<li><p>优点：查找迅速，插入和删除简单</p>\n</li>\n<li><p>缺点：要避免充足，哈希表长度固定以及哈希函数对表长有依赖性</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"磁盘组织与管理\"><a href=\"#磁盘组织与管理\" class=\"headerlink\" title=\"磁盘组织与管理\"></a>磁盘组织与管理</h1><h2 id=\"磁盘的结构\"><a href=\"#磁盘的结构\" class=\"headerlink\" title=\"磁盘的结构\"></a>磁盘的结构</h2><ul>\n<li><p>概念</p>\n<ul>\n<li><p>磁盘：</p>\n<ul>\n<li><p>磁盘是采用磁信号记录数据的盘状物</p>\n</li>\n<li><p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>\n</li>\n</ul>\n</li>\n<li><p>磁道：</p>\n<ul>\n<li>磁盘的盘面被划分成一个个磁道。这样的一个“同心圆”就是一个磁道</li>\n</ul>\n</li>\n<li><p>磁区：</p>\n<ul>\n<li>一个磁道又被划分成一个个扇区，每个扇区就是一个“磁盘块”。各个扇区存放的数据量相同（如1KB）</li>\n</ul>\n</li>\n<li><p>盘面：</p>\n<ul>\n<li><p>磁盘通常由重叠的一组盘片构成</p>\n</li>\n<li><p>一个盘片可能会有两个盘面</p>\n</li>\n<li><p>每个盘面对应一个磁头</p>\n</li>\n<li><p>所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”</p>\n</li>\n</ul>\n</li>\n<li><p>柱面：</p>\n<ul>\n<li><p>具有相同编号的磁道形成一个圆柱</p>\n</li>\n<li><p>所有盘面中相对位置相同的磁道组成柱面</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何在磁盘中读&#x2F;写数据</p>\n<ul>\n<li><p>需要把“磁头”移动到想要读&#x2F;写的扇区所在的磁道</p>\n</li>\n<li><p>磁盘会转起来，让目标扇区从磁头下面划过，才能完成对扇区的读&#x2F;写操作</p>\n</li>\n</ul>\n</li>\n<li><p>磁盘的物理地址</p>\n<ul>\n<li><p>可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”</p>\n</li>\n<li><p>文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式</p>\n</li>\n<li><p>可根据该地址读取一个块：</p>\n<ul>\n<li><p>根据“柱面号”移动磁臂，让磁头指向指定柱面</p>\n</li>\n<li><p>激活指定盘面对应的磁头</p>\n</li>\n<li><p>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>磁盘的分类</p>\n<ul>\n<li><p>根据磁盘是否可移动</p>\n<ul>\n<li><p>磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道<img src=\"https://api2.mubu.com/v3/document_image/68780c9e-3db6-42b9-ac14-ae9395b847a1-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>磁头不可移动的称为固定头磁盘。这种磁盘中每个磁道有一个磁头<img src=\"https://api2.mubu.com/v3/document_image/1528fa67-41ac-4f36-81e4-b589d8bccd59-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>根据盘片是否可更换</p>\n<ul>\n<li><p>盘片可以更换的称为可换盘磁盘</p>\n</li>\n<li><p>盘片不可更换的称为固定盘磁盘</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"磁盘调度算法\"><a href=\"#磁盘调度算法\" class=\"headerlink\" title=\"磁盘调度算法\"></a>磁盘调度算法</h2><ul>\n<li><p>一次磁盘读&#x2F;写时间组成</p>\n<ul>\n<li><p>寻找时间：在读&#x2F;写数据前，将磁头移动到指定磁道所花的时间</p>\n<ul>\n<li><p>Ts&#x3D;s + m*n</p>\n</li>\n<li><p>启动磁头臂的耗时：s</p>\n</li>\n<li><p>移动磁头：m*n</p>\n<ul>\n<li>磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道</li>\n</ul>\n</li>\n<li><p>注：现在的硬盘移动一个磁道大约需要0.2ms，磁臂启动时间约为2ms</p>\n</li>\n</ul>\n</li>\n<li><p>延迟时间：通过旋转磁盘，使磁头定位到目标扇区所需要的时间</p>\n<ul>\n<li><p>Tr&#x3D;1&#x2F;2r（磁盘转速为 r （单位：转&#x2F;秒，或 转&#x2F;分））</p>\n</li>\n<li><p>1&#x2F;r 就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以 1&#x2F;2</p>\n</li>\n<li><p>注：硬盘的典型转速为5400 转&#x2F;分，或 7200转&#x2F;分</p>\n</li>\n</ul>\n</li>\n<li><p>传输时间：从磁盘读出或向磁盘写入数据所经历的时间</p>\n<ul>\n<li><p>Tr&#x3D;b&#x2F;(rN)（磁盘转速为 r，此次读&#x2F;写的字节数为 b，每个磁道上的字节数为 N）</p>\n</li>\n<li><p>每个磁道要可存 N 字节的数据，因此 b 字节的数据需要 b&#x2F;N 个磁道才能存储</p>\n</li>\n<li><p>读&#x2F;写一个磁道所需的时间刚好又是转一圈所需要的时间 1&#x2F;r</p>\n</li>\n</ul>\n</li>\n<li><p>优化：</p>\n<ul>\n<li><p>延迟时间和传输时间都无法优化</p>\n<ul>\n<li><p>都与磁盘转速相关，且为线性相关</p>\n</li>\n<li><p>转速是硬件的固有属性</p>\n</li>\n</ul>\n</li>\n<li><p>寻道时间</p>\n<ul>\n<li><p>启动磁头臂的时间是固定不变的</p>\n</li>\n<li><p>移动磁头所需要的时间则可以通过磁盘调度算法进行优化</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>磁盘调度算法</p>\n<ul>\n<li><p>先来先服务算法（FCFS）</p>\n<ul>\n<li><p>按照进程请求访问磁盘的先后顺序进行调度</p>\n</li>\n<li><p>优点：公平、实现简单</p>\n</li>\n<li><p>缺点：仅适用于少量进程访问，不适合大量进程访问</p>\n<ul>\n<li>如果有大量进程竞争使用磁盘，则请求访问的磁道会很分散，则需要不断的移动磁头臂，性能很差，寻道时间长</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>最短寻找时间优先算法（SSTF）</p>\n<ul>\n<li><p>选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道<img src=\"https://api2.mubu.com/v3/document_image/c9c726a1-6226-4ecf-bcca-4ee59c2e8811-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>优点：性能较好，平均寻道时间短</p>\n</li>\n<li><p>缺点：容易产生饥饿现象</p>\n<ul>\n<li>如果在处理18号磁道的访问请求时，而在18号磁道附近频繁地增加新的请求，则磁头将长时间在18号磁道附近工作，使得184号磁道的访问被无限期地延迟</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>扫描（SCAN）算法</p>\n<ul>\n<li><p>只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动<img src=\"https://api2.mubu.com/v3/document_image/03678642-41c3-481b-8f39-2c7708b28a44-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>优点：</p>\n<ul>\n<li><p>寻道性能较好</p>\n</li>\n<li><p>不会产生饥饿现象</p>\n</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>对最近扫描过的区域不公平</p>\n<ul>\n<li>最近扫描过的磁道，在一定的时间内不会再被扫描到，如果进程频繁访问该磁道，将产生巨大的寻道时间</li>\n</ul>\n</li>\n<li><p>有可能最边上的磁道不需要访问，会导致寻道时间增长</p>\n<ul>\n<li>只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了</li>\n</ul>\n</li>\n<li><p>对各个位置磁道的响应频率不平均</p>\n<ul>\n<li>中间的磁盘需要一个周期时间才会再次被访问，最边上的磁盘需要两个周期时间才会被再次访问</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>循环扫描算法（C-SCAN）</p>\n<ul>\n<li><p>只有到了最边上的磁道才能改变磁头移动方向，磁头返回途中不处理任何请求</p>\n<ul>\n<li>只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>对于各个位置磁道的响应频率很平均</li>\n</ul>\n</li>\n<li><p>缺点：</p>\n<ul>\n<li><p>有可能最边上的磁道不需要访问，会导致寻道时间增长</p>\n<ul>\n<li><p>处理了184号磁道的访问请求之后就不需要再往右移动磁头了</p>\n</li>\n<li><p>磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>LOOK与C-LOOK算法</p>\n<ul>\n<li><p>增加了查看移动方向上是否有请求，如果没有就不会继续向前移动，而是直接改变方向（LOOK）或者直接回到第一个请求处（C-LOOK）</p>\n</li>\n<li><p>LOOK</p>\n<ul>\n<li>如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向</li>\n</ul>\n</li>\n<li><p>C-LOOK</p>\n<ul>\n<li>如果在磁头移动方向上已经没有别的请求，就立即使磁头回到第一个请求处<ul>\n<li>磁头改变方向，在反方向上不处理任何请求，直到回到第一个请求处再改变方向，开始处理请求</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点：</p>\n<ul>\n<li>不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</li>\n</ul>\n</li>\n<li><p>注：若题目中无特别说明，则SCAN 就是 LOOK，C-SCAN 就是C-LOOK</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"减少延迟时间的方法\"><a href=\"#减少延迟时间的方法\" class=\"headerlink\" title=\"减少延迟时间的方法\"></a>减少延迟时间的方法</h2><ul>\n<li><p>交替编号</p>\n<ul>\n<li><p>延迟时间产生的原因：</p>\n<ul>\n<li><p>磁头读入一个扇区数据后需要一小段时间处理</p>\n</li>\n<li><p>如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的延迟时间（每读完一个扇区之后等待磁盘旋转一周，才能读取下一块磁盘）</p>\n</li>\n</ul>\n</li>\n<li><p>做法：</p>\n<ul>\n<li>将编号相邻的扇区在物理上不相邻</li>\n</ul>\n</li>\n<li><p>原理：让逻辑上相邻的扇区在物理上有一定的间隔，降低延迟时间</p>\n<ul>\n<li><p>读取完有一个扇区后，需要一段时间处理才可以继续读入下一个扇区</p>\n</li>\n<li><p>若逻辑上相邻的扇区在物理上有一定的间隔，则处理时间结束后，可以很快的读入逻辑上相邻的下一个扇区</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>错位命名</p>\n<ul>\n<li><p>延迟时间产生的原因：</p>\n<ul>\n<li><p>若相邻的盘面相对位置相同，即扇区编号相同</p>\n</li>\n<li><p>由于所有盘面都是一起连轴转的</p>\n</li>\n<li><p>读取完磁盘块（000,00, 111）之后，需要短暂的时间处理</p>\n</li>\n<li><p>当（000, 01, 000）第一次划过1号盘面的磁头下方时，并不能读取数据，只能再等磁盘旋转一周，直到该扇区再次划过磁头</p>\n</li>\n</ul>\n</li>\n<li><p>做法：</p>\n<ul>\n<li>让相邻盘面的盘区编号错位</li>\n</ul>\n</li>\n<li><p>原理：降低延迟时间</p>\n<ul>\n<li><p>由于采用错位命名法，因此读取完磁盘块（000, 00, 111）之后，还有一段时间处理</p>\n</li>\n<li><p>当（000, 01, 000）第一次划过1号盘面的磁头下方时，就可以直接读取数据</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>磁盘地址结构的设计</p>\n<ul>\n<li><p>理解为什么用（柱面号，盘面号，扇区号）的结构</p>\n<ul>\n<li><p>假设：磁盘有8个柱面&#x2F;磁道，4个盘面，8个扇区</p>\n</li>\n<li><p>如果连续读取（00, 000, 000）~（00, 001, 111）的扇区</p>\n</li>\n<li><p>由于柱面号&#x2F;磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可</p>\n</li>\n</ul>\n</li>\n<li><p>理解为什么不用（盘面号，柱面号，扇区号）的结构</p>\n<ul>\n<li><p>假设：磁盘有8个柱面&#x2F;磁道，4个盘面，8个扇区</p>\n</li>\n<li><p>如果连续读取（00, 000, 000）~（00, 001, 111）的扇区</p>\n</li>\n<li><p>读取8个扇区之后，需要启动磁头臂，将磁头移动到下一个磁道</p>\n</li>\n</ul>\n</li>\n<li><p>原因：</p>\n<ul>\n<li>在读取地址连续的磁盘块时，前者移动磁头的次数少（移动磁头消耗大量的时间）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"磁盘的管理\"><a href=\"#磁盘的管理\" class=\"headerlink\" title=\"磁盘的管理\"></a>磁盘的管理</h2><ul>\n<li><p>磁盘初始化</p>\n<ul>\n<li><p>低级格式化（物理格式化）：将磁盘的各个磁道划分为扇区</p>\n<ul>\n<li><p>一个扇区通常可分为 头、数据区域（如512B大小）、尾 三个部分组成</p>\n</li>\n<li><p>管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码</p>\n<ul>\n<li><p>例如：奇偶校验、CRC循环冗余校验码</p>\n</li>\n<li><p>校验码用于校验扇区中的数据是否发生错误</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进一步格式化处理：将磁盘分区，每个分区由若干柱面组成</p>\n<ul>\n<li>即分为我们熟悉的 C盘、D盘、E盘</li>\n</ul>\n</li>\n<li><p>对物理分区进行逻辑格式化：创建文件管理系统</p>\n<ul>\n<li><p>创建初始为空的文件系统的根目录</p>\n</li>\n<li><p>初始化存储空间管理所用的数据结构（如位示图、空闲分区表）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>引导块</p>\n<ul>\n<li><p>计算机启动时运行自举程序（初始化程序），完成初始化</p>\n<ul>\n<li>CPU寄存器、设备控制器和内存等，然后启动操作系统</li>\n</ul>\n</li>\n<li><p>自举程序放在ROM （只读存储器）中</p>\n<ul>\n<li><p>ROM中的数据在出厂时就写入了，并且以后不能再修改</p>\n<ul>\n<li>注：ROM一般是出厂时就集成在主板上的</li>\n</ul>\n</li>\n<li><p>需要更新自举程序时，很不方便，因为ROM中的数据无法更改</p>\n</li>\n</ul>\n</li>\n<li><p>ROM中存放很小的自举装入程序，完整的自举程序存放在初始块（引导块）中</p>\n<ul>\n<li><p>开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化</p>\n<ul>\n<li><p>完整的自举程序放在磁盘的启动块（即引导块&#x2F;启动分区）上，启动块位于磁盘的固定位置</p>\n</li>\n<li><p>拥有启动分区的磁盘称为启动磁盘或系统磁盘（C:盘）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>坏块的管理</p>\n<ul>\n<li><p>坏块：</p>\n<ul>\n<li>无法正常使用的扇区，属于硬件故障</li>\n</ul>\n</li>\n<li><p>管理：</p>\n<ul>\n<li>操作系统对坏块是无法修复的，但是会将坏块标记出来，以免错误地使用到它</li>\n</ul>\n</li>\n<li><p>简单的磁盘</p>\n<ul>\n<li><p>在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区</p>\n</li>\n<li><p>比如：在 FAT （文件分配表）上标明</p>\n</li>\n<li><p>坏块对操作系统不透明</p>\n</li>\n</ul>\n</li>\n<li><p>复杂的磁盘</p>\n<ul>\n<li><p>磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个磁盘坏块链表</p>\n</li>\n<li><p>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化</p>\n</li>\n<li><p>会保留一些“备用扇区”，用于替换坏块，这种方案称为扇区备用</p>\n</li>\n<li><p>坏块对操作系统透明</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","2.操作系统","4.文件管理"],"tags":["写作"]},{"title":"线性表","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2.%E7%BA%BF%E6%80%A7%E8%A1%A8/","content":"<h1 id=\"线性表的定义和基本操作\"><a href=\"#线性表的定义和基本操作\" class=\"headerlink\" title=\"线性表的定义和基本操作\"></a>线性表的定义和基本操作</h1><h2 id=\"线性表的定义\"><a href=\"#线性表的定义\" class=\"headerlink\" title=\"线性表的定义\"></a>线性表的定义</h2><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>特点</td>\n<td>个数有限、逻辑上有序、元素所占空间相同</td>\n</tr>\n<tr>\n<td>辨析</td>\n<td>线性表是逻辑结构、顺序表和链表是存储结构</td>\n</tr>\n</tbody></table>\n<h2 id=\"线性表的基本操作\"><a href=\"#线性表的基本操作\" class=\"headerlink\" title=\"线性表的基本操作\"></a>线性表的基本操作</h2><blockquote>\n<p>9种基本操作：初始化、求表长、按值查找、按位查找、插入、删除、打印、判空、销毁</p>\n</blockquote>\n<ul>\n<li>InitList(&amp;L) ：初始化表，构造一个空的线性表</li>\n<li>Length(L) ：求表长，返回线性表L的长度，即L中数据元素的个数</li>\n<li>LocateElem(L，e) ：按值查找操作，在表L中查找具有给定关键字值的元素</li>\n<li>Getilem(L，i) ：按位查找操作，获取表L中第个位置的元素的值</li>\n<li>Listinsert (&amp;L，i，e)：插入操作。在表L中的第个位置上插入指定元素</li>\n<li>ListDelete(&amp;L，i，&amp;e)：删除操作，除表L中第i个位置的元素，并用e返回删除元素的值</li>\n<li>PrintList(L)：输出操作，按前后顺序输出线性表L的所有元素值</li>\n<li>Empty (L)：判空操作,若L为空表,则返回true,否则返回false</li>\n<li>DestroyList(&amp;L)：销毁操作，销毁线性表，并释放线性表L所占用的内存空间</li>\n</ul>\n<h1 id=\"线性表的顺序表示\"><a href=\"#线性表的顺序表示\" class=\"headerlink\" title=\"线性表的顺序表示\"></a>线性表的顺序表示</h1><h2 id=\"顺序表的定义\"><a href=\"#顺序表的定义\" class=\"headerlink\" title=\"顺序表的定义\"></a>顺序表的定义</h2><ul>\n<li><p>线性表的顺序存储又称顺序表（逻辑上相邻的两个元素在物理位置上也相邻）</p>\n</li>\n<li><p>用一组地址连续的存储单元依次存储线性表中的数据元素</p>\n</li>\n<li><p>一维数组空间分配</p>\n<ul>\n<li><p>静态分配</p>\n<ul>\n<li>静态分配 数组的大小和空间已经固定，一旦空间占满，再加入新的数据将会产生溢出，程序就会崩溃</li>\n</ul>\n</li>\n<li><p>动态存储</p>\n<ul>\n<li><p>存储数组的空间是在程序执行过程中通过动态存储分配语句分配</p>\n</li>\n<li><p>一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注意</p>\n<ul>\n<li>动态分配仍然是顺序存储结构，物理结构没有变化，依然是随机存取方式只是分配的空间大小可以在运行时决定</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素</p>\n</li>\n<li><p>存储密度高，每个结点只存储数据元素</p>\n<ul>\n<li>与链表形成对比</li>\n</ul>\n</li>\n<li><p>逻辑上相邻的元素物理上也相邻，当执行插入和删除操作时，需要移动大量元素</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"顺序表上基本操作的实现\"><a href=\"#顺序表上基本操作的实现\" class=\"headerlink\" title=\"顺序表上基本操作的实现\"></a>顺序表上基本操作的实现</h2><h3 id=\"插入操作\"><a href=\"#插入操作\" class=\"headerlink\" title=\"插入操作\"></a>插入操作</h3><ul>\n<li><p>由于顺序表的中元素的物理位置是相邻的，所以当插入新元素的时候就需要对表中的元素进行整体移动 插入操作</p>\n</li>\n<li><p>实现情况（长度为n）</p>\n<ul>\n<li><p>最好情况：在表尾插入（i &#x3D; n+1），元素后移语句将不执行，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：在表头插入（i &#x3D; 1），元素后移语句将执行n次，时间复杂度为O(n)</p>\n</li>\n<li><p>平均情况</p>\n<ul>\n<li><p>假设pi （pi &#x3D; 1&#x2F;(n+1)）是在第i个位置上插入一个结点的概率</p>\n</li>\n<li><p>则在长度为n的线性表中插入一个结点时，移动节点的平均次数为<img src=\"https://api2.mubu.com/v3/document_image/7d54b4a9-73f7-4d5f-893e-a2644b431f1d-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>时间复杂度为O(n)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"删除操作\"><a href=\"#删除操作\" class=\"headerlink\" title=\"删除操作\"></a>删除操作</h3><ul>\n<li><p>即为移动元素，对想要删除的元素进行覆盖</p>\n</li>\n<li><p>最好情况：删除表尾元素（i&#x3D;n） ，无须移动元素，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：删除表头元素（i&#x3D;1），需移动除第一个元素外的所有元素，时间复杂度为0（n）</p>\n</li>\n<li><p>平均情况</p>\n<ul>\n<li><p>假设pi （pi&#x3D;1&#x2F;n）是在第i个位置上删除一个结点的概率</p>\n</li>\n<li><p>则在长度为n的线性表中删除一个结点时，删除节点的平均次数为<img src=\"https://api2.mubu.com/v3/document_image/b9edf3df-0fcb-4d9b-be5d-433d592d5d7d-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>时间复杂度为O(n)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"按值查找（顺序查找）\"><a href=\"#按值查找（顺序查找）\" class=\"headerlink\" title=\"按值查找（顺序查找）\"></a>按值查找（顺序查找）</h3><ul>\n<li><p>最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)</p>\n</li>\n<li><p>最坏情况：查找的元素在表尾（或不存在）时，需要比较n次，时间复杂度为O(n)</p>\n</li>\n<li><p>平均情况</p>\n<ul>\n<li><p>假设pi（pi&#x3D;1&#x2F;n）是查找的元素在第i （1&lt;&#x3D;i&lt;&#x3D;L.1ength ）个位置上的概率</p>\n</li>\n<li><p>则在长度为n的线性表中查找值为e的元素所需比较的平均次数为<img src=\"https://api2.mubu.com/v3/document_image/60fe618f-db3c-4775-b651-154b65f8eefd-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>时间复杂度为O(n)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"线性表的链式表示\"><a href=\"#线性表的链式表示\" class=\"headerlink\" title=\"线性表的链式表示\"></a>线性表的链式表示</h1><h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><ul>\n<li><p>顺序表</p>\n<ul>\n<li><p>优点：可以随时存取表中的任意一个元素</p>\n</li>\n<li><p>缺点：插入和删除操作需要移动大量元素</p>\n</li>\n</ul>\n</li>\n<li><p>链式存储线性表</p>\n<ul>\n<li><p>优点：不需要使用地址连续的存储单元，插入和删除操作不需要移动元素，而只需修改指针</p>\n</li>\n<li><p>缺点：失去顺序表可随机存取的优点</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"两种实现方式\"><a href=\"#两种实现方式\" class=\"headerlink\" title=\"两种实现方式\"></a>两种实现方式</h2><ul>\n<li><p>带头结点</p>\n<ul>\n<li>空表判断：L&#x3D;&#x3D;NULL，代码书写不便</li>\n</ul>\n</li>\n<li><p>不带头结点</p>\n<ul>\n<li>空表判断： L—&gt;next&#x3D;&#x3D;NULL，写代码更方便</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"单链表的定义\"><a href=\"#单链表的定义\" class=\"headerlink\" title=\"单链表的定义\"></a>单链表的定义</h2><ul>\n<li><p>线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素</p>\n</li>\n<li><p>对每个链表结点，除存放元素自身的信息外，还需要存放一个指向其后继的指针</p>\n</li>\n<li><p>结构</p>\n<ul>\n<li><p>data ：数据域，存放数据元素</p>\n</li>\n<li><p>next ：指针域存放其后继结点的地址</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>解决顺序表需要大量连续存储单元的缺点</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>单链表附加指针域，浪费存储空间</p>\n</li>\n<li><p>查找某个特定的结点时，需要从表头开始遍历，依次查找</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"单链表上基本操作的实现\"><a href=\"#单链表上基本操作的实现\" class=\"headerlink\" title=\"单链表上基本操作的实现\"></a>单链表上基本操作的实现</h2><h3 id=\"采用头插法建立单链表\"><a href=\"#采用头插法建立单链表\" class=\"headerlink\" title=\"采用头插法建立单链表\"></a>采用头插法建立单链表</h3><ul>\n<li><p>从一个空表开始，生成新结点并将读取到的数据存放到新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后</p>\n</li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/8f7c33ba-1cf0-49ff-bc5f-efcf600da748-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>时间复杂度</p>\n<ul>\n<li><p>每个结点插入的时间复杂度为O(1)</p>\n</li>\n<li><p>设单链表长为n则总时间复杂度为0(n)</p>\n</li>\n</ul>\n</li>\n<li><p>优点：算法实现简单</p>\n</li>\n<li><p>缺点：生成的链表中结点的次序和输入数据的顺序不一致</p>\n<ul>\n<li>可以利用这个特点进行链表转置</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"采用尾插法建立单链表\"><a href=\"#采用尾插法建立单链表\" class=\"headerlink\" title=\"采用尾插法建立单链表\"></a>采用尾插法建立单链表</h3><ul>\n<li><p>该方法将新结点插入到当前链表的表尾，为此必须增加一个尾指针r，使其始终指向当前链表的尾结点</p>\n</li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/1feef162-3fd7-490d-87ae-f87560e5defe-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"按序号查找结点值（链表的本身特点原因，查找只能依次遍历查找）\"><a href=\"#按序号查找结点值（链表的本身特点原因，查找只能依次遍历查找）\" class=\"headerlink\" title=\"按序号查找结点值（链表的本身特点原因，查找只能依次遍历查找）\"></a>按序号查找结点值（链表的本身特点原因，查找只能依次遍历查找）</h3><ul>\n<li>时间复杂度O(n)</li>\n</ul>\n<h3 id=\"按值查找表结点（链表的本身特点原因，查找只能依次遍历查找）\"><a href=\"#按值查找表结点（链表的本身特点原因，查找只能依次遍历查找）\" class=\"headerlink\" title=\"按值查找表结点（链表的本身特点原因，查找只能依次遍历查找）\"></a>按值查找表结点（链表的本身特点原因，查找只能依次遍历查找）</h3><ul>\n<li>时间复杂度O(n)</li>\n</ul>\n<h3 id=\"插入结点操作\"><a href=\"#插入结点操作\" class=\"headerlink\" title=\"插入结点操作\"></a>插入结点操作</h3><ul>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/90a80651-f5fa-485d-810b-51b633a5af12-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>实现代码段</p>\n<ul>\n<li><p>p &#x3D; GetElem(L，i-1);</p>\n</li>\n<li><p>s-&gt;next&#x3D;p-&gt;next;</p>\n</li>\n<li><p>p-&gt;next&#x3D;s;</p>\n</li>\n</ul>\n</li>\n<li><p>若在给定的节点下进行插入，则时间复杂度为0（1）</p>\n</li>\n<li><p>本算法主要的时间开销在于查找第i-1个元素，时间复杂度为0（n）</p>\n</li>\n</ul>\n<h3 id=\"对某一结点进行前插操作\"><a href=\"#对某一结点进行前插操作\" class=\"headerlink\" title=\"对某一结点进行前插操作\"></a>对某一结点进行前插操作</h3><ul>\n<li><p>即寻找到要插入结点的前一个结点，然后按照正常插入方法执行即可</p>\n</li>\n<li><p>时间复杂度为O(n)</p>\n</li>\n</ul>\n<h3 id=\"删除结点操作\"><a href=\"#删除结点操作\" class=\"headerlink\" title=\"删除结点操作\"></a>删除结点操作</h3><ul>\n<li><p>删除结点操作是将单链表的第1个结点删除。先检查删除位置的合法性，后查找表中第i-1个结点即被删结点的前驱结点，再将其删除</p>\n</li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/89bb048b-1802-4a33-ac7e-09adf8b985e3-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>该算法的</p>\n</li>\n</ul>\n<h3 id=\"删除结点-p\"><a href=\"#删除结点-p\" class=\"headerlink\" title=\"删除结点*p\"></a>删除结点*p</h3><ul>\n<li><p>方法一</p>\n<ul>\n<li><p>求表长操</p>\n</li>\n<li><p>要删除某个给定结点*p，通常的做法是先从链表的头结点开始顺序找到其前驱结点然后再执行删除操作</p>\n</li>\n<li><p>算法的时间复杂度为0（n）</p>\n</li>\n</ul>\n</li>\n<li><p>方法二</p>\n<ul>\n<li><p>删除*p的后继结点操作来实现，实质就是将其后继结点的值赋予其自身，然后删除后继结点</p>\n</li>\n<li><p>时间复杂度为0（1）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"求表长操作\"><a href=\"#求表长操作\" class=\"headerlink\" title=\"求表长操作\"></a>求表长操作</h3><ul>\n<li><p>从第一个结点开始顺序依次访问表中的每个结点，为此需要设置一个计数器变量，每访问一个结点，计数器加1，直到访问到空结点为止</p>\n</li>\n<li><p>算法的时间复杂度为0（n）</p>\n</li>\n</ul>\n<h2 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h2><ul>\n<li><p>单链表的缺点</p>\n<ul>\n<li><p>单链表只能从头结点依次顺序地向后遍历</p>\n</li>\n<li><p>不能够快速的对其前驱结点进行操作</p>\n</li>\n</ul>\n</li>\n<li><p>概念</p>\n<ul>\n<li>双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点</li>\n</ul>\n</li>\n<li><p>双链表的插入操作</p>\n<ul>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/e2c9e5aa-964d-4a43-b108-0f23717b4158-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>原则就是在进行双链表插入的时候要保证不会造成断链</p>\n</li>\n</ul>\n</li>\n<li><p>双链表的删除操作</p>\n<ul>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/aa618e93-8f2c-4c95-9bf9-e66bc581e043-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>原则仍然是在进行操作的时候一定要考虑是否会造成断链</p>\n</li>\n</ul>\n</li>\n<li><p>操作的时候一定要考虑，本操作顺序是否会造成后继结点的丢失</p>\n</li>\n</ul>\n<h2 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h2><ul>\n<li><p>循环单链表</p>\n<ul>\n<li><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，形成了一个环</p>\n</li>\n<li><p>判空条件：头结点的指针是否等于头指针</p>\n</li>\n<li><p>仅设尾指针</p>\n<ul>\n<li><p>如果是要在链首之前插入结点，此时效率明显更高</p>\n</li>\n<li><p>时间复杂度O(1)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>循环双链表</p>\n<ul>\n<li><p>在循环双链表中，头结点的prior指针还要指向表尾结点</p>\n</li>\n<li><p>在循环双链表L中,某结点*p为尾结点时,p-&gt;next&#x3D;&#x3D;L</p>\n</li>\n<li><p>当循环双链表为空表时，其头结点的prior域和next都等于L</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h2><ul>\n<li><p>基本结构</p>\n<ul>\n<li><p>静态链表借助数组来描述线性表的链式存储结构</p>\n<ul>\n<li>静态链表也要预先分配一块连续的内存空间</li>\n</ul>\n</li>\n<li><p>结点也有数据域data和指针域next</p>\n<ul>\n<li>这里的指针是结点的相对地址（数组下标），又称游标</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>静态链表以next &#x3D;&#x3D; -1作为其结束的标志</p>\n</li>\n<li><p>静态链表的插入、删除操作与动态链表的相同，只需要修改指针，而不需要移动元素</p>\n</li>\n</ul>\n</li>\n<li><p>优点：增、删操作不需要大量移动元素</p>\n</li>\n<li><p>缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变</p>\n</li>\n<li><p>适用场景：①不支持指针的低级语言；②数据元素数量固定不变的场景（如操作系统的文件分配表FAT）</p>\n</li>\n</ul>\n<h2 id=\"顺序表和链表的比较\"><a href=\"#顺序表和链表的比较\" class=\"headerlink\" title=\"顺序表和链表的比较\"></a>顺序表和链表的比较</h2><ul>\n<li><p>存取（读写）方式</p>\n<ul>\n<li><p>顺序表可以顺序存取，也可以随机存取</p>\n</li>\n<li><p>链表只能从表头顺序存取元素</p>\n</li>\n</ul>\n</li>\n<li><p>逻辑结构与物理结构</p>\n<ul>\n<li><p>顺序存储：逻辑上相邻的元素，对应的物理存储位置也相邻</p>\n</li>\n<li><p>链式存储：逻辑上相邻的元素，物理存储位置则不一定相邻，对应的逻辑关系是通过指针链接来表示的</p>\n</li>\n</ul>\n</li>\n<li><p>查找、插入和删除操作</p>\n<ul>\n<li><p>按值查找</p>\n<ul>\n<li><p>顺序表有序：可采用折半查找此时的时间复杂度为O(log2n)</p>\n</li>\n<li><p>顺序表无序时：两者的时间复杂度均为O(n)</p>\n</li>\n</ul>\n</li>\n<li><p>对于按序号查找</p>\n<ul>\n<li><p>顺序表支持随机访问，时间复杂度仅为O(1)</p>\n</li>\n<li><p>链表的平均时间复杂度为O(n)</p>\n</li>\n</ul>\n</li>\n<li><p>插入、删除操作</p>\n<ul>\n<li><p>顺序表：平均需要移动半个表长的元素</p>\n</li>\n<li><p>链表：只需修改相关结点的指针域</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>空间分配</p>\n<ul>\n<li><p>顺序存储</p>\n<ul>\n<li><p>静态分配</p>\n<ul>\n<li>存储空间满则无法进行扩充会出现内存溢出</li>\n</ul>\n</li>\n<li><p>动态分配</p>\n<ul>\n<li>对空间进行扩充的时候需要进行数据移动，效率低下</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>连式存储</p>\n<ul>\n<li>空间分配非常灵活</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"选取存储结构\"><a href=\"#选取存储结构\" class=\"headerlink\" title=\"选取存储结构\"></a>选取存储结构</h2><ul>\n<li><p>基于存储的考虑</p>\n<ul>\n<li><p>难以估计线性表的长度或存储规模时，不宜采用顺序表</p>\n</li>\n<li><p>链表不用事先估计存储规模，但链表的存储密度较低</p>\n</li>\n</ul>\n</li>\n<li><p>基于运算的考虑</p>\n<ul>\n<li><p>按序号访问数据元素</p>\n<ul>\n<li>顺序表优于链表</li>\n</ul>\n</li>\n<li><p>进行插入、删除等操作</p>\n<ul>\n<li>链表优于顺序表</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>基于环境的考虑</p>\n<ul>\n<li><p>顺序表基于数组更容易实习</p>\n</li>\n<li><p>链表基于指针，在某些编程语言中不适合实现</p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","3.数据结构","2.线性表"],"tags":["写作"]},{"title":"串","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4%E4%B8%B2/","content":"<h1 id=\"串的定义和实现\"><a href=\"#串的定义和实现\" class=\"headerlink\" title=\"串的定义和实现\"></a>串的定义和实现</h1><h2 id=\"基本概述\"><a href=\"#基本概述\" class=\"headerlink\" title=\"基本概述\"></a>基本概述</h2><ul>\n<li><p>串是由零个或多个字符组成的有限序列</p>\n</li>\n<li><p>串的长度：串中字符的个数n（不包括双引号）</p>\n</li>\n<li><p>子串：</p>\n<ul>\n<li><p>串中任意个连续的字符组成的子序列称为该串的子串</p>\n</li>\n<li><p>空串也是串的子串</p>\n</li>\n</ul>\n</li>\n<li><p>主串：</p>\n<ul>\n<li>包含子串的串相应地称为主串</li>\n</ul>\n</li>\n<li><p>子串在主串中的位置：</p>\n<ul>\n<li>以子串的第一个字符在主串中的位置来表示（位序从1开始）</li>\n</ul>\n</li>\n<li><p>空格串</p>\n<ul>\n<li><p>由一个或多个空格（空格是特殊字符）组成的串称为空格串</p>\n</li>\n<li><p>其长度为串中空格字符的个数，每个空格字符占1B</p>\n</li>\n</ul>\n</li>\n<li><p>空串</p>\n<ul>\n<li>串中没有字符，其长度为0</li>\n</ul>\n</li>\n<li><p>串与线性表的区别</p>\n<ul>\n<li><p>串是一种特殊的线性表，数据元素之间呈线性关系</p>\n</li>\n<li><p>1、线性表的数据元素是任意数据类型</p>\n<ul>\n<li>串的数据元素的数据类型是字符集，对数据类型进行限制</li>\n</ul>\n</li>\n<li><p>2、线性表的基本操作对象是单个字符，串的基本操作对象是子串</p>\n</li>\n</ul>\n</li>\n<li><p>串相等：</p>\n<ul>\n<li>当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"串的存储结构\"><a href=\"#串的存储结构\" class=\"headerlink\" title=\"串的存储结构\"></a>串的存储结构</h2><h3 id=\"定长顺序存储表示（静态数组）\"><a href=\"#定长顺序存储表示（静态数组）\" class=\"headerlink\" title=\"定长顺序存储表示（静态数组）\"></a>定长顺序存储表示（静态数组）</h3><ul>\n<li><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列</p>\n</li>\n<li><p>截断：串的实际长度只能小于等于MAXLEN，超过预定义长度的串值会被舍去</p>\n</li>\n<li><p>静态数组的存储空间不需要手动释放（free），在函数执行结束后，系统会自动释放静态数组的存储空间</p>\n</li>\n<li><p>优缺点：</p>\n<ul>\n<li><p>优点：随机存取</p>\n</li>\n<li><p>缺点：无法进行空间的拓展和收缩（插入、删除）</p>\n</li>\n</ul>\n</li>\n<li><p>串表示方法</p>\n<ul>\n<li><p>1、用一个额外的变量来存放串的长度</p>\n</li>\n<li><p>2、串值后面加一个不计入串长的结束标记字符”\\0”，此时的串长为隐含值</p>\n</li>\n<li><p>弊端</p>\n<ul>\n<li><p>串值序列的长度超过上界，约定用截断法处理</p>\n</li>\n<li><p>解决方法</p>\n<ul>\n<li>用不限定串长的最大长度，即采用动态分配的方式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>四种方案</p>\n<ul>\n<li><p>方案1：Length放在静态数组末尾，优点：对字符串长度无限制</p>\n</li>\n<li><p>方案2：Length放在ch[0]，缺点：Length只有一个字节，串长度最大是255</p>\n</li>\n<li><p>方案3：缺点需要从ch[0]开始往后扫描，如果经常访问字符串长度，方案不可取</p>\n</li>\n<li><p>方案4：舍弃ch[0]，声明int Length，优点：兼具方案1和方案2优点</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"堆分配存储表元（动态数组）\"><a href=\"#堆分配存储表元（动态数组）\" class=\"headerlink\" title=\"堆分配存储表元（动态数组）\"></a>堆分配存储表元（动态数组）</h3><ul>\n<li><p>堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的</p>\n<ul>\n<li><p>malloc函数：申请存储空间</p>\n</li>\n<li><p>free函数：手动释放空间</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"块链存储表示\"><a href=\"#块链存储表示\" class=\"headerlink\" title=\"块链存储表示\"></a>块链存储表示</h3><ul>\n<li><p>每个结点既可以存放一个字符，也可以存放多个字符。每个结点称为块，整个链表称为块链结构</p>\n<ul>\n<li><p>每个结点存储1个字符1B，一个指针4B，存储密度低</p>\n</li>\n<li><p>每个结点存储多个字符，可以提高存储密度（每个结点实际有用的数据所占据的空间比例会升高）</p>\n<ul>\n<li>结点的字符数不足，使用（#）号键或\\0填充</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/6f38494f-d110-4017-9e7f-688478482cff-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<h2 id=\"串的基本操作\"><a href=\"#串的基本操作\" class=\"headerlink\" title=\"串的基本操作\"></a>串的基本操作</h2><ul>\n<li><p>StrAssign（&amp;T,chars）：赋值操作。把串赋值为chars</p>\n</li>\n<li><p>StrCopy（&amp;T，S ）：复制操作。由串S复制得到串T</p>\n</li>\n<li><p>StrEmpty（S）：判空操作。若S为空串则返回TRUE,否则返回FALSE</p>\n</li>\n<li><p>Strcompare（S，T ）：比较操作。若S&gt;T，则返回值&gt;0：若s&#x3D;T，则返回值&#x3D;0：若s&lt;T，则返回值&lt;0</p>\n<ul>\n<li><p>从第一个字符开始往后依次对比，先出现更大字符的串就更大（应用：英语单词按字母进行排序）</p>\n</li>\n<li><p>长串的前缀与短串相同时，长串更大</p>\n</li>\n<li><p>&#x2F;&#x2F;对于两个字符串的第i个值进行一一对比，i从0开始，如果值不相等，返回S中对应字符的ASCII码-T中对应字符的ASCII码<img src=\"https://api2.mubu.com/v3/document_image/c873e70d-f946-4e0d-b20c-b7013fd8c4f2-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>&#x2F;&#x2F;扫描完所有的字符都相同，则长度长的串更大，返回S的长度-T的长度<img src=\"https://api2.mubu.com/v3/document_image/60b11cc0-d817-46ed-90e3-480ab0b5078b-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>StrLength（S）：求串长。返回串S的元素个数</p>\n<ul>\n<li>顺序存储方案4：就是返回Length的值</li>\n</ul>\n</li>\n<li><p>SubString（&amp;Sub，S，pos，len）：求子串。用Sub返回串S的第pos个字符起长度为len的子串</p>\n<ul>\n<li><p>&#x2F;&#x2F;判断子串范围越界（pos+len-1不能超过子串的长度）<img src=\"https://api2.mubu.com/v3/document_image/ebf88b81-0e2a-42be-a54a-b13dd7200bba-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>&#x2F;&#x2F;将从第pos个字节开始，将S的字符一一赋值给Sub串<img src=\"https://api2.mubu.com/v3/document_image/ac92342e-0671-4fb4-bbba-b0cdeb81574e-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>&#x2F;&#x2F;设置串的长度<img src=\"https://api2.mubu.com/v3/document_image/9d0b81cf-573b-4c1a-94f0-2ad83c42c429-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>Concat（&amp;T，S1，S2）：串联接。用T返回由S1和S2联接而成的新串</p>\n<ul>\n<li>T&#x3D;S1+S2，需要存储空间扩展</li>\n</ul>\n</li>\n<li><p>Index（S，T）：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</p>\n<ul>\n<li><p>使用取子串操作+比较操作</p>\n</li>\n<li><p>&#x2F;&#x2F;求出S和T的长度，定义一个串 暂存 取下的子串<img src=\"https://api2.mubu.com/v3/document_image/514a02e0-311d-449d-9929-ac176e0f3b40-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>&#x2F;&#x2F;使用循环，依次取长度&#x3D;T的子串，进行比较操作</p>\n<ul>\n<li><p>如果比较操作结果!&#x3D;0，则说明取下的子串与T不相等；如果比较操作结果&#x3D;0，说明子串&#x3D;T，返回子串的位置</p>\n</li>\n<li><p>n-m+1是子串的个数</p>\n</li>\n</ul>\n</li>\n<li><p>&#x2F;&#x2F;如果始终没有找到与T相同的子串，返回0<img src=\"https://api2.mubu.com/v3/document_image/43efb11e-49c9-4029-bbb3-10912eb4e737-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>ClearString（&amp;S）：清空操作。将s清为空串</p>\n<ul>\n<li><p>将字符串的内容在逻辑上清空，但是存储空间并没有释放，还可以往这个串里面存储数据</p>\n</li>\n<li><p>顺序存储方案4：将Length设为0</p>\n</li>\n</ul>\n</li>\n<li><p>DestroyString（&amp;S）：销毁串。将串S销毁</p>\n<ul>\n<li>将存储空间释放，不能往这个串里面存储数据</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符集编码：给字符集编码\"><a href=\"#字符集编码：给字符集编码\" class=\"headerlink\" title=\"字符集编码：给字符集编码\"></a>字符集编码：给字符集编码</h2><ul>\n<li><p>任何数据存储在计算机中时都是二进制数。确定字符和二进制数的对应规则就是编码。</p>\n<ul>\n<li>比较字符的大小其实就是比较二进制数的大小</li>\n</ul>\n</li>\n<li><p>ASCII编码的每个字符都占8bit（1B），所以空格占1B</p>\n</li>\n<li><p>英文字符——ASCII字符集（一个字符只有8bit，对于表示别的字符，8bit肯定不够用）</p>\n<ul>\n<li><p>01100001：a</p>\n</li>\n<li><p>01000001：A</p>\n</li>\n<li><p>00100000：空格</p>\n</li>\n</ul>\n</li>\n<li><p>中英文——Unicode字符集</p>\n<ul>\n<li><p>基于同一个字符集，也可以有不同的编码规则，如：</p>\n<ul>\n<li>UTF-8、UTF-16</li>\n</ul>\n</li>\n<li><p>注：基于不同的编码方式，每个字符所占空间不同，考研中每个字符只占1B</p>\n</li>\n</ul>\n</li>\n<li><p>文件乱码：</p>\n<ul>\n<li>解码与编码规则不同。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"串的模式匹配\"><a href=\"#串的模式匹配\" class=\"headerlink\" title=\"串的模式匹配\"></a>串的模式匹配</h1><h2 id=\"简单的模式匹配算法（朴素模式匹配算法）\"><a href=\"#简单的模式匹配算法（朴素模式匹配算法）\" class=\"headerlink\" title=\"简单的模式匹配算法（朴素模式匹配算法）\"></a>简单的模式匹配算法（朴素模式匹配算法）</h2><ul>\n<li><p>子串的定位操作通常称为串的模式匹配，它求的是子串（常称模式串）在主串中的位置</p>\n</li>\n<li><p>子串与模式串</p>\n<ul>\n<li><p>子串：主串的一部分，一定存在</p>\n</li>\n<li><p>模式串：想要查找的串，在主串中不一定找到</p>\n</li>\n</ul>\n</li>\n<li><p>实现思想</p>\n<ul>\n<li><p>将主串中与模式串长度相同的子串搞出来，挨个与模式串对比</p>\n</li>\n<li><p>当子串与模式串某个对应字符不匹配时，就立即放弃当前子串，转而检索下一个子串</p>\n</li>\n<li><p>找到第一个域模式串匹配的子串，则返回子串的起始位置</p>\n</li>\n<li><p>若所有子串都不匹配，则返回0</p>\n</li>\n</ul>\n</li>\n<li><p>长度为n的主串中，长度为m的子串的个数：n-m+1</p>\n</li>\n<li><p>实现代码：不使用字符串的基本操作，直接通过数组下标实现</p>\n<ul>\n<li><p>i &#x3D; i - j +2，i-j回到目前子串的前一个位置，i-j+2才能指向下一个子串的起始位置</p>\n</li>\n<li><p>j&#x3D;1，重新从模式串的第一个字符开始匹配</p>\n</li>\n<li><p>如果j&gt;T.length，则当前子串匹配成功，返回当前子串的第一个字符位置：i-T.length</p>\n</li>\n<li><p>&#x2F;&#x2F;指针i指向S的第一个字符，指针j指向T的第一个字符<img src=\"https://api2.mubu.com/v3/document_image/89c3f6d1-3689-448f-a40f-6e00bc33da2b-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>&#x2F;&#x2F;如果对应字符相同，逐个往后匹配字符；如果对应字符不同，i指针回退到下个子串的第一个字符，j指针回退到模式串的第一个字符<img src=\"https://api2.mubu.com/v3/document_image/a88b042a-2908-4973-b89c-53883a9a09ea-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>&#x2F;&#x2F;如果都匹配失败，则i指针会因为超出主串范围而停止；如果匹配成功j会因为超出模式串的长度而停止<img src=\"https://api2.mubu.com/v3/document_image/e1ce0c35-546d-4cfe-b05c-5280388e9c3d-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>缺点：主串指针会出现回溯现象导致时间开销增加</p>\n</li>\n<li><p>最坏时间复杂度： O(mn)，其中n和m分别为主串和模式串的长度</p>\n<ul>\n<li>对比了n-m+1个子串，每个子串都对比了m个字符</li>\n</ul>\n</li>\n<li><p>最好时间复杂度：O(m)，匹配第一个子串就成功了</p>\n</li>\n</ul>\n<h2 id=\"改进的模式匹配算法一KMP算法\"><a href=\"#改进的模式匹配算法一KMP算法\" class=\"headerlink\" title=\"改进的模式匹配算法一KMP算法\"></a>改进的模式匹配算法一KMP算法</h2><ul>\n<li><p>字符串的前缀、后缀和部分匹配值</p>\n</li>\n<li><p>next数组：当模式串的第j个字符匹配失败时，令模式串跳到next[j]再继续匹配</p>\n<ul>\n<li><p>对比主串元素与模式串元素是否相等，如果不相等，j的值&#x3D;next[j]</p>\n</li>\n<li><p>如果第一个元素匹配失败，除了j&#x3D;next[j]，还要i++，j++</p>\n</li>\n</ul>\n</li>\n<li><p>算法实现：in Index_KMP(SString S,SString T,int next[])</p>\n<ul>\n<li><p>&#x2F;&#x2F;从主串的1和模式串的1开始匹配<img src=\"https://api2.mubu.com/v3/document_image/ae518220-3440-41e4-9be3-fd6ab2f85331-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>&#x2F;&#x2F;如果主串的元素和模式串的元素都相等的话，同时++；当j&#x3D;0，说明第一个元素不匹配，i和j也需要同时++。否则主串和模式串的元素不匹配，发生失配，令j&#x3D;next[j]<img src=\"https://api2.mubu.com/v3/document_image/c3ffdfff-b544-4fa3-809f-573fba7e8ee7-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>&#x2F;&#x2F;如果j&gt;模式串的长度，则匹配成功；否则i超过主串的长度，则匹配失败<img src=\"https://api2.mubu.com/v3/document_image/8332efd4-12f0-4042-b866-f161961873cc-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>获取串的匹配值—求出与模式串相匹配的next数组</p>\n<ul>\n<li><p>手算：”google”</p>\n<ul>\n<li><p>next[1]&#x3D;0，任何模式串都一样，第1个字符不匹配时，只能匹配下一个子串，所以next[1]&#x3D;&#x3D;0</p>\n</li>\n<li><p>next[2]&#x3D;1，任何模式串都一样，第2个字符不匹配时，应尝试匹配模式串的第1个字符，因此next[2]&#x3D;&#x3D;1</p>\n</li>\n<li><p>next[3]&#x3D;1</p>\n<ul>\n<li>在主串的第i个字符左侧画一条线，模式串依次往右移，观察线左侧的主串和模式串是否匹配，如果匹配的话将指针j移动到线右侧第一个字符的位置</li>\n</ul>\n</li>\n<li><p>next[4]&#x3D;1</p>\n</li>\n<li><p>next[5]&#x3D;2</p>\n</li>\n</ul>\n</li>\n<li><p>‘ababa’为例</p>\n<ul>\n<li><p>‘a’的前缀和后缀都为空集，最长相等前后缀长度为0</p>\n</li>\n<li><p>‘ab’的前缀为{a},后缀为{b}，{a}n{b}&#x3D;0，最长相等前后缀长度为0</p>\n</li>\n<li><p>‘aba’的前缀为{a，ab}，后缀为{a，ba}，{a，ab}n{a，ba} &#x3D; {a}，最长相等前后缀长度为1</p>\n</li>\n<li><p>‘abab’的前缀{a，ab，aba}，后缀{b，ab，bab} &#x3D; {ab}，最长相等前后缀长度为2</p>\n</li>\n<li><p>‘ababa’的前缀{a，ab，aba，abab}，后缀{a，ba， aba，baba} &#x3D; {a，aba}，公共元素有两个最长相等前后缀长度为3</p>\n</li>\n<li><p>故字符串’ababa’的部分匹配值为00123</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>当子串和模式串不匹配时，主串指针i不回溯，模式串指针j&#x3D;next[j]</p>\n<ul>\n<li>利用好不匹配字符前的字符是一一匹配的信息，也就是利用好模式串已匹配的信息</li>\n</ul>\n</li>\n<li><p>最坏时间复杂度：O(m+n)</p>\n<ul>\n<li><p>其中求next数组的时间复杂度是O(m)</p>\n</li>\n<li><p>模式匹配过程的最坏复杂度是O(n)</p>\n</li>\n</ul>\n</li>\n<li><p>优点：主串不会进行回溯</p>\n</li>\n</ul>\n<h2 id=\"KMP算法的进一步优化\"><a href=\"#KMP算法的进一步优化\" class=\"headerlink\" title=\"KMP算法的进一步优化\"></a>KMP算法的进一步优化</h2><ul>\n<li>KMP算法优化：当子串和模式串不匹配时j &#x3D; nextval[j]<ul>\n<li>通过构造nextval函数</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","3.数据结构","4.串"],"tags":["写作"]},{"title":"栈","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","content":"<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><h2 id=\"栈的基本概念\"><a href=\"#栈的基本概念\" class=\"headerlink\" title=\"栈的基本概念\"></a>栈的基本概念</h2><ul>\n<li><p>只允许在一端进行插入或删除操作的线性表 先进后出</p>\n</li>\n<li><p>结构</p>\n<ul>\n<li><p>栈顶（Top） ：线性表允许进行插入删除的那一端</p>\n</li>\n<li><p>栈底（ Bottom ） ：固定的，不允许进行插入和删除的另一端</p>\n</li>\n</ul>\n</li>\n<li><p>卡特兰数</p>\n<ul>\n<li>n个不同元素进栈，出栈元素不同排列的个数为<img src=\"https://api2.mubu.com/v3/document_image/cc6cff5e-2b41-42b4-b737-b1c12d6e73b7-3224585.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n<li><p>栈的基本操作（在解答算法题时，若题干末做出限制，则可直接使用这些基本的操作函数）</p>\n<ul>\n<li><p>InitStack （&amp;S）；初始化一个空栈S</p>\n</li>\n<li><p>StackEmpty （S）：判断一个栈是否为空，若栈S为空则返回true.否则返回false.</p>\n</li>\n<li><p>Push （&amp;S， x）：进栈，若栈S未满，则将x加入使之成为新栈顶</p>\n</li>\n<li><p>Pop （&amp;S， &amp;x）：出栈，若栈S非空，则弹出栈顶元素，并用x返回</p>\n</li>\n<li><p>GetTop（S ， &amp;x） ：读栈顶元素，若栈S非空，则用x返回栈顶元素</p>\n</li>\n<li><p>DestroyStack （&amp;S）：销毁栈，并释放栈S占用的存储空间（“&amp;”表示引用调用）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"栈的顺序存储结构\"><a href=\"#栈的顺序存储结构\" class=\"headerlink\" title=\"栈的顺序存储结构\"></a>栈的顺序存储结构</h2><h3 id=\"顺序栈的实现\"><a href=\"#顺序栈的实现\" class=\"headerlink\" title=\"顺序栈的实现\"></a>顺序栈的实现</h3><ul>\n<li><p>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置</p>\n</li>\n<li><p>基本结构与操作</p>\n<ul>\n<li><p>栈顶指针：<a href=\"http://s.top/\">S.top</a>，初始时设置<a href=\"http://s.top/\">S.top</a> &#x3D; -1</p>\n</li>\n<li><p>栈顶元素：S.data[<a href=\"http://s.top/\">S.top</a>]</p>\n</li>\n<li><p>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素</p>\n</li>\n<li><p>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1</p>\n</li>\n<li><p>栈空条件<a href=\"http://s.top/\">S.top</a> &#x3D;&#x3D; -1</p>\n</li>\n<li><p>栈满条件：<a href=\"http://s.top/\">S.top</a>&#x3D;&#x3D;MaxSize -1</p>\n</li>\n<li><p>栈长：<a href=\"http://s.top/\">S.top</a>+1</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"顺序栈的基本操作\"><a href=\"#顺序栈的基本操作\" class=\"headerlink\" title=\"顺序栈的基本操作\"></a>顺序栈的基本操作</h3><ul>\n<li><p>初始化<img src=\"https://api2.mubu.com/v3/document_image/9e8645f8-6674-48af-886a-6dac79904d72-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>判栈空<img src=\"https://api2.mubu.com/v3/document_image/0542fd31-4a86-4aff-9f53-857c06397b7b-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>进栈<img src=\"https://api2.mubu.com/v3/document_image/6aa37405-0e63-42cd-b53c-09cc57718ddc-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>出栈<img src=\"https://api2.mubu.com/v3/document_image/1d091041-b8ba-4ff1-84cb-2da77de10190-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>读栈顶元素<img src=\"https://api2.mubu.com/v3/document_image/1cf119e3-4312-4d63-a3c8-73a588c134cf-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"共享栈\"><a href=\"#共享栈\" class=\"headerlink\" title=\"共享栈\"></a>共享栈</h3><ul>\n<li><p>让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸</p>\n</li>\n<li><p>基本原则</p>\n<ul>\n<li><p>两个栈的栈顶指针都指向栈顶元素，top0&#x3D;-1时0号栈为空，top1&#x3D;MaxSize时1号栈为空</p>\n</li>\n<li><p>当两个栈顶指针相邻( top1-top0 &#x3D; 1 )时,判断为栈满</p>\n</li>\n<li><p>当0号栈进栈时，top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时则刚好相反</p>\n</li>\n</ul>\n</li>\n<li><p>存取数据的时间复杂度均为O(1)</p>\n</li>\n</ul>\n<h2 id=\"栈的链式存储结构\"><a href=\"#栈的链式存储结构\" class=\"headerlink\" title=\"栈的链式存储结构\"></a>栈的链式存储结构</h2><ul>\n<li><p>采用单链表实现，并规定所有操作都是在单链表的表头进行</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>便于多个栈共享存储空间和提高其效率</p>\n</li>\n<li><p>且不存在栈满上溢的情况</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><h2 id=\"队列的基本概念\"><a href=\"#队列的基本概念\" class=\"headerlink\" title=\"队列的基本概念\"></a>队列的基本概念</h2><ul>\n<li><p>队列的定义</p>\n<ul>\n<li><p>是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除</p>\n</li>\n<li><p>向队列中插入元素称为入队或进队；删除元素称为出队或离队</p>\n</li>\n<li><p>先进先出</p>\n</li>\n<li><p>结构</p>\n<ul>\n<li><p>队头（Front ） ：允许删除的一端，又称队首</p>\n</li>\n<li><p>队尾（Rear） ：允许插入的一端</p>\n</li>\n<li><p>空队列：不含任何元素的空表</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>队列的基本操作</p>\n<ul>\n<li><p>InitQueue （&amp;Q）：初始化队列，构造一个空队列Q</p>\n</li>\n<li><p>QueueEmpty (Q):判队列空,若队列Q为空返回true.否则返回 false</p>\n</li>\n<li><p>EnQueue （&amp;Q ， x）：入队，若队列Q未满，将x加入，使之成为新的队尾</p>\n</li>\n<li><p>DeQueue （&amp;Q ， &amp;x） ：出队，若队列Q非空，删除队头元素，并用x返回</p>\n</li>\n<li><p>GetHead(Q, &amp;x)：读队头元素,若队列Q非空,则将队头元素赋值给X</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"队列的顺序存储结构\"><a href=\"#队列的顺序存储结构\" class=\"headerlink\" title=\"队列的顺序存储结构\"></a>队列的顺序存储结构</h2><ul>\n<li><p>队列的顺序存储</p>\n<ul>\n<li><p>分配一块连续的存储单元存放队列中的元素，并附设两个指针</p>\n</li>\n<li><p>队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置（具体问题具体分析）</p>\n</li>\n<li><p>基本操作</p>\n<ul>\n<li><p>初始状态（队空条件）：0.front&#x3D;&#x3D;Q.rear&#x3D;&#x3D;0</p>\n</li>\n<li><p>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1</p>\n</li>\n<li><p>出队操作：队不空时，先取队头元素值，再将队头指针加1</p>\n</li>\n</ul>\n</li>\n<li><p>假溢出</p>\n<ul>\n<li>这种溢出并不是真正的溢出，在data数组中依然存在可以存放元素的空位置</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"队列的链式存储结构\"><a href=\"#队列的链式存储结构\" class=\"headerlink\" title=\"队列的链式存储结构\"></a>队列的链式存储结构</h2><ul>\n<li><p>队列的链式存储</p>\n<ul>\n<li><p>队列的链式表示称为链队列，是一个同时带有队头指针和队尾指针的单链表。</p>\n</li>\n<li><p>头指针指向队头结点</p>\n</li>\n<li><p>尾指针指向队尾结点</p>\n</li>\n<li><p>当Q.front &#x3D;&#x3D; NULL且Q.rear &#x3D;&#x3D; NULL时，链式队列为空</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>适合于数据元素变动比较大的情形</p>\n</li>\n<li><p>不存在队列满且产生溢出的问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h2><ul>\n<li><p>把存储队列元素的表从逻辑上视为一个环，称为循环队列</p>\n</li>\n<li><p>基本操作</p>\n<ul>\n<li><p>初始时Q.front&#x3D;Q.rear&#x3D;0 基本操作</p>\n</li>\n<li><p>队首指针进1：Q.front&#x3D; ( Q.front+1 ) %MaxSize</p>\n</li>\n<li><p>队尾指针进1：0.rear&#x3D;（Q.rear+1）%MaxSize</p>\n</li>\n<li><p>队列长度：(O.rear+ MaxSize-O.front)%MaxSize</p>\n</li>\n</ul>\n</li>\n<li><p>判断条件</p>\n<ul>\n<li><p>队空：Q.front&#x3D; Q.rear</p>\n</li>\n<li><p>队满</p>\n<ul>\n<li><p>牺牲一个单元来区分队空和队满，即”队头指针在队尾指针的下一位置作为队满的标志”</p>\n<ul>\n<li><p>队满条件：（Q.rear+1）%MaxSize&#x3D;Q.front</p>\n</li>\n<li><p>队空条件：Qfront&#x3D;&#x3D;Q.rear</p>\n</li>\n<li><p>队列中元素的个数：（ Q.rear - Q.front+MaxSize ）%MaxSize</p>\n</li>\n</ul>\n</li>\n<li><p>类型中增设表示元素个数的数据成员。</p>\n<ul>\n<li><p>队空：为Q.size&#x3D;&#x3D;0</p>\n</li>\n<li><p>队满： Q.size&#x3D;&#x3D;MaxSize</p>\n</li>\n</ul>\n</li>\n<li><p>类型中增设tag数据成员，以区分是队满还是队满</p>\n<ul>\n<li><p>tag等于0时，若因删除导致O.front&#x3D;&#x3D;O.rear，则为队空</p>\n</li>\n<li><p>tag等于1时，若因插入导致Q.front&#x3D;&#x3D;Q.rear，则为队满</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>双端队列是指允许两端都可以进行入队和出队操作的队列</p>\n</li>\n<li><p>逻辑结构仍是线性结构</p>\n</li>\n<li><p>将队列的两端分别称为前端和后端，两端都可以入队和出队</p>\n</li>\n</ul>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列</p>\n</li>\n<li><p>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"栈与队列的应用\"><a href=\"#栈与队列的应用\" class=\"headerlink\" title=\"栈与队列的应用\"></a>栈与队列的应用</h1><h2 id=\"栈的应用\"><a href=\"#栈的应用\" class=\"headerlink\" title=\"栈的应用\"></a>栈的应用</h2><h3 id=\"括号匹配\"><a href=\"#括号匹配\" class=\"headerlink\" title=\"括号匹配\"></a>括号匹配</h3><h3 id=\"表达式求值\"><a href=\"#表达式求值\" class=\"headerlink\" title=\"表达式求值\"></a>表达式求值</h3><h4 id=\"中缀表达式转后缀表达式（手算）\"><a href=\"#中缀表达式转后缀表达式（手算）\" class=\"headerlink\" title=\"中缀表达式转后缀表达式（手算）\"></a>中缀表达式转后缀表达式（手算）</h4><ul>\n<li><p>1、确定中缀表达式中各个运算符的运算顺序</p>\n</li>\n<li><p>2、选择下一个运算符，按照「左操作数，右操作数，运算符」的方式组合成一个新的操作数</p>\n</li>\n<li><p>3、如果还有运算符没被处理，就继续2</p>\n</li>\n</ul>\n<h4 id=\"后缀表达式的计算\"><a href=\"#后缀表达式的计算\" class=\"headerlink\" title=\"后缀表达式的计算\"></a>后缀表达式的计算</h4><ul>\n<li><p>手算</p>\n<ul>\n<li>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应运算，合体为一个操作数</li>\n</ul>\n</li>\n<li><p>机算</p>\n<ul>\n<li><p>1、从左往右扫描下一个元素，直到处理完所有元素</p>\n</li>\n<li><p>2、若扫描到操作数则压入栈，并回到1；否则执行3</p>\n</li>\n<li><p>3、若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"中缀表达式转前缀表达式（手算）\"><a href=\"#中缀表达式转前缀表达式（手算）\" class=\"headerlink\" title=\"中缀表达式转前缀表达式（手算）\"></a>中缀表达式转前缀表达式（手算）</h4><ul>\n<li><p>1、确定中缀表达式中各个运算符的运算顺序</p>\n</li>\n<li><p>2、选择下一个运算符，按照「左操作数  右操作数  运算符」的方式组合成一个新的操作数</p>\n</li>\n<li><p>3、如果还有运算符没被处理，就继续2</p>\n</li>\n</ul>\n<h4 id=\"前缀表达式的计算\"><a href=\"#前缀表达式的计算\" class=\"headerlink\" title=\"前缀表达式的计算\"></a>前缀表达式的计算</h4><ul>\n<li><p>1、从右往左扫描下一个元素，直到处理完所有元素</p>\n</li>\n<li><p>2、若扫描到操作数则压入栈，并回到1；否则执行3</p>\n</li>\n<li><p>3、若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算条件压回栈顶，回到1</p>\n</li>\n</ul>\n<h4 id=\"中缀表达式转后缀表达式\"><a href=\"#中缀表达式转后缀表达式\" class=\"headerlink\" title=\"中缀表达式转后缀表达式\"></a>中缀表达式转后缀表达式</h4><ul>\n<li><p>手算</p>\n<ul>\n<li><p>1、确定中缀表达式中各个运算符的运算顺序</p>\n</li>\n<li><p>2、选择下一个运算符，按照「左操作数  右操作数  运算符」的方式组合成一个新的操作数</p>\n</li>\n<li><p>3、如果还有运算符没被处理，就继续2</p>\n</li>\n<li><p>“左优先”原则：只要左边的运算符能先计算，就优先算左边的</p>\n</li>\n</ul>\n</li>\n<li><p>机算</p>\n<ul>\n<li><p>从左到右处理各个元素，直到末尾。可能遇到三种情况：</p>\n</li>\n<li><p>1、遇到操作数。直接加入后缀表达式。</p>\n</li>\n<li><p>2、遇到界限符。遇到”(“直接入栈；遇到”)”则依次弹出栈内运算符，并加入后缀表达式，直到弹出”(“为止。</p>\n<ul>\n<li>注意：”(“不加入后缀表达式。</li>\n</ul>\n</li>\n<li><p>3、遇到运算符。依次弹出栈中优先级高于等于当前运算符的所有运算符，并加入后缀表达式，若碰到”(“或栈空则停止。之后再把当前运算符入栈</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"中缀表达式的计算（用栈实现）\"><a href=\"#中缀表达式的计算（用栈实现）\" class=\"headerlink\" title=\"中缀表达式的计算（用栈实现）\"></a>中缀表达式的计算（用栈实现）</h4><ul>\n<li><p>初始化两个栈，操作数栈和运算符栈</p>\n</li>\n<li><p>若扫描到操作数，压入操作数栈</p>\n</li>\n<li><p>若扫描到运算符或界限符，则按照“中缓转后缀”相同的逻辑压入运算符栈（期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈顶元素并执行相应运算，运算结果再压回操作数栈）</p>\n</li>\n</ul>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><ul>\n<li><p>计算正整数的阶乘n!(缺点： 多层递归可能会导致栈溢出)</p>\n<ul>\n<li><p>递归调用时，函数调用栈可称为”递归工作栈”</p>\n</li>\n<li><p>每进入一层递归，就将递归调用所需信息压入栈顶</p>\n</li>\n<li><p>每退出一层递归，就从栈顶弹出相应信息</p>\n</li>\n</ul>\n</li>\n<li><p>求斐波那契数列</p>\n</li>\n</ul>\n<h2 id=\"队列在计算机系统中的应用\"><a href=\"#队列在计算机系统中的应用\" class=\"headerlink\" title=\"队列在计算机系统中的应用\"></a>队列在计算机系统中的应用</h2><ul>\n<li><p>解决主机与外部设备之间速度不匹配的问题</p>\n<ul>\n<li>利用队列先进先出的性质，实现对打印机与主机速度不匹配的协调功能</li>\n</ul>\n</li>\n<li><p>解决由多用户引起的资源竞争问题</p>\n<ul>\n<li>将多个用户排成一个队列，然后利用先进先出的性质分别将CPU分配给不同的用户使用</li>\n</ul>\n</li>\n<li><p>图的广度优先遍历</p>\n</li>\n</ul>\n<h1 id=\"矩阵的压缩存储\"><a href=\"#矩阵的压缩存储\" class=\"headerlink\" title=\"矩阵的压缩存储\"></a>矩阵的压缩存储</h1><h2 id=\"一般矩阵的存储\"><a href=\"#一般矩阵的存储\" class=\"headerlink\" title=\"一般矩阵的存储\"></a>一般矩阵的存储</h2><ul>\n<li><p>数组的定义</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li><p>数组是由n个相同类型的数据元素构成的有限序列</p>\n</li>\n<li><p>每个数据元素称为一个数组元素</p>\n</li>\n<li><p>每个元素在n个线性关系中的序号称为该元素的下标，下标的取值范围称为数组的维界</p>\n<ul>\n<li>下标默认从0开始计数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数组与线性表的关系</p>\n<ul>\n<li><p>数组是线性表的推广</p>\n</li>\n<li><p>一维数组可视为一个线性表；二维数组可视为其元素也是定长线性表的线性表</p>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li>数组一旦被定义，其维数和维界就不再改变</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数组的存储结构</p>\n<ul>\n<li><p>一个数组的所有元素在内存中占用一段连续的存储空间(各个数组元素大小相同，且物理上连续存放)</p>\n<ul>\n<li><p>下标如果从0开始计数</p>\n<ul>\n<li>数组元素a[i]的存放地址 &#x3D; LOC + i*sizeof(ElemType)</li>\n</ul>\n</li>\n<li><p>小标如果从1开始计数</p>\n<ul>\n<li>数组元素a[i]的存放地址 &#x3D; LOC + (i-1)*sizeof(ElemType)</li>\n</ul>\n</li>\n<li></li>\n</ul>\n</li>\n<li><p>多维数组</p>\n<ul>\n<li><p>映射方法（考试的时候可以根据具体问题现场推演）（可以实现随机存储）</p>\n<ul>\n<li><p>按行优先</p>\n<ul>\n<li><p>按照一行一行的存储</p>\n</li>\n<li><p>二维数组公式<img src=\"https://api2.mubu.com/v3/document_image/a06ecf97-c29b-4bbb-8af9-751106425731-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>按列优先</p>\n<ul>\n<li><p>按照一列一列的存储</p>\n</li>\n<li><p>二维数组公式<img src=\"https://api2.mubu.com/v3/document_image/cc29deee-9ff0-4427-ae69-7b583caac257-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"特殊矩阵的压缩存储\"><a href=\"#特殊矩阵的压缩存储\" class=\"headerlink\" title=\"特殊矩阵的压缩存储\"></a>特殊矩阵的压缩存储</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ul>\n<li><p>普通矩阵</p>\n<ul>\n<li>可用二维数组存储<ul>\n<li>注意：描述矩阵元素时，行、列号通常从1开始；而描述数组时通常下标从0开始</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>压缩存储（用于特殊矩阵）</p>\n<ul>\n<li><p>指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间</p>\n</li>\n<li><p>目的是为了节省存储空间</p>\n</li>\n</ul>\n</li>\n<li><p>特殊矩阵</p>\n<ul>\n<li><p>指具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵</p>\n</li>\n<li><p>常见的特殊矩阵</p>\n<ul>\n<li><p>对称矩阵</p>\n<ul>\n<li>n阶方阵，任意一个元素都有a_i,j&#x3D;a_j,i，即沿主对角线对称</li>\n</ul>\n</li>\n<li><p>上（下）三角矩阵</p>\n</li>\n<li><p>对角矩阵</p>\n</li>\n</ul>\n</li>\n<li><p>特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"对称矩阵（记不住公式的话记住推导过程，考试的时候可以-直接带入试试）\"><a href=\"#对称矩阵（记不住公式的话记住推导过程，考试的时候可以-直接带入试试）\" class=\"headerlink\" title=\"对称矩阵（记不住公式的话记住推导过程，考试的时候可以 直接带入试试）\"></a>对称矩阵（记不住公式的话记住推导过程，考试的时候可以 直接带入试试）</h3><ul>\n<li><p>概念</p>\n<ul>\n<li><p>关于主对角线对称的矩阵</p>\n</li>\n<li><p>上三角区：位于对角线右上方的区域</p>\n</li>\n<li><p>下三角区：位于对角线左下方的区域</p>\n</li>\n</ul>\n</li>\n<li><p>策略</p>\n<ul>\n<li><p>只存储主对角线和下三角区的数据</p>\n</li>\n<li><p>按行优先原则将个元素存入一维数组中<img src=\"https://api2.mubu.com/v3/document_image/5f0734c1-c0db-409c-b2d6-4ffb47a12cfd-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>数组大小：(1+n)*n&#x2F;2</p>\n</li>\n<li><p>最后一个元素的数组下标为(n+1)*n&#x2F;2-1</p>\n</li>\n<li><p>如果i&lt;j，那么访问a_i,j的时候 &#x3D; 访问a_j,i</p>\n</li>\n</ul>\n</li>\n<li><p>计算公式（映射函数：将矩阵下标转为一维数组下标）</p>\n<ul>\n<li><p>行优先：k为数组下标：从0开始，k&#x3D;第n个元素-1<img src=\"https://api2.mubu.com/v3/document_image/ff7abbb7-eb48-4a76-a7f1-9326615249b0-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>列优先：：k为数组下标：从0开始，k&#x3D;第n个元素-1</p>\n<ul>\n<li>k&#x3D;n+(n-1)+……+(n-j+2)+(i-j)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三角矩阵\"><a href=\"#三角矩阵\" class=\"headerlink\" title=\"三角矩阵\"></a>三角矩阵</h3><ul>\n<li><p>下三角矩阵</p>\n<ul>\n<li><p>上三角区的所有元素均为同一常量</p>\n</li>\n<li><p>存储完下三角区和主对角线上的元素之后，紧接着存储对角线上方的常量一次</p>\n</li>\n<li><p>元素下标之间的对应关系<img src=\"https://api2.mubu.com/v3/document_image/f2bdab06-7a3a-4dfd-9183-b9791a2bee59-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>下三角矩阵在内存中的压缩存储形式<img src=\"https://api2.mubu.com/v3/document_image/cc520661-1432-422a-8adb-819cfe20f12c-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>上三角矩阵</p>\n<ul>\n<li><p>下三角区的所有元素均为同一常量</p>\n</li>\n<li><p>只需存储主对角线、上三角区上的元素和下三角区的常量一次</p>\n</li>\n<li><p>元素下标之间的对应关系<img src=\"https://api2.mubu.com/v3/document_image/ae834106-dff5-44b7-b341-b0f79569080a-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>上三角矩阵在内存中的压缩存储形式<img src=\"https://api2.mubu.com/v3/document_image/f6f8b8ca-1de7-4005-ad88-045a5f4a43f7-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"三对角矩阵\"><a href=\"#三对角矩阵\" class=\"headerlink\" title=\"三对角矩阵\"></a>三对角矩阵</h3><ul>\n<li><p>又称为带状矩阵，以角线为中心的3条对角线的区域，其他区域的元素都为零（即行号和列号相差大于1时，元素为0）</p>\n</li>\n<li><p>三对角矩阵A也可以采用压缩存储，将3条对角线上的元素按行优先方式存放在一维数组B中，且a_1,1存放于B[0]中</p>\n<ul>\n<li><p>矩阵元素的个数：3n-2</p>\n</li>\n<li><p>最后一个元素的数组下标：3n-3</p>\n</li>\n</ul>\n</li>\n<li><p>矩阵元素在一维数组B（数组下标从0开始）中存放的下标为k&#x3D;2i + j - 3</p>\n</li>\n<li><p>数组下标k映射到矩阵：<img src=\"https://api2.mubu.com/v3/document_image/ce0ed1d7-cb05-4a67-b24f-9ac6fce34d35-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"稀疏矩阵\"><a href=\"#稀疏矩阵\" class=\"headerlink\" title=\"稀疏矩阵\"></a>稀疏矩阵</h3><ul>\n<li><p>矩阵中非零元素的个数t，相对矩阵元素的个数s来说非常少，即s&gt;&gt;t的矩阵称为稀疏矩阵（矩阵中很多0）</p>\n</li>\n<li><p>存储结构</p>\n<ul>\n<li><p>顺序存储：三元组</p>\n<ul>\n<li><p>将非零元素及其相应的行和列构成一个三元组（行标，列标，值）</p>\n</li>\n<li><p>定义struct{i;j;v}</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注意：稀疏矩阵压缩存储后便失去了随机存取特性</p>\n</li>\n<li><p>稀疏矩阵的三元组既可以采用数组存储也可以采用（链式存储）十字链表法存储<img src=\"https://api2.mubu.com/v3/document_image/2b6a34f1-52c8-4903-8739-58bb97fe2d89-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n","categories":["计算机408","3.数据结构","3.栈"],"tags":["写作"]},{"title":"树与二叉树","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><h2 id=\"树的定义\"><a href=\"#树的定义\" class=\"headerlink\" title=\"树的定义\"></a>树的定义</h2><ul>\n<li><p>树是n（n之0）个节点的有限集。当n&#x3D;0时，称为空树</p>\n</li>\n<li><p>在任意一棵非空树中应满足</p>\n<ul>\n<li><p>有且仅有一个特定的称为根的结点</p>\n</li>\n<li><p>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1，T2……Tm，其中每个集合本身又是一棵树，并且称为根的子树</p>\n<ul>\n<li>根结点的子树是互不相交的，如果相交就不是树</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>树是一种逻辑结构，也是一种分层结构</p>\n<ul>\n<li><p>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱</p>\n<ul>\n<li>否则不是树，而是图（网）</li>\n</ul>\n</li>\n<li><p>树中所有结点可以有零个或多个后继</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基本术语\"><a href=\"#基本术语\" class=\"headerlink\" title=\"基本术语\"></a>基本术语</h2><ul>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/79541708-46ee-4f07-a79f-789ac06320ff-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>考虑结点K</p>\n<ul>\n<li><p>K的祖先：根A到结点K的唯一路径上的任意结点</p>\n<ul>\n<li>从该点出发一直到根结点，路径上所有的结点都是祖先结点</li>\n</ul>\n</li>\n<li><p>子孙：结点B是结点K的祖先，而结点K是结点B的子孙</p>\n<ul>\n<li>从自身出发，所有的分支上的所有结点</li>\n</ul>\n</li>\n<li><p>双亲与孩子：路径上最接近结点K的结点E称为K的双亲（直接前驱），而K为结点E的孩子（直接后继）</p>\n</li>\n<li><p>兄弟：有相同双亲的结点称为兄弟，如结点K和结点L有相同的双亲E，即K和L为兄弟</p>\n</li>\n<li><p>堂兄弟结点：同一层除兄弟结点外的结点</p>\n</li>\n</ul>\n</li>\n<li><p>结点的度：树中一个结点的孩子个数，树中结点的最大度数称为树的度</p>\n</li>\n<li><p>根结点：A</p>\n</li>\n<li><p>分支结点：度大于0的结点，有下一级分支</p>\n</li>\n<li><p>叶子结点（又称终端结点）：度为0 （没有子女结点）的结点</p>\n</li>\n<li><p>结点的层次：从树根开始定义，根结点为第1层（有可能规定从0开始），它的子结点为第2层，以此类推（从上往下数）</p>\n</li>\n<li><p>结点的深度：从根结点开始自顶向下逐层累加的</p>\n</li>\n<li><p>结点的高度：从叶结点开始自底向上逐层累加的</p>\n</li>\n<li><p>树的高度（或深度） ：树中结点的最大层数</p>\n</li>\n<li><p>结点的度：有几个孩子（分支）</p>\n</li>\n<li><p>树的度：各结点的度的最大值</p>\n</li>\n<li><p>有序树和无序树：树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树（例如家谱，左边的年龄大），否则称为无序树（从左到右是无次序的，可以互换；例如行政区，左右无区别）</p>\n</li>\n<li><p>路径和路径长度：</p>\n<ul>\n<li><p>树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的（只能从上往下，路径是单向的）</p>\n</li>\n<li><p>路径长度是路径上所经过的边的个数</p>\n</li>\n</ul>\n</li>\n<li><p>森林：森林是n棵互不相交的树的集合（考点：树与森林相互转化）</p>\n<ul>\n<li><p>只要把树的根结点删去就成了森林</p>\n</li>\n<li><p>给农棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树</p>\n</li>\n<li><p>有空树，有空森林</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树的性质\"><a href=\"#树的性质\" class=\"headerlink\" title=\"树的性质\"></a>树的性质</h2><ul>\n<li><p>1、树中的结点数等于所有结点的度数（等于分支数）加1</p>\n</li>\n<li><p>2、树的度——各结点的度的最大值；m叉树——每个结点最多有m个孩子的树</p>\n<ul>\n<li><p>图：00:00:45</p>\n</li>\n<li><p>相同2&#x2F;区别1</p>\n</li>\n</ul>\n</li>\n<li><p>3、度为m的树（或m叉树）中第i层上至多有   个结点（i大于等于1）<img src=\"https://api2.mubu.com/v3/document_image/5fa7979e-10f1-4c4a-808b-f6a987619631-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>4、高度为h的m叉树（或者度为m的树）至多有   个结点</p>\n<ul>\n<li>将每次最多结点数相加，等比数列求和</li>\n</ul>\n</li>\n<li><p>5、高度为h的m叉树至少有h个结点；高度为h、度为m的树至少有h+m-1个结点</p>\n<ul>\n<li>m叉树每个结点只有一个孩子；度为m的树，至少有一层为m个结点，其余层只有一个结点</li>\n</ul>\n</li>\n<li><p>6、具有n个结点的m叉树的最小高度为</p>\n<ul>\n<li>为保证高度最小，每一层有尽可能多的孩子，使用4进行计算</li>\n</ul>\n</li>\n<li><p>m叉树——每个结点最多只能有m个孩子的树</p>\n<ul>\n<li><p>任意结点的度 &lt;&#x3D; m（最多m个孩子）</p>\n</li>\n<li><p>允许所有结点的度都&lt;M</p>\n</li>\n<li><p>可以是空树</p>\n</li>\n</ul>\n</li>\n<li><p>度为m的树</p>\n<ul>\n<li><p>任意结点的度 &lt;&#x3D; m （最多m个孩子）</p>\n</li>\n<li><p>至少有一个结点度 &#x3D; m（有m个孩子）</p>\n</li>\n<li><p>一定是非空树，至少有m+1个结点</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"二叉树的概念\"><a href=\"#二叉树的概念\" class=\"headerlink\" title=\"二叉树的概念\"></a>二叉树的概念</h1><h2 id=\"二叉树的定义及其主要特性\"><a href=\"#二叉树的定义及其主要特性\" class=\"headerlink\" title=\"二叉树的定义及其主要特性\"></a>二叉树的定义及其主要特性</h2><h3 id=\"二叉树的定义：\"><a href=\"#二叉树的定义：\" class=\"headerlink\" title=\"二叉树的定义：\"></a>二叉树的定义：</h3><ul>\n<li><p>二叉树：另一种树形结构，不属于树（二叉树可以为空，而树不能为空）</p>\n<ul>\n<li>二叉树可能是空二叉树，或者是一个根结点和两个互不相交的左子树和右子树组成（分别是二叉树，左右子树可以是空二叉树）</li>\n</ul>\n</li>\n<li><p>3特点：每个结点至多只有两棵子树，并且二叉树的子树有左右之分，其次序不能任意颠倒</p>\n</li>\n</ul>\n<h3 id=\"二叉树与度为2的有序树的区别\"><a href=\"#二叉树与度为2的有序树的区别\" class=\"headerlink\" title=\"二叉树与度为2的有序树的区别\"></a>二叉树与度为2的有序树的区别</h3><ul>\n<li><p>度为2的树至少有3个结点，而二叉树可以为空</p>\n</li>\n<li><p>孩子结点</p>\n<ul>\n<li><p>度为2的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序</p>\n</li>\n<li><p>二叉树无论其孩子数是否为2，均需确定其左右次序</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉树的五种不同状态\"><a href=\"#二叉树的五种不同状态\" class=\"headerlink\" title=\"二叉树的五种不同状态\"></a>二叉树的五种不同状态</h3><ul>\n<li><p>空二叉树</p>\n</li>\n<li><p>只有左子树</p>\n</li>\n<li><p>只有右子树</p>\n</li>\n<li><p>只有根结点</p>\n</li>\n<li><p>左右子树都有</p>\n</li>\n</ul>\n<h3 id=\"特殊的二叉树\"><a href=\"#特殊的二叉树\" class=\"headerlink\" title=\"特殊的二叉树\"></a>特殊的二叉树</h3><ul>\n<li><p>满二叉树</p>\n<ul>\n<li><p>一棵高度为h，且含有2^h-1个结点的二叉树称为满二叉树</p>\n</li>\n<li><p>特点：</p>\n<ul>\n<li><p>只有最后一层有叶子结点</p>\n</li>\n<li><p>不存在度为1的结点</p>\n</li>\n</ul>\n</li>\n<li><p>对于编号为i的结点</p>\n<ul>\n<li><p>双亲为<img src=\"https://api2.mubu.com/v3/document_image/dfe5e8a7-7110-4149-b3aa-9932867c2d90-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>若有左孩子，则左孩子为2i</p>\n</li>\n<li><p>若有右孩子，则右孩子为2i + 1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>完全二叉树</p>\n<ul>\n<li><p>高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树（在满二叉树的基础上，将编号更大的结点去掉）</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上 </p>\n</li>\n<li><p>若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）</p>\n</li>\n<li><p>按层序编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点</p>\n</li>\n<li><p>如果   ，则结点为分支结点（孩子&lt;&#x3D;n），否则为叶子结点（孩子&gt;n）<img src=\"https://api2.mubu.com/v3/document_image/274a9d9c-7698-4f1c-bc3a-ac5dea47fa83-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>若n为奇数，则每个分支结点都有左孩子和右孩子</p>\n</li>\n<li><p>若n为偶数，则编号最大的分支结点（编号为n&#x2F;2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二叉排序树</p>\n<ul>\n<li><p>左子树上所有结点的关键字均小于根结点的关键字</p>\n</li>\n<li><p>右子树上的所有结点的关键字均大于根结点的关键字</p>\n</li>\n<li><p>左子树和右子树又各是一棵二叉排序树</p>\n</li>\n<li><p>关键字查找（插入、删除）：从根结点开始，如果关键字小于根结点，搜索左子树；如果关键字大于根结点，搜索右子树</p>\n</li>\n</ul>\n</li>\n<li><p>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1</p>\n<ul>\n<li>为什么：平衡二叉树的关键字搜索效率更高</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉树的性质\"><a href=\"#二叉树的性质\" class=\"headerlink\" title=\"二叉树的性质\"></a>二叉树的性质</h3><ul>\n<li><p>1、非空二叉树上的叶子结点数（度为0的结点）等于度为2的结点数+1</p>\n<ul>\n<li><p>计算：</p>\n<ul>\n<li><p>结点总数n&#x3D;n0+n1+n2（直接求结点）</p>\n</li>\n<li><p>n&#x3D;n1+2*n2+1（根据分支数（总度数）求结点，除根结点外所有结点通过一个分支与双亲相连）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>2、非空二叉树上第k层上<img src=\"https://api2.mubu.com/v3/document_image/ad122d7b-66c8-45b5-9623-a8dfe15c238b-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>3、高度为h的二叉树<img src=\"https://api2.mubu.com/v3/document_image/1b2a1ad5-2c9d-458d-8554-fd73a176010d-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>对完全二叉树按从上到下、从左到右的顺序依次编号1，2，……，则有以下关系</p>\n<ul>\n<li><p>具有n个(n&gt;0)结点的完全二叉树的高度为<img src=\"https://api2.mubu.com/v3/document_image/cf9c0610-c809-47fd-9460-a548727d361c-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>具有n个结点的完全二叉树的n0、n1、n2之间的关系</p>\n<ul>\n<li><p>若完全二叉树有2k（偶数）个结点，则有n1&#x3D;1，n0&#x3D;k，n2&#x3D;k-1</p>\n</li>\n<li><p>若完全二叉树有2k-1（奇数）个结点，则有n1&#x3D;0，n0&#x3D;k，n2&#x3D;k-1</p>\n</li>\n<li><p>计算：</p>\n<ul>\n<li><p>n1&#x3D;0或1（最多只有一个度为1的结点）</p>\n</li>\n<li><p>n0&#x3D;n2+1（根据结点总数n推导得）&#x3D;》n0+n2一定是奇数</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>当i&gt;1时，结点i的双亲的编号为，即当i为偶数时，其双亲的编号为i&#x2F;2，它是双亲的左孩子；当i为奇数时，其双亲的编号为(i—1)&#x2F;2，它是双亲的右孩子<img src=\"https://api2.mubu.com/v3/document_image/d0260f4a-598d-4c78-8b19-49894c086fbb-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>2i &lt;&#x3D; n，结点i的做孩子编号2i，否则无左孩子</p>\n</li>\n<li><p>2i+1 &lt;&#x3D; n 结点的右孩子编号为2i+1，否则无右孩子</p>\n</li>\n<li><p>结点i所在层次(深度)为<img src=\"https://api2.mubu.com/v3/document_image/b700c77b-c875-4ff3-b649-a9390750a13d-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二叉树的存储结构\"><a href=\"#二叉树的存储结构\" class=\"headerlink\" title=\"二叉树的存储结构\"></a>二叉树的存储结构</h2><h3 id=\"顺序存储结构\"><a href=\"#顺序存储结构\" class=\"headerlink\" title=\"顺序存储结构\"></a>顺序存储结构</h3><ul>\n<li><p>实现思想：</p>\n<ul>\n<li>用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标为i - 1的分量中</li>\n</ul>\n</li>\n<li><p>最常适用于：</p>\n<ul>\n<li>完全二叉树和满二叉树<ul>\n<li>普通二叉树不能 从结点编号反映出结点间的逻辑关系</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何顺序存储普通二叉树：</p>\n<ul>\n<li><p>一般的二叉树，为了能反映二叉树中结点之间的逻辑关系</p>\n</li>\n<li><p>只能添加并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中</p>\n</li>\n<li><p>使用isEmpty判断是否是空结点</p>\n</li>\n</ul>\n</li>\n<li><p>顺序存储普通二叉树的缺点：</p>\n<ul>\n<li>浪费大量的存储空间，所以顺序存储只适合存储完全二叉树</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"链式存储结构\"><a href=\"#链式存储结构\" class=\"headerlink\" title=\"链式存储结构\"></a>链式存储结构</h3><ul>\n<li><p>由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点</p>\n</li>\n<li><p>结构描述<img src=\"https://api2.mubu.com/v3/document_image/24e9f9eb-e991-4b07-a411-5fec6ad1b89f-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>在含有n个结点的二叉链表中，含有n+1个空链域</p>\n<ul>\n<li><p>n个结点有2n个指针域，n-1个结点被指针所指向</p>\n</li>\n<li><p>所以这些指针域可以被利用起来构造线索二叉树</p>\n</li>\n<li><p>二叉链表：每个结点有两个指针</p>\n</li>\n</ul>\n</li>\n<li><p>优缺点：</p>\n<ul>\n<li><p>找到孩子结点很简单</p>\n</li>\n<li><p>找到父结点需要从根开始遍历寻找，耗时</p>\n<ul>\n<li><p>此时在结点内定义一个新的指针指向父结点，所以结点有三个指针，称为三叉链表</p>\n</li>\n<li><p>根据实际需求决定是否增加父指针（查找父结点的操作是否多，树的体量是不是大）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"二叉树的遍历和线索二叉树\"><a href=\"#二叉树的遍历和线索二叉树\" class=\"headerlink\" title=\"二叉树的遍历和线索二叉树\"></a>二叉树的遍历和线索二叉树</h1><h2 id=\"二叉树的遍历（时间复杂度O-n-）——递归算法和非递归算法的转换：利用栈进行实现\"><a href=\"#二叉树的遍历（时间复杂度O-n-）——递归算法和非递归算法的转换：利用栈进行实现\" class=\"headerlink\" title=\"二叉树的遍历（时间复杂度O(n)）——递归算法和非递归算法的转换：利用栈进行实现\"></a>二叉树的遍历（时间复杂度O(n)）——递归算法和非递归算法的转换：利用栈进行实现</h2><ul>\n<li><p>先序遍历（对一个表达式进行先序遍历的结果就是前缀表达式）</p>\n<ul>\n<li><p>访问根结点</p>\n</li>\n<li><p>先序遍历左子树</p>\n</li>\n<li><p>先序遍历右子树</p>\n</li>\n</ul>\n</li>\n<li><p>中序遍历（对一个表达式进行中序遍历的结果就是中缀表达式（需要加界限符））</p>\n<ul>\n<li><p>中序遍历左子树</p>\n</li>\n<li><p>访问根结点</p>\n</li>\n<li><p>中序遍历右子树</p>\n</li>\n</ul>\n</li>\n<li><p>后序遍历（对一个表达式进行后序遍历的结果就是后缀表达式）</p>\n<ul>\n<li><p>后序遍历左子树</p>\n</li>\n<li><p>后序遍历右子树</p>\n</li>\n<li><p>访问根结点</p>\n</li>\n</ul>\n</li>\n<li><p>三种遍历算法的空间复杂度：O(h)，h指二叉树的高度，递归调用时每一层都有一个结点的函数会被压到栈中，最多有h+1个结点的函数被压到栈里面（最下一层结点的空孩子结点的函数也会被压到栈顶，该函数执行后就会被弹出栈）</p>\n</li>\n</ul>\n<h2 id=\"二叉树的遍历（手算练习）——分支结点逐层展开法\"><a href=\"#二叉树的遍历（手算练习）——分支结点逐层展开法\" class=\"headerlink\" title=\"二叉树的遍历（手算练习）——分支结点逐层展开法\"></a>二叉树的遍历（手算练习）——分支结点逐层展开法</h2><h2 id=\"三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息\"><a href=\"#三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息\" class=\"headerlink\" title=\"三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息\"></a>三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息</h2><ul>\n<li><p>先序遍历</p>\n</li>\n<li><p>中序遍历</p>\n</li>\n<li><p>后序遍历</p>\n</li>\n</ul>\n<h2 id=\"求树的深度（递归算法）\"><a href=\"#求树的深度（递归算法）\" class=\"headerlink\" title=\"求树的深度（递归算法）\"></a>求树的深度（递归算法）</h2><h2 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h2><ul>\n<li><p>利用队列实现</p>\n</li>\n<li><p>实现思想：</p>\n<ul>\n<li><p>初始化一个辅助队列</p>\n</li>\n<li><p>根结点入队（结点入队时，只使用队列保存结点的指针即可，节省存储空间）</p>\n</li>\n<li><p>若队列非空，则队头结点出队，访问该结点，并将左&#x2F;右孩子插入队尾（如果有的话）</p>\n</li>\n<li><p>重复上一步骤，直至队列为空</p>\n</li>\n</ul>\n</li>\n<li><h2 id=\"具体实现：\"><a href=\"#具体实现：\" class=\"headerlink\" title=\"具体实现：\"></a>具体实现：</h2></li>\n</ul>\n<h2 id=\"由遍历序列构造二叉树\"><a href=\"#由遍历序列构造二叉树\" class=\"headerlink\" title=\"由遍历序列构造二叉树\"></a>由遍历序列构造二叉树</h2><ul>\n<li><p>单个遍历序列不能确定唯一的二叉树</p>\n<ul>\n<li><p>二叉树的先序序列、中序序列、后序序列、层序序列可能对应多种二叉树形态</p>\n</li>\n<li><p>如果只是给出一颗二叉树的前中后层遍历序列的一种是不能唯一确认一棵二叉树的</p>\n</li>\n</ul>\n</li>\n<li><p>使用两个遍历序列构造二叉树（必须有中序遍历）</p>\n<ul>\n<li><p>前序+中序</p>\n<ul>\n<li><p>如何确定二叉树？</p>\n<ul>\n<li><p>根据前序遍历的第一个结点确认根结点</p>\n</li>\n<li><p>中序遍历的左侧部分是左子树</p>\n</li>\n<li><p>所以前序遍历中的对应部分也是左子树，其余的就是右子树的前序遍历序列</p>\n</li>\n<li><p>循环</p>\n<ul>\n<li>对应部分的第一个结点时左子树的根结点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>后序+中序</p>\n<ul>\n<li><p>如何确定二叉树？</p>\n<ul>\n<li><p>根据后序遍历的第一个结点确认根结点</p>\n</li>\n<li><p>中序遍历的左侧部分是左子树</p>\n</li>\n<li><p>所以后序遍历中的对应部分也是左子树，其余的就是右子树的后序遍历序列</p>\n</li>\n<li><p>循环</p>\n<ul>\n<li>对应部分的第一个结点时左子树的根结点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>层序+中序</p>\n<ul>\n<li><p>如何确定二叉树？</p>\n<ul>\n<li><p>根据层次遍历的第一个结点确认根结点</p>\n</li>\n<li><p>中序遍历的左侧部分是左子树，中序遍历的右侧部分是右子树</p>\n</li>\n<li><p>中序遍历中已经确定位置的结点，在层次遍历中也会跳过</p>\n</li>\n<li><p>循环</p>\n<ul>\n<li>层序遍历的下一个结点是左子树的根结点</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>关键：找到树的根结点，并根据中序序列划分左右子树，再找到左右子树根结点</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"线索二叉树\"><a href=\"#线索二叉树\" class=\"headerlink\" title=\"线索二叉树\"></a>线索二叉树</h2><h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li><p>线索二叉树的基本概念</p>\n<ul>\n<li><p>遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列</p>\n</li>\n<li><p>使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继（基于遍历序列的前驱和后继）</p>\n</li>\n</ul>\n</li>\n<li><p>线索二叉树出现的原因</p>\n<ul>\n<li><p>普通二叉树进行遍历的时候都必须从根结点出发，如果从一个指定结点p开始将无法遍历线性序列的后继、前驱（遍历序列的前驱、后继）</p>\n</li>\n<li><p>普通二叉树二叉树查找前驱、后继</p>\n<ul>\n<li><p>找到p结点的中序遍历的前驱，思路：</p>\n<ul>\n<li><p>从根结点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针pre记录上一个倍访问的结点</p>\n</li>\n<li><p>当q&#x3D;&#x3D;p时，pre则为前驱</p>\n</li>\n</ul>\n</li>\n<li><p>找到p结点的中序遍历的后继，思路：</p>\n<ul>\n<li><p>从根结点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针pre记录上一个倍访问的结点</p>\n</li>\n<li><p>当pre&#x3D;&#x3D;p时，q则为后继</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>普通二叉树缺点：</p>\n<ul>\n<li><p>找前驱、后继很不方便</p>\n</li>\n<li><p>每次遍历都必须从根结点开始</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>中序线索二叉树的特点</p>\n<ul>\n<li>n个结点的二叉树，有n+1个空链域，可以用来记录前驱、后继的信息</li>\n</ul>\n</li>\n<li><p>建立 中序线索二叉树的目的</p>\n<ul>\n<li>使得查找前驱、后继和遍历更加方便</li>\n</ul>\n</li>\n<li><p>规定</p>\n<ul>\n<li><p>若无左子树， 令lchild指向其前驱结点</p>\n</li>\n<li><p>若无右子树， 令rchild指向其后继结点</p>\n</li>\n</ul>\n</li>\n<li><p>结点结构（该结点结构的线索二叉树称为线索链表）</p>\n<ul>\n<li><p>标志域的含义</p>\n<ul>\n<li><p>Itag</p>\n<ul>\n<li><p>0</p>\n</li>\n<li><p>lchild域指示结点的左孩子</p>\n</li>\n<li><p>1</p>\n</li>\n<li><p>Ichild域指示结点的前驱</p>\n</li>\n</ul>\n</li>\n<li><p>rtag</p>\n<ul>\n<li><p>0</p>\n</li>\n<li><p>rchild域指示结点的右孩子</p>\n</li>\n<li><p>1</p>\n</li>\n<li><p>rchild域指示结点的后继</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"中序线索二叉树的构造\"><a href=\"#中序线索二叉树的构造\" class=\"headerlink\" title=\"中序线索二叉树的构造\"></a>中序线索二叉树的构造</h3><ul>\n<li><p>概念</p>\n<ul>\n<li><p>二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索</p>\n</li>\n<li><p>而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树</p>\n</li>\n</ul>\n</li>\n<li><p>中序线索二叉树的建立</p>\n<ul>\n<li><p>附设指针pre指向刚刚访问过的结点，指针p指向正在访问的结点，即pre指向p的前驱</p>\n</li>\n<li><p>在中序遍历的过程中</p>\n<ul>\n<li><p>检查p的左指针是否为空，若为空就将它指向pre</p>\n</li>\n<li><p>检查pre的右指针是否为空，若为空就将它指向p</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>中序线索二叉树的遍历</p>\n<ul>\n<li>若其右标志为”1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继</li>\n</ul>\n</li>\n<li><p>先序线索二树</p>\n<ul>\n<li><p>先序序列为ABCDF，然后依次判断每个结点的左右链域，如果为空则将其改造为线索</p>\n</li>\n<li><p>结点A，B均有左右孩子；结点C无左孩子，将左链域指向前驱B，无右孩子，将右链域指向后继D</p>\n</li>\n<li><p>结点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继F</p>\n</li>\n<li><p>结点F无左孩子，将左链域指向前驱D，无右孩子，也无后继故置空</p>\n</li>\n</ul>\n</li>\n<li><p>后序线索二叉树</p>\n<ul>\n<li><p>后序序列为CDBFA，结点C无左孩子，也无前驱故置空，无右孩子，将右链域指向后继D</p>\n</li>\n<li><p>结点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继B</p>\n</li>\n<li><p>结点F无左孩子，将左链域指向前驱B，无右孩子，将右链域指向后继A</p>\n</li>\n</ul>\n</li>\n<li><p>三种线索二叉树的对比</p>\n<ul>\n<li><p>确定结点的前驱、后继关系时，是按照前序遍历还是中序遍历还是后序遍历</p>\n</li>\n<li><p>6个概念</p>\n<ul>\n<li><p>中序前驱</p>\n<ul>\n<li>按照中序遍历的前驱，也就是中序遍历序列的前驱、后继</li>\n</ul>\n</li>\n<li><p>中序后继、先序前驱、先序后继、后序前驱、后序后继</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"二叉树线索化的具体实现\"><a href=\"#二叉树线索化的具体实现\" class=\"headerlink\" title=\"二叉树线索化的具体实现\"></a>二叉树线索化的具体实现</h3><ul>\n<li><p>普通二叉树找到中序前驱</p>\n<ul>\n<li><h2 id=\"中序遍历\"><a href=\"#中序遍历\" class=\"headerlink\" title=\"中序遍历\"></a>中序遍历</h2></li>\n<li><h2 id=\"访问结点q\"><a href=\"#访问结点q\" class=\"headerlink\" title=\"访问结点q\"></a>访问结点q</h2></li>\n<li><h2 id=\"辅助全局变量，用于查找结点p的前驱\"><a href=\"#辅助全局变量，用于查找结点p的前驱\" class=\"headerlink\" title=\"辅助全局变量，用于查找结点p的前驱\"></a>辅助全局变量，用于查找结点p的前驱</h2></li>\n</ul>\n</li>\n<li><p>对二叉树进行中序线索化</p>\n<ul>\n<li><p>中序遍历</p>\n</li>\n<li><p>线索二叉树结点定义</p>\n</li>\n<li><p>定义全局变量pre</p>\n</li>\n<li><p>访问当前结点</p>\n</li>\n</ul>\n</li>\n<li><p>中序线索化——王道书版本</p>\n<ul>\n<li>pre参数是引用类型，可以在函数内部修改pre参数的值</li>\n</ul>\n</li>\n<li><p>先序线索化</p>\n<p>- </p>\n<ul>\n<li>区别：避免无限循环</li>\n</ul>\n</li>\n<li><h2 id=\"先序线索化——王道书版本\"><a href=\"#先序线索化——王道书版本\" class=\"headerlink\" title=\"先序线索化——王道书版本\"></a>先序线索化——王道书版本</h2></li>\n<li><p>后序线索化</p>\n<p>- </p>\n<ul>\n<li>不会出现无限循环</li>\n</ul>\n</li>\n<li><h2 id=\"后序线索化——王道书版本\"><a href=\"#后序线索化——王道书版本\" class=\"headerlink\" title=\"后序线索化——王道书版本\"></a>后序线索化——王道书版本</h2></li>\n</ul>\n<h3 id=\"线索二叉树找前驱、后继\"><a href=\"#线索二叉树找前驱、后继\" class=\"headerlink\" title=\"线索二叉树找前驱、后继\"></a>线索二叉树找前驱、后继</h3><ul>\n<li><p>中序线索二叉树</p>\n<ul>\n<li><p>找中序前驱</p>\n<ul>\n<li><p>实现思想：</p>\n<ul>\n<li><p>若p-&gt;rtag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;rchild</p>\n</li>\n<li><p>若p-&gt;rtag &#x3D;&#x3D;0，则next &#x3D; p的右子树中最左下结点（右子树第一个被访问）</p>\n</li>\n</ul>\n</li>\n<li><p>具体实现：</p>\n<ul>\n<li><p>找到以p为根的子树中，第一个被中序遍历的结点</p>\n</li>\n<li><p>在中序线索二叉树中找到结点p的后继结点</p>\n</li>\n</ul>\n</li>\n<li><p>如何实现中序线索二叉树的中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>\n</li>\n</ul>\n</li>\n<li><p>找中序后继</p>\n<ul>\n<li><p>实现思想：</p>\n<ul>\n<li><p>若p-&gt;ltag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;lchild</p>\n</li>\n<li><p>若p-&gt;ltag &#x3D;&#x3D;0，则next &#x3D; p的左子树中最右下结点（左子树最后一个被访问）</p>\n</li>\n</ul>\n</li>\n<li><p>具体实现：</p>\n<ul>\n<li><p>找到以p为根的子树中，最后一个被中序遍历的结点</p>\n</li>\n<li><p>在中序线索二叉树中找到结点p的前驱结点</p>\n</li>\n</ul>\n</li>\n<li><p>如何实现中序线索二叉树的逆向中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>先序线索二叉树</p>\n<ul>\n<li><p>先序后继</p>\n<ul>\n<li><p>实现思想：</p>\n<ul>\n<li><p>若p-&gt;rtag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;rchild</p>\n</li>\n<li><p>若p-&gt;rtag &#x3D;&#x3D;0</p>\n<ul>\n<li><p>如果p有左孩子，则next &#x3D; p的左子树中根结点（左子树第一个被访问）</p>\n</li>\n<li><p>如果p没有左孩子，则next&#x3D;p的右子树中根结点（右子树第一个被访问）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>具体实现：</p>\n</li>\n<li><p>如何实现中序线索二叉树的中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>\n</li>\n</ul>\n</li>\n<li><p>先序前驱</p>\n<ul>\n<li><p>实现思想：</p>\n<ul>\n<li><p>若p-&gt;ltag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;lchild</p>\n</li>\n<li><p>若p-&gt;ltag &#x3D;&#x3D;0</p>\n<ul>\n<li><p>找不到先序前驱，除非从头开始遍历</p>\n</li>\n<li><p>1.如果能找到p的父节点（三叉链表存储），且p是左孩子</p>\n<ul>\n<li>next&#x3D;p的父节点</li>\n</ul>\n</li>\n<li><p>2.如果能找到p的父节点，且p是右孩子，其左兄弟为空</p>\n<ul>\n<li>next&#x3D;p的父节点</li>\n</ul>\n</li>\n<li><p>3.如果能找到p的父节点，且p是右孩子，其左兄弟非空</p>\n<ul>\n<li>next&#x3D;p的左子树中最后一个被访问的结点（左子树中尽可能往右走，走到尽头可能会往左走，接着再往右走）</li>\n</ul>\n</li>\n<li><p>4.如果p是根结点，则next&#x3D;空</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>具体实现：</p>\n</li>\n<li><p>如何实现中序线索二叉树的逆向中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>后序线索二叉树</p>\n<ul>\n<li><p>后续前驱</p>\n<ul>\n<li><p>实现思想：</p>\n<ul>\n<li><p>若p-&gt;ltag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;lchild</p>\n</li>\n<li><p>若p-&gt;ltag &#x3D;&#x3D;0</p>\n<ul>\n<li><p>若p有右孩子，则next&#x3D;p的右子树的根结点</p>\n</li>\n<li><p>若p没有右孩子，则next&#x3D;p的左子树的根结点</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>具体实现：</p>\n</li>\n<li><p>如何实现中序线索二叉树的中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>\n</li>\n</ul>\n</li>\n<li><p>后续后继</p>\n<ul>\n<li><p>实现思想：</p>\n<ul>\n<li><p>若p-&gt;rtag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;rchild</p>\n</li>\n<li><p>若p-&gt;rtag &#x3D;&#x3D;0</p>\n<ul>\n<li><p>找不到后续后继，除非从头开始遍历</p>\n</li>\n<li><p>1.如果能找到p的父节点（三叉链表存储），且p是右孩子</p>\n<ul>\n<li>next&#x3D;p的父节点</li>\n</ul>\n</li>\n<li><p>2.如果能找到p的父节点，且p是左孩子，其有兄弟为空</p>\n<ul>\n<li>next&#x3D;p的父节点</li>\n</ul>\n</li>\n<li><p>3.如果能找到p的父节点，且p是左孩子，其右兄弟非空</p>\n<ul>\n<li>next&#x3D;p的右子树中第一个被访问的结点（右子树中尽可能往左走，走到尽头可能会往右走，接着再往左走）</li>\n</ul>\n</li>\n<li><p>4.如果p是根结点，则p没有后继结点</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>具体实现：</p>\n</li>\n<li><p>如何实现中序线索二叉树的逆向中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"树、森林\"><a href=\"#树、森林\" class=\"headerlink\" title=\"树、森林\"></a>树、森林</h1><h2 id=\"树的存储结构\"><a href=\"#树的存储结构\" class=\"headerlink\" title=\"树的存储结构\"></a>树的存储结构</h2><h3 id=\"双亲表示法\"><a href=\"#双亲表示法\" class=\"headerlink\" title=\"双亲表示法\"></a>双亲表示法</h3><ul>\n<li><p>采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置</p>\n</li>\n<li><p>根结点下标为0，其伪指针域为-1</p>\n</li>\n<li><p>代码实现</p>\n</li>\n<li><p>基本操作</p>\n<ul>\n<li><p>增加：在data中写入值（顺序无所谓），指针指向父节点</p>\n</li>\n<li><p>删除：最后还要删除以这些结点为根结点的子树</p>\n<ul>\n<li><p>方法一：将data置为空，将指针域设为-1</p>\n<ul>\n<li>空数据会使得遍历更慢</li>\n</ul>\n</li>\n<li><p>方法二：使用最下方结点的数据覆盖要删除的结点</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>利用了每个结点（根结点除外）只有唯一双亲的性质，（有伪指针）可以很快得到每个结点的双亲结点</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>但求结点的孩子时需要遍历整个结构</li>\n</ul>\n</li>\n<li><p>应用：使用二叉树的顺序存储时，一定要把二叉树的结点编号和完全二叉树对应起来</p>\n<ul>\n<li>结点编号不仅反映了存储位置，也隐含了结点之间的逻辑关系</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"孩子表示法（顺序-链式存储）\"><a href=\"#孩子表示法（顺序-链式存储）\" class=\"headerlink\" title=\"孩子表示法（顺序+链式存储）\"></a>孩子表示法（顺序+链式存储）</h3><ul>\n<li><p>将每个结点的孩子结点都用单链表链接起来，形成一个线性结构，此时n个结点就有n个孩子链表（叶子结点的孩子链表为空表）</p>\n</li>\n<li><p>代码实现</p>\n</li>\n<li><p>如何实现增、删、查</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>寻找子女的操作非常直接</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）\"><a href=\"#孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）\" class=\"headerlink\" title=\"孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）\"></a>孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）</h3><ul>\n<li><p>以二叉链表作为树的存储结构，孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针、及指向结点下一个兄弟结点的指针</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>这种存储表示法比较灵活其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>从当前结点查找其双亲结点比较麻烦</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树、森林与二叉树的转换\"><a href=\"#树、森林与二叉树的转换\" class=\"headerlink\" title=\"树、森林与二叉树的转换\"></a>树、森林与二叉树的转换</h2><ul>\n<li><p>树转换为二叉树的规则</p>\n<ul>\n<li>每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟</li>\n</ul>\n</li>\n<li><p>树转换成二叉树的画法</p>\n<ul>\n<li><p>在兄弟结点之间加一连线</p>\n</li>\n<li><p>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉</p>\n</li>\n<li><p>以树根为轴心,顺时针旋转45度</p>\n</li>\n</ul>\n</li>\n<li><p>森林转换为二叉树的画法</p>\n<ul>\n<li><p>将森林中的每棵树转换成相应的二叉树</p>\n</li>\n<li><p>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线</p>\n</li>\n<li><p>以第一棵树的根为轴心顺时针旋转45</p>\n</li>\n</ul>\n</li>\n<li><p>二叉树转换为森林的规则</p>\n<ul>\n<li><p>若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开</p>\n</li>\n<li><p>二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树</p>\n</li>\n<li><p>应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树和森林的遍历\"><a href=\"#树和森林的遍历\" class=\"headerlink\" title=\"树和森林的遍历\"></a>树和森林的遍历</h2><ul>\n<li><p>树的遍历</p>\n<ul>\n<li><p>先根遍历——树的深度优先遍历</p>\n<ul>\n<li><p>若树非空，先访问根结点再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则</p>\n</li>\n<li><p>其遍历序列与这棵树相应二叉树的先序序列相同</p>\n</li>\n<li><h2 id=\"伪代码实现\"><a href=\"#伪代码实现\" class=\"headerlink\" title=\"伪代码实现\"></a>伪代码实现</h2></li>\n</ul>\n</li>\n<li><p>后根遍历——树的深度优先遍历</p>\n<ul>\n<li><p>若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则</p>\n</li>\n<li><p>其遍历序列与这棵树相应二叉树的中序序列相同</p>\n</li>\n<li><p>伪代码实现</p>\n</li>\n</ul>\n</li>\n<li><p>层序遍历（队列实现）——也称为对树的广度优先遍历</p>\n<ul>\n<li><p>1.若树非空，则根结点入队</p>\n</li>\n<li><p>2.若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</p>\n</li>\n<li><p>3.重复2</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>森林的遍历</p>\n<ul>\n<li><p>先序遍历森林（相当于依次对各个树进行先根遍历，也等同于对二叉树的先序遍历）</p>\n<ul>\n<li><p>访问森林中第一棵树的根结点</p>\n</li>\n<li><p>先序遍历第一棵树中根结点的子树森林</p>\n</li>\n<li><p>先序遍历除去第一棵树之后剩余的树构成的森林</p>\n</li>\n</ul>\n</li>\n<li><p>中序遍历森林（相当于依次对各个树进行后根遍历，也等同于对二叉树的中序遍历）</p>\n<ul>\n<li><p>中序遍历森林中第一棵树的根结点的子树森林</p>\n</li>\n<li><p>访问第一棵树的根结点</p>\n</li>\n<li><p>中序遍历除去第一棵树之后剩余的树构成的森林</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>树的应用——并查集</p>\n<ul>\n<li><p>支持操作</p>\n<ul>\n<li><p>1）Union（S，Root1，Root2）：把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不执行合并</p>\n</li>\n<li><p>2）Find（S.x）：查找集合S中单元素x所在的子集合，并返回该子集合的名字</p>\n</li>\n<li><p>3）Initial（S）：将集合S中的每个元素都初始化为只有一个单元素的子集合</p>\n</li>\n</ul>\n</li>\n<li><p>具体实现</p>\n<ul>\n<li><p>用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示</p>\n</li>\n<li><p>所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内</p>\n</li>\n<li><p>通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"树与二叉树的应用\"><a href=\"#树与二叉树的应用\" class=\"headerlink\" title=\"树与二叉树的应用\"></a>树与二叉树的应用</h1><h2 id=\"二叉排序树（BST）\"><a href=\"#二叉排序树（BST）\" class=\"headerlink\" title=\"二叉排序树（BST）\"></a>二叉排序树（BST）</h2><ul>\n<li><p>二叉排序树的定义</p>\n<ul>\n<li><p>特性（左子树任一结点值 &lt; 根结点值 &lt; 右子树任一结点值 ）</p>\n<ul>\n<li><p>1）若左子树非空，则左子树上所有结点的值均小于根结点的值</p>\n</li>\n<li><p>2）若右子树非空，则右子树上所有结点的值均大于根结点的值</p>\n</li>\n<li><p>3）左、右子树也分别是一棵二叉排序树</p>\n</li>\n<li><p>使用中序遍历，可以得到一个递增的有序序列</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二叉排序树的查找</p>\n<ul>\n<li><p>二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程，若二叉排序树非空，先将给定值与根结点的关键字比较</p>\n<ul>\n<li><p>若相等，则查找成功</p>\n</li>\n<li><p>若不等，如果小于根结点的关键字，则在根结点的左子树上查找</p>\n</li>\n<li><p>否则在根结点的右子树上查找</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>非递归实现——空间复杂度O(1)</p>\n</li>\n<li><p>递归实现——空间复杂度O(h)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二叉排序树的插入</p>\n<ul>\n<li><p>插入结点的过程（插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访间的最后一个结点 的左孩子或右孩子）</p>\n<ul>\n<li><p>若原二叉排序树为空，则直接插入结点</p>\n</li>\n<li><p>若关键字k小于根结点值，则插入到左子树</p>\n</li>\n<li><p>若关键字k大于根结点值，则插入到右子树</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>递归实现</p>\n</li>\n<li><p>非递归实现</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二叉排序树的构造</p>\n<ul>\n<li><p>设查找的关键字序列为{45，24，53，45，12，24}，则生成的二叉排序树</p>\n</li>\n<li><p>生成示意图<img src=\"https://api2.mubu.com/v3/document_image/076d411e-0555-4a7b-9364-3e4411db4b81-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>代码实现</p>\n</li>\n</ul>\n</li>\n<li><p>二叉排序树的删除</p>\n<ul>\n<li><p>1.若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质</p>\n</li>\n<li><p>2.若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置</p>\n</li>\n<li><p>3.若结点z有左、右两棵子树</p>\n<ul>\n<li><p>则令z的直接后继（z的右子树的最左下结点）替代z，然后从二叉排序树中删去这个直接后继</p>\n<ul>\n<li><p>如果直接后继是叶子结点，则直接删除</p>\n</li>\n<li><p>如果直接后继有右子树，将这个直接后继的右子树成为直接后继的父节点的子树</p>\n</li>\n</ul>\n</li>\n<li><p>则令z的直接前驱（z的左子树的最右下结点）替代z，然后从二叉排序树中删去这个直接前驱</p>\n<ul>\n<li><p>如果直接前驱是叶子结点，则直接删除</p>\n</li>\n<li><p>如果直接前驱有左子树，将这个直接前驱的左子树成为直接前驱的父节点的子树</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二叉排序树的查找效率分析</p>\n<ul>\n<li><p>查找长度：在查找过程中，需要对比关键字的次数，反映了查找操作时间复杂度</p>\n</li>\n<li><p>查找成功的平均查找长度ASL：对比关键字的平均次数</p>\n</li>\n<li><p>查找成功的平均执行时间为</p>\n<ul>\n<li><p>最坏情况：每个结点只有一个分支，树高&#x3D;结点数n，平均查找长度&#x3D;O(n)</p>\n</li>\n<li><p>最好情况：n个结点的二叉树最小高度为（log_2(n)向下取整）+1，平均查找长度O(n)</p>\n</li>\n<li><p>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1</p>\n</li>\n</ul>\n</li>\n<li><p>查找失败的平均查找长度ASL：补上空结点，计算查找空结点时需要对比关键字的平均次数</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"平衡二叉树（AVL）\"><a href=\"#平衡二叉树（AVL）\" class=\"headerlink\" title=\"平衡二叉树（AVL）\"></a>平衡二叉树（AVL）</h2><ul>\n<li><p>平衡二叉树的定义</p>\n<ul>\n<li><p>在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树</p>\n</li>\n<li><p>平衡因子：左子树与右子树的高度差为该结点的平衡因子 平衡因子的值只可能是—1、0或1</p>\n</li>\n<li><p>代码实现</p>\n</li>\n</ul>\n</li>\n<li><p>平衡二叉树的插入</p>\n<ul>\n<li><p>当在二叉排序树中插入（或删除）一个结点时</p>\n<ul>\n<li><p>首先检查其插入路径上的所有结点是否因为此次操作而导致了不平衡</p>\n</li>\n<li><p>若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A</p>\n</li>\n<li><p>再对以A为根的子树，在保持二叉排序动特性的前提下，调整各结点的位置关系，使之重新达到平衡</p>\n</li>\n</ul>\n</li>\n<li><p>规律归纳（插入新结点后调整不平衡问题）</p>\n<ul>\n<li><p>LL平衡旋转（右单旋结）</p>\n<ul>\n<li><p>由于在结点A的左孩子（L）的左子树（L）上插入了新结点</p>\n</li>\n<li><p>A的平衡因子由1增至2，导致以A为根的子树失去平衡</p>\n</li>\n<li><p>目的：恢复平衡，保持二叉排序树特性</p>\n</li>\n<li><p>需要一次向右的旋转操作，此时B变成根，A成为B的右子树，那么B原来的右子树只能成为A的左子树</p>\n</li>\n<li><h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2></li>\n</ul>\n</li>\n<li><p>RR平衡旋转（左单旋转）</p>\n<ul>\n<li><p>由于在结点A的右孩子（R）的右子树（R）上插入了新结点</p>\n</li>\n<li><p>A的平衡因子由-1减至-2，导致以A为根的子树失去平衡</p>\n</li>\n<li><p>需要一次向左的旋转操作，此时B变成根，A成为B的左子树，那么B原来的左子树只能成为A的右子树</p>\n</li>\n<li><p>代码实现</p>\n</li>\n</ul>\n</li>\n<li><p>LR平衡旋转（先左后右双旋转）</p>\n<ul>\n<li><p>由于在A的左孩子（L）的右子树（R）上插入新结点</p>\n</li>\n<li><p>A平衡因子由-1增至2，导致以A为根的子树失去平衡</p>\n</li>\n<li><p>需要进行两次旋转操作，先左旋转后右旋转</p>\n<ul>\n<li><p>1.C到B的位置，B变为C的左孩子，CL成为B的右孩子</p>\n</li>\n<li><p>2.C到A的位置，A变为C的右孩子，CR变为A的左孩子</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n</li>\n</ul>\n</li>\n<li><p>RL平衡旋转（先右后左双旋转）</p>\n<ul>\n<li><p>由于在A的右孩子（R）的左子树（L）上插入新结点</p>\n</li>\n<li><p>A的平衡因子由-1减至-2，导致以A为根的子树失去平衡</p>\n</li>\n<li><p>需要进行两次旋转操作，先右旋转后左旋转</p>\n<ul>\n<li><p>1.C到B的位置，B变为C的右孩子，CR成为B的左孩子</p>\n</li>\n<li><p>2.C到A的位置，A变为C的左孩子，CL变为A的右孩子‘</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>为什么解决最小不平衡子树之后，整个树就平衡了？</p>\n<ul>\n<li>插入操作导致最小不平衡子树高度+1，经过调整后高度恢复原状</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>平衡二叉树的查找</p>\n<ul>\n<li><p>平均查找长度ASL：不超过O(h)——查找操作的时间复杂度</p>\n</li>\n<li><p>深度为h的平衡树最少含有的结点数</p>\n<ul>\n<li>递推公式n(h)&#x3D;n(h-1)+n(h-2)+1</li>\n</ul>\n</li>\n<li><p>平衡二叉树的最大深度：h&#x3D;Log_2(n)</p>\n</li>\n<li><p>平衡二叉树的平均查找长度：Log_2(n)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"哈夫曼树和哈夫曼编码\"><a href=\"#哈夫曼树和哈夫曼编码\" class=\"headerlink\" title=\"哈夫曼树和哈夫曼编码\"></a>哈夫曼树和哈夫曼编码</h2><ul>\n<li><p>带权路径长度（WPL）</p>\n<ul>\n<li><p>结点的权：结点有某种现实含义的数值（如：用于表示结点的重要性）</p>\n</li>\n<li><p>结点的带权路径长度：从（树的）根到任意结点的路径长度（经过的边数）与该结点上权值的乘积</p>\n</li>\n<li><p>树中所有叶子结点的带权路径长度之和称为该树的带权路径长度</p>\n<ul>\n<li><p>计算公式（重点：叶子结点）<img src=\"https://api2.mubu.com/v3/document_image/475b7c69-2f41-4986-8ce2-6858f8ed205f-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>是第i个叶结点所带的权值</p>\n</li>\n<li><p>是该叶结点到根结点的路径长度</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>哈夫曼树的定义</p>\n<ul>\n<li>称为哈夫曼树，也称最优二叉树：在含有n个带权叶结点的二叉树中其中带权路径长度（WPL）最小的二叉树<ul>\n<li>哈夫曼树中只有叶子结点有意义</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>哈夫曼树的构造</p>\n<ul>\n<li><p>算法</p>\n<ul>\n<li><p>每次从合成后存在的结点中选出两个最小的进行构造二叉树</p>\n</li>\n<li><p>并将这两个结点的权值之和作为该二叉树根结点的权值</p>\n</li>\n<li><p>重复</p>\n</li>\n</ul>\n</li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/4500ae20-68af-4289-9c32-9417f414dff7-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>每个初始结点最终都是叶子结点，且权值越小的结点到根结点的路径长度越大</p>\n</li>\n<li><p>一共合并n-1次，所以哈夫曼树的结点总数为2n-1</p>\n</li>\n<li><p>哈夫曼树不存在度为1的结点（哈夫曼树中各个结点的度只能为0或2）</p>\n</li>\n<li><p>哈夫曼树不唯一，但WPL必定相同且最优</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>哈夫曼编码（可变长度编码+前缀编码）</p>\n<ul>\n<li><p>基本概念（可变长度编码比固定长度编码要好）</p>\n<ul>\n<li><p>固定长度编码：在数据通信中，若对每个字符用相等长度的二进制位表示</p>\n</li>\n<li><p>可变长度编码</p>\n<ul>\n<li><p>允许对不同字符用不等长的二进制位表示</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码</p>\n</li>\n<li><p>可以使字符的平均编码长度减短，起到压缩数据的效果</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>前缀编码：没有一个编码是另一个编码的前缀</p>\n<ul>\n<li>为什么只能有叶子结点存在编码？<ul>\n<li>假设非叶子结点有编码为1表示A，编码11表示B。如果发送11111，就不知道究竟是AAAAA还是BBA，会有歧义。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码</p>\n<ul>\n<li>可以用于数据压缩</li>\n</ul>\n</li>\n<li><p>构造哈夫曼编码——本质就是构造哈夫曼树</p>\n<ul>\n<li><p>将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树</p>\n</li>\n<li><p>将字符的编码解释为从根至该字符的路径上边标记的序列</p>\n</li>\n<li><p>其中边标记为0表示”转向左孩子”，标记为1表示”转向右孩子”</p>\n</li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/6e0be798-ce73-405d-a16e-60d505cf06e5-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","3.数据结构","5.树与二叉树"],"tags":["写作"]},{"title":"图","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6%E5%9B%BE/","content":"<h1 id=\"图的基本概念\"><a href=\"#图的基本概念\" class=\"headerlink\" title=\"图的基本概念\"></a>图的基本概念</h1><h2 id=\"图的定义\"><a href=\"#图的定义\" class=\"headerlink\" title=\"图的定义\"></a>图的定义</h2><ul>\n<li><p>图G由顶点集V和边集E组成记为G&#x3D;（V，E ），其中V（G）表示图G中顶点的有限非空集；E（G ）表示图G中顶点之间的关系（边）集合</p>\n</li>\n<li><p>V&#x3D;{v1，v2，……，vn}，则用|V|表示图G中顶点的个数，也称图G的阶</p>\n</li>\n<li><p>E&#x3D;{（u，v）|u∈V，v∈V}，用|E|表示图G中边的条数</p>\n</li>\n<li><p>注意线性表可以是空表，树可以是空树，但图不可以是空图</p>\n<ul>\n<li>图的顶点集一定是非空集，图的边集可以是空集</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"图的一些基本概念及术语\"><a href=\"#图的一些基本概念及术语\" class=\"headerlink\" title=\"图的一些基本概念及术语\"></a>图的一些基本概念及术语</h2><ul>\n<li><p>有向图</p>\n<ul>\n<li><p>若E是有向边（也称弧）的有限集合时，则图G为有向图</p>\n</li>\n<li><p>弧（有向边）是顶点的有序对，记为&lt;v，w&gt;</p>\n<ul>\n<li><p>其中v，w是顶点，v称为弧尾，w称为弧头，&lt;v，w&gt;称为从顶点v到顶点w的弧，也称v邻接w，或w邻接自v</p>\n</li>\n<li><p>&lt;v，w&gt;与&lt;w，v&gt;是不相等的，表示两个相反的弧</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>无向图</p>\n<ul>\n<li><p>若E是无向边（简称边）的有限集合时，则图G为无向图</p>\n</li>\n<li><p>边（无向边）是顶点的无序对，记为（v，w）或（w，v），因为（v，w ） &#x3D;（w，v），其中v，w是顶点</p>\n</li>\n<li><p>可以说顶点w和顶点v互为邻接点。边(v，w )依附于顶点w和v，或者说边(v,w)和顶点v，w相关联</p>\n</li>\n</ul>\n</li>\n<li><p>简单图</p>\n<ul>\n<li><p>不存在重复边</p>\n</li>\n<li><p>不存在顶点到自身的边</p>\n</li>\n</ul>\n</li>\n<li><p>多重图</p>\n<ul>\n<li><p>若图G中某两个结点之间的边数多于一条</p>\n</li>\n<li><p>且允许顶点通过同一条边和自己关联</p>\n</li>\n</ul>\n</li>\n<li><p>顶点的度、入度和出度</p>\n<ul>\n<li><p>度：定义为以该顶点为一个端点的边的数目</p>\n</li>\n<li><p>无向图：顶点v的度是指依附于该顶点的边的条数</p>\n<ul>\n<li>度的考点：无向图的全部顶点的度的和等于边数的2倍</li>\n</ul>\n</li>\n<li><p>有向图：全部顶点的入度之和与出度之和相等，并且等于边数</p>\n<ul>\n<li><p>入度：以顶点v为终点的有向边的数目，记为ID(v)</p>\n</li>\n<li><p>出度：以顶点v为起点的有向边的数目，记为OD(v)</p>\n</li>\n<li><p>度的考点：TD(v)&#x3D;ID(v)+OD(v)、ID(v)&#x3D;OD(v)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>路径、路径长度和回路</p>\n<ul>\n<li><p>路径：两个顶点之间的一条路径就是顶点序列</p>\n<ul>\n<li><p>顶点之间有可能不存在路径</p>\n</li>\n<li><p>有向图的路径也是有向的</p>\n</li>\n</ul>\n</li>\n<li><p>回路或环：第一个顶点和最后一个顶点相同的路径</p>\n<ul>\n<li>A-B-C-A</li>\n</ul>\n</li>\n<li><p>简单路径、简单回路</p>\n<ul>\n<li><p>简单路径：顶点不重复出现的路径</p>\n</li>\n<li><p>简单回路：除第一个顶点和最后一个顶点外其余顶点不重复出现的回路</p>\n</li>\n</ul>\n</li>\n<li><p>路径长度：路径上边的个数</p>\n</li>\n<li><p>点到点的距离</p>\n<ul>\n<li><p>从顶点u出发到顶点v的最短路经若存在，则此路径的长度称为从u到v的距离</p>\n</li>\n<li><p>若从u到v根本不存在路径，则记该距离为无穷（∞）</p>\n</li>\n</ul>\n</li>\n<li><p>若一个图有n个顶点并且有大于n-1条边，则此图一定有环</p>\n</li>\n</ul>\n</li>\n<li><p>连通、强连通图、强连通分量、连通图和连通分量</p>\n<ul>\n<li><p>连通：在无向图中，若从顶点v到而点w有路径存在，则称v和w是连通的</p>\n</li>\n<li><p>连通图：若无向图中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图</p>\n</li>\n<li><p>连通图考点：</p>\n<ul>\n<li><p>若一个无向图有n个顶点，并且边数小于n—1，则此图必是非连通图</p>\n</li>\n<li><p>无向图的最大边数为C_(n-1)^2——除一个顶点外两两连通</p>\n</li>\n</ul>\n</li>\n<li><p>强连通：在有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p>\n</li>\n<li><p>强连通图：若图中任何一对顶点都是强连通的，则称此图为强连通</p>\n</li>\n<li><p>强连通图考点：</p>\n<ul>\n<li>若有向图是强连通图，至少有n条边（形成回路，每个顶点的入度和出度均为1）</li>\n</ul>\n</li>\n<li><p>无向图中的极大连通子图称为连通分量</p>\n<ul>\n<li>极大连通子图：子图必须连通，且包含尽可能多的顶点和边</li>\n</ul>\n</li>\n<li><p>有向图中的极大强连通子图称为有向图的强连通分母</p>\n<ul>\n<li>极大强连通子图：子图必须强连通，同时保留尽可能多的边</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>子图</p>\n<ul>\n<li><p>设有两个图G&#x3D;（V，E )和G’&#x3D;(V’，E’)，若V是V的子集，且E’是E的子集，则称G’是G的子图</p>\n<ul>\n<li>子图必须符合图的定义（所以子图并不是任意的挑选出几个顶点、几条边）</li>\n</ul>\n</li>\n<li><p>若有满足V(G’)&#x3D;V(G)的子图G’，则称其为G的生成子图（包含所有顶点）</p>\n</li>\n</ul>\n</li>\n<li><p>生成树、生成森林</p>\n<ul>\n<li><p>连通图的生成树是包含图中全部顶点的一个极小连通子图</p>\n<ul>\n<li><p>极小连通子图：边尽可能的少，但要保持连通</p>\n</li>\n<li><p>连通图的生成树不唯一</p>\n</li>\n</ul>\n</li>\n<li><p>若图中顶点数为n，则它的生成树含有n-1条边</p>\n</li>\n<li><p>对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路</p>\n</li>\n<li><p>在非连通图中，连通分量的生成树构成了非连通图的生成森林</p>\n</li>\n</ul>\n</li>\n<li><p>边的权和网</p>\n<ul>\n<li><p>每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</p>\n</li>\n<li><p>这种边上带有权值的图称为带权图，也称网</p>\n</li>\n<li><p>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p>\n</li>\n</ul>\n</li>\n<li><p>完全图（也称简单完全图）</p>\n<ul>\n<li><p>无向完全图：</p>\n<ul>\n<li><p>无向图中任意两个顶点之间都存在边</p>\n</li>\n<li><p>无向完全图考点：|E|的取值范围是0到n(n—1)&#x2F;2，有n( n-1)&#x2F;2条边的无向图称为完全图</p>\n</li>\n</ul>\n</li>\n<li><p>有向图完全图</p>\n<ul>\n<li><p>在有向完全图中任意两个顶点之间都存在方向相反的两条弧</p>\n</li>\n<li><p>有向完全图考点：|E|的取值范围是0到n(n-1)，有n(n—1)条弧的有向图称为有向完全图</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>稠密图、稀疏图</p>\n<ul>\n<li><p>边数很少的图称为稀疏图,反之称为稠密图</p>\n</li>\n<li><p>一般当图G满足|E| &lt; |V|log|V|可以将G视为稀疏图</p>\n</li>\n</ul>\n</li>\n<li><p>树&#x2F;有向树</p>\n<ul>\n<li><p>树：</p>\n<ul>\n<li><p>树是不存在回路，且连通的无向图</p>\n</li>\n<li><p>n个顶点的树，一定有n-1条边</p>\n</li>\n<li><p>考点：n个顶点的图，如果边&gt;n-1条，无向图一定是有回路的</p>\n</li>\n</ul>\n</li>\n<li><p>森林：</p>\n<ul>\n<li>各个子图是极小的，各个子图是连通的</li>\n</ul>\n</li>\n<li><p>有向树</p>\n<ul>\n<li><p>一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树</p>\n</li>\n<li><p>有向树并不是强连通图</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"图的存储及基本操作\"><a href=\"#图的存储及基本操作\" class=\"headerlink\" title=\"图的存储及基本操作\"></a>图的存储及基本操作</h1><h2 id=\"邻接矩阵法\"><a href=\"#邻接矩阵法\" class=\"headerlink\" title=\"邻接矩阵法\"></a>邻接矩阵法</h2><ul>\n<li><p>邻接矩阵存储</p>\n<ul>\n<li><p>是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系）</p>\n</li>\n<li><p>存储顶点之间邻接关系的二维数组称为邻接矩阵</p>\n</li>\n<li><p>结构示意</p>\n<ul>\n<li><p>非带权图示意<img src=\"https://api2.mubu.com/v3/document_image/4f567b82-5e04-40f7-b044-c25477c6d7f5-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>带权图示意</p>\n<ul>\n<li>wij：边的权值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h2 id=\"代码实现：\"><a href=\"#代码实现：\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h2></li>\n<li><p>邻接矩阵表示法的空间复杂度为O(n^2)，其中n为图的顶点数|V|</p>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素</p>\n</li>\n<li><p>无向图</p>\n<ul>\n<li>第i个顶点的度TD（vi）：<ul>\n<li>邻接矩阵的第i行（或第i列）非零元素的个数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>有向图</p>\n<ul>\n<li><p>第i个顶点的出度 OD（vi）：</p>\n<ul>\n<li>邻接矩阵的第i行非零元素的个数</li>\n</ul>\n</li>\n<li><p>第i个顶点的入度 ID（vi）：</p>\n<ul>\n<li>邻接矩阵的第i列非零元素的个数</li>\n</ul>\n</li>\n<li><p>第i个顶点的度</p>\n<ul>\n<li>邻接矩阵的第i行、第i列非零元素的个数之和</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是要确定图中有多少条边，则必须按行、按列对每个元素进行检测所花费的时间代价很大</p>\n</li>\n<li><p>稠密图适合使用邻接矩阵的存储表示（空间复杂度高）</p>\n</li>\n</ul>\n</li>\n<li><p>性能分析：</p>\n<ul>\n<li>空间复杂度：O(n^2)<ul>\n<li>顶点数为n，边数为n^2</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>邻接矩阵的性质：</p>\n<ul>\n<li><p>重点：设图G的邻接矩阵为A（矩阵元素为0&#x2F;1），则A^n的元素A^n[i][j]等于由顶点i到顶点j的长度为n的路径的数目</p>\n</li>\n<li><p>截图：</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"邻接表法\"><a href=\"#邻接表法\" class=\"headerlink\" title=\"邻接表法\"></a>邻接表法</h2><ul>\n<li><p>当一个图为稀疏图时，使用邻接矩阵法要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，减少了不必要的浪费</p>\n</li>\n<li><p>结构</p>\n<ul>\n<li><p>对图G中的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边，这个单链表就称为顶点vi的边表（对于有向图则称为出边表）</p>\n</li>\n<li><p>邻接表中的两种结点</p>\n<ul>\n<li><p>顶点表结点</p>\n<ul>\n<li>顶点的数据信息、边表的头指针，采用顺序存储</li>\n</ul>\n</li>\n<li><p>边表结点</p>\n<ul>\n<li>边结点（无数据信息）、指向下一条边&#x2F;弧的指针</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h2 id=\"代码实现：-1\"><a href=\"#代码实现：-1\" class=\"headerlink\" title=\"代码实现：\"></a>代码实现：</h2></li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/7fb0fdf7-b0c2-4465-9ec0-5902e78339ed-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>对于稀疏图，采用邻接表表示将极大地节省存储空间</p>\n</li>\n<li><p>顶点的度：</p>\n<ul>\n<li><p>无向图：这个顶点的邻接表中的结点个数</p>\n</li>\n<li><p>有向图的出度：这个顶点的邻接表中的结点个数</p>\n</li>\n<li><p>有向图的入度：遍历全部的邻接表</p>\n</li>\n</ul>\n</li>\n<li><p>图的邻接表表示并不唯一，边结点在邻接表中出现的先后顺序是任意的</p>\n</li>\n<li><p>对于邻接矩阵，只要确定了顶点编号，图的邻接矩阵表示一定是唯一的</p>\n</li>\n</ul>\n</li>\n<li><p>性能分析：</p>\n<ul>\n<li><p>空间复杂度</p>\n<ul>\n<li><p>无向图：O(|V|+2|E|)，顶点数为V，边结点的数目是2|E|</p>\n</li>\n<li><p>有向图：O(|V|+|E|)，顶点数为V，边结点的数目是|E|</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"十字链表\"><a href=\"#十字链表\" class=\"headerlink\" title=\"十字链表\"></a>十字链表</h2><ul>\n<li><p>十字链表是有向图的一种链式存储结构，在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点</p>\n</li>\n<li><p>顶点结点域结构</p>\n<ul>\n<li><p>data域存放顶点相关的数据信息</p>\n</li>\n<li><p>firstin和firstout两个域分别指向以该顶点为弧头或尾的第一个弧结点</p>\n</li>\n</ul>\n</li>\n<li><p>弧结点域结构</p>\n<ul>\n<li><p>头域（headvex）：弧头</p>\n</li>\n<li><p>尾域（tailvex ）：弧尾</p>\n</li>\n<li><p>头链域（hlink ）：指向弧头相同的下一条弧</p>\n</li>\n<li><p>尾链域（ tlink ） ：指向弧尾相同的下一条弧</p>\n</li>\n<li><p>info域：指向该弧的相关信息</p>\n</li>\n</ul>\n</li>\n<li><p>空间复杂度：O(|V|+|E|)</p>\n</li>\n<li><p>如何找到指定结点的所有出边：顺着绿色线路找（firstout、tlink）</p>\n</li>\n<li><p>如何找到指定结点的所有入边：顺着橙色线路找（firstin、hlink）</p>\n</li>\n<li><p>只能存储有向图</p>\n</li>\n</ul>\n<h2 id=\"邻接多重表\"><a href=\"#邻接多重表\" class=\"headerlink\" title=\"邻接多重表\"></a>邻接多重表</h2><ul>\n<li><p>邻接矩阵的空间复杂度高；邻接表的每条边都对应着两份冗余信息，所以删除顶点或边等操作的时间复杂度高</p>\n</li>\n<li><p>邻接多重表是无向图的另一种链式存储结构</p>\n</li>\n<li><p>边结构</p>\n<ul>\n<li><p>mark为标志域，可用以标记该条边是否被搜索过</p>\n</li>\n<li><p>ivex和jvex为该边依附的两个顶点在图中的位置</p>\n</li>\n<li><p>ilink指向下一条依附于顶点ivex的边</p>\n</li>\n<li><p>jlink指向下一条依附于顶点jvex的边</p>\n</li>\n<li><p>info为指向该边的相关信息</p>\n</li>\n</ul>\n</li>\n<li><p>顶点结构</p>\n<ul>\n<li><p>data域存储该顶点的相关信息</p>\n</li>\n<li><p>firstedge域指示第一条依附于该顶点的边</p>\n</li>\n</ul>\n</li>\n<li><p>邻接多重表每条边只有一份信息，删除顶点或边的操作简单</p>\n</li>\n<li><p>空间复杂度：O（|V| + |E|）</p>\n</li>\n<li><p>只能存储无向图</p>\n</li>\n</ul>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><ul>\n<li><p>Adjacent(G，x，y)：判断图G中是否存在边&lt;x，y&gt;或(x，y)</p>\n<ul>\n<li><p>无向图和有向图</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(1)</p>\n</li>\n<li><p>邻接表的时间复杂度：O(1)~O(|V|)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Neighbors(G，x)：列出图G中与结点x邻接的边</p>\n<ul>\n<li><p>无向图</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(|V|)</p>\n</li>\n<li><p>邻接表的时间复杂度：O(1)~O(|V|)</p>\n</li>\n</ul>\n</li>\n<li><p>有向图</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(|V|)</p>\n</li>\n<li><p>邻接表出边的时间复杂度：O(1)~O(|V|)</p>\n</li>\n<li><p>邻接表入边的时间复杂度：O(|E|)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>InsertVertex(G，x)：在图中插入顶点x</p>\n<ul>\n<li><p>无向图和有向图：</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(1)</p>\n</li>\n<li><p>邻接表的时间复杂度：O(1)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DeleteVertex(G，x)：从图中删除顶点x</p>\n<ul>\n<li><p>无向图：</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(|V|)</p>\n</li>\n<li><p>邻接表的时间复杂度：O(1)~O(|E|)</p>\n</li>\n</ul>\n</li>\n<li><p>有向图：</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(|V|)</p>\n</li>\n<li><p>邻接表的时间复杂度：</p>\n<ul>\n<li><p>删除出边：O(1)~O(|V|)</p>\n</li>\n<li><p>删除入边：O(|E|)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AddEdge(G，x，y)：若无向边(x，y)或有向边&lt;x，y&gt;不存在，则向图G中添加该边</p>\n<ul>\n<li><p>无向图和有向图：</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(|1|)</p>\n</li>\n<li><p>邻接表的时间复杂度：O(1)~O(|V|)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>FirstNeighbor(G，x)：求图G中顶点x的第一个邻接点，若有则返回顶点好。若x没有邻接点或图中不存在，则返回-1</p>\n<ul>\n<li><p>无向图：</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(1)~O(|V|)</p>\n</li>\n<li><p>邻接表的时间复杂度：O(1)</p>\n</li>\n</ul>\n</li>\n<li><p>有向图：</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(1)~O(|V|)</p>\n</li>\n<li><p>邻接表的时间复杂度</p>\n<ul>\n<li><p>找出边邻接点：O(1)</p>\n</li>\n<li><p>找入边邻接点：O(1)~O(|E|)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>NextNeighbor(G，x，y)：顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</p>\n<ul>\n<li><p>无向图：</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(1)~O(|V|)</p>\n</li>\n<li><p>邻接表的时间复杂度：O(1)</p>\n</li>\n</ul>\n</li>\n<li><p>有向图：</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(1)~O(|V|)</p>\n</li>\n<li><p>邻接表的时间复杂度</p>\n<ul>\n<li><p>找出边邻接点：O(1)</p>\n</li>\n<li><p>找入边邻接点：O(1)~O(|E|)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Get_edge_value(G，x，y)：获取图G中边(x，y)或&lt;x，y&gt;对应的权值</p>\n</li>\n<li><p>Set_edge_value(G，x，y)：设置图G中边(x，y)或&lt;x，y&gt;对应的权值为v</p>\n<ul>\n<li><p>这两个操作核心在于找到边——Adjacent(G，x，y)：判断图G中是否存在边&lt;x，y&gt;或(x，y)</p>\n</li>\n<li><p>无向图和有向图</p>\n<ul>\n<li><p>邻接矩阵的时间复杂度：O(1)</p>\n</li>\n<li><p>邻接表的时间复杂度：O(1)~O(|V|)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"图的遍历\"><a href=\"#图的遍历\" class=\"headerlink\" title=\"图的遍历\"></a>图的遍历</h1><h2 id=\"广度优先搜索\"><a href=\"#广度优先搜索\" class=\"headerlink\" title=\"广度优先搜索\"></a>广度优先搜索</h2><ul>\n<li><p>广度优先搜索（BFS）</p>\n<ul>\n<li><p>类似于二叉树的层序遍历算法</p>\n</li>\n<li><p>算法思想</p>\n<ul>\n<li><p>首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1，w2，……，wi</p>\n</li>\n<li><p>然后依次访问w1，w2，wi的所有未被访问过的邻接顶点并标记这些顶点被访问过</p>\n</li>\n<li><p>再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点直至图中所有顶点都被访问过为止</p>\n</li>\n</ul>\n</li>\n<li><p>算法实现：</p>\n<ul>\n<li><p>FirstNeighbor(G，x)和NextNeighbor(G，x，y)</p>\n</li>\n<li><p>bool visited[MAX_VERTEX_NUM]，该数组标记已被访问过的结点</p>\n</li>\n<li></li>\n</ul>\n</li>\n<li><p>利用队列实现搜索</p>\n</li>\n</ul>\n</li>\n<li><p>树与图在广度优先遍历时的不同点</p>\n<ul>\n<li><p>树：不存在回路，搜索相邻的结点时，不可能搜到已经访问过的结点</p>\n</li>\n<li><p>图：搜索相邻的顶点时，有可能搜到已经访问过的顶点</p>\n</li>\n</ul>\n</li>\n<li><p>BFS算法无法完全遍历非连通图，此时遍历visited数组，找到数组中第一个值为false的顶点，在这个顶点出发调用BFS函数</p>\n<ul>\n<li>对于无向图，调用BFS函数的次数&#x3D;连通分量数</li>\n</ul>\n</li>\n<li><p>BFS算法的性能分析</p>\n<ul>\n<li><p>在最坏的情况下，空间复杂度为O(|V|)——辅助队列（访问一个结点时，这个结点最多有V-1个邻接点）</p>\n</li>\n<li><p>时间复杂度</p>\n<ul>\n<li><p>邻接表存储方式： </p>\n<ul>\n<li><p>顶点：O（|V|）</p>\n</li>\n<li><p>边： O（|E|）</p>\n</li>\n<li><p>总时间复杂度：O（|V|+|E|）</p>\n</li>\n</ul>\n</li>\n<li><p>邻接矩阵存储方式：</p>\n<ul>\n<li><p>访问|V|个顶点的时间复杂度：O(|V|)</p>\n</li>\n<li><p>查找每个顶点的邻接点都需要O(|V|)的时间，所以查找边的时间复杂度：O(|V|^2)</p>\n</li>\n<li><p>总时间复杂度：O(|V|^2)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>广度优先生成树</p>\n<ul>\n<li><p>在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树</p>\n</li>\n<li><p>唯一性</p>\n<ul>\n<li><p>邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的</p>\n</li>\n<li><p>由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>广度优先生成森林</p>\n<ul>\n<li>对非连通图的广度优先遍历，可以得到广度优先生成树</li>\n</ul>\n</li>\n<li><p>BFS算法可以解决最短路径问题</p>\n</li>\n</ul>\n<h2 id=\"深度优先搜索\"><a href=\"#深度优先搜索\" class=\"headerlink\" title=\"深度优先搜索\"></a>深度优先搜索</h2><ul>\n<li><p>深度优先搜索（DFS）</p>\n<ul>\n<li><p>类似于树的先序遍历。搜索策略是尽可能“深”地搜索一个图</p>\n</li>\n<li><p>算法思想</p>\n<ul>\n<li><p>首先访问图中某一起始顶点，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2……重复上述过程。</p>\n</li>\n<li><p>当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程直至图中所有顶点均被访问过为止</p>\n</li>\n</ul>\n</li>\n<li><p>递归算法</p>\n<ul>\n<li>需要借助一个递归工作栈</li>\n</ul>\n</li>\n<li><p>算法实现</p>\n<ul>\n<li>bool visited[MAX_VERTEX_NUM]，该数组标记已被访问过的结点</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DFS算法的性能分析</p>\n<ul>\n<li><p>空间复杂度O（|V|），函数调用栈</p>\n</li>\n<li><p>时间复杂度</p>\n<ul>\n<li><p>邻接矩阵</p>\n<ul>\n<li><p>访问|V|个顶点的时间复杂度：O(|V|)</p>\n</li>\n<li><p>查找每个顶点的邻接点都需要O(|V|)的时间，所以查找边的时间复杂度：O(|V|^2)</p>\n</li>\n<li><p>总时间复杂度：O(|V|^2)</p>\n</li>\n</ul>\n</li>\n<li><p>邻接链表：总时间复杂度O（|V|+|E|）</p>\n<ul>\n<li><p>找所有顶点的邻接点所需的时间为O（|E|）</p>\n</li>\n<li><p>访问顶点所需的时间为O（|V|）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>深度优先的生成树和生成森林：基于邻接表存储的深度优先生成树是不唯一的</p>\n<ul>\n<li><p>对连通图调用DFS才能产生深度优先生成树</p>\n</li>\n<li><p>非连通图产生的是深度优先生成森林</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ul>\n<li><p>基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的</p>\n</li>\n<li><p>基于邻接表的遍历所得到的DFS和BFS是不唯一的</p>\n</li>\n</ul>\n<h2 id=\"图的遍历与图的连通性\"><a href=\"#图的遍历与图的连通性\" class=\"headerlink\" title=\"图的遍历与图的连通性\"></a>图的遍历与图的连通性</h2><ul>\n<li><p>图的遍历算法可以用来判断图的连通性</p>\n</li>\n<li><p>对于无向图</p>\n<ul>\n<li><p>若无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中的所有顶点</p>\n</li>\n<li><p>若无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问</p>\n</li>\n<li><p>调用BFS&#x2F;DFS函数的次数&#x3D;连通分量数</p>\n</li>\n<li><p>对于连通图，只需调用1次BFS&#x2F;DFS</p>\n</li>\n</ul>\n</li>\n<li><p>对于有向图</p>\n<ul>\n<li><p>若有向图是连通的，从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点</p>\n</li>\n<li><p>若有向图是非连通的，不能访问到所有顶点</p>\n</li>\n<li><p>对于强连通图，从任一结点触发都只需调用1次BFS&#x2F;DFS</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"图的应用\"><a href=\"#图的应用\" class=\"headerlink\" title=\"图的应用\"></a>图的应用</h1><h2 id=\"最小生成树\"><a href=\"#最小生成树\" class=\"headerlink\" title=\"最小生成树\"></a>最小生成树</h2><ul>\n<li><p>一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边</p>\n<ul>\n<li><p>若砍去它的一条边，则会使生成树变成非连通图</p>\n</li>\n<li><p>若给它增加一条边，则会形成图中的一条回路</p>\n</li>\n<li><p>连通图的顶点数为n，生成树含有n-1条边</p>\n</li>\n</ul>\n</li>\n<li><p>最小生成树：权值之和最小的那棵生成树，则称为最小生成树</p>\n<ul>\n<li>非连通图没有最小生成树，只有生成森林</li>\n</ul>\n</li>\n<li><p>最小生成树性质</p>\n<ul>\n<li><p>最小生成树不是唯一的，即最小生成树的树形不唯一</p>\n</li>\n<li><p>其对应的边的权值之和总是唯一的，而且是最小的</p>\n</li>\n<li><p>最小生成树的边数为顶点数减1</p>\n</li>\n</ul>\n</li>\n<li><p>最小生成树算法</p>\n<ul>\n<li><p>Prim算法</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li><p>开始时从图中任取一顶点加入树T，此时树中只含有一个顶点</p>\n</li>\n<li><p>之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1</p>\n</li>\n<li><p>以此类推，直至图中所有的顶点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度O(|V|^2)</p>\n<ul>\n<li><p>isJoin：标记结点是否已经加入到树</p>\n</li>\n<li><p>lowCast：各结点加入树的最低代价</p>\n</li>\n<li><p>1、遍历所有结点，找出lowCast最低的，且还没有加入树的顶点——O(n)</p>\n</li>\n<li><p>2、再次循环遍历，更新还没有加入各个顶点的lowCast值——O(n)</p>\n</li>\n<li><p>再次循环1&#x2F;2步骤，一共循环n-1次</p>\n</li>\n<li><p>总循环：(n-1)*2n，即O(n^2)</p>\n</li>\n</ul>\n</li>\n<li><p>适用于求解边稠密的图的最小生成树</p>\n</li>\n</ul>\n</li>\n<li><p>Kruskal算法</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li><p>初始时为只有n个顶点而无边的非连通图T&#x3D;{V，{}}，每个顶点自成一个连通分量</p>\n</li>\n<li><p>然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边</p>\n</li>\n<li><p>若该边依附的顶点落在中不同的连通分量上，则将此边加入T</p>\n</li>\n<li><p>否则舍弃此边而选择下一条权值最小的边</p>\n</li>\n<li><p>以此类推，直至T中所有顶点都在一个连通分量上</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度O（log|E|）</p>\n<ul>\n<li><p>一共执行E轮（E条边）</p>\n</li>\n<li><p>每轮需要判断一次两个顶点是否是一个集合，需要的时间是O(log_2(E))</p>\n</li>\n</ul>\n</li>\n<li><p>适合于边稀疏而顶点较多的图</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h2><ul>\n<li><p>BFS算法（无权图）</p>\n<ul>\n<li><p>代码实现</p>\n</li>\n<li><p>最短路径长度：</p>\n</li>\n<li><p>最短路径：</p>\n</li>\n<li><p>实际上就是把无权图转化为以2为根，高度最小的生成树（广度优先生成树）</p>\n</li>\n</ul>\n</li>\n<li><p>Dijkstra算法求单源最短路径问题（无权图和带权图）</p>\n<ul>\n<li><p>辅助数组</p>\n<ul>\n<li><p>dist[]：记录从源点v0到其他各顶点当前的最短路径长度，它的初态为：若从v0到vi有弧，则dist[i]为弧上的权值；否则置dist[i]为无穷大</p>\n</li>\n<li><p>path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点</p>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>1)初始化集合S初始为{0}，dist[]的初始值dist[i]&#x3D;arcs[0][i]，i&#x3D;1,2,……,n-1</p>\n</li>\n<li><p>2）从顶点集合V-S中选出vj，满足dist[j]&#x3D;Min{dist[i]|vi∈V-S}，vj就是当前求得的一条从v0出发的最短路径的终点，令S&#x3D;SU{j}</p>\n</li>\n<li><p>3）修改从V0出发到集合V-S上任一顶点vk可达的最短路径长度：若dist[i]+arcs[j][k]</p>\n</li>\n<li><p>4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度O(|V|^2)</p>\n<ul>\n<li><p>一共n-1轮处理</p>\n</li>\n<li><p>每轮处理：O(2n)</p>\n<ul>\n<li><p>遍历所有顶点O(n)</p>\n</li>\n<li><p>检查该顶点的所有邻接点O(n)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>不适用于边权值存在负数的情况</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Floyd算法求各顶点之间最短路径问题（无权图和带权图）\"><a href=\"#Floyd算法求各顶点之间最短路径问题（无权图和带权图）\" class=\"headerlink\" title=\"Floyd算法求各顶点之间最短路径问题（无权图和带权图）\"></a>Floyd算法求各顶点之间最短路径问题（无权图和带权图）</h2><ul>\n<li><p>实现思想：动态规划，也就是将问题的求解分为多个阶段</p>\n</li>\n<li><p>辅助二维数组</p>\n<ul>\n<li><p>A：存储各个顶点间的最短路径长度</p>\n</li>\n<li><p>path：存储各个顶点之间的中转点</p>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>初始时，不允许有其他顶点中转</p>\n<ul>\n<li><p>对于任意两个顶点vi和vi，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度</p>\n</li>\n<li><p>若它们之间不存在有向边，则以无穷大作为它们之间的最短路径长度</p>\n</li>\n</ul>\n</li>\n<li><p>以后逐步尝试在原路径中加入顶点k （k&#x3D;0，1，2..，n-1）作为中间顶点</p>\n</li>\n<li><p>若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度O（|V|^3）</p>\n<ul>\n<li><p>以某个顶点为中转点，循环|V|次——即以v1为中转点，以v1、v2为中转点……</p>\n</li>\n<li><p>遍历这个矩阵，判断当以该顶点为中转点时，路径长度是否变短，O(|V|^2)</p>\n</li>\n</ul>\n</li>\n<li><p>空间复杂度：O(|V|^2)——两个n行n列的辅助矩阵</p>\n</li>\n<li><p>允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路</p>\n</li>\n<li><p>适用于带权无向图</p>\n</li>\n</ul>\n<h2 id=\"有向无环图描述表达式\"><a href=\"#有向无环图描述表达式\" class=\"headerlink\" title=\"有向无环图描述表达式\"></a>有向无环图描述表达式</h2><ul>\n<li><p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图</p>\n</li>\n<li><p>有向无环图是描述含有公共子式的表达式的有效工具</p>\n</li>\n</ul>\n<h2 id=\"求有向无环图的解题方法\"><a href=\"#求有向无环图的解题方法\" class=\"headerlink\" title=\"求有向无环图的解题方法\"></a>求有向无环图的解题方法</h2><ul>\n<li><p>将各个操作数不重复地排成一列</p>\n</li>\n<li><p>标出每个运算符的生效顺序</p>\n</li>\n<li><p>按顺序加入运算符，注意分层</p>\n</li>\n<li><p>自底向上逐层检查同层运算符是否可以合体</p>\n</li>\n</ul>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><ul>\n<li><p>AOV网概述：是有向无环图，以顶点表示活动</p>\n<ul>\n<li><p>若用DAG图表示一个工程，其顶点表示活动，用有向边&lt;Vi，Vj&gt;表示获得Vi先于活动Vj进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为AOV网</p>\n</li>\n<li><p>活动Vi是活动Vj的直接前驱，活动Vj是活动Vi的直接后继</p>\n</li>\n<li><p>这种前驱和后继关系具有传递性，且任何活动不能以它自己作为自己的前驱或后继</p>\n</li>\n</ul>\n</li>\n<li><p>拓扑排序定义</p>\n<ul>\n<li><p>每个顶点出现且只出现一次</p>\n</li>\n<li><p>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径</p>\n</li>\n</ul>\n</li>\n<li><p>拓扑排序实现方法</p>\n<ul>\n<li><p>1、从AOV网中选择一个没有前驱的顶点并输出</p>\n</li>\n<li><p>2、从网中删除该顶点和所有以它为起点的有向边</p>\n</li>\n<li><p>3、重复1和2直到当前的AOV网为空（排序成功）或当前网中不存在无前驱的顶点（排序失败，说明有向图中必然存在回路）为止</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>indegree[]：当前顶点的入度</p>\n</li>\n<li><p>print[]：记录拓扑序列</p>\n</li>\n<li><p>栈（或队列）：保存度为0的顶点</p>\n</li>\n</ul>\n</li>\n<li><h2 id=\"DFS算法实现\"><a href=\"#DFS算法实现\" class=\"headerlink\" title=\"DFS算法实现\"></a>DFS算法实现</h2></li>\n<li><p>注意</p>\n<ul>\n<li><p>入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续</p>\n</li>\n<li><p>若一个顶点有多个直接后继则拓扑排序的结果通常不唯一</p>\n</li>\n<li><p>若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的</p>\n</li>\n<li><p>生成AOV网的新的邻接存储矩阵，可以是三角矩阵</p>\n</li>\n<li><p>对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度：</p>\n<ul>\n<li><p>邻接表存储：O(|V|+|E|)</p>\n</li>\n<li><p>邻接矩阵：O(|V|^2)</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"逆拓扑排序\"><a href=\"#逆拓扑排序\" class=\"headerlink\" title=\"逆拓扑排序\"></a>逆拓扑排序</h2><ul>\n<li><p>具体实现</p>\n<ul>\n<li><p>1.类似于拓扑排序的算法</p>\n</li>\n<li><p>2.DFS算法：在顶点退栈前输出</p>\n<ul>\n<li>判断是否存在回路</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>思想</p>\n<ul>\n<li><p>1、从AOV网中选择一个没有后继（出度为0）的顶点并输出</p>\n</li>\n<li><p>2、从网中删除该顶点和所有以它为终点的有向边</p>\n</li>\n<li><p>3、重复1和2直到当前的AOV网为空</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度：</p>\n<ul>\n<li><p>邻接矩阵：</p>\n</li>\n<li><p>逆邻接表：邻接表中保存指向该顶点的边</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"拓扑排序和逆拓扑排序性质\"><a href=\"#拓扑排序和逆拓扑排序性质\" class=\"headerlink\" title=\"拓扑排序和逆拓扑排序性质\"></a>拓扑排序和逆拓扑排序性质</h2><ul>\n<li><p>拓扑排序、逆拓扑排序序列可能不唯一</p>\n</li>\n<li><p>若图中有环，则不存在拓扑排序序列&#x2F;逆拓扑排序序列</p>\n</li>\n</ul>\n<h2 id=\"关键路径\"><a href=\"#关键路径\" class=\"headerlink\" title=\"关键路径\"></a>关键路径</h2><ul>\n<li><p>AOE网概述：以有向边表示活动</p>\n<ul>\n<li>在带权有向图中，以顶点表示事件（没有开销），以有向边表示活动（有开销），以边上的权值表示完成该活动的开销（如完成活动所需的时间） ，称之为用边表示活动的网络</li>\n</ul>\n</li>\n<li><p>AOE与AOV</p>\n<ul>\n<li><p>相同点</p>\n<ul>\n<li>AOE网和AOV网都是有向无环图</li>\n</ul>\n</li>\n<li><p>不同点</p>\n<ul>\n<li>AOE网中的边有权值；而AOV网中的边无权值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>AOE网性质</p>\n<ul>\n<li><p>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</p>\n</li>\n<li><p>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生</p>\n</li>\n<li><p>有的活动可以并行进行</p>\n</li>\n</ul>\n</li>\n<li><p>关键路径与关键活动</p>\n<ul>\n<li><p>关键路径：从源点到汇点的所有路径中具有最大路径长度的路径</p>\n<ul>\n<li>关键路径的长度：完成整个工程的最短时间</li>\n</ul>\n</li>\n<li><p>关键活动：关键路径上的活动</p>\n<ul>\n<li>若关键活动不能按时完成，则整个工程的完成时间就会延长</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>变量含义</p>\n<ul>\n<li><p>事件vk的最早发生事件ve（k）</p>\n<ul>\n<li><p>ve（源点）&#x3D;0</p>\n</li>\n<li><p>ve（k）&#x3D;Max{ve（j）+ Weight（vy，vk）}，vk为vj的任意后继，Weight （vi，vk）表示&lt;vj，vk&gt;上的权值</p>\n</li>\n<li><p>所有从vk开始的活动能够开工的最早时间</p>\n</li>\n</ul>\n</li>\n<li><p>事件vk的最迟发生事件vl（k）</p>\n<ul>\n<li><p>vl（汇点）&#x3D; ve（汇点）</p>\n</li>\n<li><p>vl（k）&#x3D;Min{vl（j）- Weight（vk，vj)}，vk为vj的任意前驱</p>\n</li>\n<li><p>指不推迟整个工程完成的前提下，该事件最迟必须完成的时间</p>\n</li>\n</ul>\n</li>\n<li><p>活动ai的最早开始时间e（i）</p>\n<ul>\n<li><p>该活动弧的起点的事件的最早发生时间</p>\n</li>\n<li><p>若边&lt;vk，vj&gt;表示活动ai，则有e（i）&#x3D;ve（k）</p>\n</li>\n</ul>\n</li>\n<li><p>活动ai的最迟开始时间l（i）</p>\n<ul>\n<li><p>该活动弧的终点的事件的最迟发生时间与该活动所需时间之差</p>\n</li>\n<li><p>若边&lt;vk，vj&gt;表示活动ai，则有l（i）&#x3D;vl（j）-Weight（vk，vj）</p>\n</li>\n</ul>\n</li>\n<li><p>活动的时间余量d(i)</p>\n<ul>\n<li><p>一个活动的最迟开始时间l（i）和最早开始时间e（i）的差额d（i）&#x3D;l（i）-e（i）</p>\n</li>\n<li><p>指在不增加完成整个工程所需总时间的前提下，该活动可以拖延的时间</p>\n</li>\n<li><p>若该活动的时间余量为0，表示该活动不能拖延，即该活动为关键活动</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>求关键路径的算法步骤</p>\n<ul>\n<li><p>从源点出发，令ve（源点）&#x3D;0，按拓扑有序求其余顶点的最早发生时间ve（）</p>\n<ul>\n<li><p>先找到拓扑排序序列</p>\n</li>\n<li><p>求各个顶点的最早发生时间（取最大值）</p>\n</li>\n</ul>\n</li>\n<li><p>从汇点出发，令vl（汇点） &#x3D;ve（汇点），按逆拓扑有序求其余顶点的最迟发生时间vl（）</p>\n<ul>\n<li><p>将汇点的最早发生时间赋值给汇点的最晚发生时间</p>\n</li>\n<li><p>按拓扑序列反向写出逆拓扑序列（取最小值）</p>\n</li>\n</ul>\n</li>\n<li><p>根据各顶点的ve（）值求所有孤的最早开始时间e（）</p>\n<ul>\n<li>活动的最早发生时间&#x3D;活动弧起点处事件的最早发生时间</li>\n</ul>\n</li>\n<li><p>根据各顶点的vl（）值求所有弧的最迟开始时间1（）</p>\n<ul>\n<li>活动的最晚发生时间&#x3D;活动弧终点处事件的最晚发生时间 - 活动所需时间</li>\n</ul>\n</li>\n<li><p>求AOE网中所有活动的差额d（），找出所有d（）&#x3D;0的活动构成关键路径</p>\n<ul>\n<li>活动的时间余量&#x3D;活动的最晚发生时间 - 活动的最早发生时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>关键活动、关键路径特性</p>\n<ul>\n<li><p>若关键活动耗时增加，则整个工程的工期将增加</p>\n</li>\n<li><p>关键路径上的所有活动都是关键活动，是决定整个工程的关键因素，因此可通过加快关键活动来缩短整个工程的工期</p>\n</li>\n<li><p>不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动</p>\n</li>\n<li><p>网中的关键路径并不唯一，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的</p>\n</li>\n<li><p>若关键活动耗时增加，则整个工程的工期将增长</p>\n</li>\n<li><p>缩短关键活动的时间，可以缩短整个工程的工期</p>\n</li>\n<li><p>当缩短到一定程度时，关键活动可能会变成非关键活动</p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","3.数据结构","6.图"],"tags":["写作"]},{"title":"查找","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7%E6%9F%A5%E6%89%BE/","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><ul>\n<li><p>查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找</p>\n</li>\n<li><p>查找表（查找结构） ：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型</p>\n</li>\n<li><p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的</p>\n</li>\n<li><p>查找表操作</p>\n<ul>\n<li><p>查询某个特定的数据元素是否在查找表中</p>\n</li>\n<li><p>检索满足条件的某个特定的数据元素的各种属性</p>\n</li>\n<li><p>在查找表中插入一个数据元素</p>\n</li>\n<li><p>从查找表中删除某个数据元素</p>\n</li>\n</ul>\n</li>\n<li><p>静态查找表</p>\n<ul>\n<li>查找后不会对表进行任何修改</li>\n</ul>\n</li>\n<li><p>动态查找表</p>\n<ul>\n<li>查找后对表进行修改</li>\n</ul>\n</li>\n<li><p>平均查找长度ASL：平均查找长度是衡量查找算法效率的最主要的指标</p>\n<ul>\n<li><p>在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值</p>\n</li>\n<li><p>数学表达式<img src=\"https://api2.mubu.com/v3/document_image/392c9d00-02e0-49c4-884d-fbdc98df1d23-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>参数含义</p>\n<ul>\n<li><p>n是查找表的长度</p>\n</li>\n<li><p>P是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即P&#x3D;1&#x2F;n</p>\n</li>\n<li><p>Ci是找到第个数据元素所需进行的比较次数</p>\n</li>\n</ul>\n</li>\n<li><p>评价一个查找算法的效率时，通常考虑查找成功&#x2F;查找失败两种情况的ASL</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"顺序查找和折半查找\"><a href=\"#顺序查找和折半查找\" class=\"headerlink\" title=\"顺序查找和折半查找\"></a>顺序查找和折半查找</h1><h2 id=\"顺序查找\"><a href=\"#顺序查找\" class=\"headerlink\" title=\"顺序查找\"></a>顺序查找</h2><ul>\n<li><p>又称线性查找，主要用于在线性表中进行查找。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的顺序表的顺序查找</p>\n</li>\n<li><p>一般线性表的顺序查找</p>\n<ul>\n<li><p>基本思想</p>\n<ul>\n<li><p>从线性表的一端开始，逐个检查关键字是否满足给定的条件。</p>\n</li>\n<li><p>若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置</p>\n</li>\n<li><p>若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><h2 id=\"一般\"><a href=\"#一般\" class=\"headerlink\" title=\"一般\"></a>一般</h2></li>\n<li><p>0号位置增加哨兵</p>\n<ul>\n<li>优点：无需判断是否越界，效率更高</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>平均查找长度</p>\n<ul>\n<li><p>成功（查找的数据存在于线性表中，n为线性表中元素总个数）</p>\n<ul>\n<li>ASL成功 &#x3D; (n+1)&#x2F;2</li>\n</ul>\n</li>\n<li><p>失败（查找的数据不存在于线性表中，n为线性表中元素总个数）</p>\n<ul>\n<li>ASL不成功 &#x3D; n+1</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺点：当n较大时，平均查找长度较大，效率低</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>对数据元素的存储没有要求，顺序存储或链式存储皆可</p>\n</li>\n<li><p>对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>有序表的顺序查找（经常查找失败）</p>\n<ul>\n<li><p>基本思想</p>\n<ul>\n<li><p>假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key</p>\n</li>\n<li><p>当查找到第i个元素时，发现第i个元素对应的关键字小于key，但第i+1个元素对应的关键字大于key，这时就可返回查找失败的信息</p>\n</li>\n<li><p>因为第i个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素</p>\n</li>\n</ul>\n</li>\n<li><p>平均查找长度</p>\n<ul>\n<li><p>成功<img src=\"https://api2.mubu.com/v3/document_image/b0e90783-27bd-4664-91e1-f4144d72fb74-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>失败（前提：假设查找失败结点的概率相等，也就是每两个结点间的差相等）<img src=\"https://api2.mubu.com/v3/document_image/c51c8c1b-62b1-44a7-b5af-4c8def6be8fe-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>查找判定树的画法</p>\n<ul>\n<li><p>一个成功结点的查找长度&#x3D;自身所在层数</p>\n</li>\n<li><p>一个失败结点的查找长度&#x3D;其父结点所在层数</p>\n</li>\n<li><p>默认情况下，各种失败情况或成功情况都等概率发生</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>无序表的顺序查找（经常查找成功）</p>\n<ul>\n<li><p>被查找概率大的数据放在靠前位置</p>\n</li>\n<li><p>平均查找长度</p>\n<ul>\n<li><p>成功：小于(n+1)&#x2F;2</p>\n</li>\n<li><p>失败：n+1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度：O(n)</p>\n</li>\n</ul>\n<h2 id=\"折半查找\"><a href=\"#折半查找\" class=\"headerlink\" title=\"折半查找\"></a>折半查找</h2><ul>\n<li><p>折半查找又称二分查找，它仅适用于有序的顺序表</p>\n<ul>\n<li>顺序表：拥有随机存取（随机访问）的特性，而链表没有</li>\n</ul>\n</li>\n<li><p>基本思想</p>\n<ul>\n<li><p>首先将给定值key与表中中间位置的元素比较，若相等则查找成功，返回该元素的存储位置</p>\n</li>\n<li><p>若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分</p>\n</li>\n<li><p>然后在缩小的范围内继续进行同样的查找如此重复，直到找到为止</p>\n</li>\n<li><p>或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>升序</p>\n</li>\n<li><p>降序</p>\n</li>\n</ul>\n</li>\n<li><p>查找过程中可以生成判定树（平衡二叉树）</p>\n<ul>\n<li><p>树中每个圆形结点表示一个记录结点中的值为该记录的关键字值</p>\n</li>\n<li><p>树中最下面的叶结点都是方形的，它表示查找不成功的情况</p>\n</li>\n<li><p>若mid&#x3D;【(low+high)&#x2F;2】向下取整，则对于任何一个结点，一定有右子树结点数-左子树结点数&#x3D;0或1</p>\n<ul>\n<li><p>如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</p>\n</li>\n<li><p>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</p>\n</li>\n</ul>\n</li>\n<li><p>折半查找判定树的构造</p>\n<ul>\n<li><p>折半查找判定树一定是平衡二叉树</p>\n</li>\n<li><p>折半查找判定树中，只有最下面一层是不满的，元素个数为n时，树高为h&#x3D;【log_2(n+1)】向上取整（不包含失败结点）</p>\n</li>\n<li><p>折半查找判定树结点关键字：左&lt;中&lt;右，满足二叉排序树的定义</p>\n</li>\n<li><p>失败结点：n+1（等于成功结点的空链域数量）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>平均查找长度</p>\n<ul>\n<li><p>成功</p>\n<ul>\n<li><p>h是树的高度，并且元素个数为n时，树高h&#x3D;log_2(n + 1)向上取整</p>\n</li>\n<li><p>ASL成功&lt;&#x3D;h</p>\n</li>\n</ul>\n</li>\n<li><p>失败</p>\n<ul>\n<li>ASL失败&lt;&#x3D;h</li>\n</ul>\n</li>\n<li><p>时间复杂度：O(log_2(n))</p>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度为<img src=\"https://api2.mubu.com/v3/document_image/cb807439-9f0e-4a3b-b308-8a495285f0af-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列</p>\n</li>\n<li><p>拓展：</p>\n<ul>\n<li><p>大部分情况下，折半查找的速度优于顺序查找的速度（平均速率）；但是，折半查找的速度不是一定比顺序查找快</p>\n</li>\n<li><p>如果mid&#x3D;【(low+high)&#x2F;2】向上取整，判定树是怎样的？对于任何一个结点，一定有右子树结点数-左子树结点数&#x3D;0或1</p>\n<ul>\n<li><p>如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</p>\n</li>\n<li><p>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h2><ul>\n<li><p>又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找</p>\n</li>\n<li><p>基本思想</p>\n<ul>\n<li><p>将查找表分为若干子块</p>\n</li>\n<li><p>块内的元素可以无序，但块之间是有序的，第一个块中的最大关键字小于第二个块中的所有记录的关键字，以此类推</p>\n</li>\n<li><p>再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址（或分块的存储区间），索引表按关键字大小有序排列</p>\n</li>\n</ul>\n</li>\n<li><p>实现思想</p>\n<ul>\n<li><p>在索引表中确定待查记录所属的分块</p>\n<ul>\n<li><p>顺序查找</p>\n<ul>\n<li><p>将查找目标的关键字与索引表中的元素的关键字依次比较</p>\n</li>\n<li><p>索引表关键字小于查找目标关键字时，指针指向索引表下一个元素</p>\n</li>\n<li><p>直到索引表关键字大于等于查找目标关键字</p>\n</li>\n</ul>\n</li>\n<li><p>分块查找</p>\n<ul>\n<li><p>在索引表中，low指向索引表第一个元素，high指向索引表最后一个元素</p>\n</li>\n<li><p>当在索引表中查找成功时，直接返回该索引表项</p>\n</li>\n<li><p>当在索引表中查找失败时，返回low所指的索引表项</p>\n<ul>\n<li>因为low+1&#x3D;high时，mid&#x3D;low，此时mid&lt;目标，所以low&#x3D;high&gt;目标，mid&#x3D;low&#x3D;high&gt;目标，high&#x3D;mid-1，所以high&lt;目标&lt;low，应该从low所指元素的区间内寻找</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在块内顺序查找</p>\n<ul>\n<li><p>从索引表中该元素的起始地址开始查找</p>\n</li>\n<li><p>如果超出分块范围，那么查找失败</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2></li>\n<li><p>查找成功长度</p>\n<ul>\n<li><h2 id=\"分块不均匀：与分块均匀有极大的区别\"><a href=\"#分块不均匀：与分块均匀有极大的区别\" class=\"headerlink\" title=\"分块不均匀：与分块均匀有极大的区别\"></a>分块不均匀：与分块均匀有极大的区别</h2></li>\n<li><p>分块均匀</p>\n<ul>\n<li><p>将长度为n的查找表均匀地分为b块，每块有s个记录，（n&#x3D;s*b）在等概率情况下</p>\n</li>\n<li><p>索引查找的平均查找长度LI；决内查找的平均查找长度LS</p>\n</li>\n<li><p>在块内和索引表中均采用顺序查找，则平均查找长度（求平均查找长度最小值：函数求导）<img src=\"https://api2.mubu.com/v3/document_image/4dc73481-b088-409b-b157-cbe708961cea-3224585.jpg\" alt=\"img\"><img src=\"https://api2.mubu.com/v3/document_image/76b2ad8d-780b-42c0-8763-6351076a3175-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>若对索引表采用折半查找时，则平均查找长度<img src=\"https://api2.mubu.com/v3/document_image/5727dec9-0d04-490a-9548-3ac38d535f03-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>若查找表是“动态查找表”——使用链式存储</p>\n</li>\n</ul>\n<h1 id=\"B树和B-树\"><a href=\"#B树和B-树\" class=\"headerlink\" title=\"B树和B+树\"></a>B树和B+树</h1><h2 id=\"B树及其基本操作\"><a href=\"#B树及其基本操作\" class=\"headerlink\" title=\"B树及其基本操作\"></a>B树及其基本操作</h2><ul>\n<li><p>概述：又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示</p>\n</li>\n<li><p>B树要么为空树，要么满足如下特点：</p>\n<ul>\n<li><p>树中每个结点至多有m裸子树，即至多含有m—1个关键字</p>\n<ul>\n<li>一个关键字可以将一个查找区间分为两个部分</li>\n</ul>\n</li>\n<li><p>若根结点不是终端结点，则至少有2棵子树，即1个关键字</p>\n<ul>\n<li>为了保证绝对平衡</li>\n</ul>\n</li>\n<li><p>规定：除根结点外的所有非叶结点至少有   棵子树,即至少含有   个关键字</p>\n<ul>\n<li><p>从而保证每个结点内关键字不会太少，树不会很高，查找的层数不会很多，从而保证查找效率</p>\n</li>\n<li><p>如果整个树只有1个元素，根结点就只有两个分叉</p>\n</li>\n</ul>\n</li>\n<li><p>规定：B树是所有结点的平衡因子均等于0（对于任何一个结点，其所有子树的高度都要相同）的多路平衡查找树</p>\n<ul>\n<li>从而保证这个树是平衡的，保证查找效率</li>\n</ul>\n</li>\n<li><p>所有的叶结点都出现在同一层次上，并且不带信息（实际上这些结点不存在，指向这些结点的指针为空）</p>\n<ul>\n<li>绝对平衡导致的结果</li>\n</ul>\n</li>\n<li><p>每个结点内关键字的值：递增，且关键字左侧指针的关键字&lt;关键字&lt;关键字左侧指针的关键字</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li>结点定义</li>\n</ul>\n</li>\n<li><p>推导性质</p>\n<ul>\n<li><p>结点的孩子个数等于该结点中关键字个数加1</p>\n</li>\n<li><p>如果根结点没有关键字就没有子树此时B树为空</p>\n</li>\n<li><p>如果根结点有关键字，则其子树必然大于等于两棵，因为子树个数等于关键字个数加1</p>\n</li>\n<li><p>结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字</p>\n</li>\n</ul>\n</li>\n<li><p>B树的高度（磁盘存取次数）</p>\n<ul>\n<li><p>最小高度：</p>\n<ul>\n<li><p>n&lt;&#x3D;(m-1)(1+m+m^2+……+m^(h-1))，m-1为每个结点的关键字，第一层1个结点，第二次m个结点，……</p>\n</li>\n<li><p>h&gt;&#x3D;log_m(n+1)</p>\n</li>\n<li><p>结论：对任意一棵包含n个关键字、高度为h、阶数为m的B树<img src=\"https://api2.mubu.com/v3/document_image/f6aaafc1-823f-48d2-8eeb-7d8ab5ca53e8-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>最大高度：让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大</p>\n<ul>\n<li><p>n个关键字的B树必有n+1个叶子结点（n个关键字将整个区间切分为n+1个区间，也就是叶子结点）</p>\n</li>\n<li><p>第一层至少1个结点，第二层至少有2个结点，第三层至少有2【m&#x2F;2】向上取整，第h层有2(【m&#x2F;2】向上取整)^(h-2)，第h+1层（失败结点个数）有2(【m&#x2F;2】向上取整)^(h-1)个</p>\n</li>\n<li><p>n+1&gt;&#x3D;2(【m&#x2F;2】向上取整)^(h-1)，即h&lt;&#x3D;log_(【m&#x2F;2】向上取整)((n+1)&#x2F;2)+1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>B树的查找</p>\n<ul>\n<li><p>在B树上查找到某个结点后，先在有序表中进行查找</p>\n</li>\n<li><p>若找到则直找成功，否则按照对应的指针信息到所指的子树中去查找</p>\n</li>\n<li><p>查找到叶结点时（对应指针为空指针） ，则说明树中没有对应的关键字，直找失败</p>\n</li>\n</ul>\n</li>\n<li><p>B树的插入</p>\n<ul>\n<li><p>定位：利用前述的B树查找算法找出插入该关键字的最低层中的某个非叶结点（注意插入位置一定是最低层中的某个非叶结点）</p>\n</li>\n<li><p>插入：在B树中，每个非失败结点的关键字个数都在区间<img src=\"https://api2.mubu.com/v3/document_image/3b2075f1-356c-4ad8-a74e-64557bba4953-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>插入后的结点关键字个数小于m可以直接插入插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于m-1时，必须对结点进行分裂</p>\n<ul>\n<li><p>从中间位置（【m&#x2F;2】向上取整）将关键字分为两部分，左侧部分存在原结点中，【m&#x2F;2】向上取整的结点插入到原结点的父结点（指向该结点指针所对应的位置），右侧部分放入新结点中与原结点成为兄弟（整个过程只增加了一个结点）</p>\n</li>\n<li><p>若父结点的关键字也超高了上限，则父结点继续进行分裂</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>B树的删除</p>\n<ul>\n<li><p>终端结点的删除</p>\n<ul>\n<li><p>直接删除关键字：若被删除关键字所在结点的关键字个数为   ，说明该结点为终端结点，表明删除该关键字后仍满足B树的定义，则直接删去该关键字<img src=\"https://api2.mubu.com/v3/document_image/05efead1-169c-4816-84f2-54b8afd0ca63-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>删除结点后，结点内关键字数低于（【m&#x2F;2】向上取整-1）</p>\n<ul>\n<li><p>兄弟够借：若被删除关键字所在结点删除前的关键字个数为    ，且与此结点相邻的右（成左）兄弟结点的关键字个数为   ，则需要调整该结点的右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡</p>\n<ul>\n<li><p>右兄弟宽裕时，当前结点的后继和后继的后继填补空缺</p>\n<ul>\n<li>当前结点的后继（该关键字存放在父结点中）存放到该结点中，当前结点的后继的后继（该关键字存放在兄弟结点中）存放在父结点中</li>\n</ul>\n</li>\n<li><p>左兄弟宽裕时，当前结点的前驱和前驱的前驱填补空缺</p>\n</li>\n</ul>\n</li>\n<li><p>兄弟不够借：若被删除关键字所在结点删除前的关键字个数    ，且此时与该结点相邻的左、右兄弟结点的关键字个数均     ，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</p>\n<ul>\n<li><p>该结点，与指向该结点指针和指向不够借的兄弟结点指针之间的双亲结点的关键字，与该结点的兄弟结点进行合并</p>\n</li>\n<li><p>若双亲结点也低于（【m&#x2F;2】向上取整-1），则重复操作，若根结点关键字个数减少到0，则直接删除根结点</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>对非终端结点的删除转化为对终端结点的删除：若被删除关键字在非终端结点，则用直接前驱或直接后继来替代被删除的关键字</p>\n<ul>\n<li><p>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</p>\n</li>\n<li><p>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"B-树的基本概念\"><a href=\"#B-树的基本概念\" class=\"headerlink\" title=\"B+树的基本概念\"></a>B+树的基本概念</h2><ul>\n<li><p>与分块查找区别</p>\n<ul>\n<li>索引表中保存每个分块的最大关键字和分块的存储区间</li>\n</ul>\n</li>\n<li><p>特性</p>\n<ul>\n<li><p>每个分支结点最多有m棵子树（孩子结点）</p>\n</li>\n<li><p>非叶根结点（根结点不是叶子）至少有两棵子树（保证平衡），其他每个分支结点至少有    棵子树<img src=\"https://api2.mubu.com/v3/document_image/d5426ede-20a7-484b-9160-f62fd8e8228a-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>结点的子树个数与关键字个数相等</p>\n</li>\n<li><p>所有叶子结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来（B+树支持顺序查找）</p>\n</li>\n<li><p>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针</p>\n</li>\n</ul>\n</li>\n<li><p>查找</p>\n<ul>\n<li><p>B+树中，无论查找成功还是失败，最终一定要走到最下层结点</p>\n</li>\n<li><p>必须找到叶子结点，叶子结点中该关键字的指针才指向该关键字的相关信息</p>\n</li>\n<li><p>B+树还可以根据p指针进行顺序查找</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"M阶的B-树与M阶的B树的主要差异\"><a href=\"#M阶的B-树与M阶的B树的主要差异\" class=\"headerlink\" title=\"M阶的B+树与M阶的B树的主要差异\"></a>M阶的B+树与M阶的B树的主要差异</h2><ul>\n<li><p>在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树，而在B树中且有n个关键字的结点含有n+1棵子树</p>\n</li>\n<li><p>在B+树中，每个结点（非根内部结点）的关键字个数n的范围是：    （根结点：1&lt;&#x3D;n&lt;&#x3D;m，其他结点关：【m&#x2F;2】向上取整  &lt;&#x3D;  n  &lt;&#x3D;  m）；在B树中，每个结点（非根内部结点）的关键字个数n的范围是    （根结点：1&lt;&#x3D;n&lt;&#x3D;m-1，其他结点：【m&#x2F;2】向上取整-1  &lt;&#x3D;  n  &lt;&#x3D;  m-1）</p>\n</li>\n<li><p>在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中叶结点包含的关键字和其他结点包含的关键字是不重复的</p>\n</li>\n<li><p>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址；B树结点中包含关键字对应记录的存储地址</p>\n</li>\n<li><p>B+树中，非叶结点不包含该关键字对应记录的存储地址，使得一个结点所需要的空间更少</p>\n<ul>\n<li>对B+树和B树的查找，每查找一个结点都需要读一次磁盘，直到找到叶子结点，读磁盘的速度很慢，所以B树和B+树都尽可能的使树更矮，每个结点尽可能包含更多的关键字信息</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"散列表（用空间换时间）\"><a href=\"#散列表（用空间换时间）\" class=\"headerlink\" title=\"散列表（用空间换时间）\"></a>散列表（用空间换时间）</h1><h2 id=\"散列表的基本概念\"><a href=\"#散列表的基本概念\" class=\"headerlink\" title=\"散列表的基本概念\"></a>散列表的基本概念</h2><ul>\n<li><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key )&#x3D;Addr</p>\n</li>\n<li><p>冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址（这两个关键字为同义词）</p>\n</li>\n<li><p>散列表：根据关键字而直接进行访问的数据结构</p>\n</li>\n<li><p>对散列表进行查找的时间复杂度为0（1）</p>\n</li>\n</ul>\n<h2 id=\"散列函数的构造方法（目的：冲突更少）\"><a href=\"#散列函数的构造方法（目的：冲突更少）\" class=\"headerlink\" title=\"散列函数的构造方法（目的：冲突更少）\"></a>散列函数的构造方法（目的：冲突更少）</h2><ul>\n<li><p>注意</p>\n<ul>\n<li><p>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围</p>\n</li>\n<li><p>散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生</p>\n</li>\n<li><p>散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址</p>\n</li>\n</ul>\n</li>\n<li><p>散列函数</p>\n<ul>\n<li><p>除留余数法</p>\n<ul>\n<li><p>假定散列表表长为m，取一个不大于m但最接近或等于m（最大）的质数p，利用以下公式把关键字转换成散列地址</p>\n<ul>\n<li><p>质数：即素数，指除了1和本身，不能被其他自然数整除的数</p>\n</li>\n<li><p>p取质数时，发生冲突的可能性更小（关键字的散列地址分布更加均匀）</p>\n</li>\n</ul>\n</li>\n<li><p>散列函数为H(key)&#x3D;key%p</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>最简单、最常用的方法</p>\n</li>\n<li><p>关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>直接定址法</p>\n<ul>\n<li><p>直接取关键字的某个线性函数值为散列地址</p>\n</li>\n<li><p>散列函数为H(key)&#x3D;key或H(key)&#x3D;a*key +b</p>\n<ul>\n<li>a和b是常数</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>计算最简单，且不会产生冲突</p>\n</li>\n<li><p>适合关键字的分布基本连续的情况</p>\n</li>\n<li><p>若关键字分布不连续，空位较多，则会造成存储空间的浪费</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数字分析法</p>\n<ul>\n<li><p>设关键字是r进制数，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等</p>\n</li>\n<li><p>而在某些位上分布不均匀只有某几种数码经常出现此时应选取数码分布较为均匀的若干位作为散列地址</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>适合于已知的关键字集合</p>\n</li>\n<li><p>若更换了关键字，则需要重新构造新的散列函数</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>平方取中法</p>\n<ul>\n<li><p>取关键字的平方值的中间几位作为散列地址</p>\n<ul>\n<li>平方的前几位和后几位可能值与关键字的前几位和后几位相关，平方的中间部分与关键字的整体相关</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>散列地址分布比较均匀</p>\n</li>\n<li><p>适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"处理冲突的方法\"><a href=\"#处理冲突的方法\" class=\"headerlink\" title=\"处理冲突的方法\"></a>处理冲突的方法</h2><ul>\n<li><p>开放定址法：可存放新表项的空闲地址既向同义词表项开放，也向非同义词表项开放</p>\n<ul>\n<li><p>数学递推公式</p>\n<ul>\n<li><p>Hi&#x3D; (H(key) +di) %m</p>\n</li>\n<li><p>H（key）为散列函数</p>\n</li>\n<li><p>m表示散列表表长；di为增量序列（i指的是该元素发生第i次冲突）</p>\n</li>\n</ul>\n</li>\n<li><p>增量的取值方法</p>\n<ul>\n<li><p>线性探测法</p>\n<ul>\n<li><p>d&#x3D;0,1,2…,m-1</p>\n</li>\n<li><p>当出现冲突时，就会顺序的向下一个单元探测，直到单元没有发生冲突</p>\n</li>\n<li><p>查找操作</p>\n<ul>\n<li><p>发生冲突时，既要检查同义词，也要检查非同义词</p>\n</li>\n<li><p>空位置的判断也要算作一次比较</p>\n</li>\n<li><p>越早遇到空位置，就可以越早确认查找失败</p>\n</li>\n</ul>\n</li>\n<li><p>删除操作</p>\n<ul>\n<li><p>问题：又可能之前的删除操作操作产生空位置</p>\n</li>\n<li><p>采用“开放定址法”时，删除结点不能简单地将被删除结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径，可以做一个“删除标记”，进行逻辑删除</p>\n</li>\n</ul>\n</li>\n<li><p>查找效率分析（ASL）</p>\n<ul>\n<li><p>ASL成功 &#x3D;（每个数据元素对比次数的累加）&#x2F;（数据元素个数）</p>\n</li>\n<li><p>ASL失败 &#x3D; （从每个位置探测到空位置的次数累加）&#x2F;（初次探测的地址数），因为此时的空位置就是没有放置过元素（无删除标记）</p>\n</li>\n</ul>\n</li>\n<li><p>优点：简单，容易实现</p>\n</li>\n<li><p>缺点：会出现聚集现象，降低查找效率</p>\n<ul>\n<li>冲突后再探测，一定是放在某个连续的位置</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>平方探测法</p>\n<ul>\n<li><p>di&#x3D;0^2, 1^2,-1^2,2^2,-2^2,…… ,k^2,-k^2</p>\n</li>\n<li><p>当在m位置发生冲突时，先探测m+1，再探测m-1，再探测m+4，再探测m-4，再探测m+9，再探测m-9</p>\n</li>\n<li><p>优点：可以避免出现”堆积“问题</p>\n<ul>\n<li>相对于线性探测法的改进</li>\n</ul>\n</li>\n<li><p>缺点：不能探测到散列表上的所有单元，但至少能探测到一半单元</p>\n<ul>\n<li>散列表长度m必须是可以表示为4j+3的素数（质数），才能探测到所有位置</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>伪随机序列法</p>\n<ul>\n<li>di&#x3D;伪随机数序列时，称为伪随机序列法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>再散列法</p>\n<ul>\n<li><p>当通过第一个散列函数H（key ）得到的地址发生冲突时，则利用第二个散列函数Hash(key)计算该关键字的地址增量，直到不冲突为止</p>\n</li>\n<li><p>计算公式式Hi&#x3D;RH(key)</p>\n</li>\n</ul>\n</li>\n<li><p>拉链法（链地址法）</p>\n<ul>\n<li><p>把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识</p>\n</li>\n<li><p>所有同义词就像被拉链串在一起一样</p>\n</li>\n<li><p>空位置的判断不算作一次比较，拉链法的散列表是索引（指针），不存放具体的元素</p>\n</li>\n<li><p>优化：在插入新元素时，保持关键字有序</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"散列查找及性能分析\"><a href=\"#散列查找及性能分析\" class=\"headerlink\" title=\"散列查找及性能分析\"></a>散列查找及性能分析</h2><ul>\n<li><p>实现过程</p>\n<ul>\n<li><p>①检测查找表中地址为Addr的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与key的值，若相等，则返回查找成功标志，否则执行步骤2</p>\n</li>\n<li><p>②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤1</p>\n</li>\n</ul>\n</li>\n<li><p>查找长度</p>\n<ul>\n<li><p>如果检测到查找表中地址为Addr的位置无记录，此时查找长度&#x3D;0（没有对比关键字）</p>\n<ul>\n<li>查找长度：在查找运算中，需要对比关键字的次数</li>\n</ul>\n</li>\n<li><p>如果检测到查找表中地址为Addr的位置并对比了n次关键字均不是目标关键字，此时查找长度&#x3D;n</p>\n</li>\n<li><p>平均查找长度：</p>\n<ul>\n<li><p>ASL成功&#x3D;(结点个数与所在层数进行累加)&#x2F;结点数</p>\n</li>\n<li><p>ASL值&gt;&#x3D;1，ASL越小，查找成功的效率越高</p>\n</li>\n<li><p>最理想的效果：散列查找时间复杂度&#x3D;O(1)</p>\n</li>\n<li><p>ASL失败&#x3D;表中记录数n&#x2F;散列表长度m&#x3D;a（装填因子）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>平均查找长度作为衡量散列表的查找效率的度量</p>\n</li>\n<li><p>散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子</p>\n</li>\n<li><p>装填因子</p>\n<ul>\n<li><p>a&#x3D;表中记录数n&#x2F;散列表长度m</p>\n</li>\n<li><p>装填因子会直接影响散列表的查找效率，装填因子越大越容易发生冲突</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","3.数据结构","7.查找"],"tags":["写作"]},{"title":"计算机网络体系结构","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"<h1 id=\"计算机网络概述\"><a href=\"#计算机网络概述\" class=\"headerlink\" title=\"计算机网络概述\"></a>计算机网络概述</h1><h2 id=\"计算机网络基本概念\"><a href=\"#计算机网络基本概念\" class=\"headerlink\" title=\"计算机网络基本概念\"></a>计算机网络基本概念</h2><ul>\n<li><p>广义观点：实现远程信息处理的系统或者能进一步达到资源共享的系统</p>\n</li>\n<li><p>资源共享观点</p>\n<ul>\n<li><p>以能够相互共享资源的方式互联起来的自治计算机系统的集合</p>\n</li>\n<li><p>目的：资源共享</p>\n</li>\n<li><p>组成单元：分布在不同地理位置的多台独立的“自治计算机”</p>\n</li>\n<li><p>网络协议：网络中计算机必须遵循的统一规则</p>\n</li>\n</ul>\n</li>\n<li><p>用户透明性观点：能为用户自动管理资源的网络操作系统，能够调用用户所需要的资源，整个网络就像一个大的计算机系统一样对用户是透明的</p>\n</li>\n</ul>\n<h2 id=\"计算机网络的组成\"><a href=\"#计算机网络的组成\" class=\"headerlink\" title=\"计算机网络的组成\"></a>计算机网络的组成</h2><ul>\n<li><p>组成部分角度</p>\n<ul>\n<li><p>硬件：主机（端系统）、通信链路（双绞线、光纤）、交换设备（路由器、交换机）以及通信处理机（网卡等）</p>\n</li>\n<li><p>软件：实现资源共享的软件以及方便用户使用的各种工具软件（网络操作系统、邮收发程序、FTP程序、聊天程序）</p>\n</li>\n<li><p>协议：计算机网络的核心，规定了网络传输数据遵循的规定</p>\n</li>\n</ul>\n</li>\n<li><p>工作角度</p>\n<ul>\n<li><p>边缘部分：所有连接到因特网上、供用户直接使用的主机组成，用来进行通信（传输数据、音频或者视频和资源共享）</p>\n<ul>\n<li><p>用户直接使用</p>\n<ul>\n<li><p>C&#x2F;S方式</p>\n</li>\n<li><p>P2P方式</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>核心部分：大量的网络和连接这些网络的路由器组成，为边缘部分提供连通性和交换服务</p>\n</li>\n</ul>\n</li>\n<li><p>功能组成角度</p>\n<ul>\n<li><p>通信子网：传输介质，通信设备，相应的网络协议</p>\n<ul>\n<li>使得网络具有数据传输，交换，控制和存储的能力，实现联网计算机之间的数据通信</li>\n</ul>\n</li>\n<li><p>资源子网：实现资源共享功能以及软件的集合，向网络用户提供共享其他计算机硬件、软件和数据的服务</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>计算机网络的功能</p>\n<ul>\n<li><p>数据通信：最基本最重要的功能，实现联网计算机之间的信息传输，将分散的计算机联系起来</p>\n</li>\n<li><p>资源共享：实现软件、硬件、数据的共享，使得计算机网络中的资源互通有无，分工协作，提高硬件、软件和数据资源的利用率</p>\n</li>\n<li><p>分布式处理：将某个计算机负载过重的任务分散到多台计算机上，提高整个系统的利用率</p>\n</li>\n<li><p>提高可靠性：各台计算机可以通过网络互为替代机</p>\n</li>\n<li><p>负载均衡：将工作任务均衡的分配给计算机网络中的各台计算机</p>\n</li>\n</ul>\n<h2 id=\"计算机网络的分类\"><a href=\"#计算机网络的分类\" class=\"headerlink\" title=\"计算机网络的分类\"></a>计算机网络的分类</h2><ul>\n<li><p>分布范围分类</p>\n<ul>\n<li><p>广域网</p>\n<ul>\n<li><p>范围：提供长距离通信，运送主机发送的数据广域网</p>\n</li>\n<li><p>距离：几十千米到几千千米</p>\n</li>\n<li><p>地位：广域网是因特网的核心部分，连接广域网的各节点交换机的链路一般是高速链路，具有较大的通信容量</p>\n</li>\n<li><p>采用交换技术</p>\n</li>\n</ul>\n</li>\n<li><p>城域网</p>\n<ul>\n<li><p>范围：跨越几个街区甚至几个城市</p>\n</li>\n<li><p>距离： 5—50km</p>\n</li>\n<li><p>地位：多采用以太网技术</p>\n</li>\n</ul>\n</li>\n<li><p>局域网</p>\n<ul>\n<li><p>范围：微机或者工作站通过高速线路相连，覆盖范围小</p>\n</li>\n<li><p>距离：几十米到几干米</p>\n</li>\n<li><p>地位：对计算机配置数量没有太多限制，采用广播技术</p>\n</li>\n</ul>\n</li>\n<li><p>个人区域网</p>\n<ul>\n<li><p>范围：个人工作的地方将电子设备用无线技术链接起来的网络</p>\n</li>\n<li><p>距离：区域直径为10m</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>传输技术分类</p>\n<ul>\n<li><p>广播式网络</p>\n<ul>\n<li><p>所有联网计算机共享一个公共通信信道</p>\n</li>\n<li><p>一台计算机发送报文分组，其他计算机也能收听这个分组（根据报文目的地址进行接收）</p>\n</li>\n<li><p>采用广播通信技术</p>\n<ul>\n<li>广域网中的无线，卫星通信网络也采用广播式通信技术</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>点对点网络</p>\n<ul>\n<li><p>计算机通过直接或者中间结点对分组进行接收，存储和转发直到目的地</p>\n</li>\n<li><p>采用分组存储转发机制</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>按照拓扑结构分类</p>\n<ul>\n<li><p>星型网络</p>\n<ul>\n<li><p>每个终端或者计算机都以单独的线路与中央设备相连</p>\n</li>\n<li><p>优点：便于集中控制和管理</p>\n</li>\n<li><p>缺点：成本高，中心节点对故障敏感</p>\n</li>\n</ul>\n</li>\n<li><p>总线型网络</p>\n<ul>\n<li><p>用单根传输线把计算机连接起来</p>\n</li>\n<li><p>优点：建网容易，增减节点方便，节省线路</p>\n</li>\n<li><p>缺点:重负载时通信效率不高,总线任意处对故障敏感</p>\n</li>\n</ul>\n</li>\n<li><p>环型网络</p>\n<ul>\n<li><p>所有计算机接口设备连接成一个环</p>\n</li>\n<li><p>典型：令牌环局域网</p>\n</li>\n</ul>\n</li>\n<li><p>网状型网络</p>\n<ul>\n<li><p>每个结点至少有两条链路与其他节点相连，形成一个网状结构</p>\n</li>\n<li><p>优点：可靠性高</p>\n</li>\n<li><p>缺点：成本高、控制复杂</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>按照使用者分类</p>\n<ul>\n<li><p>公用网</p>\n<ul>\n<li>公众使用的网络</li>\n</ul>\n</li>\n<li><p>专用网</p>\n<ul>\n<li>为满足某个部门特殊业务建立的网络（军队，电力，铁路）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>按照传输介质分类</p>\n<ul>\n<li><p>有线网络</p>\n<ul>\n<li>双绞线网络、同轴电缆网络</li>\n</ul>\n</li>\n<li><p>无线网络</p>\n<ul>\n<li>蓝牙、微波、无线电</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"计算机网络的标准化工作及相关组织\"><a href=\"#计算机网络的标准化工作及相关组织\" class=\"headerlink\" title=\"计算机网络的标准化工作及相关组织\"></a>计算机网络的标准化工作及相关组织</h2><ul>\n<li><p>生成RFC的过程</p>\n<ul>\n<li>因特网草案、建议标准、草案标准、因特网标准</li>\n</ul>\n</li>\n<li><p>国际组织</p>\n<ul>\n<li><p>国际标准化组织（ISO） ： OSI参考模型、HDLC</p>\n</li>\n<li><p>国际电信联盟（ITU ） ：远程通信标准</p>\n</li>\n<li><p>国际电气电子工程师协会（IEEE） ： 802标准</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"计算机网络的性能指标\"><a href=\"#计算机网络的性能指标\" class=\"headerlink\" title=\"计算机网络的性能指标\"></a>计算机网络的性能指标</h2><ul>\n<li><p>带宽</p>\n<ul>\n<li>网络在通信线路中传送该数据的能力，单位：比特&#x2F;每秒</li>\n</ul>\n</li>\n<li><p>时延</p>\n<ul>\n<li><p>数据从网络的一端传送到另一端所需要的总时间</p>\n</li>\n<li><p>发送时延</p>\n<ul>\n<li><p>发送分组的第一个比特开始，到最后也一个比特发送结束的时间</p>\n</li>\n<li><p>发送时延&#x3D;分组长度&#x2F;信道带宽</p>\n</li>\n</ul>\n</li>\n<li><p>传播时延</p>\n<ul>\n<li><p>一个比特从链路一端到另一端需要的时间</p>\n</li>\n<li><p>传播时延&#x3D;信道长度&#x2F;电磁波在信道上的传播速率</p>\n</li>\n</ul>\n</li>\n<li><p>处理时延</p>\n<ul>\n<li><p>数据在交换结点为存储转发而进行的一些必要的处理所花费的时间</p>\n</li>\n<li><p>如：分析分组的首部，从分组中提取数据部分，差错检验，寻找适当的路由器排队时延</p>\n</li>\n</ul>\n</li>\n<li><p>排队时延</p>\n<ul>\n<li>分组在进入路由器后，像排队一样等待被转发的时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>时延带宽积</p>\n<ul>\n<li><p>发送端连续发送数据且发送的第一个比特即将到达终点时，发送端已将发出的比特数</p>\n</li>\n<li><p>时延带宽积&#x3D;传播时延*信道带宽</p>\n</li>\n</ul>\n</li>\n<li><p>往返时延</p>\n<ul>\n<li>从发送数据到接收到接收端的确认，经历的时延</li>\n</ul>\n</li>\n<li><p>吞吐量</p>\n<ul>\n<li><p>单位时间内通过某个网络的数据量</p>\n</li>\n<li><p>受到网络带宽或者网络额定速率的限制</p>\n</li>\n</ul>\n</li>\n<li><p>速率</p>\n<ul>\n<li>连接到计算机网络上主机在数字信道上传送数据的速率（数据率或者比特率） ，最高的数据率即为带宽</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"计算机网络体系结构与参考模型\"><a href=\"#计算机网络体系结构与参考模型\" class=\"headerlink\" title=\"计算机网络体系结构与参考模型\"></a>计算机网络体系结构与参考模型</h1><h2 id=\"网络分层\"><a href=\"#网络分层\" class=\"headerlink\" title=\"网络分层\"></a>网络分层</h2><ul>\n<li><p>原则</p>\n<ul>\n<li><p>每层实现一种相对独立的功能，降低系统的复杂度</p>\n</li>\n<li><p>各层之间界面清晰，易于理解，相互交流少</p>\n</li>\n<li><p>各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现</p>\n</li>\n<li><p>保持下层对上层的独立性，上层单向使用下层提供的服务</p>\n</li>\n<li><p>整个分层结构应能促进标准化工作</p>\n</li>\n</ul>\n</li>\n<li><p>基本概念</p>\n<ul>\n<li><p>实体：任何可以发送或者接受信息的硬件或者软件进程</p>\n</li>\n<li><p>不同机器上的同一层称为对等层，同一层的实体称为对等实体</p>\n</li>\n<li><p>n层实体实现的服务为n+1层所利用</p>\n</li>\n<li><p>服务数据单元（ SDU）：完成用户所要求的的功能而传送的数据，第n层为n-SDU</p>\n</li>\n<li><p>协议控制信息（PCI ）：控制层协议操作的信息 n-PCI</p>\n</li>\n<li><p>协议数据单元（ PDU ） ：对等层次之间传送的数据单元称为该层的PDU，n-PDU</p>\n</li>\n</ul>\n</li>\n<li><p>层次结构含义</p>\n<ul>\n<li><p>第N层的实体不仅要使用第N-1层的服务来实现自身定义的功能，还要想第N+1层提供本层的服务，该服务是第N层及下面各层提供的服务总和</p>\n</li>\n<li><p>最底层只提供服务，使整个层次结构的基础，中间各层既是下一层的服务使用者，又是上一层的服务提供者，最高层面向用户提供服务</p>\n</li>\n<li><p>上一层只能通过邻近层的接口使用下一层的服务，而不能调用其他层的服务，下一层所提供的服务的实现细节对上一层透明</p>\n</li>\n<li><p>两台主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"计算机网络协议、接口、服务的概念\"><a href=\"#计算机网络协议、接口、服务的概念\" class=\"headerlink\" title=\"计算机网络协议、接口、服务的概念\"></a>计算机网络协议、接口、服务的概念</h2><ul>\n<li><p>协议</p>\n<ul>\n<li><p>控制两个或者多个对等实体进行通信的规则集合，是水平的</p>\n</li>\n<li><p>不对等实体之间是没有协议的</p>\n</li>\n<li><p>组成</p>\n<ul>\n<li><p>语法：规定了传输数据的格式</p>\n</li>\n<li><p>语义：规定了要完成的功能</p>\n</li>\n<li><p>同步：规定了执行各种操作的条件、时序关系</p>\n</li>\n</ul>\n</li>\n<li><p>协议是水平的，是控制对等实体之间通信的规则</p>\n</li>\n</ul>\n</li>\n<li><p>接口</p>\n<ul>\n<li><p>同一节点内相邻两层间交换信息的连接点，是一个系统内部的规定</p>\n</li>\n<li><p>接口每层只能为紧邻的层次之间定义接口，不能跨层定义接口</p>\n</li>\n</ul>\n</li>\n<li><p>服务</p>\n<ul>\n<li><p>下层为紧邻的上层提供的功能调用，是垂直的</p>\n</li>\n<li><p>服务原语</p>\n<ul>\n<li><p>由服务用户发往服务提供者，请求完成某项任务</p>\n</li>\n<li><p>由服务提供者发往服务用户，指示用户做某件事情</p>\n</li>\n<li><p>由服务用户发往服务提供者，作为对指示的响应</p>\n</li>\n<li><p>证实：由服务提供者发往服务用户，作为请求的证实</p>\n</li>\n</ul>\n</li>\n<li><p>只有本层的协议的实现才能保证向上一层提供服务，本层的服务用户只能看见服务，而无法看见下面的协议</p>\n</li>\n</ul>\n</li>\n<li><p>服务的分类</p>\n<ul>\n<li><p>面向连接服务和无连接服务</p>\n<ul>\n<li><p>面向连接服务</p>\n<ul>\n<li><p>通信双方必须建立连接，分配相应资源，结束后释放连接与资源（可靠服务）</p>\n</li>\n<li><p>阶段</p>\n<ul>\n<li><p>连接建立</p>\n</li>\n<li><p>数据传输</p>\n</li>\n<li><p>连接释放</p>\n</li>\n</ul>\n</li>\n<li><p>代表协议： TCP协议</p>\n</li>\n</ul>\n</li>\n<li><p>无连接服务</p>\n<ul>\n<li><p>通信双方不需要建立连接，直接发送数据（不可靠服务）</p>\n</li>\n<li><p>尽最大努力交付（IP协议UDP协议）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>可靠服务和不可靠服务</p>\n<ul>\n<li><p>可靠服务</p>\n<ul>\n<li>网络具有纠错，检错，应答机制，保证数据正确可靠的传送到目的地</li>\n</ul>\n</li>\n<li><p>不可靠服务</p>\n<ul>\n<li><p>网络尽可能正确，可靠的传送，不能保证数据的正确，可靠的传送到目的地</p>\n</li>\n<li><p>可靠性由应用或者用户来保障</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>有应答服务和无应答服务</p>\n<ul>\n<li><p>有应答服务</p>\n<ul>\n<li>接收方在收到数据后向发送方发出相应的应答，传输系统自动实现</li>\n</ul>\n</li>\n<li><p>无应等服务</p>\n<ul>\n<li>接收方受到数据后不会自动给出应答，如果需要应答就由高层实现</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"OSI参考模型\"><a href=\"#OSI参考模型\" class=\"headerlink\" title=\"OSI参考模型\"></a>OSI参考模型</h2><ul>\n<li><p>目的：支持异构网络系统的互联互通</p>\n</li>\n<li><p>资源子网</p>\n<ul>\n<li><p>应用层</p>\n</li>\n<li><p>表示层</p>\n</li>\n<li><p>会话层</p>\n</li>\n</ul>\n</li>\n<li><p>承上启下</p>\n<ul>\n<li>传输层</li>\n</ul>\n</li>\n<li><p>通信子网</p>\n<ul>\n<li><p>网络层</p>\n</li>\n<li><p>数据链路层</p>\n</li>\n<li><p>物理层</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"物理层\"><a href=\"#物理层\" class=\"headerlink\" title=\"物理层\"></a>物理层</h2><ul>\n<li><p>传输单位：比特流</p>\n</li>\n<li><p>任务：透明传输的比特流</p>\n</li>\n<li><p>功能：物理媒体上为数据端设备透明的传输原始比特流</p>\n</li>\n<li><p>定义数据终端设备和数据通信设备的物理与逻辑连接方法</p>\n<ul>\n<li>接口的机械形状和尺寸，交换电路的数量和排列</li>\n</ul>\n</li>\n<li><p>接口协议</p>\n<ul>\n<li>EIA—232C， EIA&#x2F;TIA、RS-449， CCITT的X2.1等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数据链路层\"><a href=\"#数据链路层\" class=\"headerlink\" title=\"数据链路层\"></a>数据链路层</h2><ul>\n<li><p>传输单位：帧</p>\n</li>\n<li><p>任务：将网络层传来的IP数据报组装成帧</p>\n</li>\n<li><p>功能：成帧、差错控制、流量控制、传输管理</p>\n<ul>\n<li><p>差错控制：对传输中受到干扰的信号进行检错，并对其丢弃</p>\n</li>\n<li><p>流量控制：控制发送方的速度</p>\n</li>\n</ul>\n</li>\n<li><p>介质访问子层控制共享信道的访问</p>\n</li>\n<li><p>典型协议： SDLC、HDLC、PPP、STP、帧中继</p>\n</li>\n</ul>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><ul>\n<li><p>传输单位：数据报</p>\n</li>\n<li><p>任务：把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务</p>\n</li>\n<li><p>功能：流量控制、拥塞控制、差错控制、网际互联</p>\n<ul>\n<li><p>拥塞控制：对网络中因为来不及接收导致大量丢失的情况，网络层采取一定的措施对拥塞进行缓解</p>\n</li>\n<li><p>网际互联：将大量异构网络通过路由器相互连接起来</p>\n</li>\n</ul>\n</li>\n<li><p>典型协议: IP、IPX、ICMP、ARP、RARP、OSPF</p>\n</li>\n</ul>\n<h2 id=\"传输层（作为资源子网与通信子网的桥梁）\"><a href=\"#传输层（作为资源子网与通信子网的桥梁）\" class=\"headerlink\" title=\"传输层（作为资源子网与通信子网的桥梁）\"></a>传输层（作为资源子网与通信子网的桥梁）</h2><ul>\n<li><p>传输单位：报文段（TCP ）或者用户数据报（UDP）</p>\n</li>\n<li><p>任务：主机之间两个进程的相互通信</p>\n</li>\n<li><p>功能：端到端传输、流量控制、差错控制、服务质量、数据传输管理等服务</p>\n</li>\n<li><p>典型协议： TCP、UDP</p>\n</li>\n</ul>\n<h2 id=\"会话层\"><a href=\"#会话层\" class=\"headerlink\" title=\"会话层\"></a>会话层</h2><ul>\n<li><p>任务：允许不同主机上的各个进程之间进行通话</p>\n</li>\n<li><p>功能：建立会话同步、管理主机间的会话进程（建立、管理及终止）</p>\n</li>\n<li><p>使用校验点恢复通信，实现数据同步</p>\n</li>\n</ul>\n<h2 id=\"表示层\"><a href=\"#表示层\" class=\"headerlink\" title=\"表示层\"></a>表示层</h2><ul>\n<li><p>任务：处理两个通信系统中交换信息的表示方式</p>\n</li>\n<li><p>功能：数据压缩加密和解密数据表示变换</p>\n</li>\n</ul>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><ul>\n<li><p>任务：用户与网络的界面，为特定类型的网络应用提供访问OSI环境的手段</p>\n</li>\n<li><p>典型协议： FTP、SMTP、HTTP</p>\n</li>\n</ul>\n<h2 id=\"TCP-x2F-IP类型\"><a href=\"#TCP-x2F-IP类型\" class=\"headerlink\" title=\"TCP&#x2F;IP类型\"></a>TCP&#x2F;IP类型</h2><ul>\n<li><p>应用层</p>\n<ul>\n<li><p>对应OSI的会话层、表示层和应用层</p>\n</li>\n<li><p>包含所有高层协议（ Telnet、FTP、DNS、SMTP、HTTP）</p>\n</li>\n</ul>\n</li>\n<li><p>传输层</p>\n<ul>\n<li><p>对应OSI的传输层</p>\n</li>\n<li><p>实现发送端和目的端主机上的对等实体进行会话</p>\n</li>\n<li><p>传输控制协议（TCP）</p>\n<ul>\n<li><p>面向连接（可靠交付）</p>\n</li>\n<li><p>数据传输的基本单位是报文段</p>\n</li>\n</ul>\n</li>\n<li><p>用户数据报协议（ UDP）</p>\n<ul>\n<li><p>无连接的（不可靠交付）</p>\n</li>\n<li><p>传输基本单位是用户数据报（尽最大努力交付）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>网际层</p>\n<ul>\n<li><p>对应OSI的网络层</p>\n</li>\n<li><p>将分组发送到任何网络上，选择合适的路由</p>\n</li>\n<li><p>不能保证有序到达，有序交付交给高层负责</p>\n</li>\n<li><p>定义了IP协议：IPV4、IPV6</p>\n</li>\n</ul>\n</li>\n<li><p>网络接口层</p>\n<ul>\n<li><p>对应OSI的数据链路层和物理层</p>\n</li>\n<li><p>指出主机必须使用的某种协议与网络连接</p>\n</li>\n<li><p>作用：从主机或者结点接收IP分组，并把他们发送到指定的物理网络</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP-x2F-IP模型与OSI模型的对比\"><a href=\"#TCP-x2F-IP模型与OSI模型的对比\" class=\"headerlink\" title=\"TCP&#x2F;IP模型与OSI模型的对比\"></a>TCP&#x2F;IP模型与OSI模型的对比</h2><ul>\n<li><p>相同</p>\n<ul>\n<li><p>都采用分层结构</p>\n</li>\n<li><p>都是基于独立的协议栈的概念</p>\n</li>\n<li><p>都可以解决异构网络的互联，实现不同厂家的计算机的相互通信</p>\n</li>\n</ul>\n</li>\n<li><p>不同</p>\n<ul>\n<li><p>OSI精确的定义了服务、接口和协议</p>\n<ul>\n<li>TCP&#x2F;P没有明确区分</li>\n</ul>\n</li>\n<li><p>OS1通用性良好</p>\n<ul>\n<li>TCP&#x2F;IP协议是对已有协议的描述，但是不适用于其他非TCP&#x2F;IP的协议栈</li>\n</ul>\n</li>\n<li><p>OSI没有考虑多种异构网络的互联问题</p>\n</li>\n<li><p>网络层（网际层）</p>\n<ul>\n<li><p>OSI中支持无连接和面向连接</p>\n</li>\n<li><p>TCP&#x2F;IP只有无连接</p>\n</li>\n</ul>\n</li>\n<li><p>传输层</p>\n<ul>\n<li><p>OSI只支持面向连接的通信</p>\n</li>\n<li><p>TCP&#x2F;IP支持面向连接和无连接的通信</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"信息传输过程\"><a href=\"#信息传输过程\" class=\"headerlink\" title=\"信息传输过程\"></a>信息传输过程</h2><ul>\n<li><p>用户发送数据报</p>\n</li>\n<li><p>应用层：将自然语言转化为通信数据</p>\n</li>\n<li><p>然后开始每层都会加上SDU和PCI进行包裹包装</p>\n</li>\n<li><p>到达目的主机又会进行包裹拆包，将SDU和PCI—层层拆开最终获得数据</p>\n</li>\n</ul>\n","categories":["计算机408","4.计算机网络","1.计算机网络体系结构"],"tags":["写作"]},{"title":"排序","url":"/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8%E6%8E%92%E5%BA%8F/","content":"<h1 id=\"排序的定义\"><a href=\"#排序的定义\" class=\"headerlink\" title=\"排序的定义\"></a>排序的定义</h1><ul>\n<li><p>排序：就是重新排列表中的元素，使表中的元素满足按关键字有序的过程</p>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>根据数据是否在内存中进行分类</p>\n<ul>\n<li><p>内部排序：在排序期间元素全部存放在内存中的排序</p>\n<ul>\n<li>关注：时间复杂度、空间复杂度</li>\n</ul>\n</li>\n<li><p>外部排序：在排序期间元素无法全部同时存放在内存中</p>\n<ul>\n<li><p>必须在排序的过程中根据要求不断地在内、外存之间移动的排序</p>\n</li>\n<li><p>关注：时间复杂度、空间复杂度、读写磁盘次数</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>基本类型</p>\n<ul>\n<li><p>插入排序</p>\n</li>\n<li><p>交换排序</p>\n</li>\n<li><p>选择排序</p>\n</li>\n<li><p>归并排序</p>\n</li>\n<li><p>基数排序</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>排序算法的评价指标</p>\n<ul>\n<li><p>时间复杂度</p>\n</li>\n<li><p>空间复杂度</p>\n</li>\n<li><p>算法的稳定性（是否需要稳定，具体情况具体分析）</p>\n<ul>\n<li><p>稳定的</p>\n<ul>\n<li>关键字相同的元素在排序之后相对位置不变</li>\n</ul>\n</li>\n<li><p>不稳定的</p>\n<ul>\n<li>关键字相同的元素在排序之后相对位置改变</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li><p>基本思想</p>\n<ul>\n<li>每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成</li>\n</ul>\n</li>\n<li><p>引申出的算法</p>\n<ul>\n<li><p>直接插入排序</p>\n</li>\n<li><p>折半插入排序</p>\n</li>\n<li><p>希尔排序</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"直接插入排序\"><a href=\"#直接插入排序\" class=\"headerlink\" title=\"直接插入排序\"></a>直接插入排序</h2><ul>\n<li><p>实现过程</p>\n<ul>\n<li><p>将整个序列分为两部分</p>\n<ul>\n<li><p>有序序列</p>\n</li>\n<li><p>无序序列</p>\n</li>\n</ul>\n</li>\n<li><p>每次从无序序列中取出一个元素，然后在有序序列中遍历，寻找合适的位置将该元素插入有序序列中</p>\n</li>\n<li><p>自插入的位置开始有序序列向后移动一个元素位置</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>不带哨兵</p>\n</li>\n<li><p>带哨兵：不需要每轮循环都判断j&gt;&#x3D;0</p>\n</li>\n</ul>\n</li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间效率：空间复杂度为O(1)</p>\n</li>\n<li><p>时间效率</p>\n<ul>\n<li><p>来自：对比关键字、移动元素</p>\n</li>\n<li><p>最好情况</p>\n<ul>\n<li><p>表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素</p>\n</li>\n<li><p>时间复杂度为O(n)</p>\n<ul>\n<li>对于n-1个元素，每个元素进行1次对比</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>最坏情况</p>\n<ul>\n<li><p>表中元素顺序刚好与排序结果中的元素顺序相反（逆序）</p>\n</li>\n<li><p>时间复杂度为O(n^2)</p>\n<ul>\n<li><p>对于n-1个元素，第n-1趟，进行n次对比，n+1次移动</p>\n</li>\n<li><p>总的比较次数达到最大<img src=\"https://api2.mubu.com/v3/document_image/8d54f2b8-21d0-4287-b419-342123b3c8c8-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>总的移动次数也达到最大<img src=\"https://api2.mubu.com/v3/document_image/aad76bd8-adbe-4d2c-9f9c-c315f0db21a0-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>平均情况</p>\n<ul>\n<li>时间复杂度O(n^2)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>稳定的算法</p>\n</li>\n</ul>\n</li>\n<li><p>适用于顺序存储和链式存储</p>\n<ul>\n<li><p>采用链式存储时，时间复杂度：O(n^2)</p>\n<ul>\n<li><p>移动元素的次数是O(n)</p>\n</li>\n<li><p>关键字的对比次数是O(n^2)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"折半插入排序\"><a href=\"#折半插入排序\" class=\"headerlink\" title=\"折半插入排序\"></a>折半插入排序</h2><ul>\n<li><p>目的：更快找到插入的位置</p>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>首先确定折半插入排序的范围</p>\n</li>\n<li><p>然后对其进行类似于二分法定界的方式，不断缩小其范围</p>\n<ul>\n<li><p>low&#x3D;1，high&#x3D;i-1</p>\n</li>\n<li><p>当low&gt;high时，折半查找结束，将[low，i-1]内元素全部右移，并将A[0]复制到low所指的位置</p>\n</li>\n<li><p>当A[mid]&#x3D;&#x3D;A[0]时，为了保证算法的稳定性，应继续在mid所指范围右边寻找插入位置，即low&#x3D;mid+1</p>\n</li>\n</ul>\n</li>\n<li><p>最后对数据进行移动，对待排序算法进行插入</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n</li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间效率：空间复杂度为O(1)</p>\n</li>\n<li><p>时间效率</p>\n<ul>\n<li><p>时间复杂度：O(n^2)</p>\n</li>\n<li><p>比较次数：</p>\n<ul>\n<li><p>O(nlog_2(n))</p>\n</li>\n<li><p>该算法比较次数仅与表中元素个数有关</p>\n</li>\n</ul>\n</li>\n<li><p>移动次数：</p>\n<ul>\n<li>O(n)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>稳定的算法</p>\n</li>\n</ul>\n</li>\n<li><p>适用于顺序存储</p>\n</li>\n</ul>\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><ul>\n<li><p>实现思想：先追求表中的元素部分有序，再逐渐逼近全局有序</p>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>先将待排序表分割成若干形如L[i，i+d，i+2d，……，i+kd]的“特殊”子表，对各个子表分别进行直接插入排序。缩小增量d，重复上述过程，直到d&#x3D;1为止</p>\n</li>\n<li><p>每次排序定长都减小，然后对各个子表的元素中分别进行直接插入排序</p>\n</li>\n<li><p>步长逐渐减小，最后为1，最后一次相当于对整个表进行直接插入排序</p>\n<ul>\n<li>建议每次将增量减小一半</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>算法实现</p>\n</li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间效率：空间复杂度为0(1)</p>\n</li>\n<li><p>时间复杂度为O(n^2)</p>\n</li>\n<li><p>不稳定的算法</p>\n</li>\n</ul>\n</li>\n<li><p>适用于顺序存储</p>\n</li>\n</ul>\n<h1 id=\"交换排序\"><a href=\"#交换排序\" class=\"headerlink\" title=\"交换排序\"></a>交换排序</h1><h2 id=\"基本概述\"><a href=\"#基本概述\" class=\"headerlink\" title=\"基本概述\"></a>基本概述</h2><ul>\n<li><p>根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置</p>\n</li>\n<li><p>考试涉及范围</p>\n<ul>\n<li><p>冒泡排序</p>\n</li>\n<li><p>快速排序</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><ul>\n<li><p>基本思想</p>\n<ul>\n<li><p>从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即Ai—1]）&gt;A[j），则交换它们直到序列比较完</p>\n</li>\n<li><p>将最小的元素交换到待排序列的第一个位置（或将最大的元素交换到待排序列的最后一个位置）</p>\n</li>\n<li><p>进行下一趟冒泡时，前一趟确定的最小元素不再参与比较，每趟冒泡的结果是把序列中的最小元素（或最大元素）放到了序列的最终位置</p>\n</li>\n<li><p>如果某一趟排序过程中未发生“交换” ，则算法可提前结束</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>从后往前冒泡排序</p>\n</li>\n<li><p>交换</p>\n</li>\n<li><p>从前往后冒泡排序</p>\n</li>\n</ul>\n</li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间复杂度：O(1)</p>\n</li>\n<li><p>时间效率</p>\n<ul>\n<li><p>最好情况</p>\n<ul>\n<li>时间复杂度为O(n)<ul>\n<li>有序：比较次数n-1，交换次数0</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>最坏情况</p>\n<ul>\n<li>时间复杂度O(n^2)<ul>\n<li>逆序：比较次数n(n-1)&#x2F;2，交换次数&#x3D;比较次数，移动元素次数&#x3D;3*交换次数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>平均情况</p>\n</li>\n<li><p>时间复杂度为O(n^2)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>稳定算法</p>\n</li>\n<li><p>适用于顺序存储和链式存储</p>\n<ul>\n<li>从链头像链尾冒泡，每次将更大的元素“冒”到链尾</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><ul>\n<li><p>快速排序被认为是目前基于比较的内部排序方法中最好的方法</p>\n</li>\n<li><p>基本思想</p>\n<ul>\n<li><p>首先选取一个元素作为枢纽，然后以此枢轴为界分为两个部分，左面小于该枢轴值，右面大于该枢轴值</p>\n</li>\n<li><p>然后再对这两个部分分别递归的进行上述步骤</p>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>low：指向第一个元素，作为基准（枢轴）；high：指向最后一个元素</p>\n</li>\n<li><p>如果high所指元素&gt;基准，不处理；high向左移动</p>\n</li>\n<li><p>如果high所指元素&lt;基准，high所指元素移动到low所指位置，low指针向右移动</p>\n</li>\n<li><p>如果low所指元素&lt;基准，不处理；low向右移动</p>\n</li>\n<li><p>如果low所指元素&gt;基准，low所指元素移动到high所指位置，high指针向左移动</p>\n</li>\n<li><p>如果low&#x3D;high，基准元素移动到low和high所指的位置</p>\n</li>\n</ul>\n</li>\n<li><h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2></li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间复杂度</p>\n<ul>\n<li><p>最好情况：O(log_2(n))</p>\n<ul>\n<li>空间复杂度与递归层数有关</li>\n</ul>\n</li>\n<li><p>最坏情况：O(n)</p>\n</li>\n<li><p>平均情况：O(log_2(n))</p>\n</li>\n</ul>\n</li>\n<li><p>时间效率</p>\n<ul>\n<li><p>最好时间复杂度：O(n*log_2(n))</p>\n<ul>\n<li>时间复杂度与递归层数有关</li>\n</ul>\n</li>\n<li><p>最坏情况：O(n^2)</p>\n</li>\n<li><p>快速排序的运行时间与划分是否对称有关</p>\n</li>\n<li><p>对应于初始排序表基本有序或基本逆序时，就得到最坏情况下的时间复杂度为O(n^2)</p>\n<ul>\n<li>有序和逆序时，左右划分都很不均匀</li>\n</ul>\n</li>\n<li><p>平均时间复杂度为：O(n*log_2(n))</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>算法优化</p>\n<ul>\n<li><p>1、每次选取头、中、尾三个位置的元素，取中间值作为基准元素</p>\n</li>\n<li><p>2、随机选取一个元素作为枢轴元素</p>\n</li>\n</ul>\n</li>\n<li><p>不稳定算法</p>\n</li>\n<li><p>适用于顺序存储</p>\n</li>\n<li><p>注：</p>\n<ul>\n<li><p>一趟排序：对所有尚未确定最终位置的所有元素进行一遍处理，可能确定多个元素的位置</p>\n<ul>\n<li>将各个部分分别划分为两部分</li>\n</ul>\n</li>\n<li><p>一次划分：确认一个元素的最终位置</p>\n<ul>\n<li>将一部分划分为两部分</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h1><h2 id=\"基本思想\"><a href=\"#基本思想\" class=\"headerlink\" title=\"基本思想\"></a>基本思想</h2><ul>\n<li>每一趟从待排序元素中选取关键字最小的元素加入有序子序列（与第一个无序元素交换）</li>\n</ul>\n<h2 id=\"简单选择排序\"><a href=\"#简单选择排序\" class=\"headerlink\" title=\"简单选择排序\"></a>简单选择排序</h2><ul>\n<li><p>基本思想</p>\n<ul>\n<li><p>将表分为两部分，有序部分和无序部分</p>\n</li>\n<li><p>每次从无序部分中选取最小的元素，然后将其放入有序部分中</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n</li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间效率：O(1)</p>\n</li>\n<li><p>时间效率</p>\n<ul>\n<li><p>元素间比较的次数与序列的初始状态无关</p>\n</li>\n<li><p>时间复杂度为O(n^2）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>不稳定的排序算法</p>\n</li>\n<li><p>适合顺序存储和链式存储</p>\n</li>\n</ul>\n<h2 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h2><ul>\n<li><p>基本概述</p>\n<ul>\n<li><p>堆</p>\n<ul>\n<li><p>大根堆：父节点的值大于相对应的孩子结点值（L(i)&gt;&#x3D;L(2i)且L(i)&gt;&#x3D;L(2i)）</p>\n</li>\n<li><p>小跟堆：父节点的值小于相对应的孩子结点值（L(i)&lt;&#x3D;L(2i)且L(i)&lt;&#x3D;L(2i)）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>基本思想</p>\n<ul>\n<li><p>建堆：按照大根堆或者小根堆的规则建立起相应的二叉树，那么根节点一定是最大值或者最小值</p>\n<ul>\n<li><p>1、检查所有的分支节点（非终端结点），即i&lt;&#x3D;【n&#x2F;2】向下取整</p>\n<ul>\n<li>对于所有的分支节点，从后往前进行检查（即从底层分支结点开始调整）</li>\n</ul>\n</li>\n<li><p>2、检查当前结点是否满足大根堆，如果不满足，则将当前结点与更大的孩子互换</p>\n</li>\n</ul>\n</li>\n<li><p>堆排序：</p>\n<ul>\n<li><p>每一趟将堆顶元素加入有序子序列</p>\n<ul>\n<li>堆顶元素与堆底元素互换</li>\n</ul>\n</li>\n<li><p>调整堆：将待排序元素序列再次调整为大根堆</p>\n<ul>\n<li>当根节点输出后，整颗二叉树可能被破坏，这是要根据相应的建堆规则（从下往上，从右往左），进行父节点与子节点交换以满足相应的建堆规则</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>大根堆</p>\n<ul>\n<li><p>将以k为根的子树调整为大根堆</p>\n</li>\n<li><p>建立大根堆</p>\n</li>\n<li><p>基于大根堆进行排序</p>\n</li>\n</ul>\n</li>\n<li><p>小根堆</p>\n<ul>\n<li><p>将以k为根的子树调整为小根堆</p>\n</li>\n<li><p>建立小根堆</p>\n</li>\n<li><p>基于小根堆进行排序</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间效率：空间复杂度为O(1)</p>\n</li>\n<li><p>时间效率</p>\n<ul>\n<li><p>建堆时间为O(n)</p>\n<ul>\n<li><p>一个结点，每下坠一层，最多只需对比关键字2次</p>\n</li>\n<li><p>若树高为h，某结点在第i层，则将这个结点向下调整最多只需下坠h-i层，关键字对比次数不超过2(h-i)</p>\n</li>\n<li><p>建堆过程，关键字对比次数不超过4n</p>\n</li>\n</ul>\n</li>\n<li><p>进行排序</p>\n<ul>\n<li><p>调整的时间复杂度为O(h)，h为二叉树的高度，O(log_2(n))</p>\n</li>\n<li><p>n-1趟调整：O(n)</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度O(n*log_2(n))</p>\n<ul>\n<li>O(n)+O(n)*O(log_2(n))&#x3D;O(nlog_2(n))</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>不稳定排序算法</p>\n</li>\n</ul>\n<h2 id=\"堆的插入和删除\"><a href=\"#堆的插入和删除\" class=\"headerlink\" title=\"堆的插入和删除\"></a>堆的插入和删除</h2><ul>\n<li><p>插入的实现过程</p>\n<ul>\n<li><p>对于小根堆，新元素放到表尾，与父节点对比</p>\n</li>\n<li><p>若新元素比父结点更小，则将两者互换。新元素一路上升，直到无法上升</p>\n<ul>\n<li>注：上升过程中，只需要对比一次（自己和夫结点）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>删除的实现过程</p>\n<ul>\n<li><p>对于小根堆，使用堆底元素代替被删除元素</p>\n</li>\n<li><p>让该元素不断下坠，直到无法下坠为止</p>\n<ul>\n<li>注：下坠过程中，需要对比两次（分别和左右孩子），也可能对比1次（只有一个孩子）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"归并排序和基数排序\"><a href=\"#归并排序和基数排序\" class=\"headerlink\" title=\"归并排序和基数排序\"></a>归并排序和基数排序</h1><h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><ul>\n<li><p>归并：</p>\n<ul>\n<li>把两个或多个已经有序的序列合并成一个</li>\n</ul>\n</li>\n<li><p>基本思想</p>\n<ul>\n<li><p>每次选定相应的元素分别合成一个新的有序表</p>\n<ul>\n<li><p>“2路归并”——二合一</p>\n<ul>\n<li>每选出一个小元素需对比关键字一次</li>\n</ul>\n</li>\n<li><p>“k路归并”——k合一</p>\n<ul>\n<li>m路归并，每选出一个元素需要对比关键字m-1次</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/ae84aa05-ddb2-4335-99f9-daf339e62094-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>i指向第一个有序序列的第一个元素，j指向第二个有序序列的第一个元素</p>\n</li>\n<li><p>对比i所指元素与j所指元素，选择更小的一个放入k所指的位置</p>\n</li>\n<li><p>只剩下一个子表未合并时，可以将该表中剩余元素全部加到总表</p>\n</li>\n</ul>\n</li>\n<li><p>归并排序（手算）</p>\n<ul>\n<li>核心操作：把数组内的两个有序序列合并为一个</li>\n</ul>\n</li>\n<li><h2 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2></li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间复杂度为O(n)</p>\n<ul>\n<li>辅助数组：存放所有的数组元素</li>\n</ul>\n</li>\n<li><p>时间复杂度为O(n*log_2(n))</p>\n<ul>\n<li><p>n个元素进行2路归并排序，归并趟数&#x3D;【log_2(n)】向上取整</p>\n</li>\n<li><p>每趟归并的时间复杂度为O(n)</p>\n</li>\n<li><p>所以算法的时间复杂度为O(n*log_2(n))</p>\n</li>\n</ul>\n</li>\n<li><p>稳定排序算法</p>\n</li>\n<li><p>适用于顺序表</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h2><ul>\n<li><p>概念：</p>\n<ul>\n<li><p>假设长度为n的线性表中每个结点a_j的关键字由d元组（最高（主）位关键字，……，最低（次）位关键字）组成</p>\n</li>\n<li><p>其中0&lt;&#x3D;关键字&lt;&#x3D;r-1，其中r称为基数</p>\n</li>\n</ul>\n</li>\n<li><p>排序思想</p>\n<ul>\n<li><p>最高位优先（MSD）法：按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列</p>\n</li>\n<li><p>最低位优先（ LSD ）法：按关键字权重递增依次进行排序，最后形成一个有序序列</p>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>以个位进行</p>\n<ul>\n<li><p>分配：将一个序列按照个位分配为多个子序列</p>\n</li>\n<li><p>收集：将多个子序列连接起来</p>\n<ul>\n<li>得到按照个位递减的序列</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>以十位进行</p>\n<ul>\n<li><p>分配：使得十位数相同的子序列中个位数更大的先入队，个位数更小的后入队</p>\n</li>\n<li><p>收集：得到按十位递减排序的序列，若十位相同则按个位递减排序</p>\n</li>\n</ul>\n</li>\n<li><p>以百位进行</p>\n<ul>\n<li><p>分配：使得百位数相同的子序列中，十位数更大的先入队</p>\n</li>\n<li><p>收集：得到按照按百位递减的序列，若百位相同则按照十位递减排序，若十位相同则按照个位递减排序</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实现递减序列的过程</p>\n<ul>\n<li><p>初始化：设置r个空队列</p>\n</li>\n<li><p>按照各个关键字位权重递增的次序（个、十、百），对d个关键字分别做分配和收集</p>\n<ul>\n<li><p>分配：顺序扫描各个元素，若当前处理的关键字位&#x3D;x，则将元素插入Qx队尾</p>\n</li>\n<li><p>收集：把Qr-1，Qr-2，……，Q0各个队列中的结点依次出队并链接</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实现递增序列的过程</p>\n<ul>\n<li>区别<ul>\n<li>收集：把Q0，……，Qr-2，Qr-1各个队列中的结点依次出队并链接</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li>基数排序不是基于比较的排序算法</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>结点定义</p>\n</li>\n<li><p>链式队列定义</p>\n</li>\n</ul>\n</li>\n<li><p>性能分析</p>\n<ul>\n<li><p>空间效率</p>\n<ul>\n<li><p>一趟排序需要的辅助存储空间为r（r个队列：r个队头指针和r个队尾指针）</p>\n</li>\n<li><p>基数排序的空间复杂度为O（r）</p>\n<ul>\n<li><p>r个辅助队列</p>\n</li>\n<li><p>一个辅助队列有两个指针（不算结点所占空间，因为空间效率指的是临时所占空间）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>时间效率</p>\n<ul>\n<li><p>基数排序需要进行d趟分配和收集，一趟分配需要O(n )，一趟收集需要O(r)</p>\n<ul>\n<li>收集一个队列只需要O(1)，只需要上一队列的最后一个元素的指针指向下一队列的第一个元素</li>\n</ul>\n</li>\n<li><p>基数排序的时间复杂度为O(d(n+r))</p>\n<ul>\n<li>与序列的初始状态无关（每一趟排序都不设置判断是否终止，序列的初始排序无论是怎样的都执行相同的次数）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>稳定排序算法</p>\n</li>\n<li><p>应用</p>\n<ul>\n<li><p>按年龄递减排序</p>\n<ul>\n<li><p>第一趟分配、收集（按日递增）</p>\n</li>\n<li><p>第二趟分配、收集（按月递增）</p>\n</li>\n<li><p>第三趟分配、收集（按年递增）</p>\n</li>\n</ul>\n</li>\n<li><p>善于解决的问题</p>\n<ul>\n<li><p>数据元素的关键字可以方便地拆分为d组，且d较小</p>\n<ul>\n<li>反例：5个人按身份证号排序</li>\n</ul>\n</li>\n<li><p>每组关键字的取值范围不大，即r较小</p>\n<ul>\n<li>反例：按中国人名排序</li>\n</ul>\n</li>\n<li><p>数据元素个数n较大</p>\n<ul>\n<li>擅长：给10亿人按身份证号排序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"各种内部排序算法的比较及应用\"><a href=\"#各种内部排序算法的比较及应用\" class=\"headerlink\" title=\"各种内部排序算法的比较及应用\"></a>各种内部排序算法的比较及应用</h1><ul>\n<li><p>排序算法小结</p>\n<ul>\n<li><p>若n较小，可采用直接插入排序或简单选择排序</p>\n</li>\n<li><p>当记录本身信息量较大时，用简单选择排序较好</p>\n</li>\n<li><p>若文件的初始状态已按关键字基本有序则选用直接插入或冒泡排序为宜</p>\n</li>\n<li><p>快速排序被认为是目前基于比较的内部排序方法中最好的方法</p>\n<ul>\n<li>待排序的关键字随机分布时，快速排序的平均时间最短</li>\n</ul>\n</li>\n<li><p>若n较大，则应采用时间复杂度为O(n*log_2(n))的排序方法：快速排序、堆排序或归并排序</p>\n</li>\n<li><p>要求排序稳定且时间复杂度为O(n*log_2(n))，则可选用归并排序</p>\n</li>\n<li><p>若n很大，记录的关键字位数较少且可以分解时，采用基数排序较好</p>\n</li>\n<li><p>当记录本身信息量较大时，为避免耗费大量时间移动记录，可用链表作为存储结构</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"外部排序\"><a href=\"#外部排序\" class=\"headerlink\" title=\"外部排序\"></a>外部排序</h1><h2 id=\"外部排序的基本概念\"><a href=\"#外部排序的基本概念\" class=\"headerlink\" title=\"外部排序的基本概念\"></a>外部排序的基本概念</h2><ul>\n<li><p>对大文件进行排序，因为文件中的记录很多、信息量庞大，无法将整个文件复制进内存中进行排序</p>\n</li>\n<li><p>需要将待排序的记录存储在外存上，排序时再把数据一部分一部分地调入内存进行排序，在排序过程中需要多次进行内存和外存之间的交换</p>\n</li>\n</ul>\n<h2 id=\"外部排序的方法\"><a href=\"#外部排序的方法\" class=\"headerlink\" title=\"外部排序的方法\"></a>外部排序的方法</h2><ul>\n<li><p>外存与内存之间的数据交换</p>\n<ul>\n<li><p>文件通常是按块存储在磁盘上的，操作系统也是按块为单位对磁盘上的信息进行读写的</p>\n<ul>\n<li>修改磁盘块数据时<ul>\n<li>在内存中申请缓冲区，将磁盘块读入内存，数据读入内存后才能被修改，修改完之后还要写回磁盘</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>外部排序：数据元素太多，无法一次全部读入内存进行排序，将外存中的数据进行排序</p>\n</li>\n<li><p>外部排序过程中的时间代价主要考虑访问磁盘的次数，即I&#x2F;O次数</p>\n</li>\n</ul>\n</li>\n<li><p>外部排序通常采用归并排序法</p>\n<ul>\n<li><p>最少只需在内存中分配三块大小的缓冲区，即可对任何一个大文件进行排序</p>\n<ul>\n<li>2个输入缓冲区，1个输出缓冲区</li>\n</ul>\n</li>\n<li><p>算法实现的两个阶段</p>\n<ul>\n<li><p>构造初始归并段</p>\n<ul>\n<li><p>据内存缓冲区大小将外存上的文件分成若干长度为的子文件，依次读入内存并利用内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存（归并段或顺串）</p>\n</li>\n<li><p>读写操作：2*子文件个数</p>\n</li>\n</ul>\n</li>\n<li><p>第一趟归并：对这些归并段进行逐趟归并使归并段（有序子文件）逐渐由小到大，直至得到整个有序文件为止</p>\n<ul>\n<li><p>把初始归并段进行两两归并，将归并段1和归并段2中更小的部分读入缓冲区，利用内部排序对它们进行归并，如果输出缓冲区满了，就将输出缓冲区的数据写回外存（外存的另外一块空间）</p>\n</li>\n<li><p>继续将两个缓冲区进行归并排序</p>\n</li>\n<li><p>当其中一个缓冲区空了之后，立即用该归并段的下一块补上</p>\n</li>\n<li><p>当输出缓冲区又满了，就接着将输出缓冲区的数据写回外存</p>\n</li>\n<li><p>当另一个缓冲区空了之后，继续用该归并段中的下一块补上</p>\n</li>\n<li><p>将剩余部分进行归并排序，输出</p>\n</li>\n</ul>\n</li>\n<li><p>第二趟归并</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>耗费时间</p>\n<ul>\n<li><p>外部排序的总时间&#x3D;内部排序所需的时间+外存信息读写的时间+内部归并所需的时间</p>\n<ul>\n<li><p>外存信息读取时间：(归并次数+1)·文件总块数·2·读写时间</p>\n</li>\n<li><p>内部排序时间：在内存中生成初始归并段的时间</p>\n</li>\n<li><p>内部归并时间：在内存中进行内部归并的时间</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>归并排序优化（都能减少归井趟数s，进而减少读写磁盘的次数达到提高外部排序速度的目的）</p>\n<ul>\n<li><p>增大归并路数k：在内存中增加输入缓冲区个数</p>\n<ul>\n<li><p>多路归并的负面影响：</p>\n<ul>\n<li><p>K路归并时，需要开辟k个输入缓冲区，内存开销增加</p>\n</li>\n<li><p>每挑选一个关键字需要对比关键字k-1次，内部归并时间增加</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>减少初始归并段个数r：生成初始归并段的内存工作区越大，初始归并段越长</p>\n<ul>\n<li>r&#x3D;N&#x2F;L，N为总记录数，L为内存工作区可以容纳的记录数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"K路平衡归并\"><a href=\"#K路平衡归并\" class=\"headerlink\" title=\"K路平衡归并\"></a>K路平衡归并</h2><ul>\n<li><p>最多只有k个段归并为一个</p>\n</li>\n<li><p>每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到（【m&#x2F;k】向上取整）个新的归并段</p>\n</li>\n</ul>\n<h2 id=\"多路平衡归并与败者树\"><a href=\"#多路平衡归并与败者树\" class=\"headerlink\" title=\"多路平衡归并与败者树\"></a>多路平衡归并与败者树</h2><ul>\n<li><p>引入败者树的背景</p>\n<ul>\n<li><p>减少归并排序时关键字对比次数</p>\n</li>\n<li><p>为了使内部归并不受k （归并路数）的增大的影响</p>\n</li>\n</ul>\n</li>\n<li><p>基本思想</p>\n<ul>\n<li><p>败者树是树形选择排序的一种变体，可视为一棵完全二叉树</p>\n</li>\n<li><p>k个叶结点分别存放k个归并段在归并过程中当前参加比较的记录，内部结点用来记忆左右子树中的“失败者”，而让胜者往上继续进行比较，一直到根结点</p>\n</li>\n<li><p>若比较两个数，大的为失败者、小的为胜利者，则根结点指向的数为最小数</p>\n</li>\n<li><p>基于已经构建好的败者树，选出新的胜者只需要比较【log_2(k)】向上取整（上限）</p>\n</li>\n</ul>\n</li>\n<li><p>败者树在多路平衡归并中的应用</p>\n<ul>\n<li><p>每个叶子结点对应一个归并段，首先将关键字最小的加入叶子结点</p>\n</li>\n<li><p>分支结点记录失败者来自于哪个归并段；根结点记录冠军来自于哪个归并段</p>\n</li>\n<li><p>对于K路归并，第一次构造败者树需要对比关键字k-1次</p>\n</li>\n<li><p>有了败者树，选出最小元素，只需对比关键字【log_2(k)】向上取整（上限）</p>\n</li>\n</ul>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li>K路归并的败者树只需要定义一个长度为K的数组：0对应败者树新增加的结点，1对应传统二叉树意义上的根结点，叶子结点时虚拟的</li>\n</ul>\n</li>\n<li><p>性能分析</p>\n<ul>\n<li><p>k路归并的败者树深度【log_2(k)】向上取整</p>\n</li>\n<li><p>总的比较次数<img src=\"https://api2.mubu.com/v3/document_image/318b83bb-8994-49ce-9d66-5c91dc25ee5e-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>注意</p>\n<ul>\n<li><p>归并路数k并不是越大越好。归并路数k增大时，相应地需要增加输入缓沖区的个数</p>\n</li>\n<li><p>当k值过大时，虽然归并趟数会减少，但读写外存的次数仍会增加</p>\n</li>\n</ul>\n</li>\n<li><p>优化</p>\n<ul>\n<li><p>增加归并路数k，进行多路平衡归并</p>\n<ul>\n<li><p>代价1 ：需要增加相应的输入缓冲区</p>\n</li>\n<li><p>代价2 ：每次从k个归并段中选一个最小元素需要（k—1）次关键字对比</p>\n</li>\n</ul>\n</li>\n<li><p>减少初始归并段数量</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"置换—选择排序（减少生成初始归并段数量）\"><a href=\"#置换—选择排序（减少生成初始归并段数量）\" class=\"headerlink\" title=\"置换—选择排序（减少生成初始归并段数量）\"></a>置换—选择排序（减少生成初始归并段数量）</h2><ul>\n<li><p>土办法</p>\n<ul>\n<li><p>用一片更大的内存区域来进行内部排序</p>\n</li>\n<li><p>用于内部排序的内存工作区WA可容纳l个记录，则每个初始归并段只能包含l个记录，若文件共有n个记录，则初始归并段的数量r&#x3D;n&#x2F;l</p>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录</p>\n</li>\n<li><p>1）从FI输入w个记录到工作区WA</p>\n</li>\n<li><p>2）从WA中选出其中关键字取最小值的记录，记为MINIMAX记录</p>\n</li>\n<li><p>3）将MINIMAX记录输出到FO中去</p>\n</li>\n<li><p>4）若FI不空，则从FI输入下一个记录到WA中</p>\n</li>\n<li><p>5）从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录</p>\n</li>\n<li><p>6）重复3） ～5），直至在WA中选不出新的MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去</p>\n<ul>\n<li>即WA内的关键字都要比MINIMAX更小，则该归并段在此截止，FO中的记录输出为归并段</li>\n</ul>\n</li>\n<li><p>7）重复2）～6），直至WA为空。由此得到全部初始归并段</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"最佳归并树\"><a href=\"#最佳归并树\" class=\"headerlink\" title=\"最佳归并树\"></a>最佳归并树</h2><h3 id=\"结构概述\"><a href=\"#结构概述\" class=\"headerlink\" title=\"结构概述\"></a>结构概述</h3><ul>\n<li><p>各叶结点表示一个初始归并段，上面的权值表示该归并段的长度</p>\n</li>\n<li><p>叶结点到根的路径长度表示其参加归并的趟数</p>\n</li>\n<li><p>各非叶结点代表归并成的新归并段</p>\n</li>\n<li><p>根结点表示最终生成的归并</p>\n</li>\n<li><p>树的带权路径长度WPL为归并过程中的总读记录数</p>\n<ul>\n<li>归并过程中的磁盘I&#x2F;O次数&#x3D;归并树的WPL*2</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法优化\"><a href=\"#算法优化\" class=\"headerlink\" title=\"算法优化\"></a>算法优化</h3><ul>\n<li><p>引入哈夫曼树的思想：要想让磁盘I&#x2F;O次数最少，就要使归并树WPL最小——哈夫曼树</p>\n</li>\n<li><p>在归并树中，让记录数少的初始归并段最先归并，记录数多的初始归并段最晚归并，就可以建立总的I&#x2F;O次数最少的最佳归并树</p>\n</li>\n<li><p>示意图：3路归并的最佳归并树<img src=\"https://api2.mubu.com/v3/document_image/5c71c849-1054-4f13-8974-c15a06daddbb-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n<h3 id=\"算法修正\"><a href=\"#算法修正\" class=\"headerlink\" title=\"算法修正\"></a>算法修正</h3><ul>\n<li><p>若初始归并段不足以构成一棵严格k叉树时，需添加长度为0的“虚段”</p>\n</li>\n<li><p>按照哈夫曼树的原则，权为0的叶子应离树根最远</p>\n</li>\n<li><p>示意图<img src=\"https://api2.mubu.com/v3/document_image/57cf7327-4a6b-4b5e-8450-5694ac1e164e-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>需要修正的条件（添加虚段的数量）</p>\n<ul>\n<li><p>设度为0的结点有n0个，度为k的结点有nk个，归并树总结点数&#x3D;n</p>\n</li>\n<li><p>n0&#x3D;初始归并段数量+虚段数量</p>\n</li>\n<li><p>n&#x3D;n0+nk</p>\n</li>\n<li><p>严格k叉树有n0&#x3D;(k-1)nk+1，变形可得nk&#x3D;(n0-1)&#x2F;(k-1)</p>\n<ul>\n<li>度为k的结点的分叉&#x3D;总结点数-1</li>\n</ul>\n</li>\n<li><p>(n0-1)%(k-1)&#x3D;0，说明正好可以构造k叉归并树</p>\n</li>\n<li><p>(n0-1)%(k-1)&#x3D;u≠0，再加上k-u-1个空归并段，就可以建立归并树</p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","3.数据结构","8.排序"],"tags":["写作"]},{"title":"数据链路层","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_3.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","content":"<h1 id=\"数据链路层的功能\"><a href=\"#数据链路层的功能\" class=\"headerlink\" title=\"数据链路层的功能\"></a>数据链路层的功能</h1><ul>\n<li><p>概要</p>\n<ul>\n<li>数据链路层在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路</li>\n</ul>\n</li>\n<li><p>为网络层提供服务</p>\n<ul>\n<li><p>无确认的无连接服务</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li><p>源机器发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认</p>\n</li>\n<li><p>对丢失的帧，数据链路层不负责重发而交给上层处理</p>\n</li>\n</ul>\n</li>\n<li><p>使用范围</p>\n<ul>\n<li>适用于实时通信或误码率较低的通信信道   以太网</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>有确认的无连接服务</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li><p>源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。</p>\n</li>\n<li><p>源机器在所规定的时间内未收到确定信号时，就重传丢失的帧，来提高数据的可靠性</p>\n</li>\n</ul>\n</li>\n<li><p>使用范围</p>\n<ul>\n<li>适用于误码率较高的通信信道   无线通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>有确认的面向连接服务</p>\n<ul>\n<li><p>特点</p>\n<ul>\n<li><p>帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路</p>\n</li>\n<li><p>目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧</p>\n</li>\n</ul>\n</li>\n<li><p>使用范围</p>\n<ul>\n<li>适用于通信要求（可靠性、实时性）较高的场合</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>备注：有连接就一定有确认，不存在无确认的面向连接的服务</p>\n</li>\n</ul>\n</li>\n<li><p>链路管理</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li>将链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>首先确认对方已处于就绪状态</p>\n</li>\n<li><p>交换一些必要的信息以对帧序号初始化</p>\n</li>\n<li><p>建立连接，在传输过程中则要能维持连接，而在传输完毕后要释放该连接</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>帧定界、帧同步与透明传输</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li>两个工作站之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送</li>\n</ul>\n</li>\n<li><p>帧定界</p>\n<ul>\n<li>将一段数据的前后分别增加首部和尾部就构成了帧。首部和尾部中含有很多控制信息，其作用是确认帧的界限</li>\n</ul>\n</li>\n<li><p>帧同步</p>\n<ul>\n<li>接收方应能从接收到的二进制比特流中区分出帧的起始与终止</li>\n</ul>\n</li>\n<li><p>透明传输</p>\n<ul>\n<li>采用有效的措施解决误认为“传输结束”而丢弃后面的数据的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>流量控制</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li>收发双方各自的工作速率和缓存空间的差异，出现发送方的发送能力大于接收方的接受能力的现象，如不对其进行流量控制就会导致数据丢失</li>\n</ul>\n</li>\n<li><p>实现</p>\n<ul>\n<li>通过控制发送方的发送速率，从而实现流量控制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>差错控制</p>\n<ul>\n<li><p>使发送方确定接收方是否正确收到由其发送的数据的方法</p>\n<ul>\n<li><p>位错：</p>\n<ul>\n<li>数据中的某些位出现错误</li>\n</ul>\n</li>\n<li><p>帧错：</p>\n<ul>\n<li>帧的丢失、重复或失序等错误</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>解决方法：</p>\n<ul>\n<li><p>解决位错：CRC循环冗余码</p>\n</li>\n<li><p>解决帧错：自动重传请求（ARQ）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"组帧\"><a href=\"#组帧\" class=\"headerlink\" title=\"组帧\"></a>组帧</h1><h2 id=\"功能实现\"><a href=\"#功能实现\" class=\"headerlink\" title=\"功能实现\"></a>功能实现</h2><ul>\n<li><p>为了使接收方能正确地接收并检查所传输的帧，发送方必须依据一定的规则把网络层递交的分组封装成帧</p>\n</li>\n<li><p>解决问题</p>\n<ul>\n<li><p>帧定界</p>\n</li>\n<li><p>帧同步</p>\n</li>\n<li><p>透明传输</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符计数法\"><a href=\"#字符计数法\" class=\"headerlink\" title=\"字符计数法\"></a>字符计数法</h2><ul>\n<li><p>实现方法</p>\n<ul>\n<li>在帧头部使用一个计数字段来标明帧内字符数</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>如果计数字段出错，收发双方将失去同步从而导致错误</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符填充的首位定界符法\"><a href=\"#字符填充的首位定界符法\" class=\"headerlink\" title=\"字符填充的首位定界符法\"></a>字符填充的首位定界符法</h2><ul>\n<li><p>实现方法</p>\n<ul>\n<li><p>使用一些特殊的字符来定界一帧的开始（DLE STX）与结束（DLE ETX）</p>\n</li>\n<li><p>在特殊字符前面填充一个转义字符（DLE），防止特殊字符被误判为帧的首尾定界符</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"零比特填充的首位标志法\"><a href=\"#零比特填充的首位标志法\" class=\"headerlink\" title=\"零比特填充的首位标志法\"></a>零比特填充的首位标志法</h2><ul>\n<li><p>实现方法</p>\n<ul>\n<li><p>使用一个特定的比特模式，即01111110来标志一帧的开始和结束</p>\n</li>\n<li><p>在发送信息时，遇到5个连续的1就自动在后面加0</p>\n</li>\n<li><p>当收到信息时，遇到5个连续的1就自动在后面减0</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>零比特填充法很容易由硬件来实现，性能优于字符填充法</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"违规编码法\"><a href=\"#违规编码法\" class=\"headerlink\" title=\"违规编码法\"></a>违规编码法</h2><ul>\n<li><p>使用条件</p>\n<ul>\n<li><p>在物理层进行比特编码时，通常采用违规编码法</p>\n</li>\n<li><p>违规编码法只适用于采用冗余编码的特殊编码环境</p>\n</li>\n</ul>\n</li>\n<li><p>实现方法（借用这些违规编码序列来定界帧的起始和终止）</p>\n<ul>\n<li><p>正常情况下：曼彻斯特编码中比特“1”编码成“高-低”电平，比特“0”编码成“低-高”电平</p>\n</li>\n<li><p>违规情况下：曼彻斯特编码中比特“1”编码成“高-高”电平，比特“0”编码成“低-低”电平</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"补充：目前较常用的组帧方法是比特填充法和违规编码法\"><a href=\"#补充：目前较常用的组帧方法是比特填充法和违规编码法\" class=\"headerlink\" title=\"补充：目前较常用的组帧方法是比特填充法和违规编码法\"></a>补充：目前较常用的组帧方法是比特填充法和违规编码法</h2><h1 id=\"差错控制\"><a href=\"#差错控制\" class=\"headerlink\" title=\"差错控制\"></a>差错控制</h1><h2 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h2><ul>\n<li><p>影响因素1：信道固有噪声干扰</p>\n<ul>\n<li>解决方法：提高信噪比</li>\n</ul>\n</li>\n<li><p>影响因素2：外界的冲击噪声是产生差错的重要原因</p>\n<ul>\n<li>没有办法通过提高信号幅度来降低干扰</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"利用编码技术进行差错控制\"><a href=\"#利用编码技术进行差错控制\" class=\"headerlink\" title=\"利用编码技术进行差错控制\"></a>利用编码技术进行差错控制</h2><ul>\n<li><p>自动重传请求ARQ</p>\n<ul>\n<li>接收端检测出差错时，就设法通知发送端重发，直到接收到正确的码字为止</li>\n</ul>\n</li>\n<li><p>前向纠错FEC</p>\n<ul>\n<li>接收端不但能发现差错，而且能确定比特串的错误位置，从而加以纠正</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"检测编码\"><a href=\"#检测编码\" class=\"headerlink\" title=\"检测编码\"></a>检测编码</h2><ul>\n<li><p>奇偶校验码</p>\n<ul>\n<li>n-1位数据和1位校验码组成，校验位用于调节发送信息中的1的个数是偶数还是奇数</li>\n</ul>\n</li>\n<li><p>循环冗余码</p>\n<ul>\n<li><p>任何一个由二进制数位串组成的代码都可以与一个只含有0和1两个系数的多项式建立一一对应关系</p>\n</li>\n<li><p>计算步骤</p>\n<ul>\n<li><p>假设一个帧有m位，其对应的多项式为M(x)</p>\n</li>\n<li><p>加0：假设G(x)的阶为r，在帧的低位端加上r个0</p>\n</li>\n<li><p>模2除：利用模2除法，用G(x)对应的数据串去除1)中计算出的数据串，得到的余数即为冗余码（共r位，前面的0不可省略）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"纠错编码\"><a href=\"#纠错编码\" class=\"headerlink\" title=\"纠错编码\"></a>纠错编码</h2><ul>\n<li><p>海明码</p>\n<ul>\n<li><p>原理</p>\n<ul>\n<li><p>在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中</p>\n</li>\n<li><p>当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，而且能指出错位的位置</p>\n</li>\n</ul>\n</li>\n<li><p>计算过程</p>\n<ul>\n<li><p>设n为有效信息的位数，k为校验位的位数，则信息为n和k应满足</p>\n</li>\n<li><p>确定校验位的分布</p>\n<ul>\n<li>规定校验位在海明位号为   位置上，其余各位为信息位</li>\n</ul>\n</li>\n<li><p>分组形成校验关系</p>\n<ul>\n<li>被校验位的海明位号等于校验该位号的各校验位海明位号之和</li>\n</ul>\n</li>\n<li><p>校验位取值</p>\n<ul>\n<li>校验位的值为对应组的所有位求异或</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"流量控制与可靠传输机制\"><a href=\"#流量控制与可靠传输机制\" class=\"headerlink\" title=\"流量控制与可靠传输机制\"></a>流量控制与可靠传输机制</h1><h2 id=\"流量控制、可靠传输与滑动窗口机制\"><a href=\"#流量控制、可靠传输与滑动窗口机制\" class=\"headerlink\" title=\"流量控制、可靠传输与滑动窗口机制\"></a>流量控制、可靠传输与滑动窗口机制</h2><ul>\n<li><p>流量控制涉及对连路上的帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每个帧</p>\n</li>\n<li><p>停止-等待流量协议</p>\n<ul>\n<li><p>基本原理</p>\n<ul>\n<li><p>每次只允许发送一帧，然后就陷入等待接收方确认信息的过程中，因而传输效率很低</p>\n</li>\n<li><p>如果接收方不反馈应答信号，那么发送方必须一直等待</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>滑动窗口流量控制</p>\n<ul>\n<li><p>基本原理</p>\n<ul>\n<li><p>发送方都维持一组连续的允许发送的帧的序号，称为发送窗口（发送窗口用来对发送方进行流量控制）</p>\n</li>\n<li><p>接收方也维持一组连续的允许接收的帧的序号，称为接收窗口</p>\n</li>\n<li><p>发送方</p>\n<ul>\n<li>发送窗口的大小代表在还未收到对方确认信息的情况下，发送方最多还可以发送多少个数据帧</li>\n</ul>\n</li>\n<li><p>接收方</p>\n<ul>\n<li>接收窗口是为了控制可以接收哪些数据帧和不可以接收哪些数据帧（帧的序号落在了接收窗口之内，将该数据帧收下；帧的序号落在接收窗口之外，则将其丢弃）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>机制特点</p>\n<ul>\n<li><p>只有接收窗口向前滑动（同时接收方发送了确认帧）时，发送窗口才有可能（只有发送方收到确认帧后才一定）向前滑动</p>\n</li>\n<li><p>接收窗口的大小为1时，可保证帧的有序接收</p>\n</li>\n<li><p>数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>可靠传输机制</p>\n<ul>\n<li><p>通常使用确认和超时重传两种机制</p>\n</li>\n<li><p>基本概念</p>\n<ul>\n<li><p>确认帧：是一种无数据的控制帧，这种控制帧使得接收方可以让发送方知道哪些内容被正确接收</p>\n</li>\n<li><p>捎带确认：为了提高传输效率，将确认捎带在一个回复帧（数据帧）中</p>\n</li>\n<li><p>超时重传：发送方在发送某以数据帧后就开启一个计时器，一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，直到发送成功为止</p>\n</li>\n<li><p>自动重传请求：接收方请求发送方重传出错的数据帧来回复出错的帧，是通信中用于处理信道所带来的差错的方法（下列为滑动窗口技术与请求重发技术的结合）</p>\n<ul>\n<li><p>停止-等待（Stop-and-Wait）ARQ</p>\n</li>\n<li><p>回退N帧（Go-Back-N）ARQ</p>\n</li>\n<li><p>选择重传（Selective Repeat）ARQ</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"单帧滑动窗口与停止等待协议\"><a href=\"#单帧滑动窗口与停止等待协议\" class=\"headerlink\" title=\"单帧滑动窗口与停止等待协议\"></a>单帧滑动窗口与停止等待协议</h2><ul>\n<li><p>从滑动窗口机制的角度看，停止-等待协议相当于发送窗口和接收窗口大小均为1的滑动窗口协议</p>\n</li>\n<li><p>在停止-等待协议中，除数据帧丢失外，还有其他两种差错</p>\n<ul>\n<li><p>到达目的站的帧可能已遭破坏</p>\n<ul>\n<li>解决方案：装备计时器，计时器计满时仍未收到确认，那么再次发送相同的帧，知道数据帧无错误的到达为止</li>\n</ul>\n</li>\n<li><p>数据帧正确而确认帧被破坏</p>\n<ul>\n<li>解决方案：发送方重传已被接受的数据帧，接收方收到相同的数据帧时丢弃该帧，并重传一个该帧对应的确认帧</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>帧缓冲区</p>\n<ul>\n<li><p>目的：为了超时重传和判定重传帧的需要</p>\n</li>\n<li><p>实现方法：发送端在发送完数据帧时，必须在其发送缓存中保留此数据帧的副本，这样才能在出差错时进行重传。只能在收到对方发来的确认帧ACK时，方可清除此副本</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多帧滑动窗口与后退N帧协议（GBN）\"><a href=\"#多帧滑动窗口与后退N帧协议（GBN）\" class=\"headerlink\" title=\"多帧滑动窗口与后退N帧协议（GBN）\"></a>多帧滑动窗口与后退N帧协议（GBN）</h2><ul>\n<li><p>回退N帧ARQ</p>\n<ul>\n<li><p>发送方连续发送帧，当接收方检测出是虚的数据帧后，要求发送方重传最后一个正确发送的信息帧之后所有未被确认的帧（累计确认）</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>连续发送数据帧而提高了信道利用率</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>若信道的传输质量很差导致误码率较大时，后退N帧协议不一定由于停止-等待协议</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>窗口大小</p>\n<ul>\n<li>n比特编号</li>\n</ul>\n</li>\n<li><p>GBN协议重点总结</p>\n<ul>\n<li><p>累计确认（偶尔捎带确认）</p>\n</li>\n<li><p>接收方只按顺序接收帧，不按序的帧就被丢弃</p>\n</li>\n<li><p>确认序列号最大的、按序到达的帧</p>\n</li>\n<li><p>发送窗口最大为  接收窗口大小为1</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"多帧滑动窗口与选择重传协议（SR）\"><a href=\"#多帧滑动窗口与选择重传协议（SR）\" class=\"headerlink\" title=\"多帧滑动窗口与选择重传协议（SR）\"></a>多帧滑动窗口与选择重传协议（SR）</h2><ul>\n<li><p>选择重传</p>\n<ul>\n<li><p>每个发送缓冲区对应一个计时器，当计时器超时时，缓冲区的帧就会重传</p>\n</li>\n<li><p>一旦接收方怀疑帧出错，就会发一个否定帧NAK给发送方，要求发送发对NAK中指定的帧进行重传</p>\n</li>\n<li><p>接收端要设置具有相当容量的缓冲区来暂存那些未按序接收到的帧</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>提高了信道的利用率</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>需要开辟缓存空间用来存储数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>窗口大小</p>\n<ul>\n<li>n比特编号</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"介质访问控制\"><a href=\"#介质访问控制\" class=\"headerlink\" title=\"介质访问控制\"></a>介质访问控制</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li><p>主要任务：为使用介质的每个结点隔离来自同一信道其他结点所传送的信号，以协调活动节点的传输</p>\n</li>\n<li><p>介质访问控制（Medium Access Control，MAC）子层：用来决定广播信道中信道分配</p>\n</li>\n<li><p>常用的介质访问控制方法</p>\n<ul>\n<li><p>静态分配信道</p>\n<ul>\n<li>信道划分介质访问控制</li>\n</ul>\n</li>\n<li><p>动态分配信道</p>\n<ul>\n<li><p>随机访问介质访问控制：ALOHA协议、CSMA协议、CSMA&#x2F;CD协议、CSMA&#x2F;CA协议</p>\n</li>\n<li><p>轮询访问介质访问控制</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"信道划分介质访问控制\"><a href=\"#信道划分介质访问控制\" class=\"headerlink\" title=\"信道划分介质访问控制\"></a>信道划分介质访问控制</h2><ul>\n<li><p>信道划分介质访问控制将使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开来，把时域和频域资源合理地分配给网络上的设备</p>\n</li>\n<li><p>多路复用技术</p>\n<ul>\n<li><p>多个信号组合在一条物理信道上进行传输，使多个计算机或终端设备共享信道资源</p>\n</li>\n<li><p>优点：提高了信道的利用率</p>\n</li>\n</ul>\n</li>\n<li><p>信道划分介质访问控制分类</p>\n<ul>\n<li><p>频分多路复用（FDM）</p>\n<ul>\n<li><p>将多路基带信号调制到不同频率载波上，再叠加形成一个复合信号</p>\n</li>\n<li><p>优点：充分利用传输介质的带宽，系统效率高</p>\n</li>\n<li><p>不足：需要在相邻信道之间加入保护频带防止子信道互相干扰</p>\n</li>\n</ul>\n</li>\n<li><p>时分多路复用（TDM）</p>\n<ul>\n<li><p>时分多路复用是将一条物理信道按时间分成若干时间片，轮流地分配给多个信号使用</p>\n</li>\n<li><p>缺点：由于计算机的数据的突发性，对于子信道的利用率不高</p>\n</li>\n<li><p>优化：统计时分多路复用（STDM，异步时分多路复用）</p>\n<ul>\n<li><p>采用STDM帧，STDM帧不固定分配时隙，而按需动态地分配时隙</p>\n</li>\n<li><p>提高线路的利用率</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>波分多路复用（WDM）</p>\n<ul>\n<li>在一条光线中传输多种不同波长（频率）的光信号，由于波长（频率）不同，各路光信号互不干扰，然后再用波长分解复用器将各路波长分解出来</li>\n</ul>\n</li>\n<li><p>码分多路复用（CDM）</p>\n<ul>\n<li><p>采用不同的编码来区分各路原始信号的一种复用方式。与FDM和TDM不同，它既共享信道的频率，又共享时间。</p>\n</li>\n<li><p>码分多址（Code Division Multiple Access，CDMA）</p>\n<ul>\n<li><p>每比特时间被分成n个更短的时间槽，称为码片（Chip）</p>\n</li>\n<li><p>发送1时，站点发送码片序列，发送0时，站点发送码片序列的反码</p>\n</li>\n<li><p>多个站点发送数据：每个站点的码片序列相互正交，从而从信道中分理处各路数据</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"随机访问介质访问控制\"><a href=\"#随机访问介质访问控制\" class=\"headerlink\" title=\"随机访问介质访问控制\"></a>随机访问介质访问控制</h2><ul>\n<li><p>不采用集中控制方式解决信息的次序问题，所有用户能根据自己的意愿随机地发送信息，占用信道全部速率</p>\n</li>\n<li><p>ALOHA协议</p>\n<ul>\n<li><p>纯ALOHA协议</p>\n<ul>\n<li><p>思想</p>\n<ul>\n<li><p>当网络中的任何一个站点需要发送数据时，可以不进行任何检测就发送数据</p>\n</li>\n<li><p>在一段时间内未收到确认，那么该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直至发送成功</p>\n</li>\n</ul>\n</li>\n<li><p>缺陷</p>\n<ul>\n<li>数据碰撞的概率较大，所以网络的吞吐量很低</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>时隙ALOHA协议</p>\n<ul>\n<li><p>思想</p>\n<ul>\n<li>所有站点在时间上同步起来，并将时间划分为一段段等长的时隙，规定只能在每个时隙开始时才能发送一个帧</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>避免了用户发送数据的随意性</p>\n</li>\n<li><p>减少了数据发生冲突的可能性</p>\n</li>\n<li><p>提高了信道的利用率</p>\n</li>\n</ul>\n</li>\n<li><p>缺陷</p>\n<ul>\n<li>每个用户都是想法就发，碰撞概率还是很大</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CSMA协议</p>\n<ul>\n<li><p>1-坚持CSMA</p>\n<ul>\n<li><p>思想</p>\n<ul>\n<li><p>一个结点要发送数据时，首先侦听信道</p>\n<ul>\n<li><p>如果信道空闲，那么立即发送数据</p>\n</li>\n<li><p>如果信道忙，那么等待，同时继续侦听直至信道空闲</p>\n</li>\n<li><p>如果发生冲突，那么随机等待一段时间后，再重复开始侦听信道</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>传播时延对协议的性能影响很大</p>\n</li>\n<li><p>存在碰撞现象</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>非坚持CSMA</p>\n<ul>\n<li><p>思想</p>\n<ul>\n<li><p>一个结点要发送数据时，首先侦听信道</p>\n<ul>\n<li><p>如果信道空闲，那么立即发送数据</p>\n</li>\n<li><p>如果信道忙，那么放弃侦听，等待一个随机的时间后再重复此过程</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>降低了多个节点等待信道空闲后同时发送发送数据导致冲突的概率</li>\n</ul>\n</li>\n<li><p>缺陷</p>\n<ul>\n<li>增加了数据在网络中的延迟时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>p-坚持CSMA</p>\n<ul>\n<li><p>思想</p>\n<ul>\n<li><p>一个结点要发送数据时，首先侦听信道</p>\n<ul>\n<li><p>如果信道忙，就持续侦听，直至信道空闲</p>\n</li>\n<li><p>如果信道空闲，那么以概率P发送数据，以概率1-P推迟到下一个时隙（依次循环）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>降低了冲突概率</p>\n</li>\n<li><p>减少了时间时延</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CSMA-x2F-CD协议\"><a href=\"#CSMA-x2F-CD协议\" class=\"headerlink\" title=\"CSMA&#x2F;CD协议\"></a>CSMA&#x2F;CD协议</h2><ul>\n<li><p>适用于总线型网络或半双工网络环境</p>\n</li>\n<li><p>思想：发送数据时先广播告知其他结点，让其他结点在某段时间内不要发送数据，以免出现碰撞</p>\n</li>\n<li><p>基本概念</p>\n<ul>\n<li><p>载波侦听多路访问&#x2F;碰撞检测协议是CSMA协议的改进方案</p>\n</li>\n<li><p>载波侦听：发送前先侦听，即每个站在发送数据之前要先检测一下总线上是否有其他站点正在发送数据，若有则暂时不发送数据，等待信道变为空闲时间再发送</p>\n</li>\n<li><p>碰撞检测：就是边发送边侦听，即适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站点是否也在发送数据</p>\n</li>\n<li><p>最小帧长&#x3D;总线型传播时延×数据传输×2</p>\n</li>\n<li><p>争用期：以太网端到端的往返时间，只有度过了争用期才能确定本次传输不会发生冲突</p>\n</li>\n</ul>\n</li>\n<li><p>二进制指数退避算法解决碰撞</p>\n<ul>\n<li><p>基本概念</p>\n<ul>\n<li><p>定义参数K作为第几次重传</p>\n</li>\n<li><p>取其中一个数为r</p>\n</li>\n<li><p>（r*争用期2τ）所得数值即为退避等待时间</p>\n</li>\n<li><p>重传16次不成功，则认为此帧用于无法发出，丢弃此帧，并向高层报告</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>重传需要推迟的平均时间随重传次数的增大而增大，降低发生碰撞的概率，有利于整个系统的稳定</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CSMA-x2F-CA协议\"><a href=\"#CSMA-x2F-CA协议\" class=\"headerlink\" title=\"CSMA&#x2F;CA协议\"></a>CSMA&#x2F;CA协议</h2><ul>\n<li><p>适用于无线局域网</p>\n</li>\n<li><p>思想：发送前侦听，边发送边侦听，一旦出现碰撞马上停止发送</p>\n</li>\n<li><p>接收信号的强度往往会远小于发送信号的强度，且在无线介质上信号强度的动态变化范围很大</p>\n</li>\n<li><p>并非所有站点都能够听见对方，存在“隐蔽站”问题</p>\n</li>\n<li><p>采用二进制指数退避算法</p>\n<ul>\n<li><p>预约信道</p>\n<ul>\n<li><p>发送放在发送数据的同时向其他站点通知自己传输数据需要的时间长度，让其他站点在这段时间内不发送数据，避免碰撞</p>\n</li>\n<li><p>ACK帧</p>\n<ul>\n<li><p>所有站点在正确接收到发送给自己的数据帧（除广播帧和组播帧）后，都需要向发送方发回一个ACK帧</p>\n<ul>\n<li><p>接收失败，那么不采取任何行动</p>\n</li>\n<li><p>在规定的时间内如果未接收到ACK帧，那么认为发送失败，此时进行该数据帧的重发，直到收到ACK帧或达到规定重传次数为止</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>RTS&#x2F;CTS帧</p>\n<ul>\n<li>可选的碰撞避免机制，主要用于解决无线网中的隐蔽站问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CSMA-x2F-CD与CSMA-x2F-CA区别\"><a href=\"#CSMA-x2F-CD与CSMA-x2F-CA区别\" class=\"headerlink\" title=\"CSMA&#x2F;CD与CSMA&#x2F;CA区别\"></a>CSMA&#x2F;CD与CSMA&#x2F;CA区别</h2><ul>\n<li><p>CSMA&#x2F;CD可以检测冲突，但无法避免；CSMA&#x2F;CA发送包的同时不能检测到信道上有无冲突</p>\n</li>\n<li><p>CSMA&#x2F;CD用于总线型以太网，CSMA&#x2F;CA用于无线局域网802.1a&#x2F;b&#x2F;g&#x2F;n等</p>\n</li>\n<li><p>CSMA&#x2F;CD通过电缆中的电压变化来检测；而CSMA&#x2F;CA可以选用能量检测、载波监测和能量载波混合检测三种检测信道空闲的方式</p>\n</li>\n</ul>\n<h2 id=\"轮询访问介质访问控制：令牌传递协议\"><a href=\"#轮询访问介质访问控制：令牌传递协议\" class=\"headerlink\" title=\"轮询访问介质访问控制：令牌传递协议\"></a>轮询访问介质访问控制：令牌传递协议</h2><ul>\n<li><p>通过一个集中控制的监控站，以循环方式轮询每个结点，再决定信道的分配</p>\n</li>\n<li><p>令牌在固定次序中转圈，拿到令牌就可以发送数据</p>\n</li>\n<li><p>适用于负载很高的广播信道</p>\n</li>\n</ul>\n<h1 id=\"局域网\"><a href=\"#局域网\" class=\"headerlink\" title=\"局域网\"></a>局域网</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li><p>在一个较小的地理范围（如一所学校）内，将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>为一个单位所拥有的</p>\n</li>\n<li><p>所有站点共享较高的总带宽（即较高的数据传输率）</p>\n</li>\n<li><p>较低的时延和较低的误码率</p>\n</li>\n<li><p>各站为平等关系而非主从关系</p>\n</li>\n<li><p>能进行广播和组播</p>\n</li>\n</ul>\n</li>\n<li><p>局域网的特性主要由三个要素决定：拓扑结构、传输介质、介质访问控制方式，最重要的是介质访问控制技术，它决定着局域网的技术特性</p>\n</li>\n<li><p>常见的局域网拓扑结构</p>\n<ul>\n<li><p>星型结构</p>\n</li>\n<li><p>环型结构</p>\n</li>\n<li><p>总线型结构</p>\n</li>\n<li><p>星型和总线型结合的复合型结构</p>\n</li>\n</ul>\n</li>\n<li><p>传输介质</p>\n<ul>\n<li>双绞线、铜缆和光纤<ul>\n<li>双绞线为主流传输介质</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>介质访问控制方法</p>\n<ul>\n<li><p>总线型局域网</p>\n<ul>\n<li><p>CSMA&#x2F;CD</p>\n</li>\n<li><p>令牌总线</p>\n</li>\n</ul>\n</li>\n<li><p>环型局域网</p>\n<ul>\n<li>令牌环</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>局域网拓扑实现</p>\n<ul>\n<li><p>以太网</p>\n<ul>\n<li>逻辑拓扑是总线型，物理拓扑是星型或拓展星型结构</li>\n</ul>\n</li>\n<li><p>令牌环</p>\n<ul>\n<li>逻辑拓扑是环型结构，物理拓扑是星型结构</li>\n</ul>\n</li>\n<li><p>FDDI</p>\n<ul>\n<li>逻辑拓扑是环型结构，物理拓扑是双环结构</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>逻辑链路控制（LLC）子层</p>\n<ul>\n<li>向网络层提供无确认无连接、面向连接、带确认无连接、高速传送4种不同的连接服务类型</li>\n</ul>\n</li>\n<li><p>媒体接入控制（MAC）子层</p>\n<ul>\n<li>向上层屏蔽对物理层访问的各种差异，提供对物理层的统一访问接口，主要功能包括：组帧、拆卸帧、比特传输差错检测、透明传输</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"以太网与IEEE-802-3\"><a href=\"#以太网与IEEE-802-3\" class=\"headerlink\" title=\"以太网与IEEE 802.3\"></a>以太网与IEEE 802.3</h2><ul>\n<li><p>采用总线型拓扑结构</p>\n</li>\n<li><p>简化通信</p>\n<ul>\n<li><p>采用无连接的工作方式（尽最大努力交付）</p>\n</li>\n<li><p>差错的纠正由高层完成</p>\n</li>\n</ul>\n</li>\n<li><p>传输介质的适用情况<img src=\"https://api2.mubu.com/v3/document_image/24e38905-ca82-4027-953d-2e7fb7cc8f4c-3224585.jpg\" alt=\"img\"></p>\n</li>\n<li><p>网卡</p>\n<ul>\n<li><p>局域网中连接计算机和传输介质的接口</p>\n</li>\n<li><p>功能</p>\n<ul>\n<li><p>实现与局域网传输介质之间的物理连接和电信号匹配</p>\n</li>\n<li><p>实现顿的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码及数据缓存功能</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>介质访问控制（MAC）地址</p>\n<ul>\n<li><p>网卡在出厂时都有一个唯一的代码</p>\n</li>\n<li><p>用于控制主机在网络上的数据通信</p>\n</li>\n</ul>\n</li>\n<li><p>以太网的MAC帧</p>\n<ul>\n<li><p>网卡从网络上每收到一个MAC顿，首先要用硬件检查MAC帧中的MAC地址。如果是发往本站的帧，那么就收下，否则丢弃</p>\n</li>\n<li><p>结构组成</p>\n<ul>\n<li><p>地址：通常使用6字节（48bit）地址</p>\n</li>\n<li><p>类型： 2字节，指出数据域中携带的数据应交给哪个协议实体处理</p>\n</li>\n<li><p>数据： 46-1500字节，包含高层的协议消息，由于CSMA&#x2F;CD算法的限制，以太网帧必须满足最小长度要求64字节，数据较少时必须加以填充（0-46字节）</p>\n</li>\n<li><p>填充： 0-46字节，当帧长太短时填充帧，使之达到64字节的最小长度</p>\n</li>\n<li><p>校验码（ FCS ） ：采用CRC循环冗余码</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"高速以太网\"><a href=\"#高速以太网\" class=\"headerlink\" title=\"高速以太网\"></a>高速以太网</h2><ul>\n<li><p>100BASE-T以太网</p>\n<ul>\n<li><p>在双绞线上传送100Mb&#x2F;s基带信号的星型拓扑结构以太网</p>\n</li>\n<li><p>使用CSMA&#x2F;CD协议（半双工）</p>\n</li>\n<li><p>支持全双工方，支持半双工方式</p>\n</li>\n</ul>\n</li>\n<li><p>吉比特以太网</p>\n<ul>\n<li><p>在1Gb&#x2F;s下用全双工和半双工两种方式工作</p>\n</li>\n<li><p>半双工方式下使用CSMA&#x2F;CD协议</p>\n</li>\n</ul>\n</li>\n<li><p>10吉比特以太网</p>\n</li>\n<li><p>使用光纤作为传输媒体</p>\n</li>\n<li><p>只工作在全双工方式，因此没有争用问题，也不使用CSMA&#x2F;CD协议</p>\n</li>\n</ul>\n<h2 id=\"IEEE-802-11\"><a href=\"#IEEE-802-11\" class=\"headerlink\" title=\"IEEE 802.11\"></a>IEEE 802.11</h2><ul>\n<li><p>IEEE 802.11是无线局域网的一系列协议标准，包括802.11a和802.11b等。它们制定了MAC层协议，运行在多个物理层标准上</p>\n</li>\n<li><p>有固定基础设施无线局域网</p>\n<ul>\n<li><p>802.11标准规定无线局域网的最小构件是基本服务集（BBS）</p>\n</li>\n<li><p>组成：一个基本服务集包括一个基站和若干移动站</p>\n</li>\n<li><p>所有的站在本BSS内都可以直接通信，但在与本BSS外的站通信时都要通过本BBS的基站</p>\n</li>\n</ul>\n</li>\n<li><p>无固定基础设施无线局域网（自组织网络）</p>\n<ul>\n<li><p>由一些平等状态移动站相互通信组成的临时网络。各结点之间地位平等，中间结点都为转发结点，这些结点都具有路由器功能</p>\n</li>\n<li><p>移动自组织网络把移动性拓展到无线领域中的自治系统，具有自己特定的路由选择协议，并且可以不和因特网相连</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"令牌环网的基本原理\"><a href=\"#令牌环网的基本原理\" class=\"headerlink\" title=\"令牌环网的基本原理\"></a>令牌环网的基本原理</h2><ul>\n<li><p>令牌环网的每一站通过电缆与环形接口干线耦合器（TCU）相连。TCU的主要作用是：传递所有经过的帧，为接入站发送和接收数据提供接口</p>\n</li>\n<li><p>控制机制</p>\n<ul>\n<li><p>分布式控制模式的循环方法</p>\n</li>\n<li><p>拿到令牌就可以占有信道发送数据</p>\n</li>\n</ul>\n</li>\n<li><p>物理上采用星型拓扑结构，但逻辑上仍是环形拓扑结构</p>\n</li>\n</ul>\n<h1 id=\"广域网\"><a href=\"#广域网\" class=\"headerlink\" title=\"广域网\"></a>广域网</h1><h2 id=\"广域网的基本概念\"><a href=\"#广域网的基本概念\" class=\"headerlink\" title=\"广域网的基本概念\"></a>广域网的基本概念</h2><ul>\n<li><p>通常是覆盖范围很广的长距离网络</p>\n</li>\n<li><p>广域网由节点交换机以及连接这些交换机的链路组成</p>\n<ul>\n<li>节点交换机用来将分组存储和转发</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"广域网与局域网对比\"><a href=\"#广域网与局域网对比\" class=\"headerlink\" title=\"广域网与局域网对比\"></a>广域网与局域网对比</h2><ul>\n<li><p>广域网</p>\n<ul>\n<li>局域网</li>\n</ul>\n</li>\n<li><p>覆盖范围：很广，通常跨区域</p>\n<ul>\n<li>覆盖范围：较小，通常在一个区域内</li>\n</ul>\n</li>\n<li><p>连接方式：点到点连接</p>\n<ul>\n<li>连接方式：多点接入</li>\n</ul>\n</li>\n<li><p>OSI层次：物理层、数据链路层、网络层</p>\n<ul>\n<li>OSI层次：物理层、数据链路层</li>\n</ul>\n</li>\n<li><p>着重点：强调资源共享</p>\n<ul>\n<li>着重点：强调数据传输</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"PPP协议\"><a href=\"#PPP协议\" class=\"headerlink\" title=\"PPP协议\"></a>PPP协议</h2><ul>\n<li><p>概要：使用串行线路通信的面向字节的协议，该协议应用在直接连接两个结点的链路上</p>\n</li>\n<li><p>目的：主要是用来通过拨号或专线方式建立点对点连接发送数据</p>\n</li>\n<li><p>PPP协议是在SLIP协议的基础上发展而来的，它既可以在异步线路上传输，又可以在同步线路上使用；不仅用于Modem链路，也可用于租用的路由器到路由器的线路</p>\n</li>\n<li><p>背景：SLIP主要完成数据报的传送，但没有寻址、数据检验、分组类型识别和数据压缩等功能，只能传送IP分组</p>\n</li>\n<li><p>组成部分</p>\n<ul>\n<li><p>链路控制协议（LCP）：一种扩展链路控制协议，用于建立、配置、测试和管理数据链路</p>\n</li>\n<li><p>网络控制协议（NCP）：PPP协议允许同时采用多种网络层协议，每个不同的网络层协议要一个相应的NCP来配置，为网络层协议建立和配置逻辑连接</p>\n</li>\n<li><p>一个将IP数据报封装到串行链路的方法：IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元（MTU）的限制</p>\n</li>\n</ul>\n</li>\n<li><p>注意</p>\n<ul>\n<li><p>PPP提供差错检测但不提供纠错功能，只保证无差错接收（通过硬件进行CRC校验）。它是不可靠的传输协议，因此也不使用序号和确认机制</p>\n</li>\n<li><p>它仅支持点对点的链路通信，不支持多点线路</p>\n</li>\n<li><p>PPP只支持双全工链路</p>\n</li>\n<li><p>PPP的两端可以运行不同的网络层协议，但仍然可使用同一个PPP进行通信</p>\n</li>\n<li><p>PPP是面向字节的</p>\n<ul>\n<li><p>当信息字段出现和标志字段一致的比特组合时</p>\n<ul>\n<li><p>PPP用在一步链路（默认），则采用字节填充法</p>\n</li>\n<li><p>PPP用在SONET&#x2F;SDH等同步线路，则协议规定采用硬件来完成比特填充（和HDLC的做法一样）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HDLC协议\"><a href=\"#HDLC协议\" class=\"headerlink\" title=\"HDLC协议\"></a>HDLC协议</h2><ul>\n<li><p>概要</p>\n<ul>\n<li><p>数据报文可以透明传输，用于实现透明传输的0比特插入法易于硬件实现</p>\n</li>\n<li><p>全双工通信，有较高的数据链路通信效率</p>\n</li>\n<li><p>传输控制功能与处理功能分离，具有较大的灵活性</p>\n</li>\n<li><p>所有帧采用CRC校验，对信息帧进行顺序编号，可防止漏发或重发，传输可靠性高</p>\n</li>\n</ul>\n</li>\n<li><p>两种配置方式</p>\n<ul>\n<li><p>非平衡配置的特点是由一个主站控制整个链路的工作</p>\n</li>\n<li><p>平衡配置的特点是链路两端的两个站都是复合站，每个复合站都可以平等地发起数据传输，而不需要得到对方复合站的允许</p>\n</li>\n</ul>\n</li>\n<li><p>站类型</p>\n<ul>\n<li><p>主站：负责控制链路的操作，主站发出的帧称为控制帧</p>\n</li>\n<li><p>从站：受控于主站，按助战的命令进行操作发出的帧称为响应</p>\n</li>\n<li><p>复合站：可以发出命令帧和响应帧</p>\n</li>\n</ul>\n</li>\n<li><p>数据操作方式</p>\n<ul>\n<li><p>常响应方式：这是一种非平衡结构操作方式，即主站向从站传输数据，从站响应传输，但从站只有得到主站许可后，才可进行响应</p>\n</li>\n<li><p>异步平衡方式：这是一种平衡结构操作方式。在这种方式中，每个复合站都可以进行对另一站的数据传输</p>\n</li>\n<li><p>异步响应方式：这是一种非平衡结构操作方式。在这种方式中，从站即使未受到主站的允许，也可进行传输</p>\n</li>\n</ul>\n</li>\n<li><p>HDLC帧</p>\n<ul>\n<li><p>信息帧（D）：第1位为0，用来传输数据信息，或使用捎带技术对数据进行确认</p>\n</li>\n<li><p>监督帧（S）：第1、2位分别为1、0，用于对流量控制和差错控制，执行对数据帧的确认、请求重发和请求暂停发送等功能</p>\n</li>\n<li><p>无编号帧（U）：第1、2位均为1，用于提供对链路的建立、拆除等多种控制功能。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数据链路层设备\"><a href=\"#数据链路层设备\" class=\"headerlink\" title=\"数据链路层设备\"></a>数据链路层设备</h1><h2 id=\"网桥的概念及其基本原理\"><a href=\"#网桥的概念及其基本原理\" class=\"headerlink\" title=\"网桥的概念及其基本原理\"></a>网桥的概念及其基本原理</h2><ul>\n<li><p>两个或多个以太网通过网桥连接后，就成为一个覆盖范围更大的以太网，而原来的每个以太网就成为一个网段</p>\n</li>\n<li><p>网桥工作在链路层的MAC子层，可以使以太网各网段称为隔离开的碰撞域</p>\n</li>\n<li><p>基本特点</p>\n<ul>\n<li><p>具备寻址和路径选择能力，可以确认帧的传输方向</p>\n</li>\n<li><p>从源网络接收帧，以目的网络的介质访问控制协议向目的网络转发该帧</p>\n</li>\n<li><p>网桥在不同或相同类型的LAN之间存储并转发帧，必要时还进行链路层上的协议转换</p>\n</li>\n<li><p>网桥对接收到的帧不做任何修改，或只对帧的封装格式做很少的修改</p>\n</li>\n<li><p>可以把原协议的信息短的内容作为另一种协议的信息部分封装在帧中</p>\n</li>\n<li><p>有足够大的缓冲空间</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>能过滤通行量</p>\n</li>\n<li><p>扩大了物理范围</p>\n</li>\n<li><p>可使用不同的物理层</p>\n</li>\n<li><p>可互联不同类型的局域网</p>\n</li>\n<li><p>提高了可靠性</p>\n</li>\n<li><p>性能得到改善</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>增大了时延</p>\n</li>\n<li><p>只适用于用户数不多和通信量不大的网络</p>\n</li>\n<li><p>没有流量控制功能</p>\n</li>\n<li><p>不同MAC子层的网段桥接在一起需要进行帧格式转换</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"路径选择算法\"><a href=\"#路径选择算法\" class=\"headerlink\" title=\"路径选择算法\"></a>路径选择算法</h2><ul>\n<li><p>透明网桥（选择的不是最佳路由）</p>\n<ul>\n<li><p>建立转发表，采用自学习算法处理收到的帧</p>\n</li>\n<li><p>工作原理</p>\n<ul>\n<li><p>如果源LAN和目的LAN相同，那么丢弃该帧</p>\n</li>\n<li><p>如果源LAN和目的LAN不同，那么转发该帧</p>\n</li>\n<li><p>如果目的LAN未知，那么扩散该帧</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>源路由网桥（选择的是最佳路由）</p>\n<ul>\n<li><p>路由选择由选择数据帧的源站负责，网桥只根据数据真正的路由信息对帧进行接收和转发</p>\n</li>\n<li><p>源站以广播方式向目的站发送一个发现帧（Discovery Frame）作为探测只用，然后根据经过的结点生成最佳路径</p>\n</li>\n<li><p>缺陷</p>\n<ul>\n<li>如果发现帧过多，会导致网络出现阻塞</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"局域网交换机及其工作原理\"><a href=\"#局域网交换机及其工作原理\" class=\"headerlink\" title=\"局域网交换机及其工作原理\"></a>局域网交换机及其工作原理</h2><ul>\n<li><p>局域网交换机</p>\n<ul>\n<li><p>又称以太网交换机，从本质上说，以太网交换机是一个多端口的网桥</p>\n</li>\n<li><p>能经济地将网络分成小的冲突域，为每个工作站提供更高的带宽</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>对工作站是透明的，管理低廉开销</p>\n</li>\n<li><p>简化了网络节点的增加、移动和网络变化的操作</p>\n</li>\n<li><p>方便地实现虚拟局域网（VLAN）</p>\n<ul>\n<li>VLAN可以隔离冲突域，而且可以隔离广播域</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>原理</p>\n<ul>\n<li><p>检测从以太网端口来的数据帧的源和目的地的MAC（介质访问层）地址，然后与系统内部的动态查找表进行比较</p>\n</li>\n<li><p>若数据帧的MAC地址不在查找表中，则将该地址加入查找表，并将数据帧发送给对应的目的端口</p>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>工作在全双工方式</p>\n</li>\n<li><p>碰撞地传输数据</p>\n</li>\n<li><p>转发表也是通过自学习算法自动地逐步建立起来的</p>\n</li>\n<li><p>使用了专用的交换结构芯片，因此交换效率较高</p>\n</li>\n<li><p>独占传输媒体的带宽</p>\n</li>\n</ul>\n</li>\n<li><p>两种交换模式</p>\n<ul>\n<li><p>直通式交换机</p>\n<ul>\n<li><p>只检查帧的目的地址，数据帧可以马上就被传输出去</p>\n</li>\n<li><p>优点：速度快</p>\n</li>\n<li><p>缺点：缺乏智能性和安全性，也无法支持具有不同速率的端口的交换</p>\n</li>\n</ul>\n</li>\n<li><p>存储转发式交换机</p>\n<ul>\n<li><p>先将接收到的帧缓存，然后并检查数据是否正确</p>\n<ul>\n<li><p>正确就发送出去</p>\n</li>\n<li><p>发现帧有错，那么就将其丢弃</p>\n</li>\n</ul>\n</li>\n<li><p>优点：可靠性高，并能支持不同速率端口间的转换</p>\n</li>\n<li><p>缺点：延迟较大</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","4.计算机网络","3.数据链路层"],"tags":["写作"]},{"title":"物理层","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_2.%E7%89%A9%E7%90%86%E5%B1%82/","content":"<h1 id=\"通信基础\"><a href=\"#通信基础\" class=\"headerlink\" title=\"通信基础\"></a>通信基础</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><h2 id=\"奈奎斯特定理与香农定理\"><a href=\"#奈奎斯特定理与香农定理\" class=\"headerlink\" title=\"奈奎斯特定理与香农定理\"></a>奈奎斯特定理与香农定理</h2><h2 id=\"编码与调制\"><a href=\"#编码与调制\" class=\"headerlink\" title=\"编码与调制\"></a>编码与调制</h2><h2 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h2><h2 id=\"报文交换\"><a href=\"#报文交换\" class=\"headerlink\" title=\"报文交换\"></a>报文交换</h2><h2 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h2><h2 id=\"数据报服务\"><a href=\"#数据报服务\" class=\"headerlink\" title=\"数据报服务\"></a>数据报服务</h2><h2 id=\"虚电路服务\"><a href=\"#虚电路服务\" class=\"headerlink\" title=\"虚电路服务\"></a>虚电路服务</h2><h2 id=\"通信方式\"><a href=\"#通信方式\" class=\"headerlink\" title=\"通信方式\"></a>通信方式</h2><h2 id=\"串行传输-amp-并行传输\"><a href=\"#串行传输-amp-并行传输\" class=\"headerlink\" title=\"串行传输&amp;并行传输\"></a>串行传输&amp;并行传输</h2><h2 id=\"同步传输-amp-异步传输\"><a href=\"#同步传输-amp-异步传输\" class=\"headerlink\" title=\"同步传输&amp;异步传输\"></a>同步传输&amp;异步传输</h2><h1 id=\"传输介质\"><a href=\"#传输介质\" class=\"headerlink\" title=\"传输介质\"></a>传输介质</h1><h2 id=\"双绞线、同轴电缆、光纤与无线传输介质\"><a href=\"#双绞线、同轴电缆、光纤与无线传输介质\" class=\"headerlink\" title=\"双绞线、同轴电缆、光纤与无线传输介质\"></a>双绞线、同轴电缆、光纤与无线传输介质</h2><h2 id=\"物理接口的特性\"><a href=\"#物理接口的特性\" class=\"headerlink\" title=\"物理接口的特性\"></a>物理接口的特性</h2><h1 id=\"物理层设备\"><a href=\"#物理层设备\" class=\"headerlink\" title=\"物理层设备\"></a>物理层设备</h1><h2 id=\"中继器\"><a href=\"#中继器\" class=\"headerlink\" title=\"中继器\"></a>中继器</h2><h2 id=\"集线器（Hub）\"><a href=\"#集线器（Hub）\" class=\"headerlink\" title=\"集线器（Hub）\"></a>集线器（Hub）</h2><ul>\n<li>只起到信号放大和转发作用，扩大网络的传输范围</li>\n</ul>\n","categories":["计算机408","4.计算机网络","2.物理层"],"tags":["写作"]},{"title":"网络层","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_4.%E7%BD%91%E7%BB%9C%E5%B1%82/","content":"<h1 id=\"网络层的功能\"><a href=\"#网络层的功能\" class=\"headerlink\" title=\"网络层的功能\"></a>网络层的功能</h1><h2 id=\"主要任务\"><a href=\"#主要任务\" class=\"headerlink\" title=\"主要任务\"></a>主要任务</h2><ul>\n<li><p>把分组从源端传到目的段，为分组交换网的不同主机提供通信服务。网络层传输单位是数据报。</p>\n</li>\n<li><p>分组是数据报进行切割后形成的片段。</p>\n</li>\n</ul>\n<h2 id=\"异构网络互联\"><a href=\"#异构网络互联\" class=\"headerlink\" title=\"异构网络互联\"></a>异构网络互联</h2><ul>\n<li><p>异构网络</p>\n<ul>\n<li>不同的寻址方案、不同的网络接入机制、不同的差错处理方法、不同的路由选择机制等</li>\n</ul>\n</li>\n<li><p>网络互联</p>\n<ul>\n<li>将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备（即中间设备）相互连接起来，以构成更大的网络系统</li>\n</ul>\n</li>\n<li><p>中继系统</p>\n<ul>\n<li><p>网络层中继系统</p>\n<ul>\n<li>中继器、集线器（Hub）</li>\n</ul>\n</li>\n<li><p>数据链路层中继系统</p>\n<ul>\n<li>网桥或交换机</li>\n</ul>\n</li>\n<li><p>网络层中继系统和数据链路层中继系统备注：使用物理层或数据链路层的中继系统时，只是把一个网络扩大了，而从网络层的角度看，它仍然是同一个网络，一般并不称之为网络互联</p>\n</li>\n<li><p>网络层中继系统</p>\n<ul>\n<li><p>路由器</p>\n</li>\n<li><p>TCP&#x2F;IP体系在网络互联上采用的做法是在网络层（即IP层）采用标准化协议，相互连接的网络可以是异构的</p>\n</li>\n</ul>\n</li>\n<li><p>网络层以上的中继系统</p>\n<ul>\n<li>网关</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>虚拟互联网络</p>\n<ul>\n<li><p>也就是逻辑互联网络，即互联起来的各种网络结构的异构性本来是客观存在的，但是通过使用IP就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互联的具体的网络异构细节（如具体的编址方案、路由选择协议等）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"路由选择与分组转发\"><a href=\"#路由选择与分组转发\" class=\"headerlink\" title=\"路由选择与分组转发\"></a>路由选择与分组转发</h2><ul>\n<li><p>功能</p>\n<ul>\n<li><p>路由选择（确定哪一条路径）</p>\n<ul>\n<li><p>根据特定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表</p>\n</li>\n<li><p>按照复杂的分布式算法，根据从相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由</p>\n</li>\n</ul>\n</li>\n<li><p>分组转发（当一个分组到达时所采取的动作）</p>\n<ul>\n<li><p>处理通过路由器的数据流，关键操作是转发表查询、转发及相关的队列管理和任务调度等</p>\n</li>\n<li><p>路由器根据转发表将用户的IP数据表从合适的端口转发出去</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><ul>\n<li><p>在通信子网中，因出现过量的分组而引起网络性能下降的现象称为拥塞</p>\n</li>\n<li><p>判断拥塞状态的方法</p>\n<ul>\n<li><p>轻度拥塞</p>\n<ul>\n<li>随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量</li>\n</ul>\n</li>\n<li><p>拥塞状态</p>\n<ul>\n<li>网络的吞吐量随着网络负载的增大而下降</li>\n</ul>\n</li>\n<li><p>死锁状态</p>\n<ul>\n<li>网络的负载继续增大，而网络的吞吐量下降到零</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>避免拥塞控制</p>\n<ul>\n<li>获取网络中发生拥塞的信息，从而利用这些信息进行控制，以避免由于拥塞而出现分组的丢失，以及严重拥塞而产生网络死锁的现象</li>\n</ul>\n</li>\n<li><p>作用</p>\n<ul>\n<li>确保子网能够承载所达到的流量</li>\n</ul>\n</li>\n<li><p>实现方法</p>\n<ul>\n<li><p>合理优化主机、路由器及路由器内部的转发处理过程等</p>\n</li>\n<li><p>单一地增加资源并不能解决拥塞</p>\n</li>\n</ul>\n</li>\n<li><p>流量控制与拥塞控制的区别</p>\n<ul>\n<li><p>流量控制所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收</p>\n</li>\n<li><p>拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，设计网络中所有的主机、路由器及导致网络传输能力下降的所有因素</p>\n</li>\n</ul>\n</li>\n<li><p>拥塞控制的方法</p>\n<ul>\n<li><p>开环控制</p>\n<ul>\n<li><p>设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>一种静态的预防方法，一旦整个系统启动并运行，中途就不再需要修改</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>闭环控制</p>\n<ul>\n<li><p>事先不考虑有关发生拥塞的各种因素，采用监测网络系统去检测，及时检测出哪里发生了拥塞，然后将拥塞信息传到合适的地方</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li>基于反馈环路的概念，是一种动态的方法</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"路由算法\"><a href=\"#路由算法\" class=\"headerlink\" title=\"路由算法\"></a>路由算法</h1><h2 id=\"路由表-x2F-转发表：包括目的网络地址，子网掩码，下一跳IP地址，接口\"><a href=\"#路由表-x2F-转发表：包括目的网络地址，子网掩码，下一跳IP地址，接口\" class=\"headerlink\" title=\"路由表&#x2F;转发表：包括目的网络地址，子网掩码，下一跳IP地址，接口\"></a>路由表&#x2F;转发表：包括目的网络地址，子网掩码，下一跳IP地址，接口</h2><h2 id=\"路由算法：\"><a href=\"#路由算法：\" class=\"headerlink\" title=\"路由算法：\"></a>路由算法：</h2><ul>\n<li>路由算法选择出最佳路由方式，将这个路由方式添加到路由表项中。<ul>\n<li>最佳路由：相对于每一种特定要求下的较为合理的选择。一般选择经过跳数最短，传输时延（发送时延）通常大于传播时延。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"路由算法分类：静态路由与动态路由\"><a href=\"#路由算法分类：静态路由与动态路由\" class=\"headerlink\" title=\"路由算法分类：静态路由与动态路由\"></a>路由算法分类：静态路由与动态路由</h2><ul>\n<li><p>静态路由算法（又称非自适应路由算法）</p>\n<ul>\n<li><p>概念</p>\n<ul>\n<li><p>由网络管理员手工配置的路由信息</p>\n</li>\n<li><p>手动配置：目的网络地址，子网掩码，下一跳IP地址，接口</p>\n</li>\n<li><p>当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>（配置）简便、可靠（安全性高），在负荷稳定、拓扑变化不大的网络中运行效果很好（对运行协议的设备的性能要求低）</p>\n<ul>\n<li>拓扑变化不大：拓扑不经常变化，不会频繁的有主机加入或离开</li>\n</ul>\n</li>\n<li><p>广泛用于高度安全性的军事网络和较小的商业网络</p>\n</li>\n</ul>\n</li>\n<li><p>缺陷</p>\n<ul>\n<li><p>路由更新慢</p>\n<ul>\n<li>发生变化后需要大范围修改和调整路由信息，人工难以频繁更新路由表</li>\n</ul>\n</li>\n<li><p>管理员难以全面了解网络拓扑结构</p>\n</li>\n</ul>\n</li>\n<li><p>使用范围</p>\n<ul>\n<li><p>广泛用于高度安全的军事系统和较小的商业网络</p>\n</li>\n<li><p>不适用于大型和复杂的网络环境</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>动态路由算法（又称自适应路由算法）</p>\n<ul>\n<li><p>概念</p>\n<ul>\n<li><p>路由器上的路由表项是通过相互连接的路由器之间彼此交换信息，然后按照一定的路由算法优化出路由表项</p>\n</li>\n<li><p>路由信息会在一定时间间隙里不断更新，以适应不断变化的网络，随时获得最优的寻路效果。</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>路由更新快，能够及时响应链路费用或网络拓扑变化</p>\n<ul>\n<li>链路费用：路经的代价，或者为跳数</li>\n</ul>\n</li>\n<li><p>改善网络的性能（根据链路费用及时改变路径）并有助于流量控制（根据链路上负载状况更改路径）</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>算法本身比较复杂，运行时会增加网络的负担</p>\n</li>\n<li><p>路由算法设计复杂</p>\n<ul>\n<li>防止路由器对动态变化的反应太快而引起振荡，或反应太慢而影响网络路由的一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动态路由算法\"><a href=\"#动态路由算法\" class=\"headerlink\" title=\"动态路由算法\"></a>动态路由算法</h2><ul>\n<li><p>距离—向量路由算法（分散性算法）</p>\n<ul>\n<li><p>原理</p>\n<ul>\n<li><p>所有结点都定期地将它们的整个路由选择表传送给所有与之直接相邻的结点</p>\n</li>\n<li><p>路由器只掌握物理相邻的邻居及链路费用</p>\n</li>\n</ul>\n</li>\n<li><p>更新路由表的条化</p>\n<ul>\n<li><p>被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由</p>\n</li>\n<li><p>来的路由信息中有一条到达某个目的地的路由，该路由与当前使用的路由相比，有较短的距离（较小的代价）</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li>容易出现路由环路问题</li>\n</ul>\n</li>\n<li><p>最常见的距离一向量路由算法是RIP算法，它采用“跳数”作为距离的度量</p>\n</li>\n</ul>\n</li>\n<li><p>链路状态路由算法（全局性算法）</p>\n<ul>\n<li><p>原理</p>\n<ul>\n<li><p>链路状态路由算法要求每个参与该算法的结点都具有完全的网络拓扑和链路费用信息</p>\n</li>\n<li><p>主动测试所有邻接结点的状态</p>\n</li>\n<li><p>定期地将链路状态传播给所有其他结点（或称路由结点）</p>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>使用泛洪法向所有相邻的路由器发送信息，然后相邻路由器又向其他相邻路由器发送信息</p>\n</li>\n<li><p>发送的信息是与路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息</p>\n</li>\n<li><p>只有当链路状态发生变化时，路由器才向所有路由器发送此消息</p>\n</li>\n</ul>\n</li>\n<li><p>用于大型的或路由信息变化聚敛的互联网环境</p>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>每个路由结点都使用同样的原始状态数据独立地计算路径，而不依赖中间结点的计算</p>\n</li>\n<li><p>链路状态报文不加改变地传播，因此采用该算法易于查找故障</p>\n</li>\n<li><p>当一个结点从所有其他结点接收到报文时，它可以在本地立即计算正确的通路，保证一步汇聚</p>\n</li>\n<li><p>链路状态算法比距离—向量算法有更好的规模可伸展性</p>\n</li>\n</ul>\n</li>\n<li><p>典型的链路状态算法是OSPF算法</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"层次路由\"><a href=\"#层次路由\" class=\"headerlink\" title=\"层次路由\"></a>层次路由</h2><ul>\n<li><p>背景</p>\n<ul>\n<li><p>当网络规模扩大时，路由器的路由表成比例地增大</p>\n<ul>\n<li>这不仅会消耗越来越多的路由器缓冲区空间，而且需要用更多CPU时间来扫描路由表，用更多的带宽来交换路由状态信息</li>\n</ul>\n</li>\n<li><p>许多单位不想让外界知道直接的路由协议，但还想接入因特网</p>\n</li>\n</ul>\n</li>\n<li><p>自治系统（AS）</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li><p>单一技术管理下的一组路由器，这些路由器使用一种AS内部的路由选择协议和共同的度量来确定分组在该AS内的路由</p>\n<ul>\n<li>一个AS内的所有网络都属于一个行政单位来管辖，一个AS内的所有路由器都必须相互连通。</li>\n</ul>\n</li>\n<li><p>同时还使用一种AS之间的路由选择协议来确定分组在AS之间的路由</p>\n</li>\n</ul>\n</li>\n<li><p>AS内部路由器不了解AS外部的路由协议，AS外部路由器 也不了解AS内部路由器，减小了路由器的负担</p>\n</li>\n</ul>\n</li>\n<li><p>路由选择协议分为：域内路由协议和域间路由协议</p>\n<ul>\n<li><p>内部网关协议（IGP）</p>\n<ul>\n<li><p>自治系统内部所使用的路由选择协议</p>\n</li>\n<li><p>常见：RIP，OSPF</p>\n</li>\n<li><p>目前内部网关协议使用的最多</p>\n</li>\n</ul>\n</li>\n<li><p>外部网关协议（ EGP）</p>\n<ul>\n<li><p>不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径</p>\n<ul>\n<li>源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时（两个自治系统可能使用不同的IGP ）需要使用一种协议将路由选择信息传递到另一个自治系统中</li>\n</ul>\n</li>\n<li><p>常见：BGP-4</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>每个路由器都知道在本AS内如何把分组路由到目的地的细节（路由），但（除边界路由器外的）不知道本AS外（AS和AS之间和其他AS内）的结构</p>\n</li>\n<li><p>使交换信息的种类增多，但也会使OSPF协议更加复杂</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"IPV4\"><a href=\"#IPV4\" class=\"headerlink\" title=\"IPV4\"></a>IPV4</h1><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><ul>\n<li><p>IPV4即现在普遍使用的IP （版本4）</p>\n</li>\n<li><p>IP定义数据传送的基本单元——IP分组及其确切的数据格式</p>\n</li>\n<li><p>IP也包括一套规则，指明分组如何处理、错误怎样控制</p>\n</li>\n<li><p>包含非可靠投递的思想，以及与此关联的分组路由选择的思想</p>\n</li>\n</ul>\n<h2 id=\"IPV4分组\"><a href=\"#IPV4分组\" class=\"headerlink\" title=\"IPV4分组\"></a>IPV4分组</h2><ul>\n<li><p>IPV4分组格式</p>\n<ul>\n<li><p>首部的固定部分（20字节）</p>\n<ul>\n<li><p>版本：指IP版本，目前广泛使用的版本号是4</p>\n</li>\n<li><p>首部长度：占4位。基本单位为4B ，最大值为60B （ 15*4B ），最常用的首部长度是20B</p>\n</li>\n<li><p>区分服务：占8位，指期望获取哪种类型的服务，设置数据报的优先级。</p>\n</li>\n<li><p>总长度：占16位。基本单位为1B，指首部与数据之和（整个IP数据报）的长度最大长度65535B。长度远不会达到上限值，长度过大就会进行分片。</p>\n</li>\n<li><p>标识：占16位。同一数据报的分片使用同一标识，是一个计数器，用于保证数据报片能够正确组装成原来的数据报</p>\n</li>\n<li><p>标志：占3位，最低位MF，中间位DF</p>\n<ul>\n<li><p>MF （ more fragment）：为1代表进行了分片且后面还有分片，为1代表这是最后一片或者没有进行分片。只有在DF为0时，MF才有意义。</p>\n</li>\n<li><p>DF (don’t fragment) :为0时才可以进行分片，为1时不允许分片</p>\n</li>\n</ul>\n</li>\n<li><p>片偏移：占13位，指出分片后，某片在原分组中的相对位置。片偏移以8个字节为偏移单位，即除最后一个分片外的每个分片的长度一定是8B（64位）的整数倍。</p>\n</li>\n<li><p>生存时间TTL：占8位，保证分组不会在网络中循环，每次路由转发TTL-1，当TTL为0，丢弃该分组。</p>\n</li>\n<li><p>协议：占8位指出该分组的数据部分所使用的协议（6为TCP协议17为UDP协议）</p>\n</li>\n<li><p>首部校验和：占16位，IP数据报的首部校验和只校验分组的首部，而不校验数据部分。每经过一台路由器都要重新计算首部检验和，因为生存时间&#x2F;标志&#x2F;片偏移都有可能改变。判断首部是否出错，出错则丢弃。</p>\n</li>\n<li><p>源地址字段：占4B，标识发送发的IP地址</p>\n</li>\n<li><p>目的地址字段：占4B，标识接收方的IP地址</p>\n</li>\n</ul>\n</li>\n<li><p>首部的可变部分</p>\n<ul>\n<li><p>可选字段：用来支持排错，测量以及安全措施。</p>\n</li>\n<li><p>填充字段：全0，将首部长度填充成4字节的整数倍。</p>\n</li>\n</ul>\n</li>\n<li><p>数据部分</p>\n</li>\n</ul>\n</li>\n<li><p>字段单位总结：</p>\n<ul>\n<li><p>总长度单位：1字节</p>\n</li>\n<li><p>片偏移单位：8字节</p>\n</li>\n<li><p>首部长度单位：4字节</p>\n</li>\n</ul>\n</li>\n<li><p>IP数据报分片</p>\n<ul>\n<li><p>最大传送单元（MTU） ：一个链路层数据报能承载的最大数据量</p>\n</li>\n<li><p>MTU</p>\n<ul>\n<li><p>以太网：1500B</p>\n</li>\n<li><p>广域网：一般不超过576B</p>\n</li>\n</ul>\n</li>\n<li><p>分片：当数据报长度大于链路MTU时，就要对其进行分片传输</p>\n</li>\n<li><p>分片会在目的地进行组装，不会在中间路由处进行组装</p>\n</li>\n</ul>\n</li>\n<li><p>网络层转发分组的流程</p>\n<ul>\n<li><p>提取目的主机的IP地址</p>\n</li>\n<li><p>直接交付或者根据路由表进行转发交付</p>\n</li>\n<li><p>若找不到目标路由就发送给默认路由</p>\n</li>\n<li><p>如果最后没有转发成功，就报告转发分组出错</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IPV4地址与NAT\"><a href=\"#IPV4地址与NAT\" class=\"headerlink\" title=\"IPV4地址与NAT\"></a>IPV4地址与NAT</h2><ul>\n<li><p>IPV4地址</p>\n<ul>\n<li><p>IP地址</p>\n<ul>\n<li><p>连接到因特网上的每台主机（或路由器）都分配一个32比特的全球唯一标识符</p>\n</li>\n<li><p>标识主机或路由器的接口</p>\n</li>\n</ul>\n</li>\n<li><p>IP编址的历史阶段</p>\n<ul>\n<li><p>第一阶段：分类的IP地址</p>\n</li>\n<li><p>第二阶段：子网的划分</p>\n</li>\n<li><p>第三阶段：构成超网（无分类编址方法）</p>\n</li>\n</ul>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>A类（1-126）</p>\n<ul>\n<li><p>最大可用网络数：2^7-2（全0，环回地址127）</p>\n</li>\n<li><p>第一个可用网络号：1，最后一个可用网络号：126</p>\n</li>\n<li><p>每个网络中的最大主机数：2^24-2（全0-网络号，全1-广播地址）</p>\n</li>\n</ul>\n</li>\n<li><p>B类(128-191)</p>\n<ul>\n<li><p>最大可用网络数：2^14-1（网络号128.0不分配）</p>\n</li>\n<li><p>第一个可用的网络号：128.1，最后一个可用的网络号：191.255</p>\n</li>\n<li><p>每个网络中最大主机数：2^16-2</p>\n</li>\n</ul>\n</li>\n<li><p>C类(192-223)</p>\n<ul>\n<li><p>最大可用网络数：2^21-1（网络号192.0.0不分配）</p>\n</li>\n<li><p>第一个可用的网络号：192.0.1，最后一个可用的网络号：223.255.255</p>\n</li>\n<li><p>每个网络中最大主机数：2^8-2</p>\n</li>\n</ul>\n</li>\n<li><p>D 类（224–239）</p>\n</li>\n<li><p>E 类(240-255)</p>\n</li>\n<li><p>图示<img src=\"https://api2.mubu.com/v3/document_image/3b8f19be-e800-4771-8031-5a45cd86992f-3224585.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>特殊含义地址</p>\n<ul>\n<li><p>32位全为0，可以作为IP分组源地址，不能作为IP分组的目的地址，即0.0.0.0表示本网络上的本主机</p>\n</li>\n<li><p>网络号全为0，主机号为特定值，可以作为IP分组源地址，不能作为IP分组的目的地址，即表示本网内的某个特定主机</p>\n</li>\n<li><p>特殊含义地址32位全为1，即255.255.255.255表示整个TCP&#x2F;P网络的广播地址，又称受限广播地址，不能作为IP分组源地址，可以作为IP分组的目的地址，路由器不转发（路由器隔离广播域，不会将该分组转发出去），实际使用时，由于路由器对广播域的隔离， 255.255.255.255等效为本网络的广播地址</p>\n</li>\n<li><p>网络号是特定值，主机号全为0表示本网络本身，如202.98.174.0，不能作为IP分组源地址，不能作为IP分组的目的地址</p>\n</li>\n<li><p>网络号是特定值，主机号全为1表示特定网络的广播地址，又称直接广播地址，如202.98.174.255，可以不是本网络</p>\n</li>\n<li><p>网络号为127，主机号为非全0&#x2F;1，保留为环路自检（Loopback Test）地址，此地址表示任意主机本身，目的地址为环回地址的IP数据报永远不会出现在任何网络上（永远不会离开主机），用于本地软件环回测试，称为环回地址</p>\n</li>\n</ul>\n</li>\n<li><p>私有IP地址</p>\n<ul>\n<li><p>A类：10.0.0.0～10.255.255.255，网段：1个</p>\n</li>\n<li><p>B类：172.16.0.0～172.31.255.255，网段：16个</p>\n</li>\n<li><p>C类：192.168.0.0～192.168.255.255，网段：256个</p>\n</li>\n<li><p>内部网络使用的IP地址，在外部网络上，这些IP地址是无效的</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>网络地址转换（NAT）</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li><p>通过将专用网络地址（如Intranet ）转换为公用地址（如Internet ），从而对外隐藏内部管理的IP地址</p>\n</li>\n<li><p>在专用网连接到因特网的路由器上安装NAT软件，安装了NAT软件的路由器叫NAT路由器，它至少有一个外部有效的全球IP地址。</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>只需要一个全球IP地址就可以与因特网连通，由于专用网本地IP地址是可重用的，所以NAT大大节省了IP地址的消耗</p>\n</li>\n<li><p>隐藏了内部网络结构，从而降低了内部网络受到攻击的风险</p>\n</li>\n</ul>\n</li>\n<li><p>具体实现</p>\n<ul>\n<li><p>本地地址的主机和外界通信时， NAT路由器使用NAT转换表将本地地址转换成全球地址，或将全球地址转换成本地地址</p>\n</li>\n<li><p>NAT转换表</p>\n<ul>\n<li><p>WAN端（广域网端）</p>\n<ul>\n<li>IP地址+端口号，例：172.38.1.5:40001</li>\n</ul>\n</li>\n<li><p>LAN端（局域网端）</p>\n<ul>\n<li>IP地址+端口号，例：192.168.0.3:30000</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>主机A向主机B发送数据报，封装源IP：192.168.0.3，目的IP：213.18.2.4，端口号为30000</p>\n</li>\n<li><p>数据报到达NAT路由器时，使用NAT转换表对应的WAN端IP和端口号，替换源IP地址和端口号。</p>\n</li>\n<li><p>主机B向主机A发送数据报，封装目的IP：172.38.1.5，源IP：213.18.2.4，端口号为40001</p>\n</li>\n<li><p>数据报到达NAT路由器时，根据NAT转换表对应的LAN端IP和端口号，替换目的地址和端口号。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注意</p>\n<ul>\n<li><p>普通路由器在转发IP数据报时，不改变其源IP地址和目的IP地址</p>\n</li>\n<li><p>NAT路由器在转发IP数据报时，一定要更换其IP地址</p>\n</li>\n<li><p>普通路由器仅工作在网络层</p>\n</li>\n<li><p>NAT路由器转发数据报时需要查看和转换传输层的端口号</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"子网划分与子网掩码、CIDR\"><a href=\"#子网划分与子网掩码、CIDR\" class=\"headerlink\" title=\"子网划分与子网掩码、CIDR\"></a>子网划分与子网掩码、CIDR</h2><ul>\n<li><p>子网划分</p>\n<ul>\n<li><p>背景</p>\n<ul>\n<li><p>两级IP地址的缺点</p>\n<ul>\n<li><p>IP地址空间的利用率有时很低</p>\n<ul>\n<li>为了未来的可扩展性，每个公司在申请IP地址的时候都会申请较多的IP地址，就造成了部分IP地址未使用</li>\n</ul>\n</li>\n<li><p>两级的IP地址不够灵活</p>\n<ul>\n<li>每次申请一个网络时，都需要向ISP申请，使得创建新网络不够灵活</li>\n</ul>\n</li>\n<li><p>会使路由表变得太大而使网络性能变坏</p>\n<ul>\n<li>一个A类网络内的任何一台路由器都要加载特别大的路由表</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>概述</p>\n<ul>\n<li>两级IP地址变成了三级IP地址，从主机号中拿出一部分作为子网号。</li>\n</ul>\n</li>\n<li><p>划分思路</p>\n<ul>\n<li><p>子网划分纯属一个单位内部的事情，单位对外仍然表现为没有划分子网的网络</p>\n</li>\n<li><p>从主机号借用若干比特作为子网号，当然主机号也就相应减少了相同的比特划分，主机位最少保留两位（全0，全1不能用）</p>\n</li>\n<li><p>IP地址&#x3D;{（网络号），（子网号），（主机号）}</p>\n</li>\n<li><p>先找到连接到本单位网络上的路由器。然后该路由器在收到IP数据报后，按目的网络号和子网号找到目的子网。最后把IP数据报直接交付给目的主机</p>\n</li>\n</ul>\n</li>\n<li><p>注意</p>\n<ul>\n<li><p>在最初对IPv4地址进行子网划分的时候，子网号不能全为0和全为1。但是随着CIDR的广泛应用，目前全0和全1的字网号也可以使用，使用时应注意路由器的路由选择软件是否支持全0和全1的子网号</p>\n</li>\n<li><p>主机号全为0为本网络号，全为1为子网的广播地址，不能作为主机地址</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>子网掩码（本单位网络的路由器发给哪个子网）</p>\n<ul>\n<li><p>使用子网掩码来表达对原网络的借位</p>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>A类：255.0.0.0</p>\n</li>\n<li><p>B类： 255.255.0.0</p>\n</li>\n<li><p>C类: 255.255.255.0</p>\n</li>\n</ul>\n</li>\n<li><p>使用子网掩码情况</p>\n<ul>\n<li><p>一台主机在设置IP地址的同时必须设置子网掩码</p>\n</li>\n<li><p>同属于一个子网的所有主机及路由器的相应端口，必须设置相同的子网掩码</p>\n</li>\n<li><p>路由表中必须包含有目的网络地址，子网掩码，下一跳地址</p>\n</li>\n</ul>\n</li>\n<li><p>子网网络地址的计算</p>\n<ul>\n<li>使用子网掩码和IP地址相与（都是1，则为1；否则为0）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用子网时分组转发过程</p>\n<ul>\n<li><p>提取出数据报中的目的IP地址</p>\n</li>\n<li><p>判断是否直接交付（是否是和本路由器直连的网络）</p>\n<ul>\n<li>使用目的地址与相连网络的各个子网掩码（网络掩码可以不同）进行相与，如果得到的结果与相连网络的网络地址匹配，则转发给这个子网</li>\n</ul>\n</li>\n<li><p>路由器中是否有特定主机路由</p>\n<ul>\n<li>特定主机路由在路由表中表现为IP地址+255.255.255.255，判断数据报的目的IP地址与特定主机路由的IP地址是否匹配</li>\n</ul>\n</li>\n<li><p>检验路由表中有无路径</p>\n<ul>\n<li>将路由表中每一行的子网掩码与数据报的目的IP地址进行相与，如果结果与路由表中的目的网络地址相匹配，则转发给该行的下一跳路由器。</li>\n</ul>\n</li>\n<li><p>检测是否存在默认路由，如果存在默认路由，则发给默认路由中的下一跳路由器（该路由器循环所有步骤），否则执行下一步</p>\n</li>\n<li><p>报告分组转发错误</p>\n</li>\n</ul>\n</li>\n<li><p>无分类域间路由选择（CIDR）</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li>无分类域间路由选择是在变长子网掩码的基础上提出的一种消除传统A、B、 C类网络划分，并且可以在软件的支持下实现超网构造的一种IP地址的划分方法</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>消除了传统A、 B、 C类地址及划分子网的概念，因而可以更有效地分配Pv4的地址空间</p>\n</li>\n<li><p>融合子网地址与子网掩码，方便子网划分</p>\n<ul>\n<li>取几位主机位，和网络前缀合并为新的网络前缀</li>\n</ul>\n</li>\n<li><p>IP&#x3D;{&lt;网络前缀&gt; ， &lt;主机号&gt;}</p>\n</li>\n<li><p>将网络前缀都相同的连续IP地址组成：CIDR地址块</p>\n<ul>\n<li>这种地址的聚合称为路由聚合，或称构成超网</li>\n</ul>\n</li>\n<li><p>网络前缀越长，其地址块就越小，路由就越具体</p>\n</li>\n</ul>\n</li>\n<li><p>构成超网（路由聚合）</p>\n<ul>\n<li><p>将转发接口相同的多个子网聚合成一个较大的子网</p>\n</li>\n<li><p>方法：将网络前缀缩短（所有网络地址取交集，求出网络1和网络2的合体网络，写入路由表，删除网络1和网络2的路由）</p>\n</li>\n</ul>\n</li>\n<li><p>最长前缀匹配</p>\n<ul>\n<li>使用CIDR时，查找路由表可能得到多个匹配结果（和网络掩码按位相与），选择最长网络前缀的路由。（思想：前缀越长，地址块越小，路由越具体）</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>（超网的优点）有利于减少路由器之间的路由选择信息的交换，提高网络性能</p>\n</li>\n<li><p>网络前缀长度具有灵活性。（上层路由器中的路由的网络前缀较短，使得路由条目少。内部又可以延长网络前缀从而灵活划分子网。使得每一层次路由器的路由条目不同，有利于提高性能）</p>\n</li>\n</ul>\n</li>\n<li><p>查找路由表使用的数据结构方法</p>\n<ul>\n<li>二叉线索树（层次性数据结构）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IP地址与硬件地址\"><a href=\"#IP地址与硬件地址\" class=\"headerlink\" title=\"IP地址与硬件地址\"></a>IP地址与硬件地址</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>IP地址是网络层使用的地址，它是分层次等级的</p>\n</li>\n<li><p>硬件地址是数据链路层使用的地址（如MAC地址），它是平面式的</p>\n</li>\n<li><p>在网络层及网络层之上使用IP地址， IP地址放在IP数据报的首部，而MAC地址放在MAC帧的首部</p>\n</li>\n<li><p>数据链路层看不见数据报分组中的IP地址</p>\n</li>\n</ul>\n</li>\n<li><p>具体关系</p>\n<ul>\n<li>在网络层中的路由器相互传输时使用IP地址，当到达目标网络后，使用MAC地址查找目标物理主机</li>\n</ul>\n</li>\n<li><p>路由器</p>\n<ul>\n<li><p>拥有多个IP地址</p>\n</li>\n<li><p>拥有多个硬件地址</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"地址解析协议（ARP）\"><a href=\"#地址解析协议（ARP）\" class=\"headerlink\" title=\"地址解析协议（ARP）\"></a>地址解析协议（ARP）</h2><ul>\n<li><p>作用：实现IP地址到MAC地址的映射（ARP就是为了获取目的MAC地址）</p>\n</li>\n<li><p>ARP表：每台主机都设有一个ARP高速缓存，用来存放本局域网上（没有局域网外的）各主机和路由器的IP地址到MAC地址的映射表</p>\n</li>\n<li><p>发送数据的过程</p>\n<ul>\n<li><p>源主机在数据链路层会封装源MAC地址和目的MAC地址（ARP就是为了获取目的MAC地址）</p>\n</li>\n<li><p>主机A将自己的子网掩码与目的IP地址进行相与，判断目的IP地址是否和本主机属于同一局域网。</p>\n</li>\n<li><p>如果属于同一个局域网：</p>\n<ul>\n<li><p>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为全1的帧封装并广播ARP请求分组（由于目的MAC为全1，局域网内的设备会进行广播），同一局域网内的所有主机都会收到该请求。</p>\n</li>\n<li><p>目的主机收到请求后会向源主机单播一个ARP响应分组（带有目的主机的IP地址和MAC地址）。源主机收到后将此映射写入ARP缓存（10min-20min更新一次）。</p>\n</li>\n<li><p>源主机收到后就会封装该目的MAC地址。</p>\n</li>\n</ul>\n</li>\n<li><p>不属于同一个局域网中：</p>\n<ul>\n<li><p>主机A广播ARP请求分组（目的IP：默认网关的IP地址，目的MAC为全1），默认网关回复一个单播ARP响应分组（带有默认网关的IP地址和MAC地址）。源主机收到后将封装该MAC地址。</p>\n</li>\n<li><p>默认网关收到数据后进行解封装，再封装时源MAC地址为默认网关转发出去的接口的MAC地址，（如果是点对点网络的PPP协议，目的MAC地址为全1，如果是多点网络，目的MAC地址需要为下一个路由器相连接口的MAC地址（再使用一次ARP协议））。</p>\n</li>\n<li><p>到达目的网络后，再次使用ARP协议获取目的MAC地址。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>ARP协议特点</p>\n<ul>\n<li><p>必须使用MAC地址，因为局域网内部只能看懂MAC地址。ARP是为了获取目的MAC地址（IP地址到MAC地址的映射，也就是下一跳去哪的问题）</p>\n</li>\n<li><p>从IP地址到硬件地址的解析是自动进行的。（主机用户不知道ARP的过程）</p>\n</li>\n<li><p>ARP协议是处于网络层与链路层之间的协议（因为结合了IP地址和MAC地址），划分为网络层协议是因为ARP协议为IP协议提供服务。</p>\n</li>\n</ul>\n</li>\n<li><p>可能出现的情况</p>\n<ul>\n<li><p>发送方是主机时，要把IP数据报发送到本网络上的另一台主机：这时用ARP找到目的主机的硬件地址</p>\n</li>\n<li><p>发送方是主机时，要把IP数据报发送到另一个网络上的一台主机：这时用ARP找到本网络上的一个路由器（网关）的硬件地址，剩下的工作由这个路由器来完成</p>\n</li>\n<li><p>发送方是路由器时，要把IP数据报转发到本网络上的一台主机：这时用ARP找到目的主机的硬件地址</p>\n</li>\n<li><p>发送方是路由器时，要把IP数据报转发到另一个网络上的一台主机：这时用ARP找到本网络上的一个路由器的硬件地址，剩下的工作由另一个路由器完成</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动态主机配置协议（DHCP）\"><a href=\"#动态主机配置协议（DHCP）\" class=\"headerlink\" title=\"动态主机配置协议（DHCP）\"></a>动态主机配置协议（DHCP）</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>常用于给主机动态地分配IP地址。</p>\n</li>\n<li><p>提供了即插即用联网的机制，这种机制允许一台计算机加入新的网络时就自动获取IP地址而不用手工参与</p>\n<ul>\n<li>获取到的信息：IP地址，子网掩码，默认网关，DNS服务器的名称与IP地址。</li>\n</ul>\n</li>\n<li><p>DHCP是应用层协议，它是基于UDP的，使用客户&#x2F;服务器方式（主机向DHCP服务器请求IP地址），客户端和服务端通过广播方式进行交互</p>\n<ul>\n<li>为什么？DHCP协议为网络层提供基础，只有有了IP地址，IP协议才会起作用。</li>\n</ul>\n</li>\n<li><p>允许地址重用</p>\n<ul>\n<li>主机A离开本网络后，原来A使用的IP地址可以被新加入的主机B使用</li>\n</ul>\n</li>\n<li><p>支持移动用户加入网络</p>\n<ul>\n<li>移动设备加入网络时，会使用DHCP服务获取IP地址。</li>\n</ul>\n</li>\n<li><p>支持在用地址续租</p>\n<ul>\n<li><p>DHCP服务器分配给DHCP客户的IP地址是临时的，因此DHCP客户只能在一段有限的时间内使用这个分配到的IP地址</p>\n</li>\n<li><p>IP地址有租用期，租用期过了，可以对在用的IP地址续租</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>DHCP客户机广播“DHCP发现“消息，试图找到网络中的DHCP服务器</p>\n</li>\n<li><p>DHCP服务器收到“DHCP发现”消息后，向网络中广播”DHCP提供”消息，其中包括提供DHCP客户机的IP地址和相关配置信息</p>\n<ul>\n<li><p>如果DHCP服务器的地址池中存在可分配IP地址，则所有可提供IP地址的DHCP服务器都会回复“DHCP提供”报文</p>\n</li>\n<li><p>IP地址和相关配置信息是拟分配，因为可以有多台DHCP服务器同时分配</p>\n</li>\n</ul>\n</li>\n<li><p>DHCP客户机收到“DHCP提供”消息，如果接收DHCP服务器所提供的相关参数，那么通过广播“DHCP请求”消息向DHCP服务器请求提供IP地址</p>\n<ul>\n<li><p>主机会请求最先收到的“DHCP提供”消息中的IP地址</p>\n</li>\n<li><p>为什么广播：其余DHCP收到后会将拟分配IP地址放回地址池</p>\n</li>\n</ul>\n</li>\n<li><p>DHCP服务器广播”DHCP确认”消息,正式将IP地址分配给DHCP客户机</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"网际控制报文协议（ICMP）\"><a href=\"#网际控制报文协议（ICMP）\" class=\"headerlink\" title=\"网际控制报文协议（ICMP）\"></a>网际控制报文协议（ICMP）</h2><ul>\n<li><p>目的</p>\n<ul>\n<li><p>为了提高IP数据报交付成功的机会，在网络层使用了网际控制报文协议（ ICMP）来让主机或路由器报告差错和异常情况，或者网络探询</p>\n</li>\n<li><p>网络层收到错误分组时，直接丢弃。同时需要发送差错报文（就是ICMP报文）</p>\n</li>\n</ul>\n</li>\n<li><p>封装位置：ICMP报文封装在IP数据报的数据部分，所以ICMP是网络层协议</p>\n</li>\n<li><p>字段</p>\n<ul>\n<li><p>类型：1字节</p>\n</li>\n<li><p>代码：1字节，进一步区分各个类型中的不同情况</p>\n</li>\n<li><p>检验和：2字节，检验整个ICMP报文（IP数据报的首部检验和只检验首部，并不检验数据部分）</p>\n</li>\n<li><p>4个字节取决于ICMP报文类型</p>\n</li>\n<li><p>ICMP数据部分：长度取决于类型</p>\n</li>\n</ul>\n</li>\n<li><p>种类</p>\n<ul>\n<li><p>ICMP差错报告报文（5种）</p>\n<ul>\n<li><p>终点不可达：当路由器或主机不能向上层交付数据报时，就向源点发送终点不可达报文</p>\n</li>\n<li><p>源点抑制：当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</p>\n</li>\n<li><p>时间超过：当路由器收到生存时间（TTL）为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。在规定的时间内没有收到一个数据报的全部数据报片时，就将已收到的分片都丢弃，并向源点发送数据超过报文。</p>\n</li>\n<li><p>参数问题：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文</p>\n</li>\n<li><p>改变路由（重定向）：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）</p>\n</li>\n</ul>\n</li>\n<li><p>ICMP差错报文的数据字段</p>\n<ul>\n<li><p>差错的IP数据报中的（首部和数据部分的前8字节）</p>\n</li>\n<li><p>ICMP的前8个字节+该ICMP的数据字段&#x3D;完整的ICMP差错报告报文</p>\n</li>\n<li><p>ICMP差错报告报文+IP数据报的首部&#x3D;IP数据报</p>\n</li>\n</ul>\n</li>\n<li><p>几种情况：不应发送ICMP差错报告报文</p>\n<ul>\n<li><p>对ICMP差错报告报文不再发送ICMP差错报告报文</p>\n<ul>\n<li>由于IP数据报的首部检验和不检验数据部分，数据部分（收到的ICMP差错报文）就可能出错，即使出错，也不会对ICMP差错报文发送ICMP差错差错报告</li>\n</ul>\n</li>\n<li><p>对第一个分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</p>\n</li>\n<li><p>对具有组播或广播地址的数据报都不发送ICMP差错报告报文</p>\n<ul>\n<li><p>组播：一点发送到多点（广播是一点发送到所有节点）</p>\n</li>\n<li><p>防止广播风暴</p>\n</li>\n</ul>\n</li>\n<li><p>对具有特殊地址（如127.0.0.0（环回地址）或0.0.0.0（本网络的本主机地址） ）的数据报不发送ICMP差错报告报文</p>\n</li>\n</ul>\n</li>\n<li><p>ICMP询问报文</p>\n<ul>\n<li><p>回送请求和回答报文</p>\n<ul>\n<li><p>主机或路由器向特定主机发出询问“会送请求报文”，收到该报文的特定主机必须向与源主机或路由器发送ICMP“会送回答报文”。</p>\n</li>\n<li><p>具体应用：PING，测试目的站是否可达，以及了解目的站的相关状态。</p>\n</li>\n</ul>\n</li>\n<li><p>时间戳请求和回答报文</p>\n<ul>\n<li><p>请求某个主机或路由器回答当前时间。</p>\n</li>\n<li><p>具体应用：用于进行时钟同步和时间的测量。</p>\n</li>\n</ul>\n</li>\n<li><p>掩码地址请求和回答报文</p>\n</li>\n<li><p>路由器询问和通告报文</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>ICMP的应用</p>\n<ul>\n<li><p>分组网间探测PING</p>\n<ul>\n<li><p>测试两台主机之间的连通性</p>\n</li>\n<li><p>使用了ICMP回送请求和回答报文</p>\n</li>\n<li><p>PING工作在应用层，直接使用网络层的ICMP，未使用传输层的TCP或UDP。</p>\n</li>\n</ul>\n</li>\n<li><p>Traceroute</p>\n<ul>\n<li><p>用来跟踪分组经过的路径</p>\n</li>\n<li><p>使用了ICMP时间超过报文</p>\n</li>\n<li><p>过程：</p>\n<ul>\n<li>源主机发送多个数据报。首先发送第一个数据报（TTL设置为1），收到该数据报的第一个路由器就会回复时间超过报文，然后发送第二个数据报（TTL设置为2），同理源点到终点上的所有节点都会依次回复时间超过报文。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"IPV6\"><a href=\"#IPV6\" class=\"headerlink\" title=\"IPV6\"></a>IPV6</h1><h2 id=\"解决IP地址耗尽的办法\"><a href=\"#解决IP地址耗尽的办法\" class=\"headerlink\" title=\"解决IP地址耗尽的办法\"></a>解决IP地址耗尽的办法</h2><p>根本方法：IPv6</p>\n<p>缓解方法：超网聚合，NAT等</p>\n<h2 id=\"IPv6数据报格式\"><a href=\"#IPv6数据报格式\" class=\"headerlink\" title=\"IPv6数据报格式\"></a>IPv6数据报格式</h2><ul>\n<li><p>分为基本首部和有效载荷</p>\n<ul>\n<li><p>扩展首部放在数据载荷中，可有可无</p>\n</li>\n<li><p>IPv4的首部中一些不常用的字段放在扩展首部中</p>\n</li>\n</ul>\n</li>\n<li><p>基本首部</p>\n<ul>\n<li><p>版本：4bit，值为6，因为是IPv6版本协议</p>\n</li>\n<li><p>优先级：8bit，区分数据报的类别和优先级，是否对数据报进行优先处理</p>\n</li>\n<li><p>流标签：所有属于同一个流的数据报都有相同的流标签</p>\n<ul>\n<li><p>流：区分从特点源点到特定终点的一系列数据报。</p>\n</li>\n<li><p>对比——IPv4的标识位：同一个数据报的分片有相同的标识位</p>\n</li>\n</ul>\n</li>\n<li><p>有效载荷长度：IPv6数据报的有效载荷的长度（扩展首部+数据部分）</p>\n<ul>\n<li>对比——IPv4的首部长度：首部大小，IPv4的总长度字段：首部+数据部分大小</li>\n</ul>\n</li>\n<li><p>下一个首部：标识下一个扩展首部或者是上层的协议首部。</p>\n<ul>\n<li><p>对于IPv6数据报的扩展首部都有下一个首部字段。</p>\n</li>\n<li><p>基本首部里也有下一个首部字段指向扩展首部1。扩展首部1的下一个首部字段指向扩展首部2。同理，最后一个扩展首部的首部字段指向数据部分（数据是上层的报文段，所以指向上层报文段的首部）。</p>\n</li>\n</ul>\n</li>\n<li><p>条数限制：相当于IPv4的TTL（生存时间）。</p>\n<ul>\n<li>如果条数限制为0，就丢弃报文，并返回ICMP差错报告报文。</li>\n</ul>\n</li>\n<li><p>源地址：128位。</p>\n<ul>\n<li>对比IPv4：32位</li>\n</ul>\n</li>\n<li><p>目的地址：128位。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IPv6与IPv4的区别：\"><a href=\"#IPv6与IPv4的区别：\" class=\"headerlink\" title=\"IPv6与IPv4的区别：\"></a>IPv6与IPv4的区别：</h2><ul>\n<li><p>更大的地址空间</p>\n<ul>\n<li>IPv6将地址从32位（4B）扩大到了128位（16B）</li>\n</ul>\n</li>\n<li><p>移除校验和字段</p>\n<ul>\n<li>路由器对于数据报首部的校验时间变小，每跳的处理时间也就变小了。</li>\n</ul>\n</li>\n<li><p>扩展的地址层次结构</p>\n<ul>\n<li>分为三级。第一级（顶级）：全球都知道的公共拓扑，第二级（场点级）：单个场点，第三级：单个网络接口。</li>\n</ul>\n</li>\n<li><p>灵活的首部格式</p>\n<ul>\n<li><p>IPv6将IPv4的可选字段移出首部，变成了扩展首部，路由器通常不会对扩展首部进行检查，大大提高了路由器的处理和转发数据报的效率。</p>\n</li>\n<li><p>IPv4的首部格式分为固定部分和可变部分，且固定部分的字段种类繁多</p>\n</li>\n</ul>\n</li>\n<li><p>支持即插即用（即自动配置IP地址）</p>\n<ul>\n<li><p>IPv6不需要DHCP协议。</p>\n</li>\n<li><p>IPv4自动配置IP地址的时候需要DHCP协议，需要DHCP服务器。</p>\n</li>\n</ul>\n</li>\n<li><p>IPv6首部长度必须是8B的整数倍，而IPv4首部是4B的整数倍</p>\n</li>\n<li><p>IPv6只有在包的源结点（主机处）才能分片，是端到端的，传输路径中的路由器不能分片</p>\n<ul>\n<li><p>如果发到了路由器之后，想要转发出去的链路的MTU值小于IPv6的分片时，路由器会直接丢弃分片，并且返回ICMPv6协议的“分组过大”差错报告报文</p>\n</li>\n<li><p>IPv4在源结点和路由器上都可以进行分片</p>\n</li>\n</ul>\n</li>\n<li><p>IP v6协议使用ICMPv6协议报告差错和异常情况，附加报文类型有“分组过大”。</p>\n</li>\n<li><p>支持资源的预分配</p>\n<ul>\n<li>支持实时影像等要求，支持需要高带宽和低时延的应用。</li>\n</ul>\n</li>\n<li><p>IPv6取消了协议字段，将协议字段改为下一个首部字段。</p>\n</li>\n<li><p>IPv6取消了首部长度字段和总长度字段，该用有效载荷字段。</p>\n</li>\n<li><p>IPv6取消了服务类型字段</p>\n<ul>\n<li>期望得到哪种类型的，可以设置数据报的优先级，IPv6该用优先级字段</li>\n</ul>\n</li>\n<li><p>改进的选项</p>\n</li>\n<li><p>允许协议继续扩充</p>\n</li>\n<li><p>增大了安全性。身份验证和保密功能是IPv6的关键特征</p>\n</li>\n<li><p>支持Qos</p>\n<ul>\n<li><p>Qos指一个网络能够利用多种基础技术，为指定的网络通信提供更好的服务能力</p>\n</li>\n<li><p>Qos是网络的一种安全机制</p>\n</li>\n<li><p>Qos可以解决网络延迟和阻塞等问题</p>\n</li>\n<li><p>可以满足实时和多媒体通信的需要</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IPV6地址\"><a href=\"#IPV6地址\" class=\"headerlink\" title=\"IPV6地址\"></a>IPV6地址</h2><ul>\n<li><p>基本类型地址</p>\n<ul>\n<li><p>单播：传统的点对点通信，可作为源地址和目的地址</p>\n</li>\n<li><p>多播：多播是一点对多点的通信，分组被交付到一组计算机的每台计算机，只可作为目的地址。多播包括广播。</p>\n</li>\n<li><p>任播</p>\n<ul>\n<li><p>这是IPv6增加的一种类型</p>\n</li>\n<li><p>表现为一对多中的一个通信，实质是单播通信，表现形式为多播通信，只可作为目的地址。</p>\n</li>\n<li><p>任播的目的站（目的IP地址）是一组计算机，但数据报在交付时只交付其中的一台计算机，通常是距离最近的一台计算机</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>IPv6地址表示形式</p>\n<ul>\n<li><p>一般形式：使用冒号十六进制算法</p>\n<ul>\n<li>每四位使用一个16进制数表示，每四个16进制数位一组，总共有8组</li>\n</ul>\n</li>\n<li><p>压缩形式：</p>\n<ul>\n<li><p>零压缩：将一组内是四个连续的0的，写为一个0。例如4BF5:0:0:0:BA5F:A:0:2176</p>\n</li>\n<li><p>双冒号表示法：将几个相邻组都为0的，可以进一步缩写，写成一对冒号。例如FF05::3A:0:B3</p>\n<ul>\n<li>注意⚠️：双冒号表示法只能在一个地址中出现一次，如果出现两次，计算机就不能识别::中省略了多少位零。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IPV4向IPV6过渡（IPv6如何兼容IPv4）\"><a href=\"#IPV4向IPV6过渡（IPv6如何兼容IPv4）\" class=\"headerlink\" title=\"IPV4向IPV6过渡（IPv6如何兼容IPv4）\"></a>IPV4向IPV6过渡（IPv6如何兼容IPv4）</h2><ul>\n<li><p>双协议栈</p>\n<ul>\n<li><p>双协议栈技术是指在一台设备上同时装有IPv4和IPv6协议栈，那么这台设备既能和IPv4网络通信，又能和IPv6网络通信</p>\n</li>\n<li><p>如果这台设备是一台路由器，路由器的不同接口分别配置IPv4地址和IPv6地址，那么路由器内部就可以实现IPv4数据报与IPv6数据报的互相转换，也就是连接了IPv4和IPv6网络。</p>\n</li>\n<li><p>如果这台设备是一台计算机，那么它的一个接口将同时拥有IPv4地址和IPv6地址，并具备同时处理IPv4和IPv6协议的能力。</p>\n</li>\n</ul>\n</li>\n<li><p>隧道技术</p>\n<ul>\n<li><p>将整个IPv6数据报封装到IPv4数据报的数据部分，使得IPv6数据报可以在IPv4网络的隧道中传输</p>\n</li>\n<li><p>封装在IP v4数据报中的IPv6数据报在穿过IPv4网络后，会去掉IPv4首部，重新作为IPv6数据报进行正常传输</p>\n</li>\n<li><p>在互联网中广泛应用</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"路由协议\"><a href=\"#路由协议\" class=\"headerlink\" title=\"路由协议\"></a>路由协议</h1><h2 id=\"路由信息协议（RIP）\"><a href=\"#路由信息协议（RIP）\" class=\"headerlink\" title=\"路由信息协议（RIP）\"></a>路由信息协议（RIP）</h2><ul>\n<li><p>简介</p>\n<ul>\n<li><p>内部网关协议（IGP）中最先得到广泛应用的协议</p>\n</li>\n<li><p>是一种分布式的基于距离向量的路由选择协议，其最大优点就是简单</p>\n</li>\n</ul>\n</li>\n<li><p>路由表的内容</p>\n<ul>\n<li>目的网络，距离，下一跳路由器（如果是直接相连，就是直接交付）</li>\n</ul>\n</li>\n<li><p>RIP协议只适用于小互联网</p>\n</li>\n<li><p>RIP的规定</p>\n<ul>\n<li><p>RIP协议要求网络中每个路由器都维护从自己到每一个网络的唯一最佳距离记录（即一组距离矢量之和）</p>\n</li>\n<li><p>跳数：</p>\n<ul>\n<li><p>从一个路由器到直接连接网络的跳数为1，距离基本单位为“跳” ，每到达一个路由器为一跳</p>\n</li>\n<li><p>RIP规定一条路径最多包含15个路由器，即最多允许15跳，超过15跳即为不可达。因此距离等于16时，表示网络不可达<img src=\"https://api2.mubu.com/v3/document_image/BEDB631967B94D461627205706.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>路由信息在相邻路由之间交换</p>\n</li>\n<li><p>每30秒广播一次RIP路由更新信息，建立并维护路由表（动态路由表）</p>\n</li>\n<li><p>RIP协议中每个网络的子网掩码必须相同</p>\n<ul>\n<li>RIPv1的报文中不携带子网掩码，所以每个网路的子网掩码必须相同。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>交换路由信息的特点</p>\n<ul>\n<li><p>仅和相邻路由器交换信息。</p>\n</li>\n<li><p>路由器交换的信息是当前路由器所知道的全部信息，即自己的路由表</p>\n</li>\n<li><p>每30秒交换一次路由信息，然后路由器根据新的路由信息更新路由表，若超过180s没有收到邻居路由器的通告，则判定邻居没了，并更新自己的路由表</p>\n</li>\n</ul>\n</li>\n<li><p>路由表更新过程</p>\n<ul>\n<li>路由器开始时，只知道直连网络的网络距离（&#x3D;1），然后通过相邻路由器交换并更新路由信息，使得若干次交换之后每一个路由器都知道到达本自治系统的任何一个网络的路由信息，即收敛。</li>\n</ul>\n</li>\n<li><p>距离向量算法</p>\n<ul>\n<li><p>修改相邻路由器发来的RIP报文中的所有表项</p>\n<ul>\n<li>对地址为X的相邻路由器发来的RIP报文，修改所有项目：下一跳改为x，距离字段+1</li>\n</ul>\n</li>\n<li><p>对修改后的RIP报文中的每一个项目，进行以下步骤</p>\n<ul>\n<li><p>若路由表中没有Net3，收到的RIP报文中有Net3，则将该项目填入路由表</p>\n</li>\n<li><p>若路由表中存在Net3，则查看路由表中的下一跳地址</p>\n<ul>\n<li><p>若下一跳是X，则用收到的项目替换路由表中的项目<br>因为路由表的更新以最新的消息为准，有可能链路发生了改变。无论距离增大还是减小，都会用新项目代替原来的项目</p>\n</li>\n<li><p>若下一跳不是X，则比较原来项目的距离长度和新项目的距离长度</p>\n<ul>\n<li><p>如果原来距离&gt;新距离，则更新</p>\n</li>\n<li><p>如果原来距离&lt;新距离，则不做处理</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>若180s还没收到相邻路由器X的更新信息，则把X记为不可达路由器，即将下一跳为X的项目的距离设置为16</p>\n</li>\n<li><p>重复上述步骤</p>\n</li>\n</ul>\n</li>\n<li><p>RIP协议的报文格式（不需要详细记忆）</p>\n<ul>\n<li><p>RIP报文的首部和路由部分，被添加到UDP用户数据报中</p>\n</li>\n<li><p>封装到UDP用户数据报中的报文是应用层报文，所以RIP是应用层协议</p>\n</li>\n<li><p>每条路由信息为20字节，所以每个RIP报文最多传送25个路由，如果路由表中超过25个路由，则需要分别发送几个RIP报文。</p>\n</li>\n</ul>\n</li>\n<li><p>缺陷</p>\n<ul>\n<li><p>RIP限制了网络的规模，它能使用的最大距离为15 （16表示不可达）</p>\n</li>\n<li><p>路由器之间交换的是路由器中的完整路由表，因此网络规模越大，开销也越大</p>\n</li>\n<li><p>网络出现故障时，会出现慢收敛现象（即需要较长时间才能将此信息传送到所有路由器），俗称“坏消息传得慢与好消息传得快”</p>\n<ul>\n<li><p>假设第0秒的时候，R1刚刚向R2交换完路由信息，R1的直连网络Net1就断了，此时R1就会将到达Net1网络的距离设为16，但是此时不会向R2发送路由信息，需要等到30s之后。在这期间R1很可能就收到R2的路由表，在这期间可能收到了R2的路由信息，R1发现R2可以到达网络1，R1就更改到达Net1的距离为3。</p>\n</li>\n<li><p>此时R2再次收到R1的路由表时，发现R1到达Net1的距离&#x3D;3，R2就会修改到达Net1的距离&#x3D;4，此时R2的路由表项：Net1，4，R1。R1的路由表项：Net1，3，R2。</p>\n</li>\n<li><p>出现这种情况的原因是，R1和R2都认为对方可以到达Net1，结果双方都到达不了Net1，导致R1和R2需要不断的更新路由表项距离，双方不断更新，即距离+1，只有等到距离&#x3D;16时，R1和R2才知道不能到达Net1，坏消息更新的慢就是只有等很长一段时间。</p>\n</li>\n<li><p>不仅是故障问题，同样如果链路开销增加了，相邻路由器同样需要经过一段时间才能将距离更新到正确的状态。但是如果发现了一条更短的路由，那么相邻路由器只需要更新一次，路由表项的距离就可以更新到正确的状态。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>实现简单、开销小、收敛过程较快</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"开放最短路径优先（OSPF）协议\"><a href=\"#开放最短路径优先（OSPF）协议\" class=\"headerlink\" title=\"开放最短路径优先（OSPF）协议\"></a>开放最短路径优先（OSPF）协议</h2><ul>\n<li><p>简介</p>\n<ul>\n<li><p>使用分布式链路状态路由算法的典型代表，也是内部网关协议（IGP）的一种</p>\n</li>\n<li><p>开放：不受某一家厂商控制，公开发表的</p>\n</li>\n<li><p>最短路径优先：是用来最短路径算法SPF</p>\n</li>\n</ul>\n</li>\n<li><p>链路状态路由算法</p>\n<ul>\n<li><p>链路建立时</p>\n<ul>\n<li><p>每个路由器向邻居结点发送【HELLO问候分组】，并了解邻居结点的网络地址（每10秒发生一次HELLO，判断临站是否可达）</p>\n</li>\n<li><p>每个路由器设置到每个邻居的成本度量metric</p>\n</li>\n<li><p>构造【DD数据库描述分组】，向邻站给出自己链路状态数据库中的所有链路状态 项目的摘要信息。</p>\n</li>\n<li><p>如果邻站有DD分组中的所有信息，则不做处理；如果邻站有一些数据没有，或者有一些数据不一样（更新的），则发送【LSR链路状态请求分组】，请求这些信息。</p>\n</li>\n<li><p>收到邻站的LSR请求，发送【LSU链路状态更新分组】。</p>\n</li>\n<li><p>邻站收到LSU更新分组后会进行更新，更新结束后就会返回一个【LSAck链路状态确认分组】进行确认。</p>\n</li>\n</ul>\n</li>\n<li><p>链路状态发生变化时</p>\n<ul>\n<li><p>如果路由器的链路状态发生变化，则泛洪发送【LSU链路状态更新分组】。</p>\n</li>\n<li><p>其它站点更新完毕后，会返回一个【LSAck链路状态确认分组】进行确认。</p>\n</li>\n</ul>\n</li>\n<li><p>使用Dijkstra算法根据自己的链路状态数据库构造到各个节点的最短路径</p>\n</li>\n</ul>\n</li>\n<li><p>分组类型</p>\n<ul>\n<li><p>问候分组，用来发现和维持邻站的可达性</p>\n</li>\n<li><p>数据库描述分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</p>\n</li>\n<li><p>链路状态请求分组，向对方请求发送某些链路状态项目的详细信息</p>\n</li>\n<li><p>链路状态更新分组，用洪泛法对全网更新链路状态</p>\n</li>\n<li><p>链路状态确认分组，对链路更新分组的确认</p>\n</li>\n</ul>\n</li>\n<li><p>OSPF的区域</p>\n<ul>\n<li><p>为了使OSPF能够适用规模较大的网络，OSPF将较大的自治系统再划分，形成若干个区域。</p>\n</li>\n<li><p>每个区域都有一个32位的区域标识符（点分十进制表示），与IP地址完全不同，只在AS内有效。</p>\n</li>\n<li><p>主干区域：0.0.0.0，用来连接区域不同的区域。</p>\n</li>\n<li><p>主干路由器：主干区域的路由器，可能包括区域边界路由器</p>\n</li>\n<li><p>自治系统边界路由器：该路由器位于主干区域，用于连接其它自治系统。</p>\n</li>\n<li><p>区域内部路由器：在下层区域中的路由器</p>\n</li>\n<li><p>区域边界路由器：区域间</p>\n</li>\n</ul>\n</li>\n<li><p>OSPF分组</p>\n<ul>\n<li><p>OSPF分组首部+类型1至类型5的OSPF分组，封装上IP数据报首部，形成IP数据报</p>\n</li>\n<li><p>OSPF使用IP数据报进行传送，属于网络层协议。</p>\n</li>\n</ul>\n</li>\n<li><p>交换路由信息的特点</p>\n<ul>\n<li><p>OSPF向本自治系统中的所有路由器发送信息，这里使用的方法是洪泛法</p>\n<ul>\n<li><p>路由器A先向相邻路由器发送路由信息，相邻路由器将路由信息的副本保存下来，再通过所有连接路由器的接口转发出去，所以所有的路由器都会在极短的时间内知道路由器A的路由信息</p>\n</li>\n<li><p>类似于广播</p>\n</li>\n</ul>\n</li>\n<li><p>发送的信息是与本路由器相邻的所有路由器的链路状态</p>\n<ul>\n<li>链路状态：相邻路由器路由器，以及到相邻路由器的链路的度量&#x2F;代价（代价可以是费用、距离、时延、带宽）</li>\n</ul>\n</li>\n<li><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息，并且更新过程收敛得快，平时链路状态没有发生变化时，路由器不会发送路由信息</p>\n</li>\n<li><p>所有路由器最后都能建立一个链路状态数据库，即全网拓扑<img src=\"https://api2.mubu.com/v3/document_image/AEF439594C8742931627284544.jpg\" alt=\"img\"></p>\n</li>\n<li><p>OSPF是网络层协议，它不使用UDP或TCP，而直接用IP数据报传送</p>\n</li>\n</ul>\n</li>\n<li><p>其他特点</p>\n<ul>\n<li><p>每隔30min更新一次数据库中的链路状态</p>\n<ul>\n<li>链路状态数据库中的每条LSA只有30分钟的有效时间，所以即使数据链路没有发生变化，也会在30分钟之后发送LSR请求链路状态信息。</li>\n</ul>\n</li>\n<li><p>适用于规模较大的网络</p>\n<ul>\n<li>由于LSU更新分组中只有路由器相邻结点的链路状态信息，所以LSU更新分组的大小与网络的规模无直接关系，所以适用于规模较大的网络。</li>\n</ul>\n</li>\n<li><p>出现链路断开的情况，收敛速度快</p>\n<ul>\n<li>OSPF收到链路状态信息后会使用Dijkstra算法算出最短路径，所以知道全网拓扑，直接计算出最短路径，所以收敛速度快（RIP协议之所以慢是因为R1不知道全网拓扑，它误以为R2可以到，就发给R2）</li>\n</ul>\n</li>\n<li><p>OSPF对不同的链路可根据IP分组的不同服务类型（TOS ）而设置成不同的代价</p>\n</li>\n<li><p>OSPF对于不同类型的业务可计算出不同的路由，十分灵活</p>\n</li>\n<li><p>负载平衡：如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径</p>\n</li>\n<li><p>所有在OSPF路由器之间交换的分组都具有鉴别功能，因而保证了仅在可信赖的路由器之间交换链路状态信息</p>\n</li>\n<li><p>支持可变长度的子网划分和无分类编址CIDR</p>\n</li>\n<li><p>每个链路状态都带上一个32位的序号，序号越大，状态就越新</p>\n</li>\n<li><p>使用迪杰斯特拉算法</p>\n</li>\n<li><p>使用洪泛法，就像水波一样，相互交互路由表信息</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"边界网关协议（BGP）\"><a href=\"#边界网关协议（BGP）\" class=\"headerlink\" title=\"边界网关协议（BGP）\"></a>边界网关协议（BGP）</h2><ul>\n<li><p>简介</p>\n<ul>\n<li><p>是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议</p>\n</li>\n<li><p>边界网关协议常用于互联网的网关之间</p>\n</li>\n<li><p>BGP采用的是路径向量路由选择协议</p>\n</li>\n<li><p>应用层协议，基于TCP</p>\n</li>\n</ul>\n</li>\n<li><p>交换路由信息的特点</p>\n<ul>\n<li><p>与其他AS的邻站（BGP发言人）交换信息</p>\n<ul>\n<li><p>每个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP发言人”</p>\n</li>\n<li><p>BGP发言人往往是BGP边界路由器</p>\n</li>\n</ul>\n</li>\n<li><p>交换的信息是网络可达性信息，即到达某个网络所要经过的一系列AS</p>\n<ul>\n<li><p>一个BGP发言人与其他自治系统中的BGP发言人要交换路由信息，先建立TCP连接，即通过TCP传送</p>\n</li>\n<li><p>在此连接上交换BGP报文以建立BGP会话，再利用BGP会话交换路由信息</p>\n</li>\n<li><p>所有BGP发言人都相互交换网络可达性的信息后，各BGP发言人就可找出到达各个自治系统的较好路由</p>\n</li>\n</ul>\n</li>\n<li><p>发生变化的时候才会更新有变化的部分</p>\n</li>\n</ul>\n</li>\n<li><p>BGP协议交换信息的过程</p>\n<ul>\n<li><p>BGP发言人交换路径向量</p>\n<ul>\n<li><p>AS2的BGP发言人发给AS1的BGP发言人：到达网络Net1、Net3，可以经过AS2</p>\n</li>\n<li><p>AS3的BGP发言人发给AS1的BGP发言人：到达网络Net4、Net5，可以经过AS3</p>\n</li>\n<li><p>AS1发给AS2：到达Net4、Net5，可以经过AS1、AS3</p>\n</li>\n<li><p>AS1发给AS3:到达Net1、Net3，可以经过AS1、AS2</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>BGP报文格式</p>\n<ul>\n<li><p>BGP报文通用首部+主体部分，封装上TCP首部，形成TCP报文</p>\n</li>\n<li><p>BGP是应用层协议，借助TCP传送</p>\n<ul>\n<li>为什么使用TCP：更加可靠，可以简化路由选择协议</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>BGP交换路由信息的结点数量级是自治系统的数量级，要比这些自治系统中的网络数少很多</p>\n</li>\n<li><p>每个自治系统中BGP发言人（或边界路由器）的数目是很少的</p>\n</li>\n<li><p>BGP支持CIDR，即BGP路由表应包括目的网络前缀，下一跳路由器，以及到达该网络的各个自治系统序列。</p>\n</li>\n<li><p>在BGP刚运行时， BGP的邻站交换整个BGP路由表，但以后只需在发生变化时更新有变化的部分</p>\n</li>\n</ul>\n</li>\n<li><p>BGP-4的四种报文类型</p>\n<ul>\n<li><p>打开（Open ）报文：用来与相邻的另一个BGP发言人建立关系，并认证发送方（身份认证）</p>\n</li>\n<li><p>更新（ Update ）报文：通知新路径或撤销原路径</p>\n</li>\n<li><p>保活（ Keepalive ）报文：用来确认打开报文或者在没有更新时周期性地证实邻站关系</p>\n</li>\n<li><p>通知（ Notification ）报文：用来发送检测到的差错，也被用于关闭TCP连接</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"路由协议比较\"><a href=\"#路由协议比较\" class=\"headerlink\" title=\"路由协议比较\"></a>路由协议比较</h2><ul>\n<li><p>协议：RIP、OSPF、BGP</p>\n</li>\n<li><p>类型：内部、内部、外部</p>\n</li>\n<li><p>路由算法：距离-向量、链路状态、路径-向量</p>\n</li>\n<li><p>传递协议：UDP、IP、TCP</p>\n</li>\n<li><p>路径选择：跳数最少、代价最低、较好，非最佳</p>\n</li>\n<li><p>交换结点：和本结点相邻的路由器、网络中的所有路由器、和本结点相邻的路由器</p>\n</li>\n<li><p>交换内容：当前本路由器知道的全部信息，即自己的路由器、与本路由器相邻的所有路由器的链路状态(只有发生变化时才交换)、(首次)整个路由表，(非首次)有变化的部分</p>\n</li>\n<li><p>层次结构：应用层、网络层、应用层</p>\n</li>\n</ul>\n<h1 id=\"IP组播\"><a href=\"#IP组播\" class=\"headerlink\" title=\"IP组播\"></a>IP组播</h1><h2 id=\"IP数据报的三种传输方式\"><a href=\"#IP数据报的三种传输方式\" class=\"headerlink\" title=\"IP数据报的三种传输方式\"></a>IP数据报的三种传输方式</h2><ul>\n<li><p>单播：用于一个主机发送数据包给一个主机，一个单播地址作为源地址，一个单播地址作为目的地址。点对点传输。</p>\n</li>\n<li><p>广播：用于一台主机发送数据包给局域网中的所有主机，一个单播地址作为源地址，广播地址全1作为目的地字。点对多点传输。</p>\n</li>\n<li><p>组播（多播）：用于一台主机发送数据包给多台主机，一个单播地址作为源地址，组播地址（D类）作为目的地址。点对多点传输。</p>\n<ul>\n<li><p>借助组播路由协议为组播数据包建立组播分发树，被传递的数据到达距离用户端尽可能近的节点后才会被复制和分发。</p>\n</li>\n<li><p>广播报文遇到一个路由器或交换机，就会复制一次，并从所有端口转发出去。</p>\n</li>\n<li><p>组播报文在前期经过路由器或交换机的时候，只会在特定的端口转发出去，只有到达距离目的主机尽可能近的设备时，才会复制数据包和并从多个端口转发出去。</p>\n</li>\n</ul>\n</li>\n<li><p>对比：视频服务器</p>\n<ul>\n<li><p>单播：90个用户要求观看视频，会建立90个单播连接，源站点会发送90个数据包分发给90个主机。那么距离源站点越近的线路上占用的资源越多。</p>\n</li>\n<li><p>组播：源站点会发送一份数据包，遇到路由器或交换机，根据组播地址判断是否复制数据包，直到到达目的主机。这样每条链路上都只有一个数据包。</p>\n<ul>\n<li><p>所以组播可以提高数据传输效率，减少了主干网出现拥塞的可能性。</p>\n</li>\n<li><p>组播组中的主机可以在一个物理网络中，也可以在不同的物理网络中，在不同的物理网络中时，需要有组播路由器的支持（即运行组播协议的路由器）。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"组播的概念\"><a href=\"#组播的概念\" class=\"headerlink\" title=\"组播的概念\"></a>组播的概念</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>组播机制是让源计算机一次发送的单个分组可以抵达用一个组地址标识的若干目标主机，并被它们正确接收</p>\n<ul>\n<li>组播仅应用于UDP</li>\n</ul>\n</li>\n<li><p>因特网中的IP组播也使用组播组的概念，每个组都有一个特别分配的地址，要给该组发送的计算机将使用这个地址作为分组的目标地址</p>\n</li>\n</ul>\n</li>\n<li><p>实现过程</p>\n<ul>\n<li><p>主机使用一个称为IGMP （因特网组管理协议）的协议加入组播组</p>\n</li>\n<li><p>使用该协议通知本地网络上的路由器关于要接收发送给某个组播组的分组的愿望</p>\n</li>\n<li><p>通过扩展路由器的路由选择和转发功能，可以在许多路由器互联的支持硬件组播的网络上面实现因特网组播</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li>数据只需发送一次就可发送到所有接收者，大大减轻了网络的负载和发送者的负担</li>\n</ul>\n</li>\n<li><p>注意</p>\n<ul>\n<li>组播需要路由器的支持才能实现，能够运行组播协议的路由器称为组播路由器</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IP组播地址\"><a href=\"#IP组播地址\" class=\"headerlink\" title=\"IP组播地址\"></a>IP组播地址</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>组播组中的设备除了拥有自己的全球唯一的IP地址外，都会被分配一个组播组IP地址（即D类地址），属于同一个组播组的设备都将会被分配同一个组播组地址。</p>\n</li>\n<li><p>组播地址是在加入组播组的时候，才会被分配。</p>\n</li>\n</ul>\n</li>\n<li><p>结构</p>\n<ul>\n<li><p>IP组播使用D类地址格式：224.0.0.0～239.255.255.255</p>\n</li>\n<li><p>组播地址只能作为分组的目的地址，单播地址才能作为分组的源地址。</p>\n</li>\n</ul>\n</li>\n<li><p>组播数据报和一般的IP数据报的区别</p>\n<ul>\n<li><p>组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP</p>\n<ul>\n<li>为什么？速度较快，组播数据报一般对实时性要求很高</li>\n</ul>\n</li>\n<li><p>组播地址只能用于目的地址，而不能用于源地址</p>\n</li>\n<li><p>对组播数据报不产生ICMP差错报文。</p>\n<ul>\n<li>因此，若在PING命令后面键入组播地址，将永远不会收到响应</li>\n</ul>\n</li>\n<li><p>并非所有的D类地址都可作为组播地址</p>\n<ul>\n<li>一部分地址已经被指派为永久组地址了。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>只在本局域网上进行硬件组播</p>\n</li>\n<li><p>在因特网的范围内进行组播（因特网上进行组播的最后阶段，还是要把组播数据报在局域网上用硬件组播交付给组播组的所有成员）</p>\n</li>\n</ul>\n</li>\n<li><p>同单播地址一样，组播IP地址也需要相应的组播MAC地址在本地网络中实际传送数据帧。组播MAC地址以16进制值01-00-5E开头，剩下的6个16进制数是根据IP组播地址的最后23位转换而来。</p>\n<ul>\n<li>组播IP地址的第5位-第9位没有写入组播MAC地址地址中，如果有两个组播IP的后23位相同，可能使得两个组播组混到一起，解决办法：<ul>\n<li>硬件地址的映射关系不是唯一的，因此收到组播数据报的主机，还要在IP层利用软件进行过滤，把不是本主机要接收的数据报丢弃</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IGMP与组播路由算法\"><a href=\"#IGMP与组播路由算法\" class=\"headerlink\" title=\"IGMP与组播路由算法\"></a>IGMP与组播路由算法</h2><ul>\n<li><p>用途</p>\n<ul>\n<li><p>因特网组管理协议（ IGMP ）：要使路由器知道组播组成员的信息</p>\n<ul>\n<li><p>IGMP协议让路由器知道本局域网上是否有主机（的进程）加入或退出了某个组播组。</p>\n</li>\n<li><p>IGMP协议决定路由器在局域网中只发给加入组播组的主机，而不发给组播组外的主机。</p>\n</li>\n<li><p>IGMP协议不知道在所连接的局域网内加入组播组的成员个数，也不知道他们分布在哪些网络，只知道（各个接口）所连接的局域网内有无组播组的成员。</p>\n</li>\n</ul>\n</li>\n<li><p>组播路由选择协议：组播数据报和一般的单播的路由选择协议（OSPF、RIP等）有所不同，需要有单独的路由选择协议。</p>\n<ul>\n<li>组播路由选择协议：在因特网范围上把组播数据报用最小的代价发给所有组成员。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>IGMP是TCP&#x2F;IP的一部分</p>\n</li>\n<li><p>IGMP是网络层协议，使用IP数据包传递报文。</p>\n</li>\n</ul>\n</li>\n<li><p>工作阶段</p>\n<ul>\n<li><p>第一阶段</p>\n<ul>\n<li><p>主机加入新的组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明要成为该组的成员</p>\n</li>\n<li><p>本地的组播路由器收到IGMP报文后，将组成员关系转发给因特网上的其他组播路由器</p>\n<ul>\n<li>所以组播路由器和同一组播组内的主机都会收到这个IGMP报文</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>第二阶段</p>\n<ul>\n<li><p>本地组播路由器周期性地探询本地局域网上的主机，以便知道这些主机是否仍继续是组的成员</p>\n<ul>\n<li>探询：就是发送IGMP的询问报文</li>\n</ul>\n</li>\n<li><p>响应结果</p>\n<ul>\n<li><p>只要所连接局域网中某个组中有一台主机响应，那么组播路由器就认为在所连接的局域网内这个组是活跃的</p>\n<ul>\n<li>如果一台主机响应了，其他主机收到响应报文后，就不再发送响应报文</li>\n</ul>\n</li>\n<li><p>一个组在经过几次的探询后仍然没有一台主机响应时，则不再将该组的成员关系转发给其他的组播路由器</p>\n<ul>\n<li>成员关系：所连接局域网中有无组播组的成员</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>组播路由选择协议</p>\n<ul>\n<li><p>目的：找出以源主机为根节点的组播转发树</p>\n<ul>\n<li><p>构造树形接口可以避免在路由器之间兜圈子</p>\n</li>\n<li><p>对于不同的组播组，有不同的组播转发树；对于同一个组播组，如果源点不同，也会有不同的组播转发树</p>\n</li>\n</ul>\n</li>\n<li><p>三种算法：</p>\n<ul>\n<li><p>三种路由算法基于链路状态的路由选择</p>\n</li>\n<li><p>基于距离—向量的路由选择</p>\n</li>\n<li><p>协议无关的组播（ PIM ） （可以建立在任何路由器协议之上）</p>\n<ul>\n<li><p>与单播路由协议无关，直接利用已有的单播路由表，而不需要额外自己维护专门的单播路由信息。</p>\n</li>\n<li><p>稀疏&#x2F;密集：根据组播组的稀疏程度使用协议无关的组播的不同算法</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"移动IP\"><a href=\"#移动IP\" class=\"headerlink\" title=\"移动IP\"></a>移动IP</h1><h2 id=\"移动IP的概念\"><a href=\"#移动IP的概念\" class=\"headerlink\" title=\"移动IP的概念\"></a>移动IP的概念</h2><ul>\n<li><p>支持移动性的因特网体系结构与协议共称为移IP，它是为了满足移动结点（计算机、服务器、网段等）在移动中保持其连接性而设计的</p>\n</li>\n<li><p>三种功能实体和两种地址</p>\n<ul>\n<li><p>移动结点：具有永久IP地址的移动结点（设备）</p>\n</li>\n<li><p>本地代理：在一个网络环境中，一个移动结点的永久“居所”被称为归属网络，在归属网络中代表移动结点执行移动管理功能的实体称为归属代理（本地代理） ，它根据移动用户的转交地址，采用隧道技术转交移动结点的数据包</p>\n<ul>\n<li><p>本地代理：在归属网络中管理并且帮助移动结点执行功能的设备。</p>\n</li>\n<li><p>路由器也可以作为本地代理</p>\n</li>\n</ul>\n</li>\n<li><p>外部代理：在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理</p>\n</li>\n<li><p>永久地址（归属地址&#x2F;主地址）：移动结点在归属网络中的原始地址。</p>\n</li>\n<li><p>转交地址（辅地址）：可以是外部代理的地址，也可以是动态配置的一个地址。</p>\n</li>\n</ul>\n</li>\n<li><p>移动IP与动态IP</p>\n<ul>\n<li><p>动态IP：局域网中的计算机可以通过网络中的DHCP服务器动态地获得一个IP地址</p>\n</li>\n<li><p>移动IP：移动结点以固定的网络IP地址实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"移动IP通信过程\"><a href=\"#移动IP通信过程\" class=\"headerlink\" title=\"移动IP通信过程\"></a>移动IP通信过程</h2><ul>\n<li><p>可以理解为呼叫转移</p>\n<ul>\n<li><p>移动结点在本地网时，按传统的TCP&#x2F;IP方式进行通信（在本地网中有固有的地址）</p>\n</li>\n<li><p>移动结点到一个外地网络时，移动结点向本地代理注册当前的位置地址，即转交地址</p>\n</li>\n<li><p>转交地址的注册后，本地地址会将截获的信息通过隧道发送给转交地址</p>\n</li>\n<li><p>到达转交地址，恢复成原来数据，发送给移动结点</p>\n</li>\n</ul>\n</li>\n<li><p>移动结点在外网通过外网的路由器或外部代理向通信对端发送IP数据包</p>\n</li>\n<li><p>移动结点来到另一个外网时，只需向本地代理更新注册的转交地址，就可继续通信。</p>\n</li>\n<li><p>移动结点回到本地网时，移动结点向本地代理注销转交地址，这时移动结点又将使用传统的TCP&#x2F;IP方式进行通信</p>\n</li>\n</ul>\n<h2 id=\"移动IP通信过程-1\"><a href=\"#移动IP通信过程-1\" class=\"headerlink\" title=\"移动IP通信过程\"></a>移动IP通信过程</h2><ul>\n<li><p>A刚进入外部网络：</p>\n<ul>\n<li><p>1.获得外部代理的地址作为转交地址（转交地址可以是外部代理的地址，也可以是动态配置的地址），或者向外部代理注册一个转交地址</p>\n<ul>\n<li><p>被动获得：外部代理广播ICMP报文，报文中包含外部代理的地址，将作为A的转交地址</p>\n</li>\n<li><p>主动获得：A向外部代理发送广播报文，获得一个转交地址</p>\n</li>\n</ul>\n</li>\n<li><p>2.移动节点通过外部代理发送“注册报文”给归属代理（包含A的永久地址&amp;外部代理的转交地址）</p>\n</li>\n<li><p>3.归属代理接收请求，并将移动节点的永久地址和转交地址绑定，并返回“注册响应报文”</p>\n<ul>\n<li>之后到达归属代理的数据报且要发给移动节点A的数据报将会被封装，并以隧道的方式转发给转交地址。</li>\n</ul>\n</li>\n<li><p>4.外部代理接收“注册响应”，并转发给移动节点。</p>\n</li>\n</ul>\n</li>\n<li><p>A移动到新的外部网络：</p>\n<ul>\n<li><p>1.获得新的外部代理的地址作为转交地址，或者移动节点在新的外部代理登记注册一个转交地址</p>\n</li>\n<li><p>2.移动节点A用新获取的转交地址覆盖旧的转交地址</p>\n</li>\n<li><p>3.同上</p>\n</li>\n</ul>\n</li>\n<li><p>A回到归属网络</p>\n<ul>\n<li><p>1.A向本地代理注销A的转交地址</p>\n</li>\n<li><p>2.同上</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"网络层设备\"><a href=\"#网络层设备\" class=\"headerlink\" title=\"网络层设备\"></a>网络层设备</h1><h2 id=\"路由器的组成和功能\"><a href=\"#路由器的组成和功能\" class=\"headerlink\" title=\"路由器的组成和功能\"></a>路由器的组成和功能</h2><ul>\n<li><p>基本描述</p>\n<ul>\n<li>路由器是一种具有多个输入&#x2F;输出端口的专用计算机<ul>\n<li>多个输入端口和多个输出端口：连接多台主机和多个网络</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>任务</p>\n<ul>\n<li>连接不同的网络（连接异构网络）并完成路由转发（路由选择、分组转发）</li>\n</ul>\n</li>\n<li><p>功能</p>\n<ul>\n<li><p>可以隔离广播域</p>\n</li>\n<li><p>重点：不同层次的设备隔离不同的域</p>\n<ul>\n<li><p>集线器：不隔离</p>\n</li>\n<li><p>网桥：隔离碰撞域（所以有广播风暴）</p>\n</li>\n<li><p>路由器：隔离广播域</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>工作过程</p>\n<ul>\n<li><p>源主机和目标主机在同一个网络上，那么直接交付而无须通过路由器</p>\n</li>\n<li><p>源主机和目标主机不在同一个网络上，路由器按照转发表指出的路由将数据报转发给下一个路由器，即间接交付</p>\n</li>\n</ul>\n</li>\n<li><p>功能组成</p>\n<ul>\n<li><p>路由选择部分（控制部分）</p>\n<ul>\n<li><p>核心构件：路由选择处理机</p>\n</li>\n<li><p>任务</p>\n<ul>\n<li><p>根据选定的路由选择协议构造出路由表</p>\n</li>\n<li><p>和其他相邻路由器交换路由信息然后更新和维护路由表</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>分组转发部分（三部分）</p>\n<ul>\n<li><p>交换结构</p>\n<ul>\n<li><p>根据转发表对分组进行处理，将从输入口进入的分组从一个合适的输出端口转发出去</p>\n<ul>\n<li>转发表：由路由表得到</li>\n</ul>\n</li>\n<li><p>不同分组的转发情况</p>\n<ul>\n<li><p>若收到RIP&#x2F;OSPF分组等，则将分组送给路由选择处理机</p>\n<ul>\n<li>也就是RIP&#x2F;OSPF启动时</li>\n</ul>\n</li>\n<li><p>若收到数据分组，则差咋后转发表并输出</p>\n</li>\n</ul>\n</li>\n<li><p>交换方法</p>\n<ul>\n<li><p>通过存储器进行交换</p>\n</li>\n<li><p>通过总线进行交换</p>\n</li>\n<li><p>通过互联网络进行交换</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>一组输入端口</p>\n<ul>\n<li><p>从物理层接收到的比特流中提取出链路层帧，进而从帧中提取出网络层数据报</p>\n<ul>\n<li><p>判断是否是路由器之间交换路由信息的分组，如果是则交付给路由选择处理机；如果不是则交付给交换结构</p>\n</li>\n<li><p>网络层处理分组时需要排队，数据分组查表和转发都会产生时延</p>\n</li>\n<li><p>输入端口的查找和转发功能在路由器的交换功能中是最重要的</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>一组输出端口</p>\n<ul>\n<li><p>将数据报变为比特流发送到物理层</p>\n<ul>\n<li><p>网络层处理分组时需要排队，网络层处理模块有缓存管理（当网络层处理来不及时，就会先放入缓存），也会产生时延</p>\n</li>\n<li><p>如果路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使得再进入的分组没有存储空间而被丢弃</p>\n</li>\n<li><p>所以路由器输入和输出队列产生溢出是造成分组丢失的重要原因</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>注意</p>\n<ul>\n<li>如果一个存储转发设备实现了某个层次的功能，那么它就可以互联两个在该层次上使用不同协议的网段（网络）</li>\n</ul>\n</li>\n<li><p>功能</p>\n<ul>\n<li><p>分组转发</p>\n<ul>\n<li><p>处理通过路由器的数据流</p>\n</li>\n<li><p>转发表查询、转发及相关的队列管理和任务调度等</p>\n</li>\n</ul>\n</li>\n<li><p>路由计算</p>\n<ul>\n<li>通过和其他路由器进行基于路由协议的交互，完成路由表的计算</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>三层设备的区别</p>\n<ul>\n<li><p>路由器：是面向协议的，依据网络地址进行操作，并进行路径选择、分段、帧格式转换、对数据报的生存时间和流量进行控制等。能隔离冲突域和广播域。</p>\n<ul>\n<li>面向协议：互联两个不同网络层协议的网络</li>\n</ul>\n</li>\n<li><p>网桥：与高层协议无关。能隔离冲突域，不能隔离广播域</p>\n<ul>\n<li>可以互联两个物理层和链路层不同的网段</li>\n</ul>\n</li>\n<li><p>集线器：不能隔离冲突域和广播域</p>\n<ul>\n<li>不能互联两个物理层不同的网段</li>\n</ul>\n</li>\n<li><p>错误🙅‍♂️：所有设备都可互联所在层次与以下层次不同协议的网段。因为集线器就不能互联网络层的网段。</p>\n</li>\n</ul>\n</li>\n<li><p>支持协议</p>\n<ul>\n<li>OSI、TCP&#x2F;IP、IPX等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"路由表与路由转发\"><a href=\"#路由表与路由转发\" class=\"headerlink\" title=\"路由表与路由转发\"></a>路由表与路由转发</h2><ul>\n<li><p>路由表功能：实现路由选择，通常用软件实现（用路由算法得出）</p>\n<ul>\n<li>路由选择：涉及很多路由器，路由表是许多路由器协同工作的结果</li>\n</ul>\n</li>\n<li><p>路由表结构</p>\n<ul>\n<li><p>目的网络IP地址</p>\n</li>\n<li><p>子网掩码</p>\n</li>\n<li><p>下一跳IP地址</p>\n</li>\n<li><p>接口</p>\n</li>\n</ul>\n</li>\n<li><p>默认路由（路由表中）：目的网络：0.0.0.0，子网掩码：0.0.0.0</p>\n<ul>\n<li>目的：减少转发表的重复项目，使用一个默认路由代替所有具有相同“下一跳”的项目<ul>\n<li>不知道往哪发的分组，全都发送给默认路由的下一跳</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>转发表：由路由表的来，可以用软件实现，也可以由硬件实现</p>\n<ul>\n<li><p>转发表必须包含完成转发功能所必需的信息，在转发表的每一行必须包含：要到达的目的网络、输出端口、某些MAC地址信息的映射</p>\n</li>\n<li><p>转发：路由器根据转发表把收到的IP数据报从合适的端口转发出去，仅涉及一个路由器</p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","4.计算机网络","4.网络层"],"tags":["写作"]},{"title":"传输层","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_5.%E4%BC%A0%E8%BE%93%E5%B1%82/","content":"<h1 id=\"传输层提供的服务\"><a href=\"#传输层提供的服务\" class=\"headerlink\" title=\"传输层提供的服务\"></a>传输层提供的服务</h1><h2 id=\"传输层的功能\"><a href=\"#传输层的功能\" class=\"headerlink\" title=\"传输层的功能\"></a>传输层的功能</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层</p>\n</li>\n<li><p>为运行在不同主机上的进程之间提供了逻辑通信</p>\n</li>\n</ul>\n</li>\n<li><p>传输层的功能</p>\n<ul>\n<li><p>传输层提供应用进程之间的逻辑通信（即端到端的通信）</p>\n</li>\n<li><p>复用和分用</p>\n<ul>\n<li><p>复用：发送方不同的应用进程都可使用同一个传输层协议传送数据</p>\n</li>\n<li><p>分用：接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用讲程</p>\n</li>\n</ul>\n</li>\n<li><p>传输层还要对收到的报文进行差错检测（首部和数据部分）</p>\n</li>\n<li><p>提供两种不同的传输协议，即面向连接的TCP和无连接的UDP</p>\n</li>\n<li><p>向高层用户屏蔽低层网络核心的细节（如网络拓扑、路由协议等） ，使应用进程好像在两个传输层实体之间有一条端到端的逻辑通信信道</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"传输层的寻址与端口\"><a href=\"#传输层的寻址与端口\" class=\"headerlink\" title=\"传输层的寻址与端口\"></a>传输层的寻址与端口</h2><ul>\n<li><p>端口的作用</p>\n<ul>\n<li><p>端口可以标识主机中的应用进程</p>\n</li>\n<li><p>让应用层的各种应用讲程将其教据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程</p>\n</li>\n<li><p>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的</p>\n</li>\n</ul>\n</li>\n<li><p>软件端口与硬件端口（传输层使用的是软件端口）</p>\n<ul>\n<li><p>软件端口：协议栈层间的抽象的协议端口，是应用层的各种协议讲程与传输实体进行层间交互的一种地址</p>\n</li>\n<li><p>硬件端口：不同硬件设备进行交互的接口</p>\n</li>\n</ul>\n</li>\n<li><p>端口号</p>\n<ul>\n<li><p>服务端使用的端口号</p>\n<ul>\n<li><p>熟知端口号（0~1023）</p>\n<ul>\n<li><p>FTP</p>\n<ul>\n<li>20</li>\n</ul>\n</li>\n<li><p>TELNET</p>\n<ul>\n<li>23</li>\n</ul>\n</li>\n<li><p>SMTP</p>\n<ul>\n<li>25</li>\n</ul>\n</li>\n<li><p>DNS</p>\n<ul>\n<li>53</li>\n</ul>\n</li>\n<li><p>TFTP</p>\n<ul>\n<li>69</li>\n</ul>\n</li>\n<li><p>HTTP</p>\n<ul>\n<li>80</li>\n</ul>\n</li>\n<li><p>SNMP</p>\n<ul>\n<li>161</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>登记端口号（1024~49151）</p>\n<ul>\n<li>使用这类端口号必须在IANA登记，以防止重复</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>客户端使用的端口号（1024~49151）</p>\n<ul>\n<li><p>又称短暂端口号（也称临时端口） ：这类端口号仅在客户进程运行时才动态地选择</p>\n</li>\n<li><p>通信结束后，刚用过的客户端口号就不复存在，从而这个端口号就可供其他客户进程使用</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>套接字</p>\n<ul>\n<li><p>背景</p>\n<ul>\n<li><p>IP地址来标识和区别不同的主机</p>\n</li>\n<li><p>端口号来标识和区分一台主机中的不同应用进程</p>\n</li>\n</ul>\n</li>\n<li><p>在网络中采用发送方和接收方的套接字（Socket ）组合来识别端点</p>\n<ul>\n<li><p>套接字&#x3D; （主机IP地址，端口号）</p>\n</li>\n<li><p>唯一地标识网络中的一台主机和其上的一个应用（进程）</p>\n</li>\n<li><p>实际上是一个通信端点</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"无连接服务与面向连接服务\"><a href=\"#无连接服务与面向连接服务\" class=\"headerlink\" title=\"无连接服务与面向连接服务\"></a>无连接服务与面向连接服务</h2><ul>\n<li><p>面向连接服务</p>\n<ul>\n<li><p>在通信双方进行通信之前，必须先建立连接，在通信过程中，整个连接的情况一直被实时地监控和管理</p>\n</li>\n<li><p>通信结束后，应该释放这个连接</p>\n</li>\n</ul>\n</li>\n<li><p>无连接服务</p>\n<ul>\n<li>两个实体之间的通信不需要先建立好连接，需要通信时，直接将信息发送到”网络中，让该信息的传递在网上尽力而为地往目的地传送</li>\n</ul>\n</li>\n<li><p>TCP&#x2F;IP协议族的传输协议</p>\n<ul>\n<li><p>面向连接的传输控制协议（TCP ），：采用TCP时，传输层向上提供的是一条全双工的可靠逻辑信道</p>\n</li>\n<li><p>无连接的用户数据报协议（ UDP） ：采用UDP时，传输层向上提供的是一条不可靠的逻辑信道</p>\n</li>\n</ul>\n</li>\n<li><p>TCP&#x2F;IP协议</p>\n<ul>\n<li><p>TCP提供面向连接的可靠传输服务，增加了许多开销，如确认、流量控制、计时器及连接管理等</p>\n</li>\n<li><p>TCP主要适用于可靠性更重要的场合，如文件传输协议（ FTP ）、超文本传输协议（ HTTP ）、远程登录（ TELNET ）等</p>\n</li>\n</ul>\n</li>\n<li><p>UDP协议</p>\n<ul>\n<li><p>在IP之上仅提供两个附加服务：多路复用和对数据的错误检查</p>\n</li>\n<li><p>远程主机的传输层收到UDP报文后，不需要给出任何确认</p>\n</li>\n<li><p>UDP简单，执行速度比较快、实时性好</p>\n</li>\n<li><p>UDP的应用有：小文件传送协议（TFTP）、DNS、SNMP和实时传输协议（ RTP）</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h2><ul>\n<li><p>IP数据报和UDP数据报的区别</p>\n<ul>\n<li><p>IP数据报在网络层要经过路由的存储转发</p>\n</li>\n<li><p>UDP数据报在传输层的端到端的逻辑信道中传输，封装成IP数据报在网络层传输时， UDP数据报的信息对路由是不可见的</p>\n</li>\n</ul>\n</li>\n<li><p>TCP和网络层虚链路的区别</p>\n<ul>\n<li><p>一</p>\n<ul>\n<li><p>TCP报文段在传输层抽象的逻辑信道中传输，对路由器不可见</p>\n</li>\n<li><p>虚电路所经过的交换结点都必须保存虚电路状态信息</p>\n</li>\n</ul>\n</li>\n<li><p>二</p>\n<ul>\n<li><p>网络层若采用虚电路方式，则无法提供无连接服务</p>\n</li>\n<li><p>而传输层采用TCP不影响网络层提供无连接服务</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h1><h2 id=\"UDP数据报\"><a href=\"#UDP数据报\" class=\"headerlink\" title=\"UDP数据报\"></a>UDP数据报</h2><ul>\n<li><p>UDP实现了传输协议能够做的最少工作，在IP的数据报服务之上增加了两个最基本的服务：复用和分用以及差错检测</p>\n</li>\n<li><p>UDP优点</p>\n<ul>\n<li><p>UDP无须建立连接</p>\n<ul>\n<li>不会有建立连接的时延</li>\n</ul>\n</li>\n<li><p>无连接状态</p>\n<ul>\n<li>UDP不维护连接状态，应用服务器使用UDP时，一般都能支持更多的活动客户机</li>\n</ul>\n</li>\n<li><p>分组首部开销小</p>\n</li>\n</ul>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>UDP常用于一次性传输较少数据的网络应用，如DNS、SNMP等</p>\n</li>\n<li><p>UDP提供尽最大努力的交付，即不保证可靠交付</p>\n<ul>\n<li>所有维护传输可靠性的工作需要用户在应用层来完成</li>\n</ul>\n</li>\n<li><p>UDP是面向报文的</p>\n<ul>\n<li>报文是UDP数据报处理的最小单位</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UDP的首部格式</p>\n<ul>\n<li><p>源端口：源端口号。在需要对方回信时选用，不需要时可用全0</p>\n</li>\n<li><p>目的端口：这在终点交付报文时必须使用到。</p>\n</li>\n<li><p>长度： UDP数据报的长度（包括首部和数据） ，其最小值是8 （仅有首部）</p>\n</li>\n<li><p>校验和</p>\n<ul>\n<li><p>检测UDP数据报在传输中是否有错。有错就丢弃</p>\n</li>\n<li><p>该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全0</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>收到数据报</p>\n<ul>\n<li><p>根据首部中的目的端口，把UDP数据报通过相应的端口上交给应用进程</p>\n</li>\n<li><p>如果接收方UDP发现收到的报文中的目的端口号不正确，丢弃该报文，并由ICMP发送“端口不可达”差错报文给发送方</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"UDP校验\"><a href=\"#UDP校验\" class=\"headerlink\" title=\"UDP校验\"></a>UDP校验</h2><ul>\n<li><p>UDP的校验和只检查首部和数据部分</p>\n</li>\n<li><p>注意</p>\n<ul>\n<li><p>校验时，若UDP数据报部分的长度不是偶数个字节，则需填入一个全0字节</p>\n</li>\n<li><p>如果UDP校验和校验出UDP数据报是错误的，那么可以丢弃，也可以交付给上层，但是需要附上错误报告</p>\n</li>\n<li><p>通过伪首部，不仅可以检查源端口号、目的端口号和UDP用户数据报的数据部分，还可以检查IP数据报的源IP地址和目的地址</p>\n</li>\n</ul>\n</li>\n<li><p>备注：检错能力并不强；优点：简单、处理速度快</p>\n</li>\n</ul>\n<h1 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h1><h2 id=\"TCP协议的特点\"><a href=\"#TCP协议的特点\" class=\"headerlink\" title=\"TCP协议的特点\"></a>TCP协议的特点</h2><ul>\n<li><p>TCP是在不可靠的IP层之上实现的可靠的数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题</p>\n</li>\n<li><p>特点</p>\n<ul>\n<li><p>TCP是面向连接的传输层协议</p>\n</li>\n<li><p>每条TCP连接只能有两个端点，每条TCP连接只能是点对点的（一对一）</p>\n</li>\n<li><p>TCP提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序</p>\n</li>\n<li><p>TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据</p>\n</li>\n<li><p>TCP是面向字节流的</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP报文段\"><a href=\"#TCP报文段\" class=\"headerlink\" title=\"TCP报文段\"></a>TCP报文段</h2><ul>\n<li><p>TCP传送的数据单元称为报文段</p>\n</li>\n<li><p>作用</p>\n<ul>\n<li><p>运载数据</p>\n</li>\n<li><p>建立连接、释放连接和应答</p>\n</li>\n</ul>\n</li>\n<li><p>字段意义</p>\n<ul>\n<li><p>源端口和目的端口字段：各占2B ，端口是运输层与应用层的服务接口，运输层的复用和分用功能都要通过端口实现</p>\n</li>\n<li><p>序号字段</p>\n<ul>\n<li><p>占4B ，TCP是面向字节流的（即TCP传送时是逐个字节传送的） ，所以TCP连接传送的数据流中的每个字节都编上一个序号</p>\n</li>\n<li><p>序号字段的值指的是本报文段所发送的数据的第一个字节的序号</p>\n</li>\n</ul>\n</li>\n<li><p>确认号字段：占4B，是期望收到对方的下一个报文段的数据的第一个字节的序号</p>\n</li>\n<li><p>数据偏移（即首部长度） ：占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远</p>\n</li>\n<li><p>保留字段：占6位，保留为今后使用</p>\n</li>\n<li><p>紧急位URG ： URG&#x3D; 1时，表明紧急指针字段有效。它告诉系统报文段中有紧急数据，应尽快传送（相当于高优先级的数据）</p>\n</li>\n<li><p>确认位ACK（TCP规定，在连接建立后所有传送的报文段都必须把ACK置为1）</p>\n<ul>\n<li><p>ACK&#x3D;1时确认号字段才有效</p>\n</li>\n<li><p>ACK&#x3D;0时，确认号无效</p>\n</li>\n</ul>\n</li>\n<li><p>推送位PSH （Push ） ：接收TCP收到PSH&#x3D;1的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满后再向上交付</p>\n</li>\n<li><p>复位位RST （Reset） ： RST—1时，表明TCP连接中出现严重差错（如主机崩溃或其他原因） ，必须释放连接，然后再重新建立运输连接</p>\n</li>\n<li><p>同步位SYN ： SYN&#x3D;1表示这是一个连接请求或连接接收报文</p>\n</li>\n<li><p>终止位FIN （Finish ）：用来释放一个连接。FIN&#x3D; 1表明此报文段的发送方的数据已发送完毕，并要求释放传输连接</p>\n</li>\n<li><p>窗口字段：占2B ，表示允许对方发送的数据量，单位为字节</p>\n</li>\n<li><p>校验和：占2B，校验和字段检验的范围包括首部和数据两部分</p>\n</li>\n<li><p>紧急指针字段：占16位，指出在本报文段中紧急数据共有多少字节（紧急数据放在本报文段数据的最前面）</p>\n</li>\n<li><p>选项字段：长度可变， TCP最初只规定了一种选项，即最大报文段长度</p>\n</li>\n<li><p>填充字段：使整个首部长度是4B的整数倍</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP连接管理\"><a href=\"#TCP连接管理\" class=\"headerlink\" title=\"TCP连接管理\"></a>TCP连接管理</h2><ul>\n<li><p>TCP连接的管理就是使运输连接的建立和释放都能正常进行</p>\n</li>\n<li><p>连接阶段</p>\n<ul>\n<li><p>连接建立</p>\n</li>\n<li><p>数据传送</p>\n</li>\n<li><p>连接释放</p>\n</li>\n</ul>\n</li>\n<li><p>TCP连接建立时面对的问题</p>\n<ul>\n<li><p>要使每一方都能够确知对方的存在</p>\n</li>\n<li><p>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项、时间截选项及服务质量等）</p>\n</li>\n<li><p>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</p>\n</li>\n</ul>\n</li>\n<li><p>连接的建立（三次握手）（服务器易受到SYN洪泛攻击）</p>\n<ul>\n<li><p>客户机的TCP首先向服务器的TCP发送一个连接请求报文段</p>\n<ul>\n<li><p>SYN&#x3D;1</p>\n</li>\n<li><p>seq&#x3D;x</p>\n</li>\n</ul>\n</li>\n<li><p>服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量</p>\n<ul>\n<li><p>SYN&#x3D;1</p>\n</li>\n<li><p>ACK&#x3D;1</p>\n</li>\n<li><p>ack&#x3D;x+1</p>\n</li>\n<li><p>seq&#x3D;y</p>\n</li>\n</ul>\n</li>\n<li><p>当客户机收到确认报文段后，还要向服务器给出确认，并且也要给该连接分配缓存和变量</p>\n<ul>\n<li><p>ACK&#x3D;1</p>\n</li>\n<li><p>seq&#x3D;x+1</p>\n</li>\n<li><p>ack&#x3D;y+1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>连接的释放（四次挥手）</p>\n<ul>\n<li><p>客户机向其TCP发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接</p>\n<ul>\n<li><p>FIN&#x3D;1</p>\n</li>\n<li><p>seq&#x3D;u</p>\n</li>\n</ul>\n</li>\n<li><p>服务器收到连接释放报文段后即发出确认</p>\n<ul>\n<li><p>ACK&#x3D;1</p>\n</li>\n<li><p>seq&#x3D;v</p>\n</li>\n<li><p>ack&#x3D;u+1</p>\n</li>\n</ul>\n</li>\n<li><p>服务器通知客户端TCP释放连接</p>\n<ul>\n<li><p>FIN&#x3D;1</p>\n</li>\n<li><p>ACK&#x3D;1</p>\n</li>\n<li><p>seq&#x3D;w</p>\n</li>\n<li><p>ack&#x3D;u+1</p>\n</li>\n</ul>\n</li>\n<li><p>客户机受到连接释放报文后，发出确认</p>\n<ul>\n<li><p>ACK&#x3D;1</p>\n</li>\n<li><p>seq&#x3D;u+1</p>\n</li>\n<li><p>ack&#x3D;w+1</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SYN洪泛攻击\"><a href=\"#SYN洪泛攻击\" class=\"headerlink\" title=\"SYN洪泛攻击\"></a>SYN洪泛攻击</h2><ul>\n<li><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手</p>\n</li>\n<li><p>攻击者发送TCP SYN ， SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认</p>\n</li>\n<li><p>那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者</p>\n</li>\n<li><p>影响：</p>\n<ul>\n<li><p>浪费服务器的资源</p>\n</li>\n<li><p>在服务器上，这些TCP连接因为挂起状态而消耗CPU和内存，最后服务器可能死机</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP可靠传输（实现机制）\"><a href=\"#TCP可靠传输（实现机制）\" class=\"headerlink\" title=\"TCP可靠传输（实现机制）\"></a>TCP可靠传输（实现机制）</h2><ul>\n<li><p>序号</p>\n<ul>\n<li>TCP首部的序号字段用来保证数据能有序提交给应用层，序号建立在传送的字节流之上</li>\n</ul>\n</li>\n<li><p>确认</p>\n<ul>\n<li><p>TCP首部的确认号是期望收到对方的下一个振文段的数据的第一个字节的序号</p>\n</li>\n<li><p>TCP默认使用累计确认，即TCP只确认数据流中至第一个丢失字节为止的字节</p>\n</li>\n</ul>\n</li>\n<li><p>重传</p>\n<ul>\n<li><p>超时</p>\n<ul>\n<li>TCP每发送一个报文段，就对这个报文段设置一次计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段</li>\n</ul>\n</li>\n<li><p>冗余ACK</p>\n<ul>\n<li><p>再次确认某个报文段的ACK，而发送方先前已经收到过该报文段的确认</p>\n</li>\n<li><p>当收到对于某个报文段的3个冗余ACK，可以认为该报文段已经丢失。这时发送方可以立即对该报文执行重传</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP流量控制\"><a href=\"#TCP流量控制\" class=\"headerlink\" title=\"TCP流量控制\"></a>TCP流量控制</h2><ul>\n<li><p>匹配发送方的发送速与接收方的读取速率</p>\n</li>\n<li><p>流量控制机制</p>\n<ul>\n<li><p>基于滑动窗口协议的流量控制机制</p>\n</li>\n<li><p>实现方法</p>\n<ul>\n<li><p>接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小（接收窗口rwnd ） ，限制发送方向网络注入报文的速率</p>\n</li>\n<li><p>发送方根据其对当前网络拥塞程序的估计而确定的窗口值，这称为拥塞窗口cwnd </p>\n<ul>\n<li>其大小与网络的带宽和时延有关</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>流量控制的区别</p>\n<ul>\n<li><p>传输层：定义端到端用户之间的流量控制</p>\n</li>\n<li><p>数据链路层：定义两个中间的相邻结点的流量控制</p>\n</li>\n</ul>\n</li>\n<li><p>窗口大小的区别</p>\n<ul>\n<li><p>传输层：滑动窗口可以动态变化</p>\n</li>\n<li><p>数据链路层：滑动窗口不能动态变化</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"TCP拥塞控制\"><a href=\"#TCP拥塞控制\" class=\"headerlink\" title=\"TCP拥塞控制\"></a>TCP拥塞控制</h2><ul>\n<li><p>拥塞控制：防止过多的数据注入网络，保证网络中的路由器或链路不致过载</p>\n</li>\n<li><p>拥塞控制与流量控制的区别</p>\n<ul>\n<li><p>相同点：它们都通过控制发送方发送数据的速率来达到控制效果</p>\n</li>\n<li><p>区别</p>\n<ul>\n<li><p>拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素</p>\n</li>\n<li><p>流量控制是点对点的通信量的控制，即接收端控制发送端，它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>窗口（发送窗口的上限值&#x3D;min[rwnd，cwnd]）</p>\n<ul>\n<li><p>接收窗口rwnd ：接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量</p>\n</li>\n<li><p>拥塞窗口cwnd：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量</p>\n</li>\n</ul>\n</li>\n<li><p>实现机制</p>\n<ul>\n<li><p>慢开始</p>\n<ul>\n<li><p>每经过一个传输轮次（即往返时延RTT ），拥塞窗口cwnd就会加倍</p>\n</li>\n<li><p>令拥塞窗口cwnd &#x3D;1即一个最大报文段长度MSS ，每收到一个对新报文段的确认后，将cwnd加1</p>\n</li>\n<li><p>使分组注入网络的速率更加合理</p>\n</li>\n<li><p>慢开始一直把拥塞窗口cwnd增大到一个规定的慢开始门限ssthresh （阈值） ，然后改用拥塞避免算法</p>\n</li>\n</ul>\n</li>\n<li><p>拥塞避免</p>\n<ul>\n<li><p>发送端的拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，而不是加倍</p>\n</li>\n<li><p>cwnd按线性规律缓慢增长（即加法增大） ，而当出现一次超时（网络拥塞）时，令慢开始门限ssthresh等于当前cwnd的一半（即乘法减小）</p>\n</li>\n</ul>\n</li>\n<li><p>快重传</p>\n<ul>\n<li>当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时</li>\n</ul>\n</li>\n<li><p>快恢复</p>\n<ul>\n<li><p>发送端收到连续三个冗余ACK （即重复确认）时，执行”乘法减小算法，把慢开始门限ssthresh设置为出现拥塞时发送方cwnd的一半</p>\n</li>\n<li><p>把cwnd的值设置为慢开始门限ssthresh改变后的数值，然后开始执行拥塞避免算法（ “加法增大” ），使拥塞窗口缓慢地线性增大</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>网络拥塞的处理</p>\n<ul>\n<li><p>发送方检测到超时事件的发生（未按时收到确认，重传计时器超时） ，就要把慢开始门限ssthresh设置为出现拥塞时的发送方的cwnd值的一半（但不能小于2）</p>\n</li>\n<li><p>然后把拥塞窗口cwnd重新设置为L执行慢开始算法</p>\n</li>\n</ul>\n</li>\n</ul>\n","categories":["计算机408","4.计算机网络","5.传输层"],"tags":["写作"]},{"title":"应用层","url":"/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_6.%E5%BA%94%E7%94%A8%E5%B1%82/","content":"<h1 id=\"网络应用模型\"><a href=\"#网络应用模型\" class=\"headerlink\" title=\"网络应用模型\"></a>网络应用模型</h1><h2 id=\"客户-x2F-服务器模型\"><a href=\"#客户-x2F-服务器模型\" class=\"headerlink\" title=\"客户&#x2F;服务器模型\"></a>客户&#x2F;服务器模型</h2><ul>\n<li><p>概述</p>\n<ul>\n<li>在客户&#x2F;服务器（C&#x2F;S ）模型中，有一个总是打开的主机称为服务器，它服务于许多来自其他称为客户机的主机请求</li>\n</ul>\n</li>\n<li><p>工作流程</p>\n<ul>\n<li><p>服务器处于接收请求的状态</p>\n</li>\n<li><p>客户机发出服务请求，并等待接收结果</p>\n</li>\n<li><p>服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机</p>\n</li>\n</ul>\n</li>\n<li><p>主要特征</p>\n<ul>\n<li><p>客户是服务请求方，服务器是服务提供方</p>\n</li>\n<li><p>网络中各计算机的地位不平等，服务器可以通过对用户权限的限制来达到管理客户机的目的，使它们不能随意存储&#x2F;删除数据，或进行其他受限的网络活动</p>\n</li>\n<li><p>客户机相互之间不直接通信</p>\n</li>\n<li><p>可扩展性不佳</p>\n</li>\n</ul>\n</li>\n<li><p>客户&#x2F;服务器模型的应用</p>\n<ul>\n<li><p>Web</p>\n</li>\n<li><p>文件传输协议（FTP）</p>\n</li>\n<li><p>远程登录</p>\n</li>\n<li><p>电子邮件</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"P2P模型\"><a href=\"#P2P模型\" class=\"headerlink\" title=\"P2P模型\"></a>P2P模型</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>各计算机没有固定的客户和服务器划分</p>\n</li>\n<li><p>任意一对计算机——称为对等方（ Peer ），直接相互通信</p>\n</li>\n<li><p>每个结点既作为客户访问其他结点的资源，也作为服务器提供资源给其他结点访问</p>\n</li>\n</ul>\n</li>\n<li><p>P2P应用</p>\n<ul>\n<li><p>PPlive</p>\n</li>\n<li><p>Bittorrent</p>\n</li>\n<li><p>电驴</p>\n</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>减轻了服务器的计算压力，消除了对某个服务器的完全依赖，提高了系统效率和资源利用率</p>\n</li>\n<li><p>多个客户机之间可以直接共享文档</p>\n</li>\n<li><p>可扩展性好，传统服务器有响应和带宽的限制，只能接受一定数量的请求</p>\n</li>\n<li><p>网络健壮性强，单个结点的失效不会影响其他部分的结点</p>\n</li>\n</ul>\n</li>\n<li><p>缺点（各大ISP（互联网提供商，如电信、网通等）通常对P2P应用持反对态度）</p>\n<ul>\n<li><p>占用较多的内存，影响整机速度</p>\n</li>\n<li><p>P2P下载会对硬盘造成较大的损任</p>\n</li>\n<li><p>使网络变得非常拥塞</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"域名系统（DNS）\"><a href=\"#域名系统（DNS）\" class=\"headerlink\" title=\"域名系统（DNS）\"></a>域名系统（DNS）</h1><h2 id=\"基本概述\"><a href=\"#基本概述\" class=\"headerlink\" title=\"基本概述\"></a>基本概述</h2><ul>\n<li><p>域名系统（ DNS ）是因特网使用的命名系统，用来把便于人们记忆的具有特定含义的主机名（如<a href=\"http://www.cskaoyan.com/\">www.cskaoyan.com</a> ）转换为便于机器处理的IP地址</p>\n</li>\n<li><p>地址 DNS系统采用客户&#x2F;服务器模型</p>\n</li>\n<li><p>协议运行在UDP之上，使用53号端口</p>\n</li>\n</ul>\n<h2 id=\"层次域名空间\"><a href=\"#层次域名空间\" class=\"headerlink\" title=\"层次域名空间\"></a>层次域名空间</h2><ul>\n<li><p>因特网采用层次树状结构的命名方法，任何一个连接到因特网的主机或路由器，都有一个唯一的层次结构名称，即域名</p>\n</li>\n<li><p>域名规则</p>\n<ul>\n<li><p>标号中的英文不区分大小写。</p>\n</li>\n<li><p>标号中除连字符（-）外不能使用其他的标点符号</p>\n</li>\n<li><p>每个标号不超过63个字符，多标号组成的完整域名最长不超过255个字符</p>\n</li>\n<li><p>级别最低的域名写在最左边，级别最高的顶级域名写在最右边</p>\n</li>\n</ul>\n</li>\n<li><p>顶级域名分类</p>\n<ul>\n<li><p>国家顶级域名（ nTLD ）：国家和某些地区的域名，如“.cn”表示中国， “us”表示美国， “.uk”表示英国</p>\n</li>\n<li><p>通用顶级域名（ gTLD ）：常见的有“.com” （公司）、“.net” （网络服务机构）&#x2F;“.org” （非营利性组织）和“.gov” （国家或政府部门）等</p>\n</li>\n<li><p>基础结构域名：这种顶级域名只有一个arpa，用于反向域名解析，因此又称反向域名</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"域名服务器\"><a href=\"#域名服务器\" class=\"headerlink\" title=\"域名服务器\"></a>域名服务器</h2><ul>\n<li><p>因特网的域名系统被设计成一个联机分布式的数据库系统，并采用客户&#x2F;服务器模型</p>\n</li>\n<li><p>分类</p>\n<ul>\n<li><p>根域名服务器：是最高层次的域名服务器，所有的根域名服务器都知道所有的顶级域名服务器的IP地址</p>\n</li>\n<li><p>顶级域名服务器</p>\n<ul>\n<li><p>负责管理在该顶级域名服务器注册的所有二级域名</p>\n</li>\n<li><p>收到DNS查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当查找的域名服务器的IP地址）</p>\n</li>\n</ul>\n</li>\n<li><p>授权域名服务器（权限域名服务器）</p>\n<ul>\n<li><p>每台主机都必须在授权域名服务器处登记</p>\n</li>\n<li><p>授权域名服务器总能将其管辖的主机名转换为该主机的IP地址</p>\n</li>\n</ul>\n</li>\n<li><p>本地域名服务器 </p>\n<ul>\n<li><p>当一台主机发出DNS查询请求时，这个查询请求报文就发送给该主机的本地域名服务器</p>\n</li>\n<li><p>每个因特网服务提供者（ISP ），或一所大学，甚至一所大学中的各个系，都可以拥有一个本地域名服务器</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"域名解析过程\"><a href=\"#域名解析过程\" class=\"headerlink\" title=\"域名解析过程\"></a>域名解析过程</h2><ul>\n<li><p>正向解析：把域名映射成为IP地址</p>\n</li>\n<li><p>反向解析：把IP地址映射成域名的过程</p>\n</li>\n<li><p>查询方式</p>\n<ul>\n<li><p>递归查询</p>\n<ul>\n<li>该方法给根域名服务造成的负载过大，所以在实际中几乎不使用</li>\n</ul>\n</li>\n<li><p>递归与迭代相结合的查询</p>\n<ul>\n<li><p>主机向本地域名服务器的查询采用的是递归查询</p>\n</li>\n<li><p>本地域名服务器向根域名服务器的查询采用迭代查询</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>域名解析的过程</p>\n<ul>\n<li><p>客户机向其本地域名服务器发出DNS请求报文</p>\n</li>\n<li><p>本地域名服务器收到请求后，查询本地缓存，若没有该记录，则以DNS客户的身份向根域名服务器发出解析请求</p>\n</li>\n<li><p>根域名服务器收到请求后，判断该域名属于域，将对应的顶级域名服务器<a href=\"http://dns.com/\">dns.com</a>的IP地址返回给本地域名服务器</p>\n</li>\n<li><p>本地域名服务器向顶级域名服务器<a href=\"http://dns.com/\">dns.com</a>发出解析请求报文</p>\n</li>\n<li><p>顶级域名服务器<a href=\"http://dns.com/\">dns.com</a>收到请求后，判断该域名属于<a href=\"http://abc.com/\">abc.com</a>域，因此将对应的授权域名服务器<a href=\"http://dns.abc.com/\">dns.abc.com</a>的IP地址返回给本地域名服务器</p>\n</li>\n<li><p>本地域名服务器向授权域名服务器<a href=\"http://dns.abc.com/\">dns.abc.com</a>发起解析请求报文</p>\n</li>\n<li><p>授权域名服务器<a href=\"http://dns.abc.com/\">dns.abc.com</a>收到请求后，将查询结果返回给本地域名服务器</p>\n</li>\n<li><p>本地域名服务器将查询结果保存到本地缓存，同时返回给客户机</p>\n</li>\n</ul>\n</li>\n<li><p>高速缓存</p>\n<ul>\n<li><p>注意</p>\n<ul>\n<li>主机名和IP地址之间的映射不是永久的，所以DNS服务器将在一段时间后丢弃高速缓存中的信息</li>\n</ul>\n</li>\n<li><p>优点</p>\n<ul>\n<li><p>提高DNS的查询效率</p>\n</li>\n<li><p>减少因特网上的DNS查询报文数量</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"文件传输协议（FTP）\"><a href=\"#文件传输协议（FTP）\" class=\"headerlink\" title=\"文件传输协议（FTP）\"></a>文件传输协议（FTP）</h1><h2 id=\"FTP的工作原理\"><a href=\"#FTP的工作原理\" class=\"headerlink\" title=\"FTP的工作原理\"></a>FTP的工作原理</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>FTP提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限</p>\n</li>\n<li><p>屏蔽了各计算机系统的细节，因而适合于在异构网络中的任意计算机之间传送文件</p>\n</li>\n<li><p>FTP采用客户服务器的工作方式，它使用TCP可靠的传输服务</p>\n</li>\n</ul>\n</li>\n<li><p>FTP功能</p>\n<ul>\n<li><p>提供不同种类主机系统（硬、软件体系等都可以不同）之间的文件传输能力</p>\n</li>\n<li><p>以用户权跟管理的方式提供用户对远程FTP服务器上的文件管理能力</p>\n</li>\n<li><p>以匿名FTP的方式提供公用文件共享的能力</p>\n</li>\n</ul>\n</li>\n<li><p>FTP进程组成</p>\n<ul>\n<li><p>主进程：负责接收新的请求</p>\n</li>\n<li><p>若干从属进程：处理单个请求</p>\n</li>\n</ul>\n</li>\n<li><p>工作步骤（FTP服务器必须在整个会话期间保留用户的状态信息）</p>\n<ul>\n<li><p>打开熟知端口21 （控制端口） ，使客户进程能够连接上</p>\n</li>\n<li><p>等待客户进程发连接请求</p>\n</li>\n<li><p>启动从属进程来处理客户进程发来的请求。主进程与从属进程并发执行，从属进程对客户进程的请求处理完毕后即终止</p>\n</li>\n<li><p>回到等待状态，继续接收其他客户进程的请求</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"控制连接与数据连接\"><a href=\"#控制连接与数据连接\" class=\"headerlink\" title=\"控制连接与数据连接\"></a>控制连接与数据连接</h2><ul>\n<li><p>特点：FTP在工作时使用两个并行的TCP连接</p>\n</li>\n<li><p>控制连接（端口号21）</p>\n<ul>\n<li><p>服务器监听21号端口，等待客户连接，建立在这个端口上的连接称为控制连接</p>\n</li>\n<li><p>控制连接用来传输控制信息（如连接请求、传送请求等） ，并且控制信息都以7位ASCII格式传送</p>\n</li>\n<li><p>控制连接在整个会话期间一直保持打开状态</p>\n</li>\n</ul>\n</li>\n<li><p>数据连接（端口号20）</p>\n<ul>\n<li><p>服务器端的控制进程在接收到FTP客户发来的文件传输请求后，就创建数据传送进程和数据连接</p>\n</li>\n<li><p>传送完毕后关闭“数据传送连接”并结束运行</p>\n</li>\n</ul>\n</li>\n<li><p>备注：使用两个不同的端口号可使协议更加简单和更容易实现</p>\n</li>\n</ul>\n<h1 id=\"电子邮件\"><a href=\"#电子邮件\" class=\"headerlink\" title=\"电子邮件\"></a>电子邮件</h1><h2 id=\"电子邮件的组成结构\"><a href=\"#电子邮件的组成结构\" class=\"headerlink\" title=\"电子邮件的组成结构\"></a>电子邮件的组成结构</h2><ul>\n<li><p>主要的组成</p>\n<ul>\n<li><p>用户代理：用户与电子邮件系统的接口</p>\n</li>\n<li><p>邮件服务器</p>\n<ul>\n<li><p>组成电子邮件系统的核心</p>\n</li>\n<li><p>发送和接收邮件</p>\n</li>\n<li><p>向用户回报发送情况</p>\n</li>\n</ul>\n</li>\n<li><p>邮件发送协议和读取协议</p>\n<ul>\n<li><p>SMTP ：邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件</p>\n</li>\n<li><p>POP3 ：邮件读取协议用于用户代理从邮件服务器读取邮件</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"电子邮件的收发过程\"><a href=\"#电子邮件的收发过程\" class=\"headerlink\" title=\"电子邮件的收发过程\"></a>电子邮件的收发过程</h2><ul>\n<li><p>发信人调用用户代理来撰写和编辑要发送的邮件。用户代理用SMTP把邮件传送给发送方邮件服务器</p>\n</li>\n<li><p>发送方邮件服务器将邮件放入邮件缓存队列中，等待发送</p>\n</li>\n<li><p>运行在发送方邮件服务器的SMTP客户进程，发现邮件缓存中有待发送的邮件，就向运行在接收方邮件服务器的SMTP服务器进程发起建立TCP连接</p>\n</li>\n<li><p>TCP连接建立后， SMTP客户进程开始向远程SMTP服务器进程发送邮件。当所有待发送邮件发完后， SMTP就关闭所建立的TCP连接</p>\n</li>\n<li><p>运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，将邮件放入收信人的用户邮箱，等待收信人在方便时进行读取</p>\n</li>\n<li><p>收信人打算收信时，调用用户代理，使用POP3 （或IMAP ）协议将自己的邮件从接收方邮件服务器的用户邮箱中取回（如果邮箱中有来信的话）</p>\n</li>\n</ul>\n<h2 id=\"电子邮件格式与MIME\"><a href=\"#电子邮件格式与MIME\" class=\"headerlink\" title=\"电子邮件格式与MIME\"></a>电子邮件格式与MIME</h2><ul>\n<li><p>电子邮件格式</p>\n<ul>\n<li><p>to是必需的关键字，后面填入一个或多个收件人的电子邮件地址</p>\n</li>\n<li><p>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容。</p>\n</li>\n<li><p>From是必填的关键字，但它通常由邮件系统自动填入</p>\n</li>\n</ul>\n</li>\n<li><p>典型的邮件内容</p>\n<ul>\n<li><p>From：<a href=\"mailto:&#104;&#111;&#x6f;&#x70;&#x64;&#x6f;&#103;&#64;&#104;&#117;&#x73;&#x74;&#46;&#x65;&#x64;&#117;&#x2e;&#x63;&#110;\">&#104;&#111;&#x6f;&#x70;&#x64;&#x6f;&#103;&#64;&#104;&#117;&#x73;&#x74;&#46;&#x65;&#x64;&#117;&#x2e;&#x63;&#110;</a></p>\n</li>\n<li><p>To:<a href=\"mailto:&#97;&#x62;&#99;&#64;&#99;&#x73;&#107;&#97;&#111;&#x79;&#97;&#x6e;&#x2e;&#99;&#x6f;&#109;\">&#97;&#x62;&#99;&#64;&#99;&#x73;&#107;&#97;&#111;&#x79;&#97;&#x6e;&#x2e;&#99;&#x6f;&#109;</a></p>\n</li>\n<li><p>Subject:Say hell to Internet</p>\n</li>\n<li><p>blahblah······</p>\n</li>\n</ul>\n</li>\n<li><p>多用途网际邮件扩充（MIME）</p>\n<ul>\n<li><p>背景</p>\n<ul>\n<li><p>SMTP只能传送一定长度的ASCII码，许多其他非英语国家的文字（如中文）就无法传送</p>\n</li>\n<li><p>无法传送可执行文件及其他二进制对象</p>\n</li>\n</ul>\n</li>\n<li><p>继续使用目前的格式，增加了邮件主体的结构，并定义了传送非ASCII码的编码规则</p>\n</li>\n<li><p>内容</p>\n<ul>\n<li><p>5个新的邮件首部字段，包括MIME版本、类型</p>\n</li>\n<li><p>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</p>\n</li>\n<li><p>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SMTP和POP3\"><a href=\"#SMTP和POP3\" class=\"headerlink\" title=\"SMTP和POP3\"></a>SMTP和POP3</h2><ul>\n<li><p>简单邮件传输协议（SMTP）</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li><p>一种提供可靠且有效的电子邮件传输的协议，它控制两个相互通信的SMTP进程交换信息</p>\n</li>\n<li><p>使用客户&#x2F;服务器方式</p>\n</li>\n<li><p>发送邮件的SMTP进程是SMTP客户，而负责接收邮件的SMTP进程是SMTP服务器</p>\n</li>\n<li><p>TCP连接，端口号为25</p>\n</li>\n</ul>\n</li>\n<li><p>通信阶段</p>\n<ul>\n<li><p>连接建立</p>\n<ul>\n<li><p>发件人的邮件发送到发送方邮件服务器的邮件缓存中后， SMTP客户就每隔一定时间对邮件缓存扫描一次</p>\n</li>\n<li><p>发现有邮件，就使用SMTP的熟知端口号（25）与接收方邮件服务器的SMTP服务器建立TCP连接</p>\n</li>\n<li><p>SMTP不使用中间邮件服务器。TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立</p>\n</li>\n</ul>\n</li>\n<li><p>邮件传送</p>\n<ul>\n<li><p>连接建立后，就可开始传送邮件</p>\n</li>\n<li><p>邮件的传送从MAIL命令开始， MALL命令后面有发件人的地址</p>\n</li>\n<li><p>SMTP服务器已准备好接收邮件，则回答250 OK，接着SMTP客户端发送一个或多个RCPT （收件人recipient的缩写）命令</p>\n</li>\n<li><p>RCPT命令的作用：先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，避免浪费通信资源</p>\n</li>\n</ul>\n</li>\n<li><p>连接释放</p>\n<ul>\n<li><p>邮件发送完毕后， SMTP客户应发送QUIT命令</p>\n</li>\n<li><p>SMTP服务器返回的信息是221 （服务关闭） ，表示SMTP同意释放TCP连接</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>1、SMTP不能传送可执行文件或者其他二进制对象</p>\n</li>\n<li><p>2、SMTP仅限于传送7位ASCII码，不能传送其他非英语国家的文字。</p>\n</li>\n<li><p>3、SMTP服务器会拒绝超过一定长度的邮件。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>POP3</p>\n<ul>\n<li><p>概述</p>\n<ul>\n<li><p>邮局协议（ POP）是一个非常简单但功能有限的邮件读取协议，现在使用的是它的第3个版本POP3 </p>\n</li>\n<li><p>当用户读取邮件时，用户代理向邮件服务器发出请求，拉取用户邮箱中的邮件</p>\n</li>\n<li><p>使用客户&#x2F;服务器的工作方式</p>\n</li>\n<li><p>在传输层使用TCP，端口号为110</p>\n</li>\n</ul>\n</li>\n<li><p>工作方式</p>\n<ul>\n<li><p>下载并保留</p>\n</li>\n<li><p>下载并删除</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"因特网报文存取协议（IMAP）\"><a href=\"#因特网报文存取协议（IMAP）\" class=\"headerlink\" title=\"因特网报文存取协议（IMAP）\"></a>因特网报文存取协议（IMAP）</h2><ul>\n<li><p>邮件接收协议，比POP复杂得多</p>\n</li>\n<li><p>用户提供了创建文件夹、在不同文件夹之间移动邮件及在远程文件夹中查询邮件的命令，为此IMAP服务器维护了会话用户的状态信息</p>\n</li>\n<li><p>允许用户代理只获取报文的某些部分</p>\n</li>\n</ul>\n<h2 id=\"基于万维网的电子邮件\"><a href=\"#基于万维网的电子邮件\" class=\"headerlink\" title=\"基于万维网的电子邮件\"></a>基于万维网的电子邮件</h2><ul>\n<li><p>特点</p>\n<ul>\n<li><p>用户浏览器与Hotmail或Gmail的邮件服务器之间的邮件发送或接收使用HTTP</p>\n</li>\n<li><p>在不同邮件服务器之间传送邮件时使用SMTP</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"万维网（WWW）\"><a href=\"#万维网（WWW）\" class=\"headerlink\" title=\"万维网（WWW）\"></a>万维网（WWW）</h1><h2 id=\"WWW的概念与组成结构\"><a href=\"#WWW的概念与组成结构\" class=\"headerlink\" title=\"WWW的概念与组成结构\"></a>WWW的概念与组成结构</h2><ul>\n<li><p>概念</p>\n<ul>\n<li><p>万维网（WWW）</p>\n<ul>\n<li><p>在这个空间中，有用的事物称为资源，并由一个全域“统一资源定位符” （URL ）标识。</p>\n</li>\n<li><p>这些资源通过超文本传输协议（ HTTP ）传送给使用者，而后者通过单击链接来获取资</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>内核部分标准构成</p>\n<ul>\n<li><p>统一资源定位符（ URL） ：负责标识万维网上的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符URL</p>\n</li>\n<li><p>超文本传输协议（HTTP ） ：一个应用层协议，它使用TCP连接进行可靠的传输， HTTP是万维网客户程序和服务器程序之间交互所必须严格遵守的协议</p>\n</li>\n<li><p>超文本标记语言（HTML） ：一种文档结构的标记语言，它使用一些约定的标记对页面上的各种信息（包括文字、声音、图像、视频等）、格式进行描述</p>\n</li>\n</ul>\n</li>\n<li><p>工作流程</p>\n<ul>\n<li><p>Web用户使用浏览器（指定URL ）与Web服务器建立连接，并发送浏览请求</p>\n</li>\n<li><p>Web服务器把URL转换为文件路径，并返回信息给Web浏览器</p>\n</li>\n<li><p>通信完成，关闭连接</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"超文本传输协议（HTTP）\"><a href=\"#超文本传输协议（HTTP）\" class=\"headerlink\" title=\"超文本传输协议（HTTP）\"></a>超文本传输协议（HTTP）</h2><ul>\n<li><p>概述</p>\n<ul>\n<li><p>HTTP定义了浏览器（万维网客户进程）怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器</p>\n</li>\n<li><p>HTTP是面向事务的应用层协议</p>\n</li>\n<li><p>规定了在浏览器和服务器之间的请求和响应的格式与规则</p>\n</li>\n<li><p>是万维网上能够可靠地交换文件的重要基础</p>\n</li>\n</ul>\n</li>\n<li><p>HTTP的操作过程</p>\n<ul>\n<li><p>每个万维网站点都有一个服务器进程，它不断地监听TCP的端口80 （默认）</p>\n</li>\n<li><p>当监听到连接请求后便与浏览器建立连接</p>\n</li>\n<li><p>TCP连接建立后，浏览器就向服务器发送请求获取某个Web页面的HTTP请求</p>\n</li>\n<li><p>服务器收到HTTP请求后，将构建所请求Web页的必需信息，并通过HTTP响应返回给浏览器</p>\n</li>\n<li><p>浏览器再将信息进行解释，然后将Web页显示给用户</p>\n</li>\n<li><p>TCP连接释放</p>\n</li>\n</ul>\n</li>\n<li><p>HTTP报文</p>\n<ul>\n<li><p>请求报文</p>\n</li>\n<li><p>响应报文</p>\n</li>\n</ul>\n</li>\n<li><p>用户单击鼠标后发生的事件按顺序</p>\n<ul>\n<li><p>浏览器分析链接指向页面的URL。</p>\n</li>\n<li><p>浏览器向DNS请求解析域名的IP地址。</p>\n</li>\n<li><p>域名服务器DNS解析出IP地址</p>\n</li>\n<li><p>浏览器与该服务器建立TCP连接（默认端口号为80）</p>\n</li>\n<li><p>浏览器发出HTTP请求GET &#x2F;ch&#x2F;index.html</p>\n</li>\n<li><p>服务器通过HTTP响应把文件index.htm发送给浏览器</p>\n</li>\n<li><p>TCP连接释放</p>\n</li>\n<li><p>浏览器解释文件index.htm，并将Web页显示给用户</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP的特点\"><a href=\"#HTTP的特点\" class=\"headerlink\" title=\"HTTP的特点\"></a>HTTP的特点</h2><ul>\n<li><p>HTTP是无状态的，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同</p>\n</li>\n<li><p>HTTP的无状态特性简化了服务器的设计，使服务器更容易支持大量并发的HTTP请求</p>\n</li>\n<li><p>使用Cookie加数据库的方式来跟踪用户的活动</p>\n</li>\n<li><p>HTTP采用TCP作为运输层协议，保证了数据的可靠传输</p>\n</li>\n<li><p>HTTP既可以使用非持久连接，也可以使用持久连接（ HTTP&#x2F;1.1支持）</p>\n</li>\n</ul>\n<h2 id=\"持久连接与非持久连接\"><a href=\"#持久连接与非持久连接\" class=\"headerlink\" title=\"持久连接与非持久连接\"></a>持久连接与非持久连接</h2><ul>\n<li><p>非持久连接：每个网页元素对象（如JPEG图形、Flash等）的传输都需要单独建立一个TCP连接</p>\n</li>\n<li><p>持久连接：是指万维网服务器在发送响应后仍然保持这条连接，使同一个客户和服务器可以继续在这条连接上传送后续的HTTP请求与响应报文</p>\n</li>\n<li><p>持久连接</p>\n<ul>\n<li><p>非流水线</p>\n<ul>\n<li>客户在收到前一个响应后才能发出下一个请求</li>\n</ul>\n</li>\n<li><p>流水线</p>\n<ul>\n<li>客户每遇到一个对象引用，就立即发出一个请求</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"HTTP的报文结构\"><a href=\"#HTTP的报文结构\" class=\"headerlink\" title=\"HTTP的报文结构\"></a>HTTP的报文结构</h2><ul>\n<li><p>HTTP是面向文本的</p>\n</li>\n<li><p>报文类型</p>\n<ul>\n<li><p>请求报文：从客户向服务器发送的请求报文。</p>\n<ul>\n<li><p>方法（操作）、意义</p>\n</li>\n<li><p>GET、请求读取由URL标识的信息</p>\n</li>\n<li><p>HEAD、请求读取由URL标识的信息的首部</p>\n</li>\n<li><p>POST、给服务器添加信息（如注释）</p>\n</li>\n<li><p>CONNECT、用于代理服务器</p>\n</li>\n</ul>\n</li>\n<li><p>响应报文：从服务器到客户的回答</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h2><ul>\n<li><p>1xx表示通知信息的，如请求收到了或正在处理。</p>\n</li>\n<li><p>2xx表示成功，如接受或知道了。</p>\n</li>\n<li><p>3xx表示重定向，如要完成请求还必须采取进一步的行动</p>\n</li>\n<li><p>4xx表示客户的差错，如请求中有错误的语法或不能完成</p>\n</li>\n<li><p>5xx表示服务器的差错，如服务器失效无法完成请求</p>\n</li>\n</ul>\n","categories":["计算机408","4.计算机网络","6.应用层"],"tags":["写作"]},{"title":"1.入门","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_1.%E5%85%A5%E9%97%A8/","content":"<h1 id=\"Java简介\"><a href=\"#Java简介\" class=\"headerlink\" title=\"Java简介\"></a>Java简介</h1><h2 id=\"跨平台（Java-特点）\"><a href=\"#跨平台（Java-特点）\" class=\"headerlink\" title=\"跨平台（Java 特点）\"></a>跨平台（Java 特点）</h2><blockquote>\n<p>Java程序不是直接运行的。</p>\n<p>Java编译器：将Java源程序编译成与平台无关的字节码文件(class文件)</p>\n<p>Java虚拟机（JVM）：对字节码文件解释执行，所以不同的操作系统，只需安装不同的Java虚拟机（JVM）即可实现java程序的跨平台</p>\n</blockquote>\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><h3 id=\"Java-SE、Java-EE、Java-ME辨析\"><a href=\"#Java-SE、Java-EE、Java-ME辨析\" class=\"headerlink\" title=\"Java SE、Java EE、Java ME辨析\"></a>Java SE、Java EE、Java ME辨析</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>地位</th>\n<th>包含</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Java SE</td>\n<td>标准版</td>\n<td>JVM、标准库</td>\n<td>学习Java必学的第一步</td>\n</tr>\n<tr>\n<td>Java EE</td>\n<td>企业版</td>\n<td>JVM、标准库、大量API和库</td>\n<td>深入学习企业版Java</td>\n</tr>\n<tr>\n<td>Java ME</td>\n<td>嵌入式设备</td>\n<td>JVM瘦身版、特有的标准库</td>\n<td>现在几乎无人使用，普遍使用Android</td>\n</tr>\n</tbody></table>\n<p>Java学习路线图如下：</p>\n<ol>\n<li>首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；</li>\n<li>如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；</li>\n<li>如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；</li>\n<li>如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。</li>\n</ol>\n<h3 id=\"JRE、JDK、JVM辨析\"><a href=\"#JRE、JDK、JVM辨析\" class=\"headerlink\" title=\"JRE、JDK、JVM辨析\"></a>JRE、JDK、JVM辨析</h3><ul>\n<li><p>JDK（开发工具）</p>\n<ul>\n<li><p>JRE &#x3D; JVM + Java API ，用于执行</p>\n</li>\n<li><p>开发工具</p>\n<ul>\n<li>编译器javac</li>\n<li>java程序调试、分析</li>\n<li>java程序编写所需的文档和demo例子程序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>JDK：Java开发工具，包含了JRE和开发工具</p>\n<p>JRE：Java运行环境，包含了JVM和Java的核心类库（Java API）</p>\n<p>JVM：Java虚拟机</p>\n</blockquote>\n<p>总结：安装JDK，即包含了java的运行环境和虚拟机</p>\n<h3 id=\"JDK下载和安装\"><a href=\"#JDK下载和安装\" class=\"headerlink\" title=\"JDK下载和安装\"></a>JDK下载和安装</h3><h4 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h4><p>注意选择对应操作系统的JDK：<a href=\"http://www.oracle.com/\">JDK下载</a></p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>只需要修改安装目录：D:\\Design</p>\n<p><strong>注意</strong>：安装目录不能包含中文和特殊字符</p>\n<h4 id=\"Path变量的配置\"><a href=\"#Path变量的配置\" class=\"headerlink\" title=\"Path变量的配置\"></a>Path变量的配置</h4><p>具体配置步骤参见《Java环境变量配置说明》文档</p>\n<h4 id=\"JDK安装目录\"><a href=\"#JDK安装目录\" class=\"headerlink\" title=\"JDK安装目录\"></a>JDK安装目录</h4><table>\n<thead>\n<tr>\n<th>目录名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bin</td>\n<td>工具命令，包括javac和java</td>\n</tr>\n<tr>\n<td>conf</td>\n<td>配置文件</td>\n</tr>\n<tr>\n<td>include</td>\n<td>头文件</td>\n</tr>\n<tr>\n<td>jmods</td>\n<td>各种模块</td>\n</tr>\n<tr>\n<td>legal</td>\n<td>各模块的授权文档</td>\n</tr>\n<tr>\n<td>lib</td>\n<td>JDK工具的一些补充——AR包</td>\n</tr>\n</tbody></table>\n<h4 id=\"DOS命令\"><a href=\"#DOS命令\" class=\"headerlink\" title=\"DOS命令\"></a>DOS命令</h4><p>由于经常使用命令行窗口对java程序进行编译和运行，所以需要知道一些常用DOS命令</p>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>盘符名称:</td>\n<td>盘符切换。例如E:【回车】，表示切换到E盘</td>\n</tr>\n<tr>\n<td>dir</td>\n<td>查看当前路径下的内容</td>\n</tr>\n<tr>\n<td>cd 目录</td>\n<td>进入单级目录，例如：cd itheima</td>\n</tr>\n<tr>\n<td>cd ..</td>\n<td>回退到上一级目录</td>\n</tr>\n<tr>\n<td>cd 目录1\\目录2...</td>\n<td>进入多级目录，例如：cd itheima\\JavaSE</td>\n</tr>\n<tr>\n<td>cd \\</td>\n<td>回退到盘符目录</td>\n</tr>\n<tr>\n<td>cls</td>\n<td>清屏</td>\n</tr>\n<tr>\n<td>exit</td>\n<td>退出命令提示符窗口</td>\n</tr>\n</tbody></table>\n<h2 id=\"HelloWorld案例\"><a href=\"#HelloWorld案例\" class=\"headerlink\" title=\"HelloWorld案例\"></a>HelloWorld案例</h2><h3 id=\"Java程序开发运行流程\"><a href=\"#Java程序开发运行流程\" class=\"headerlink\" title=\"Java程序开发运行流程\"></a>Java程序开发运行流程</h3><p>开发Java程序，需要三个步骤：编写程序，编译程序，运行程序。</p>\n<p><img src=\"/1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.assets/image-20220105173114417.png\" alt=\"image-20220105173114417\"></p>\n<p>先用&#x3D;&#x3D;javac&#x3D;&#x3D;把&#x3D;&#x3D;Hello.java&#x3D;&#x3D;编译成字节码文件&#x3D;&#x3D;Hello.class&#x3D;&#x3D;，然后，用&#x3D;&#x3D;java&#x3D;&#x3D;命令执行这个字节码文件</p>\n<p>注：可以使用java Hello.java，因为Java 11支持直接运行一个单文件源码</p>\n<h3 id=\"编写\"><a href=\"#编写\" class=\"headerlink\" title=\"编写\"></a>编写</h3><p>1、新建文本文档文件，修改名称为HelloWorld.java</p>\n<p>2、用记事本打开HelloWorld.java文件，输写程序内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;\t<span class=\"comment\">//定义公开的类，保存时文件名必须是HelloWorld.java，且注意大小写</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//类中定义一个公开的main方法，static表明是静态方法，void是返回类型，main中有一个参数，参数类型为String[]，参数名为args</span></span><br><span class=\"line\">    <span class=\"comment\">//public static void main(String[] args)是Java程序的固定入口方法</span></span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">&quot;HelloWorld&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><p>编译java文件生成class文件</p>\n<blockquote>\n<p>命令：javac 文件名.java</p>\n<p>范例：javac HelloWorld.java</p>\n</blockquote>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>运行class文件</p>\n<blockquote>\n<p>命令：java 类名</p>\n<p>范例：java HelloWorld</p>\n</blockquote>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><p>1、.java文件中存在中文字符等&#x3D;&#x3D;非法字符&#x3D;&#x3D;</p>\n<p>2、Java区分&#x3D;&#x3D;大小写&#x3D;&#x3D;</p>\n<p>3、windows系统中可能&#x3D;&#x3D;没有显示文件的扩展名&#x3D;&#x3D;，避免出现HelloWorld.java.txt文件</p>\n<p>4、编译java文件时，需要&#x3D;&#x3D;带文件后缀【.java】&#x3D;&#x3D;</p>\n<p>5、运行class文件（类名）&#x3D;&#x3D;不带文件后缀.class&#x3D;&#x3D;</p>\n<h2 id=\"Notepad-安装和使用\"><a href=\"#Notepad-安装和使用\" class=\"headerlink\" title=\"Notepad++安装和使用\"></a>Notepad++安装和使用</h2><h3 id=\"Notepad-软件安装\"><a href=\"#Notepad-软件安装\" class=\"headerlink\" title=\"Notepad++软件安装\"></a>Notepad++软件安装</h3><p>安装：傻瓜式安装，一直下一步即可。修改开发软件目录下，比如D:\\Design</p>\n<p><a href=\"https://notepad-plus.en.softonic.com/\">Notepad下载</a></p>\n<h3 id=\"1-5-2-Notepad-软件配置\"><a href=\"#1-5-2-Notepad-软件配置\" class=\"headerlink\" title=\"1.5.2 Notepad++软件配置\"></a>1.5.2 Notepad++软件配置</h3><p>先做简单的配置：修改默认语言和编码</p>\n<blockquote>\n<p>打开软件，选择“设置”，在下拉菜单中选择“首选项”</p>\n<p>在弹出的首选项框中，选择“新建”，默认语言修改为：Java，编码修改为：ANSI</p>\n</blockquote>\n<h1 id=\"Java-基础语法\"><a href=\"#Java-基础语法\" class=\"headerlink\" title=\"Java 基础语法\"></a>Java 基础语法</h1><h2 id=\"注释、关键字、命名\"><a href=\"#注释、关键字、命名\" class=\"headerlink\" title=\"注释、关键字、命名\"></a>注释、关键字、命名</h2><h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><table>\n<thead>\n<tr>\n<th>三种注释方法</th>\n<th>如何使用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>单行注释</td>\n<td>&#x2F;&#x2F;注释文字</td>\n</tr>\n<tr>\n<td>多行注释</td>\n<td>&#x2F;* 注释文字 *&#x2F;</td>\n</tr>\n<tr>\n<td>文档注释</td>\n<td>&#x2F;** 注释内容 *&#x2F;，可以通过 Javadoc 命令把文档注释中的内容生成文档，并输出到 HTML 文件中</td>\n</tr>\n</tbody></table>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><p>关键字：被java语言赋予了特殊含义的单词</p>\n<p>特点：</p>\n<p>​    关键字的字母全部&#x3D;&#x3D;小写&#x3D;&#x3D;</p>\n<p>​    常用的代码编辑器对&#x3D;&#x3D;关键字有高亮显示&#x3D;&#x3D;</p>\n<h3 id=\"命名习惯\"><a href=\"#命名习惯\" class=\"headerlink\" title=\"命名习惯\"></a>命名习惯</h3><p>类名：习惯首字母大写</p>\n<p>方法：习惯首字母小写</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><h4 id=\"四种基本数据类型\"><a href=\"#四种基本数据类型\" class=\"headerlink\" title=\"四种基本数据类型\"></a>四种基本数据类型</h4><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>解释</th>\n<th>包括</th>\n<th>注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>整数类型</td>\n<td>Java只定义了带符号的整型，0表示整数，1表示负数</td>\n<td>byte（1字节）、short（2字节）、int（4字节）、long（8字节）</td>\n<td></td>\n</tr>\n<tr>\n<td>浮点数类型</td>\n<td>浮点数的表示方法非常复杂，与整数完全不同，只需要记住大概的范围</td>\n<td>float（4字节）、double（8字节）</td>\n<td>float最大表示3.4x10^38^，double最大表示1.79x10^308^</td>\n</tr>\n<tr>\n<td>字符类型</td>\n<td>表示ASCII，或&#x3D;&#x3D;Unicode字符&#x3D;&#x3D;（与C++不同）</td>\n<td>char（2字节）</td>\n<td></td>\n</tr>\n<tr>\n<td>布尔类型</td>\n<td>只有true和false两个值，只需要1bit，但通常JVM会把<code>boolean</code>表示为4byte整数</td>\n<td>boolean（1bit）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h4 id=\"基本数据类型中Java与C-的区别\"><a href=\"#基本数据类型中Java与C-的区别\" class=\"headerlink\" title=\"基本数据类型中Java与C++的区别\"></a>基本数据类型中Java与C++的区别</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>Java</th>\n<th>C++</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>整型</td>\n<td>java整型的范围与运行java代码的机器无关<br />没有无符号类型</td>\n<td>C或者C++程序会根据不同的处理器选择最有效的整型<br />有无符号类型unsigned</td>\n</tr>\n<tr>\n<td>布尔类型</td>\n<td>用boolean表示，boolean类型与整数值之间不能相互转化</td>\n<td>用bool表示，bool类型与整数值之间可以相互转化</td>\n</tr>\n<tr>\n<td>变量初始化</td>\n<td>不区分变量的声明和定义</td>\n<td>区分变量的声明和定义<br />例如int i;（定义），extern int i;(声明)</td>\n</tr>\n<tr>\n<td>常量</td>\n<td>使用final声明常量，使用static final 设置类常量，类常量的定义位于mian方法的外部</td>\n<td>const来定义常量</td>\n</tr>\n</tbody></table>\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><p>最常用的就是<code>String</code>字符串：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">String s</span> = <span class=\"string\">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置</p>\n<h4 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h4><ul>\n<li>常量：定义变量时加上<code>final</code>修饰符，变量就变成了常量</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"keyword\">double</span> PI = <span class=\"number\">3.14</span>; <span class=\"comment\">// PI是一个常量</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>注意：常量在定义时进行初始化后就&#x3D;&#x3D;不可再次赋值&#x3D;&#x3D;，再次赋值会导致编译错误</p>\n</li>\n<li><p>作用：（1）数字意义难以理解（2）数值改动时，可能不只改动一个地方</p>\n</li>\n<li><p>习惯：常量名通常全部大写</p>\n</li>\n</ul>\n<h4 id=\"var关键字\"><a href=\"#var关键字\" class=\"headerlink\" title=\"var关键字\"></a>var关键字</h4><p>类型的名字太长，写起来比较麻烦。例如：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">StringBuilder sb</span> = new StringBuilder();</span><br></pre></td></tr></table></figure>\n\n<p>省略变量类型，使用<code>var</code>关键字：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sb = <span class=\"keyword\">new</span> <span class=\"type\">StringBuilder</span>();</span><br></pre></td></tr></table></figure>\n\n<p>编译器会根据赋值语句自动推断出变量<code>sb</code>的类型是<code>StringBuilder</code></p>\n<h4 id=\"变量的作用范围\"><a href=\"#变量的作用范围\" class=\"headerlink\" title=\"变量的作用范围\"></a>变量的作用范围</h4><p>多行语句用{ }括起来。很多控制语句，例如条件判断和循环，都以{ }作为它们自身的范围</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (...) &#123; <span class=\"regexp\">//</span> <span class=\"keyword\">if</span>开始</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (...) &#123; <span class=\"regexp\">//</span> <span class=\"keyword\">while</span> 开始</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (...) &#123; <span class=\"regexp\">//</span> <span class=\"keyword\">if</span>开始</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125; <span class=\"regexp\">//</span> <span class=\"keyword\">if</span>结束</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"regexp\">//</span> <span class=\"keyword\">while</span>结束</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"regexp\">//</span> <span class=\"keyword\">if</span>结束</span><br></pre></td></tr></table></figure>\n\n<p>在语句块中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"params\">...</span></span><br><span class=\"line\">    int i = <span class=\"number\">0</span>; <span class=\"comment\">// 变量i从这里开始定义</span></span><br><span class=\"line\">    <span class=\"params\">...</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"params\">...</span></span><br><span class=\"line\">        int x = <span class=\"number\">1</span>; <span class=\"comment\">// 变量x从这里开始定义</span></span><br><span class=\"line\">        <span class=\"params\">...</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"params\">...</span></span><br><span class=\"line\">            <span class=\"built_in\">String</span> s = <span class=\"string\">&quot;hello&quot;</span>; <span class=\"comment\">// 变量s从这里开始定义</span></span><br><span class=\"line\">            <span class=\"params\">...</span></span><br><span class=\"line\">        &#125; <span class=\"comment\">// 变量s作用域到此结束</span></span><br><span class=\"line\">        <span class=\"params\">...</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意，这是一个新的变量s，它和上面的变量同名，</span></span><br><span class=\"line\">        <span class=\"comment\">// 但是因为作用域不同，它们是两个不同的变量:</span></span><br><span class=\"line\">        <span class=\"built_in\">String</span> s = <span class=\"string\">&quot;hi&quot;</span>;</span><br><span class=\"line\">        <span class=\"params\">...</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 变量x和s作用域到此结束</span></span><br><span class=\"line\">    <span class=\"params\">...</span></span><br><span class=\"line\">&#125; <span class=\"comment\">// 变量i作用域到此结束</span></span><br></pre></td></tr></table></figure>\n\n<p>定义变量时，要遵循作用域最小化原则，并且不重复使用变量名。</p>\n<h3 id=\"整数运算\"><a href=\"#整数运算\" class=\"headerlink\" title=\"整数运算\"></a>整数运算</h3><p>整数的数值表示不但是精确的，整数运算也是精确的，因为只能得到结果的整数部分</p>\n<h4 id=\"除法\"><a href=\"#除法\" class=\"headerlink\" title=\"除法\"></a>除法</h4><figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int</span> x = <span class=\"number\">12345</span> / <span class=\"number\">67</span>; // <span class=\"number\">184</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：整数除法对于除数为0时，运行报错，编译不会报错</p>\n<h4 id=\"求余\"><a href=\"#求余\" class=\"headerlink\" title=\"求余\"></a>求余</h4><figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int</span> y = <span class=\"number\">12345</span> % <span class=\"number\">67</span>; // <span class=\"number\">12345</span>÷<span class=\"number\">67</span>的余数是<span class=\"number\">17</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"溢出\"><a href=\"#溢出\" class=\"headerlink\" title=\"溢出\"></a>溢出</h4><p>整数存在范围限制，如果计算结果超出了范围就会产生溢出，溢出不会出错，但会得到一个错误的结果</p>\n<p>整数<code>2147483640</code>和<code>15</code>换成二进制做加法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  0111 1111 1111 1111 1111 1111 1111 1000</span><br><span class=\"line\">+ 0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class=\"line\">-----------------------------------------</span><br><span class=\"line\">  1000 0000 0000 0000 0000 0000 0000 0111</span><br></pre></td></tr></table></figure>\n\n<p>由于最高位计算结果为<code>1</code>，因此，加法结果变成了一个负数</p>\n<p>解决方法：把<code>int</code>换成<code>long</code>类型，<code>long</code>可表示的整型范围更大</p>\n<h4 id=\"简写运算符\"><a href=\"#简写运算符\" class=\"headerlink\" title=\"简写运算符\"></a>简写运算符</h4><p><code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，使用方法：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">n</span> += <span class=\"number\">100</span>; // <span class=\"number\">3409</span>, 相当于 n = n + <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"attribute\">n</span> -= <span class=\"number\">100</span>; // <span class=\"number\">3309</span>, 相当于 n = n - <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"自增-x2F-自减\"><a href=\"#自增-x2F-自减\" class=\"headerlink\" title=\"自增&#x2F;自减\"></a>自增&#x2F;自减</h4><p><code>++</code>运算和<code>--</code>运算，对整数进行加1和减1的操作：</p>\n<p>注意：<code>++n</code>表示先加1再引用n，<code>n++</code>表示先引用n再加1，不要把<code>++</code>运算混入到常规运算</p>\n<h4 id=\"移位运算\"><a href=\"#移位运算\" class=\"headerlink\" title=\"移位运算\"></a>移位运算</h4><table>\n<thead>\n<tr>\n<th>移位运算</th>\n<th>结果</th>\n<th>操作</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>左移</td>\n<td>不断地×2</td>\n<td>低位补0</td>\n</tr>\n<tr>\n<td>右移</td>\n<td>不断地÷2</td>\n<td>（补码是）正数高位补0<br />（补码是）负数高位补1</td>\n</tr>\n<tr>\n<td>无符号右移</td>\n<td>负数无符号右移变为正数</td>\n<td>高位补0</td>\n</tr>\n<tr>\n<td><code>byte</code>和<code>short</code>类型进行移位时<br />先转换为<code>int</code>再进行移位</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>注：<code>byte</code>和<code>short</code>类型进行移位时，先转换为<code>int</code>再进行移位</p>\n<h4 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h4><table>\n<thead>\n<tr>\n<th>运算</th>\n<th>规则</th>\n<th>例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>与</td>\n<td>两个数同时为<code>1</code>，结果为<code>1</code></td>\n<td>n &#x3D; 1 &amp; 1; &#x2F;&#x2F; 1</td>\n</tr>\n<tr>\n<td>或</td>\n<td>任意一个为<code>1</code>，结果就为<code>1</code></td>\n<td>n &#x3D; 0 | 1; &#x2F;&#x2F; 1</td>\n</tr>\n<tr>\n<td>非</td>\n<td><code>0</code>和<code>1</code>互换</td>\n<td>n &#x3D; ~0; &#x2F;&#x2F; 1</td>\n</tr>\n<tr>\n<td>异或</td>\n<td>如果两个数不同，结果为<code>1</code>，否则为<code>0</code></td>\n<td>n &#x3D; 0 ^ 1; &#x2F;&#x2F; 1</td>\n</tr>\n</tbody></table>\n<h4 id=\"运算优先级\"><a href=\"#运算优先级\" class=\"headerlink\" title=\"运算优先级\"></a>运算优先级</h4><p>在Java的计算表达式中，运算优先级从高到低依次是：</p>\n<ul>\n<li><code>()</code></li>\n<li><code>!</code> <code>~</code> <code>++</code> <code>--</code></li>\n<li><code>*</code> <code>/</code> <code>%</code></li>\n<li><code>+</code> <code>-</code></li>\n<li><code>&lt;&lt;</code> <code>&gt;&gt;</code> <code>&gt;&gt;&gt;</code></li>\n<li><code>&amp;</code></li>\n<li><code>|</code></li>\n<li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code></li>\n</ul>\n<p>记不住也没关系，只需要加括号就可以保证运算的优先级正确</p>\n<h4 id=\"类型自动提升与强制转型\"><a href=\"#类型自动提升与强制转型\" class=\"headerlink\" title=\"类型自动提升与强制转型\"></a>类型自动提升与强制转型</h4><p>在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，<code>short</code>和<code>int</code>计算，结果总是<code>int</code>，原因是<code>short</code>首先自动被转型为<code>int</code>：</p>\n<p>也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用<code>(类型)</code>，例如，将<code>int</code>强制转型为<code>short</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">12345</span>;</span><br><span class=\"line\"><span class=\"keyword\">short</span> s = (<span class=\"keyword\">short</span>) i; <span class=\"comment\">// 12345</span></span><br></pre></td></tr></table></figure>\n\n<p>注：超出范围的强制转型会得到错误的结果，原因是转型时，<code>int</code>的两个高位字节直接被扔掉，仅保留了低位的两个字节：</p>\n<h3 id=\"浮点数运算\"><a href=\"#浮点数运算\" class=\"headerlink\" title=\"浮点数运算\"></a>浮点数运算</h3><h4 id=\"比较两浮点数是否相等\"><a href=\"#比较两浮点数是否相等\" class=\"headerlink\" title=\"比较两浮点数是否相等\"></a>比较两浮点数是否相等</h4><p>浮点数的特点：常常无法精确表示</p>\n<p>举例：浮点数<code>0.1</code>在计算机中无法精确表示，因为十进制的<code>0.1</code>换算成二进制是一个无限循环小数，显然，无论使用<code>float</code>还是<code>double</code>，都只能存储一个<code>0.1</code>的近似值。但是，<code>0.5</code>这个浮点数又可以精确地表示。</p>\n<p>因为浮点数常常无法精确表示，因此，浮点数运算&#x3D;&#x3D;会产生误差&#x3D;&#x3D;</p>\n<p>比较两个浮点数是否相等，是判断两个浮点数之差的绝对值是否小于一个很小的数：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 比较x和y是否相等，先计算其差的绝对值:</span><br><span class=\"line\">double r = Math.abs(x - y);</span><br><span class=\"line\"><span class=\"regexp\">//</span> 再判断绝对值是否足够小:</span><br><span class=\"line\"><span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0.00001</span>) &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span> 可以认为相等</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span> 不相等</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>浮点数在内存的表示方法和整数比更加复杂。Java的浮点数完全遵循<a href=\"https://web.archive.org/web/20070505021348/http://babbage.cs.qc.edu/courses/cs341/IEEE-754references.html\">IEEE-754</a>标准，这也是绝大多数计算机平台都支持的浮点数标准表示方法。</p>\n<h4 id=\"类型提升\"><a href=\"#类型提升\" class=\"headerlink\" title=\"类型提升\"></a>类型提升</h4><p>如果参与运算的两个数其中一个是整型，那么整型可以自动提升到浮点型：</p>\n<p>注：在一个复杂的四则运算中，两个整数的运算不会出现自动提升的情况。例如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">double</span> d = <span class=\"number\">2</span> + <span class=\"number\">24</span> / <span class=\"number\">5</span>; // <span class=\"number\">5</span>.<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>计算结果为<code>5.2</code>，原因是编译器计算<code>24 / 5</code>这个子表达式时，按两个整数进行运算，结果仍为整数<code>4</code>。</p>\n<h4 id=\"溢出-1\"><a href=\"#溢出-1\" class=\"headerlink\" title=\"溢出\"></a>溢出</h4><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p>\n<ul>\n<li><code>NaN</code>表示Not a Number</li>\n<li><code>Infinity</code>表示无穷大</li>\n<li><code>-Infinity</code>表示负无穷大</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">double</span> d<span class=\"number\">1</span> = <span class=\"number\">0</span>.<span class=\"number\">0</span> / <span class=\"number\">0</span>; // NaN</span><br><span class=\"line\"><span class=\"attribute\">double</span> d<span class=\"number\">2</span> = <span class=\"number\">1</span>.<span class=\"number\">0</span> / <span class=\"number\">0</span>; // Infinity</span><br><span class=\"line\"><span class=\"attribute\">double</span> d<span class=\"number\">3</span> = -<span class=\"number\">1</span>.<span class=\"number\">0</span> / <span class=\"number\">0</span>; // -Infinity</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"强制转型\"><a href=\"#强制转型\" class=\"headerlink\" title=\"强制转型\"></a>强制转型</h4><p>可以将浮点数强制转型为整数。在转型时，浮点数的小数部分会被丢掉。如果转型后超过了整型能表示的最大范围，将返回整型的最大值。例如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int</span> n<span class=\"number\">1</span> = (int) <span class=\"number\">12</span>.<span class=\"number\">3</span>; // <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"attribute\">int</span> n<span class=\"number\">2</span> = (int) <span class=\"number\">12</span>.<span class=\"number\">7</span>; // <span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"attribute\">int</span> n<span class=\"number\">2</span> = (int) -<span class=\"number\">12</span>.<span class=\"number\">7</span>; // -<span class=\"number\">12</span></span><br><span class=\"line\"><span class=\"attribute\">int</span> n<span class=\"number\">3</span> = (int) (<span class=\"number\">12</span>.<span class=\"number\">7</span> + <span class=\"number\">0</span>.<span class=\"number\">5</span>); // <span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"attribute\">int</span> n<span class=\"number\">4</span> = (int) <span class=\"number\">1</span>.<span class=\"number\">2</span>e<span class=\"number\">20</span>; // <span class=\"number\">2147483647</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要进行四舍五入，可以对浮点数加上0.5再强制转型：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 四舍五入</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> d = <span class=\"number\">2.6</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = (<span class=\"keyword\">int</span>) (d + <span class=\"number\">0.5</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"布尔运算\"><a href=\"#布尔运算\" class=\"headerlink\" title=\"布尔运算\"></a>布尔运算</h3><h4 id=\"几种布尔运算\"><a href=\"#几种布尔运算\" class=\"headerlink\" title=\"几种布尔运算\"></a>几种布尔运算</h4><p>对于布尔类型<code>boolean</code>，永远只有<code>true</code>和<code>false</code>两个值。</p>\n<p>布尔运算是一种关系运算，包括以下几类：</p>\n<ul>\n<li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code>，<code>==</code>，<code>!=</code></li>\n<li>与运算 <code>&amp;&amp;</code></li>\n<li>或运算 <code>||</code></li>\n<li>非运算 <code>!</code></li>\n</ul>\n<p>关系运算符的优先级从高到低依次是：</p>\n<ul>\n<li><code>!</code></li>\n<li><code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>\n<li><code>==</code>，<code>!=</code></li>\n<li><code>&amp;&amp;</code></li>\n<li><code>||</code></li>\n</ul>\n<h4 id=\"短路运算\"><a href=\"#短路运算\" class=\"headerlink\" title=\"短路运算\"></a>短路运算</h4><p>如果布尔运算的表达式能提前确定结果，则后续的计算不再执行，直接返回结果</p>\n<p>因为<code>false &amp;&amp; x</code>的结果总是<code>false</code>，无论<code>x</code>是<code>true</code>还是<code>false</code>，因此，与运算在确定第一个值为<code>false</code>后，不再继续计算，而是直接返回<code>false</code></p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> b = <span class=\"number\">5</span> &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = b &amp;&amp; (<span class=\"number\">5</span> / <span class=\"number\">0</span> &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果变量<code>b</code>的值为<code>true</code>，则表达式变为<code>true &amp;&amp; (5 / 0 &gt; 0)</code>。因为无法进行短路运算，该表达式必定会由于除数为<code>0</code>而报错，可以自行测试</p>\n<p>对于<code>||</code>运算，只要能确定第一个值为<code>true</code>，后续计算也不再进行，而是直接返回<code>true</code></p>\n<h4 id=\"三元运算符\"><a href=\"#三元运算符\" class=\"headerlink\" title=\"三元运算符\"></a>三元运算符</h4><p>Java还提供一个三元运算符<code>b ? x : y</code>，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。示例：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 三元运算</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">-100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> x = n &gt;= <span class=\"number\">0</span> ? n : -n;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>上述语句的意思是，判断<code>n &gt;= 0</code>是否成立，如果为<code>true</code>，则返回<code>n</code>，否则返回<code>-n</code>。这实际上是一个求绝对值的表达式。</p>\n<p>注意：</p>\n<ul>\n<li><p>三元运算<code>b ? x : y</code>会首先计算<code>b</code>，如果<code>b</code>为<code>true</code>，则只计算<code>x</code>，否则，只计算&#96;y&#96;&#96;</p>\n</li>\n<li><p>&#96;&#96;x<code>和</code>y<code>的类型必须相同，因为返回值不是</code>boolean<code>，而是</code>x<code>和</code>y&#96;之一</p>\n</li>\n</ul>\n<h3 id=\"字符和字符串\"><a href=\"#字符和字符串\" class=\"headerlink\" title=\"字符和字符串\"></a>字符和字符串</h3><p>在Java中，字符和字符串是两个不同的类型。</p>\n<h4 id=\"字符类型\"><a href=\"#字符类型\" class=\"headerlink\" title=\"字符类型\"></a>字符类型</h4><p>字符类型<code>char</code>是基本数据类型，它是<code>character</code>的缩写。一个<code>char</code>保存一个Unicode字符：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> c1 = <span class=\"comment\">&#x27;A&#x27;;</span></span><br><span class=\"line\"><span class=\"type\">char</span> c2 = <span class=\"comment\">&#x27;中&#x27;;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个<code>char</code>类型表示，它们都占用两个字节。要显示一个字符的Unicode编码，只需将<code>char</code>类型直接赋值给<code>int</code>类型即可：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n1 = <span class=\"string\">&#x27;A&#x27;</span>; <span class=\"comment\">// 字母“A”的Unicodde编码是65</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n2 = <span class=\"string\">&#x27;中&#x27;</span>; <span class=\"comment\">// 汉字“中”的Unicode编码是20013</span></span><br></pre></td></tr></table></figure>\n\n<p>还可以直接用转义字符<code>\\u</code>+Unicode编码来表示一个字符：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 注意是十六进制:</span><br><span class=\"line\">char c3 = <span class=\"string\">&#x27;\\u0041&#x27;</span>; <span class=\"regexp\">//</span> <span class=\"string\">&#x27;A&#x27;</span>，因为十六进制<span class=\"number\">0041</span> = 十进制<span class=\"number\">65</span></span><br><span class=\"line\">char c4 = <span class=\"string\">&#x27;\\u4e2d&#x27;</span>; <span class=\"regexp\">//</span> <span class=\"string\">&#x27;中&#x27;</span>，因为十六进制<span class=\"number\">4</span>e2d = 十进制<span class=\"number\">20013</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符串类型\"><a href=\"#字符串类型\" class=\"headerlink\" title=\"字符串类型\"></a>字符串类型</h4><p>和<code>char</code>类型不同，字符串类型<code>String</code>是引用类型，我们用双引号<code>&quot;...&quot;</code>表示字符串。一个字符串可以存储0个到任意个字符：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> s = <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\">// 空字符串，包含0个字符</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> s1 = <span class=\"string\">&quot;A&quot;</span>; <span class=\"comment\">// 包含一个字符</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> s2 = <span class=\"string\">&quot;ABC&quot;</span>; <span class=\"comment\">// 包含3个字符</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> s3 = <span class=\"string\">&quot;中文 ABC&quot;</span>; <span class=\"comment\">// 包含6个字符，其中有一个空格</span></span><br></pre></td></tr></table></figure>\n\n<p>因为字符串使用双引号<code>&quot;...&quot;</code>表示开始和结束，那如果字符串本身恰好包含一个<code>&quot;</code>字符怎么表示？例如，<code>&quot;abc&quot;xyz&quot;</code>，编译器就无法判断中间的引号究竟是字符串的一部分还是表示字符串结束。这个时候，我们需要借助转义字符<code>\\</code></p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> s = <span class=\"string\">&quot;abc\\&quot;xyz&quot;</span>; <span class=\"comment\">// 包含7个字符: a, b, c, &quot;, x, y, z</span></span><br></pre></td></tr></table></figure>\n\n<p>常见的转义字符包括：</p>\n<ul>\n<li><code>\\&quot;</code> 表示字符<code>&quot;</code></li>\n<li><code>\\&#39;</code> 表示字符<code>&#39;</code></li>\n<li><code>\\\\</code> 表示字符<code>\\</code></li>\n<li><code>\\n</code> 表示换行符</li>\n<li><code>\\r</code> 表示回车符</li>\n<li><code>\\t</code> 表示Tab</li>\n<li><code>\\u####</code> 表示一个Unicode编码的字符</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> s = <span class=\"string\">&quot;ABC\\n\\u4e2d\\u6587&quot;</span>; <span class=\"comment\">// 包含6个字符: A, B, C, 换行符, 中, 文</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符串连接\"><a href=\"#字符串连接\" class=\"headerlink\" title=\"字符串连接\"></a>字符串连接</h4><p>Java的编译器对字符串做了特殊照顾，可以使用<code>+</code>连接任意字符串和其他数据类型，这样极大地方便了字符串的处理。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串连接</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s1 = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s2 = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s = s1 + <span class=\"string\">&quot; &quot;</span> + s2 + <span class=\"string\">&quot;!&quot;</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 如果用<code>+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串连接</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s = <span class=\"string\">&quot;age is &quot;</span> + age;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h4><p>从Java 13开始，字符串可以用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>表示多行字符串（Text Blocks）</p>\n<figure class=\"highlight ceylon\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 多行字符串</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    public static <span class=\"keyword\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">        String s = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">                   SELECT * FROM</span></span><br><span class=\"line\"><span class=\"string\">                     users</span></span><br><span class=\"line\"><span class=\"string\">                   WHERE id &gt; 100</span></span><br><span class=\"line\"><span class=\"string\">                   ORDER BY name DESC</span></span><br><span class=\"line\"><span class=\"string\">                   &quot;&quot;&quot;</span>;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述多行字符串实际上是5行，在最后一个<code>DESC</code>后面还有一个<code>\\n</code>。如果不想在字符串末尾加一个<code>\\n</code>，就需要这么写：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> s = <span class=\"string\">&quot;&quot;&quot; </span></span><br><span class=\"line\"><span class=\"string\">           SELECT * FROM</span></span><br><span class=\"line\"><span class=\"string\">             users</span></span><br><span class=\"line\"><span class=\"string\">           WHERE id &gt; 100</span></span><br><span class=\"line\"><span class=\"string\">           ORDER BY name DESC&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>还需要注意到，多行字符串前面共同的空格会被去掉，即：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> s = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">...........SELECT * FROM</span></span><br><span class=\"line\"><span class=\"string\">...........  users</span></span><br><span class=\"line\"><span class=\"string\">...........WHERE id &gt; 100</span></span><br><span class=\"line\"><span class=\"string\">...........ORDER BY name DESC</span></span><br><span class=\"line\"><span class=\"string\">...........&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>.</code>标注的空格都会被去掉</p>\n<p>如果多行字符串的排版不规则，去掉的空格就会变成</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> s = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">.........  SELECT * FROM</span></span><br><span class=\"line\"><span class=\"string\">.........    users</span></span><br><span class=\"line\"><span class=\"string\">.........WHERE id &gt; 100</span></span><br><span class=\"line\"><span class=\"string\">.........  ORDER BY name DESC</span></span><br><span class=\"line\"><span class=\"string\">.........  &quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>即总是以最短的行首空格为基准</p>\n<h4 id=\"不可变特性\"><a href=\"#不可变特性\" class=\"headerlink\" title=\"不可变特性\"></a>不可变特性</h4><p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串不可变</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(s); <span class=\"comment\">// 显示 hello</span></span><br><span class=\"line\">        s = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(s); <span class=\"comment\">// 显示 world</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察执行结果，字符串<code>s</code>没有变，变的是变量<code>s</code>的“指向”</p>\n<p>执行<code>String s = &quot;hello&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;hello&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      s</span><br><span class=\"line\">      │</span><br><span class=\"line\">      ▼</span><br><span class=\"line\">┌───┬───────────┬───┐</span><br><span class=\"line\">│   │  &quot;hello&quot;  │   │</span><br><span class=\"line\">└───┴───────────┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>紧接着，执行<code>s = &quot;world&quot;;</code>时，JVM虚拟机先创建字符串<code>&quot;world&quot;</code>，然后，把字符串变量<code>s</code>指向它：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      s ──────────────┐</span><br><span class=\"line\">                      │</span><br><span class=\"line\">                      ▼</span><br><span class=\"line\">┌───┬───────────┬───┬───────────┬───┐</span><br><span class=\"line\">│   │  &quot;hello&quot;  │   │  &quot;world&quot;  │   │</span><br><span class=\"line\">└───┴───────────┴───┴───────────┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>原来的字符串<code>&quot;hello&quot;</code>还在，只是我们无法通过变量<code>s</code>访问它而已。因此，字符串的不可变是指字符串内容不可变</p>\n<h4 id=\"空值null\"><a href=\"#空值null\" class=\"headerlink\" title=\"空值null\"></a>空值null</h4><p>引用类型的变量可以指向一个空值<code>null</code>，它表示不存在，即该变量不指向任何对象。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"keyword\">null</span>; <span class=\"comment\">// s1是null</span></span><br><span class=\"line\">String s2; <span class=\"comment\">// 没有赋初值值，s2也是null</span></span><br><span class=\"line\">String s3 = s1; <span class=\"comment\">// s3也是null</span></span><br><span class=\"line\">String s4 = <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\">// s4指向空字符串，不是null</span></span><br></pre></td></tr></table></figure>\n\n<p>注意要区分空值<code>null</code>和空字符串<code>&quot;&quot;</code>，空字符串是一个有效的字符串对象，它不等于<code>null</code>。</p>\n<h3 id=\"数组类型\"><a href=\"#数组类型\" class=\"headerlink\" title=\"数组类型\"></a>数组类型</h3><h4 id=\"数组的定义\"><a href=\"#数组的定义\" class=\"headerlink\" title=\"数组的定义\"></a>数组的定义</h4><p>没有必要定义5个<code>int</code>变量。可以使用数组来表示“一组”<code>int</code>类型。代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] ns = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure>\n\n<p>定义一个数组类型的变量，使用数组类型“类型[]”，例如，<code>int[]</code>。和单个基本类型变量不同，数组变量初始化必须使用<code>new int[5]</code>表示创建一个可容纳5个<code>int</code>元素的数组。</p>\n<p>Java的数组有几个特点：</p>\n<ul>\n<li>数组所有元素初始化为默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>；</li>\n<li>数组一旦创建后，大小就不可改变。</li>\n</ul>\n<p>要访问数组中的某一个元素，需要使用索引。数组索引从<code>0</code>开始，例如，5个元素的数组，索引范围是<code>0</code>~&#96;4&#96;。</p>\n<p>可以修改数组中的某一个元素，使用赋值语句，例如，<code>ns[1] = 79;</code>。</p>\n<p>可以用<code>数组变量.length</code>获取数组大小：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"built_in\">int</span><span class=\"literal\">[]</span> ns = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span><span class=\"literal\">[<span class=\"number\">5</span>]</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(ns.length); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>可以在定义数组时直接指定初始化的元素，这样就不必写出数组大小，而是由编译器自动推算数组大小。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] ns = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; <span class=\"number\">68</span>, <span class=\"number\">79</span>, <span class=\"number\">91</span>, <span class=\"number\">85</span>, <span class=\"number\">62</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>还可以进一步简写为：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int</span>[] ns = &#123; <span class=\"number\">68</span>, <span class=\"number\">79</span>, <span class=\"number\">91</span>, <span class=\"number\">85</span>, <span class=\"number\">62</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>注意数组是引用类型，并且数组大小不可变。我们观察下面的代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 5位同学的成绩:</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ns;</span><br><span class=\"line\">        ns = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; <span class=\"number\">68</span>, <span class=\"number\">79</span>, <span class=\"number\">91</span>, <span class=\"number\">85</span>, <span class=\"number\">62</span> &#125;;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(ns.length); <span class=\"comment\">// 5</span></span><br><span class=\"line\">        ns = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(ns.length); <span class=\"comment\">// 3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>数组大小变了吗？看上去好像是变了，但其实根本没变。</p>\n<p>对于数组<code>ns</code>来说，执行<code>ns = new int[] &#123; 68, 79, 91, 85, 62 &#125;;</code>时，它指向一个5个元素的数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">     ns</span><br><span class=\"line\">      │</span><br><span class=\"line\">      ▼</span><br><span class=\"line\">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│   │68 │79 │91 │85 │62 │   │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>ns = new int[] &#123; 1, 2, 3 &#125;;</code>时，它指向一个<em>新的</em>3个元素的数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">     ns ──────────────────────┐</span><br><span class=\"line\">                              │</span><br><span class=\"line\">                              ▼</span><br><span class=\"line\">┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│   │68 │79 │91 │85 │62 │   │ 1 │ 2 │ 3 │   │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>但是，原有的5个元素的数组并没有改变，只是无法通过变量<code>ns</code>引用到它们而已。</p>\n<h4 id=\"字符串数组\"><a href=\"#字符串数组\" class=\"headerlink\" title=\"字符串数组\"></a>字符串数组</h4><p>如果数组元素不是基本类型，而是一个引用类型，那么，修改数组元素会有哪些不同？</p>\n<p>字符串是引用类型，因此我们先定义一个字符串数组：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span>[] names = &#123;</span><br><span class=\"line\">    <span class=\"string\">&quot;ABC&quot;</span>, <span class=\"string\">&quot;XYZ&quot;</span>, <span class=\"string\">&quot;zoo&quot;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>String[]</code>类型的数组变量<code>names</code>，它实际上包含3个元素，但每个元素都指向某个字符串对象：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">          ┌─────────────────────────┐</span><br><span class=\"line\">    names │   ┌─────────────────────┼───────────┐</span><br><span class=\"line\">      │   │   │                     │           │</span><br><span class=\"line\">      ▼   │   │                     ▼           ▼</span><br><span class=\"line\">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class=\"line\">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │</span><br><span class=\"line\">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class=\"line\">      │                 ▲</span><br><span class=\"line\">      └─────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>对<code>names[1]</code>进行赋值，例如<code>names[1] = &quot;cat&quot;;</code>，效果如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">          ┌─────────────────────────────────────────────────┐</span><br><span class=\"line\">    names │   ┌─────────────────────────────────┐           │</span><br><span class=\"line\">      │   │   │                                 │           │</span><br><span class=\"line\">      ▼   │   │                                 ▼           ▼</span><br><span class=\"line\">┌───┬───┬─┴─┬─┴─┬───┬───────┬───┬───────┬───┬───────┬───┬───────┬───┐</span><br><span class=\"line\">│   │░░░│░░░│░░░│   │ &quot;ABC&quot; │   │ &quot;XYZ&quot; │   │ &quot;zoo&quot; │   │ &quot;cat&quot; │   │</span><br><span class=\"line\">└───┴─┬─┴───┴───┴───┴───────┴───┴───────┴───┴───────┴───┴───────┴───┘</span><br><span class=\"line\">      │                 ▲</span><br><span class=\"line\">      └─────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>这里注意到原来<code>names[1]</code>指向的字符串<code>&quot;XYZ&quot;</code>并没有改变，仅仅是将<code>names[1]</code>的引用从指向<code>&quot;XYZ&quot;</code>改成了指向<code>&quot;cat&quot;</code>，其结果是字符串<code>&quot;XYZ&quot;</code>再也无法通过<code>names[1]</code>访问到了。</p>\n<h1 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h1><h2 id=\"输入和输出\"><a href=\"#输入和输出\" class=\"headerlink\" title=\"输入和输出\"></a>输入和输出</h2><h3 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h3><p>使用<code>System.out.println()</code>来向屏幕输出一些内容</p>\n<ul>\n<li><code>println</code>是print line的缩写，表示输出并换行</li>\n<li>如果输出后不想换行，可以用<code>print()</code></li>\n</ul>\n<h3 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h3><p>格式化输出使用<code>System.out.printf()</code>，通过使用占位符<code>%?</code>，<code>printf()</code>可以把后面的参数格式化成指定格式：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 格式化输出</span></span><br><span class=\"line\">double d = <span class=\"number\">3.1415926</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.printf(<span class=\"string\">&quot;%.2f\\n&quot;</span>, d); <span class=\"comment\">// 显示两位小数3.14</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.printf(<span class=\"string\">&quot;%.4f\\n&quot;</span>, d); <span class=\"comment\">// 显示4位小数3.1416</span></span><br></pre></td></tr></table></figure>\n\n<p>Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">占位符</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">%d</td>\n<td align=\"left\">格式化输出整数</td>\n</tr>\n<tr>\n<td align=\"left\">%x</td>\n<td align=\"left\">格式化输出十六进制整数</td>\n</tr>\n<tr>\n<td align=\"left\">%f</td>\n<td align=\"left\">格式化输出浮点数</td>\n</tr>\n<tr>\n<td align=\"left\">%e</td>\n<td align=\"left\">格式化输出科学计数法表示的浮点数</td>\n</tr>\n<tr>\n<td align=\"left\">%s</td>\n<td align=\"left\">格式化字符串</td>\n</tr>\n</tbody></table>\n<p>注意：由于%表示占位符，因此，连续两个%%表示一个%字符本身</p>\n<p>占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 格式化输出</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> n = <span class=\"number\">12345000</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.printf(<span class=\"string\">&quot;n=%d, hex=%08x&quot;</span>, n, n); <span class=\"comment\">// 注意，两个%占位符必须传入两个数</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h3><p>从控制台读取一个字符串和一个整数：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> <span class=\"built_in\">Scanner</span>(System.in); <span class=\"comment\">// 创建Scanner对象</span></span><br><span class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;Input your name: &quot;</span>); <span class=\"comment\">// 打印提示</span></span><br><span class=\"line\">        <span class=\"keyword\">String</span> name = scanner.<span class=\"built_in\">nextLine</span>(); <span class=\"comment\">// 读取一行输入并获取字符串</span></span><br><span class=\"line\">        System.out.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;Input your age: &quot;</span>); <span class=\"comment\">// 打印提示</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> age = scanner.<span class=\"built_in\">nextInt</span>(); <span class=\"comment\">// 读取一行输入并获取整数</span></span><br><span class=\"line\">        System.out.<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hi, %s, you are %d\\n&quot;</span>, name, age); <span class=\"comment\">// 格式化输出</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>首先，通过<code>import</code>语句导入<code>java.util.Scanner</code></p>\n<ul>\n<li><code>import</code>是导入某个类的语句，必须放到Java源代码的开头</li>\n</ul>\n</li>\n<li><p>然后，创建<code>Scanner</code>对象并传入&#96;System.in&#96;&#96;</p>\n<ul>\n<li>&#96;&#96;System.out<code>代表标准输出流，而</code>System.in&#96;代表标准输入流</li>\n<li>直接使用<code>System.in</code>读取用户输入虽然是可以的，但需要更复杂的代码，而通过<code>Scanner</code>就可以简化后续的代码</li>\n</ul>\n</li>\n<li><p>有了<code>Scanner</code>对象后，要读取用户输入的字符串，使用<code>scanner.nextLine()</code>，要读取用户输入的整数，使用&#96;scanner.nextInt()&#96;&#96;</p>\n<ul>\n<li>&#96;&#96;Scanner&#96;会自动转换数据类型，因此不必手动转换。</li>\n</ul>\n</li>\n</ul>\n<p>要测试输入，不能在线运行它，因为输入必须从命令行读取，因此，需要走编译、执行的流程：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ javac <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java</span><br></pre></td></tr></table></figure>\n\n<p>这个程序编译时如果有警告，可以暂时忽略它，在后面学习IO的时候再详细解释。编译成功后，执行：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"keyword\">java </span>Main</span><br><span class=\"line\">Input your name: <span class=\"keyword\">Bob</span></span><br><span class=\"line\"><span class=\"keyword\"></span>Input your age: <span class=\"number\">12</span></span><br><span class=\"line\">Hi, <span class=\"keyword\">Bob, </span>you are <span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>根据提示分别输入一个字符串和整数后，我们得到了格式化的输出。</p>\n<h2 id=\"if判断\"><a href=\"#if判断\" class=\"headerlink\" title=\"if判断\"></a>if判断</h2><p>在Java程序中，如果要根据条件来决定是否执行某一段代码，就需要<code>if</code>语句。</p>\n<p><code>if</code>语句的基本语法是：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (条件) &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span> 条件满足时执行</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>根据<code>if</code>的计算结果（<code>true</code>还是<code>false</code>），JVM决定是否执行<code>if</code>语句块（即花括号{}包含的所有语句）。</p>\n<p>由于使用缩进格式，很容易把两行语句都看成<code>if</code>语句的执行块，但实际上只有第一行语句是<code>if</code>的执行块。在使用git这些版本控制系统自动合并时更容易出问题，所以不推荐忽略花括号的写法。</p>\n<h3 id=\"else\"><a href=\"#else\" class=\"headerlink\" title=\"else\"></a>else</h3><ul>\n<li><p>使用</p>\n<ul>\n<li><code>if</code>语句还可以编写一个<code>else &#123; ... &#125;</code>，当条件判断为<code>false</code>时，将执行<code>else</code>的语句块：</li>\n<li>还可以用多个<code>if ... else if ...</code>串联。例如：</li>\n</ul>\n</li>\n<li><p>在串联使用多个<code>if</code>时，要特别注意判断顺序：按照判断范围从小到大依次判断：</p>\n</li>\n<li><p>使用<code>if</code>时，还要特别注意边界条件，<code>&gt;</code>和<code>&gt;=</code>效果是不同的。</p>\n</li>\n<li><p>浮点数判断</p>\n<ul>\n<li>由于浮点数在计算机中常常无法精确表示，并且计算可能出现误差，因此，判断浮点数相等用<code>==</code>判断不靠谱</li>\n<li>正确的方法是利用差值小于某个临界值来判断：</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"判断引用类型相等\"><a href=\"#判断引用类型相等\" class=\"headerlink\" title=\"判断引用类型相等\"></a>判断引用类型相等</h3><p>在Java中，判断值类型的变量是否相等，可以使用<code>==</code>运算符。但是，判断引用类型的变量是否相等，<code>==</code>表示“引用是否相等”，或者说，是否指向同一个对象。例如，下面的两个String类型，它们的内容是相同的，但是，分别指向不同的对象，用<code>==</code>判断，结果为<code>false</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 条件判断</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s1 = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s2 = <span class=\"string\">&quot;HELLO&quot;</span>.<span class=\"built_in\">toLowerCase</span>();</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(s1);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(s2);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s1 == s2) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;s1 == s2&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;s1 != s2&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要判断引用类型的变量内容是否相等，必须使用<code>equals()</code>方法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 条件判断</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (s1.equals(s2)) &#123;</span><br><span class=\"line\">\t<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;s1 equals s2&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;s1 not equals s2&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意：执行语句<code>s1.equals(s2)</code>时，如果变量<code>s1</code>为<code>null</code>，会报<code>NullPointerException</code>：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 条件判断</span></span><br><span class=\"line\">String s1 = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (s1.<span class=\"keyword\">equals</span>(<span class=\"string\">&quot;hello&quot;</span>)) &#123;</span><br><span class=\"line\">\tSystem.<span class=\"keyword\">out</span>.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要避免<code>NullPointerException</code>错误</p>\n<ul>\n<li>可以利用短路运算符<code>&amp;&amp;</code>：</li>\n</ul>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 条件判断</span></span><br><span class=\"line\">String s1 = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (s1 != <span class=\"literal\">null</span> &amp;&amp; s1.<span class=\"keyword\">equals</span>(<span class=\"string\">&quot;hello&quot;</span>)) &#123;</span><br><span class=\"line\">\tSystem.<span class=\"keyword\">out</span>.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>还可以把一定不是<code>null</code>的对象<code>&quot;hello&quot;</code>放到前面：例如：<code>if (&quot;hello&quot;.equals(s)) &#123; ... &#125;</code></li>\n</ul>\n<h2 id=\"switch多重选择\"><a href=\"#switch多重选择\" class=\"headerlink\" title=\"switch多重选择\"></a>switch多重选择</h2><p>除了if语句外，还有一种条件判断，是根据某个表达式的结果，分别去执行不同的分支。</p>\n<p>例如，在游戏中，让用户选择选项：</p>\n<ol>\n<li>单人模式</li>\n<li>多人模式</li>\n<li>退出游戏</li>\n</ol>\n<p>这时，<code>switch</code>语句就派上用场了。</p>\n<p><code>switch</code>语句根据<code>switch (表达式)</code>计算的结果，跳转到匹配的<code>case</code>结果，然后继续执行后续语句，直到遇到<code>break</code>结束执行。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> switch</span><br></pre></td></tr></table></figure>\n\n<p>修改<code>option</code>的值分别为<code>1</code>、<code>2</code>、<code>3</code>，观察执行结果。</p>\n<p>如果<code>option</code>的值没有匹配到任何<code>case</code>，例如<code>option = 99</code>，那么，<code>switch</code>语句不会执行任何语句。这时，可以给<code>switch</code>语句加一个<code>default</code>，当没有匹配到任何<code>case</code>时，执行<code>default</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> option = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (option) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Selected 1&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Selected 2&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Selected 3&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果把<code>switch</code>语句翻译成<code>if</code>语句，那么上述的代码相当于：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">option</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Selected 1&quot;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">option</span> == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Selected 2&quot;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">option</span> == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Selected 3&quot;);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Not selected&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于多个<code>==</code>判断的情况，使用<code>switch</code>结构更加清晰。</p>\n<p>同时注意，上述“翻译”只有在<code>switch</code>语句中对每个<code>case</code>正确编写了<code>break</code>语句才能对应得上。</p>\n<p>使用<code>switch</code>时，注意<code>case</code>语句并没有花括号<code>&#123;&#125;</code>，而且，<code>case</code>语句具有“<em>穿透性</em>”，漏写<code>break</code>将导致意想不到的结果：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> switch</span><br></pre></td></tr></table></figure>\n\n<p>当<code>option = 2</code>时，将依次输出<code>&quot;Selected 2&quot;</code>、<code>&quot;Selected 3&quot;</code>、<code>&quot;Not selected&quot;</code>，原因是从匹配到<code>case 2</code>开始，后续语句将全部执行，直到遇到<code>break</code>语句。因此，任何时候都不要忘记写<code>break</code>。</p>\n<p>如果有几个<code>case</code>语句执行的是同一组语句块，可以这么写：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> switch</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>switch</code>语句时，只要保证有<code>break</code>，<code>case</code>的顺序不影响程序逻辑：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (option) &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是仍然建议按照自然顺序排列，便于阅读。</p>\n<p><code>switch</code>语句还可以匹配字符串。字符串匹配时，是比较“内容相等”。例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> switch</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>switch</code>语句还可以使用枚举类型，枚举类型我们在后面讲解。</p>\n<h3 id=\"编译检查\"><a href=\"#编译检查\" class=\"headerlink\" title=\"编译检查\"></a>编译检查</h3><p>使用IDE时，可以自动检查是否漏写了<code>break</code>语句和<code>default</code>语句，方法是打开IDE的编译检查。</p>\n<p>在Eclipse中，选择<code>Preferences</code> - <code>Java</code> - <code>Compiler</code> - <code>Errors/Warnings</code> - <code>Potential programming problems</code>，将以下检查标记为Warning：</p>\n<ul>\n<li>‘switch’ is missing ‘default’ case</li>\n<li>‘switch’ case fall-through</li>\n</ul>\n<p>在Idea中，选择<code>Preferences</code> - <code>Editor</code> - <code>Inspections</code> - <code>Java</code> - <code>Control flow issues</code>，将以下检查标记为Warning：</p>\n<ul>\n<li>Fallthrough in ‘switch’ statement</li>\n<li>‘switch’ statement without ‘default’ branch</li>\n</ul>\n<p>当<code>switch</code>语句存在问题时，即可在IDE中获得警告提示。</p>\n<p><img src=\"/1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.assets/l.png\" alt=\"switch-note\"></p>\n<h3 id=\"switch表达式\"><a href=\"#switch表达式\" class=\"headerlink\" title=\"switch表达式\"></a>switch表达式</h3><p>使用<code>switch</code>时，如果遗漏了<code>break</code>，就会造成严重的逻辑错误，而且不易在源代码中发现错误。从Java 12开始，<code>switch</code>语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要<code>break</code>语句：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> switch</span><br></pre></td></tr></table></figure>\n\n<p>注意新语法使用<code>-&gt;</code>，如果有多条语句，需要用<code>&#123;&#125;</code>括起来。不要写<code>break</code>语句，因为新语法只会执行匹配的语句，没有穿透效应。</p>\n<p>很多时候，我们还可能用<code>switch</code>语句给某个变量赋值。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> opt;</span><br><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">switch</span></span> (fruit) &#123;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;apple&quot;</span>:</span><br><span class=\"line\">    opt = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;pear&quot;</span>:</span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"string\">&quot;mango&quot;</span>:</span><br><span class=\"line\">    opt = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\"><span class=\"keyword\">default</span>:</span><br><span class=\"line\">    opt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用新的<code>switch</code>语法，不但不需要<code>break</code>，还可以直接返回值。把上面的代码改写如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> switch</span><br></pre></td></tr></table></figure>\n\n<p>这样可以获得更简洁的代码。</p>\n<h3 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h3><p>大多数时候，在<code>switch</code>表达式内部，我们会返回简单的值。</p>\n<p>但是，如果需要复杂的语句，我们也可以写很多语句，放到<code>&#123;...&#125;</code>里，然后，用<code>yield</code>返回一个值作为<code>switch</code>语句的返回值：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> yield</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a>while循环</h2><p>循环语句就是让计算机根据条件做循环计算，在条件满足时继续循环，条件不满足时退出循环。</p>\n<p>例如，计算从1到100的和：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">1 </span>+ <span class=\"number\">2</span> + <span class=\"number\">3</span> + <span class=\"number\">4</span> + … + <span class=\"number\">100</span> = ?</span><br></pre></td></tr></table></figure>\n\n<p>除了用数列公式外，完全可以让计算机做100次循环累加。因为计算机的特点是计算速度非常快，我们让计算机循环一亿次也用不到1秒，所以很多计算的任务，人去算是算不了的，但是计算机算，使用循环这种简单粗暴的方法就可以快速得到结果。</p>\n<p>我们先看Java提供的<code>while</code>条件循环。它的基本用法是：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (条件表达式) &#123;</span><br><span class=\"line\">    循环语句</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"regexp\">//</span> 继续执行后续代码</span><br></pre></td></tr></table></figure>\n\n<p><code>while</code>循环在每次循环开始前，首先判断条件是否成立。如果计算结果为<code>true</code>，就把循环体内的语句执行一遍，如果计算结果为<code>false</code>，那就直接跳到<code>while</code>循环的末尾，继续往下执行。</p>\n<p>我们用while循环来累加1到100，可以这么写：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">while</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到<code>while</code>循环是先判断循环条件，再循环，因此，有可能一次循环都不做。</p>\n<p>对于循环条件判断，以及自增变量的处理，要特别注意边界条件。思考一下下面的代码为何没有获得正确结果：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">while</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果循环条件永远满足，那这个循环就变成了死循环。死循环将导致100%的CPU占用，用户会感觉电脑运行缓慢，所以要避免编写死循环代码。</p>\n<p>如果循环条件的逻辑写得有问题，也会造成意料之外的结果：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">while</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>表面上看，上面的<code>while</code>循环是一个死循环，但是，Java的<code>int</code>类型有最大值，达到最大值后，再加1会变成负数，结果，意外退出了<code>while</code>循环。</p>\n<h2 id=\"do-while循环\"><a href=\"#do-while循环\" class=\"headerlink\" title=\"do while循环\"></a>do while循环</h2><p>在Java中，<code>while</code>循环是先判断循环条件，再执行循环。而另一种<code>do while</code>循环则是先执行循环，再判断条件，条件满足时继续循环，条件不满足时退出。它的用法是：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    执行循环语句</span><br><span class=\"line\">&#125; <span class=\"keyword\">while</span> <span class=\"comment\">(条件表达式)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>可见，<code>do while</code>循环会至少循环一次。</p>\n<p>我们把对1到100的求和用<code>do while</code>循环改写一下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">do</span>-<span class=\"keyword\">while</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>使用<code>do while</code>循环时，同样要注意循环条件的判断。</p>\n<h2 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h2><p>除了<code>while</code>和<code>do while</code>循环，Java使用最广泛的是<code>for</code>循环。</p>\n<p><code>for</code>循环的功能非常强大，它使用计数器实现循环。<code>for</code>循环会先初始化计数器，然后，在每次循环前检测循环条件，在每次循环后更新计数器。计数器变量通常命名为<code>i</code>。</p>\n<p>我们把1到100求和用<code>for</code>循环改写一下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">for</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>在<code>for</code>循环执行前，会先执行初始化语句<code>int i=1</code>，它定义了计数器变量<code>i</code>并赋初始值为<code>1</code>，然后，循环前先检查循环条件<code>i&lt;=100</code>，循环后自动执行<code>i++</code>，因此，和<code>while</code>循环相比，<code>for</code>循环把更新计数器的代码统一放到了一起。在<code>for</code>循环的循环体内部，不需要去更新变量<code>i</code>。</p>\n<p>因此，<code>for</code>循环的用法是：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (初始条件; 循环检测条件; 循环后更新计数器) &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span> 执行语句</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要对一个整型数组的所有元素求和，可以用<code>for</code>循环实现：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">for</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上面代码的循环条件是<code>i&lt;ns.length</code>。因为<code>ns</code>数组的长度是<code>5</code>，因此，当循环<code>5</code>次后，<code>i</code>的值被更新为<code>5</code>，就不满足循环条件，因此<code>for</code>循环结束。</p>\n<p> 思考：如果把循环条件改为i&lt;&#x3D;ns.length，会出现什么问题？</p>\n<p>注意<code>for</code>循环的初始化计数器总是会被执行，并且<code>for</code>循环也可能循环0次。</p>\n<p>使用<code>for</code>循环时，千万不要在循环体内修改计数器！在循环体中修改计数器常常导致莫名其妙的逻辑错误。对于下面的代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">for</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>虽然不会报错，但是，数组元素只打印了一半，原因是循环内部的<code>i = i + 1</code>导致了计数器变量每次循环实际上加了<code>2</code>（因为<code>for</code>循环还会自动执行<code>i++</code>）。因此，在<code>for</code>循环中，不要修改计数器的值。计数器的初始化、判断条件、每次循环后的更新条件统一放到<code>for()</code>语句中可以一目了然。</p>\n<p>如果希望只访问索引为奇数的数组元素，应该把<code>for</code>循环改写为：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] ns = &#123; <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;ns.<span class=\"built_in\">length</span>; i=i+<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    System.<span class=\"keyword\">out</span>.println(ns[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过更新计数器的语句<code>i=i+2</code>就达到了这个效果，从而避免了在循环体内去修改变量<code>i</code>。</p>\n<p>使用<code>for</code>循环时，计数器变量<code>i</code>要尽量定义在<code>for</code>循环中：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] ns = &#123; <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;ns.<span class=\"built_in\">length</span>; i++) &#123;</span><br><span class=\"line\">    System.<span class=\"keyword\">out</span>.println(ns[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 无法访问i</span></span><br><span class=\"line\"><span class=\"type\">int</span> n = i; <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>如果变量<code>i</code>定义在<code>for</code>循环外：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] ns = &#123; <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span> &#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i&lt;ns.<span class=\"built_in\">length</span>; i++) &#123;</span><br><span class=\"line\">    System.<span class=\"keyword\">out</span>.println(ns[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 仍然可以使用i</span></span><br><span class=\"line\"><span class=\"type\">int</span> n = i;</span><br></pre></td></tr></table></figure>\n\n<p>那么，退出<code>for</code>循环后，变量<code>i</code>仍然可以被访问，这就破坏了变量应该把访问范围缩到最小的原则。</p>\n<h3 id=\"灵活使用for循环\"><a href=\"#灵活使用for循环\" class=\"headerlink\" title=\"灵活使用for循环\"></a>灵活使用for循环</h3><p><code>for</code>循环还可以缺少初始化语句、循环条件和每次循环更新语句，例如：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">//</span> 不设置结束条件:</span><br><span class=\"line\">for <span class=\"params\">(int <span class=\"attr\">i</span>=0; ; i++)</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">//</span> 不设置结束条件和更新语句:</span><br><span class=\"line\">for <span class=\"params\">(int <span class=\"attr\">i</span>=0; ;)</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">//</span> 什么都不设置:</span><br><span class=\"line\">for <span class=\"params\">(;;)</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常不推荐这样写，但是，某些情况下，是可以省略<code>for</code>循环的某些语句的。</p>\n<h3 id=\"for-each循环\"><a href=\"#for-each循环\" class=\"headerlink\" title=\"for each循环\"></a>for each循环</h3><p><code>for</code>循环经常用来遍历数组，因为通过计数器可以根据索引来访问数组的每个元素：</p>\n<figure class=\"highlight glsl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>[] ns = &#123; <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">16</span>, <span class=\"number\">25</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;ns.<span class=\"built_in\">length</span>; i++) &#123;</span><br><span class=\"line\">    System.<span class=\"keyword\">out</span>.println(ns[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，很多时候，我们实际上真正想要访问的是数组每个元素的值。Java还提供了另一种<code>for each</code>循环，它可以更简单地遍历数组：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">for</span> each</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。<code>for each</code>循环的写法也更简洁。但是，<code>for each</code>循环无法指定遍历顺序，也无法获取数组的索引。</p>\n<p>除了数组外，<code>for each</code>循环能够遍历所有“可迭代”的数据类型，包括后面会介绍的<code>List</code>、<code>Map</code>等。</p>\n<h2 id=\"break和continue\"><a href=\"#break和continue\" class=\"headerlink\" title=\"break和continue\"></a>break和continue</h2><p>无论是<code>while</code>循环还是<code>for</code>循环，有两个特别的语句可以使用，就是<code>break</code>语句和<code>continue</code>语句。</p>\n<h3 id=\"break\"><a href=\"#break\" class=\"headerlink\" title=\"break\"></a>break</h3><p>在循环过程中，可以使用<code>break</code>语句跳出当前循环。我们来看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>使用<code>for</code>循环计算从1到100时，我们并没有在<code>for()</code>中设置循环退出的检测条件。但是，在循环内部，我们用<code>if</code>判断，如果<code>i==100</code>，就通过<code>break</code>退出循环。</p>\n<p>因此，<code>break</code>语句通常都是配合<code>if</code>语句使用。要特别注意，<code>break</code>语句总是跳出自己所在的那一层循环。例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上面的代码是两个<code>for</code>循环嵌套。因为<code>break</code>语句位于内层的<code>for</code>循环，因此，它会跳出内层<code>for</code>循环，但不会跳出外层<code>for</code>循环。</p>\n<h3 id=\"continue\"><a href=\"#continue\" class=\"headerlink\" title=\"continue\"></a>continue</h3><p><code>break</code>会跳出当前循环，也就是整个循环都不会执行了。而<code>continue</code>则是提前结束本次循环，直接继续执行下次循环。我们看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"keyword\">continue</span></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意观察<code>continue</code>语句的效果。当<code>i</code>为奇数时，完整地执行了整个循环，因此，会打印<code>begin i=1</code>和<code>end i=1</code>。在i为偶数时，<code>continue</code>语句会提前结束本次循环，因此，会打印<code>begin i=2</code>但不会打印<code>end i = 2</code>。</p>\n<p>在多层嵌套的循环中，<code>continue</code>语句同样是结束本次自己所在的循环。</p>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h2 id=\"遍历数组\"><a href=\"#遍历数组\" class=\"headerlink\" title=\"遍历数组\"></a>遍历数组</h2><p>我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。而数组最常见的一个操作就是遍历。</p>\n<p>通过<code>for</code>循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的<code>for</code>循环可以完成一个数组的遍历：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 遍历数组</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>为了实现<code>for</code>循环遍历，初始条件为<code>i=0</code>，因为索引总是从<code>0</code>开始，继续循环的条件为<code>i&lt;ns.length</code>，因为当<code>i=ns.length</code>时，<code>i</code>已经超出了索引范围（索引范围是<code>0</code> ~ <code>ns.length-1</code>），每次循环后，<code>i++</code>。</p>\n<p>第二种方式是使用<code>for each</code>循环，直接迭代数组的每个元素：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 遍历数组</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意：在<code>for (int n : ns)</code>循环中，变量<code>n</code>直接拿到<code>ns</code>数组的元素，而不是索引。</p>\n<p>显然<code>for each</code>循环更加简洁。但是，<code>for each</code>循环无法拿到数组的索引，因此，到底用哪一种<code>for</code>循环，取决于我们的需要。</p>\n<h3 id=\"打印数组内容\"><a href=\"#打印数组内容\" class=\"headerlink\" title=\"打印数组内容\"></a>打印数组内容</h3><p>直接打印数组变量，得到的是数组在JVM中的引用地址：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int</span>[] ns = &#123; <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span> &#125;;</span><br><span class=\"line\"><span class=\"attribute\">System</span>.out.println(ns); // 类似<span class=\"meta\"> [I@7852e922</span></span><br></pre></td></tr></table></figure>\n\n<p>这并没有什么意义，因为我们希望打印的数组的元素内容。因此，使用<code>for each</code>循环来打印它：</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span>[] ns = &#123; <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span> &#125;;</span><br><span class=\"line\">for (<span class=\"built_in\">int</span> <span class=\"built_in\">n</span> <span class=\"symbol\">:</span> ns) &#123;</span><br><span class=\"line\">    System.out.print(<span class=\"built_in\">n</span> + <span class=\"string\">&quot;, &quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>for each</code>循环打印也很麻烦。幸好Java标准库提供了<code>Arrays.toString()</code>，可以快速打印数组内容：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 遍历数组</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h2 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h2><p>对数组进行排序是程序中非常基本的需求。常用的排序算法有冒泡排序、插入排序和快速排序等。</p>\n<p>我们来看一下如何使用冒泡排序算法对一个整型数组从小到大进行排序：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 冒泡排序</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>冒泡排序的特点是，每一轮循环后，最大的一个数被交换到末尾，因此，下一轮循环就可以“刨除”最后的数，每一轮循环都比上一轮循环的结束位置靠前一位。</p>\n<p>另外，注意到交换两个变量的值必须借助一个临时变量。像这么写是错误的：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">int x = <span class=\"number\">1</span><span class=\"comment\">;</span></span><br><span class=\"line\">int y = <span class=\"number\">2</span><span class=\"comment\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">x</span> = y<span class=\"comment\">; // x现在是2</span></span><br><span class=\"line\"><span class=\"attribute\">y</span> = x<span class=\"comment\">; // y现在还是2</span></span><br></pre></td></tr></table></figure>\n\n<p>正确的写法是：</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> y = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">int</span> <span class=\"built_in\">t</span> = x; // 把x的值保存在临时变量<span class=\"built_in\">t</span>中, <span class=\"built_in\">t</span>现在是<span class=\"number\">1</span></span><br><span class=\"line\">x = y; // x现在是<span class=\"number\">2</span></span><br><span class=\"line\">y = <span class=\"built_in\">t</span>; // y现在是<span class=\"built_in\">t</span>的值<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的<code>Arrays.sort()</code>就可以排序：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 排序</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>必须注意，对数组排序实际上修改了数组本身。例如，排序前的数组是：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int</span>[] ns = &#123; <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在内存中，这个整型数组表示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      ┌───┬───┬───┬───┐</span><br><span class=\"line\">ns───&gt;│ 9 │ 3 │ 6 │ 5 │</span><br><span class=\"line\">      └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>当我们调用<code>Arrays.sort(ns);</code>后，这个整型数组在内存中变为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      ┌───┬───┬───┬───┐</span><br><span class=\"line\">ns───&gt;│ 3 │ 5 │ 6 │ 9 │</span><br><span class=\"line\">      └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>即变量<code>ns</code>指向的数组内容已经被改变了。</p>\n<p>如果对一个字符串数组进行排序，例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span>[] ns = &#123; <span class=\"string\">&quot;banana&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;pear&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>排序前，这个数组在内存中表示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                   ┌──────────────────────────────────┐</span><br><span class=\"line\">               ┌───┼──────────────────────┐           │</span><br><span class=\"line\">               │   │                      ▼           ▼</span><br><span class=\"line\">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class=\"line\">ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class=\"line\">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class=\"line\">           │                 ▲</span><br><span class=\"line\">           └─────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>Arrays.sort(ns);</code>排序后，这个数组在内存中表示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                   ┌──────────────────────────────────┐</span><br><span class=\"line\">               ┌───┼──────────┐                       │</span><br><span class=\"line\">               │   │          ▼                       ▼</span><br><span class=\"line\">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class=\"line\">ns ─────&gt;│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class=\"line\">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class=\"line\">           │                              ▲</span><br><span class=\"line\">           └──────────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>原来的3个字符串在内存中均没有任何变化，但是<code>ns</code>数组的每个元素指向变化了。</p>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><h3 id=\"二维数组\"><a href=\"#二维数组\" class=\"headerlink\" title=\"二维数组\"></a>二维数组</h3><p>二维数组就是数组的数组。定义一个二维数组如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 二维数组</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为<code>ns</code>包含3个数组，因此，<code>ns.length</code>为<code>3</code>。实际上<code>ns</code>在内存中的结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                    ┌───┬───┬───┬───┐</span><br><span class=\"line\">         ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │</span><br><span class=\"line\">ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘</span><br><span class=\"line\">         ├───┤      ┌───┬───┬───┬───┐</span><br><span class=\"line\">         │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │</span><br><span class=\"line\">         ├───┤      └───┴───┴───┴───┘</span><br><span class=\"line\">         │░░░│──┐   ┌───┬───┬───┬───┐</span><br><span class=\"line\">         └───┘  └──&gt;│ 9 │10 │11 │12 │</span><br><span class=\"line\">                    └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>如果我们定义一个普通数组<code>arr0</code>，然后把<code>ns[0]</code>赋值给它：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 二维数组</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>实际上<code>arr0</code>就获取了<code>ns</code>数组的第0个元素。因为<code>ns</code>数组的每个元素也是一个数组，因此，<code>arr0</code>指向的数组就是<code>&#123; 1, 2, 3, 4 &#125;</code>。在内存中，结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">            arr0 ─────┐</span><br><span class=\"line\">                      ▼</span><br><span class=\"line\">                    ┌───┬───┬───┬───┐</span><br><span class=\"line\">         ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │</span><br><span class=\"line\">ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘</span><br><span class=\"line\">         ├───┤      ┌───┬───┬───┬───┐</span><br><span class=\"line\">         │░░░│─────&gt;│ 5 │ 6 │ 7 │ 8 │</span><br><span class=\"line\">         ├───┤      └───┴───┴───┴───┘</span><br><span class=\"line\">         │░░░│──┐   ┌───┬───┬───┬───┐</span><br><span class=\"line\">         └───┘  └──&gt;│ 9 │10 │11 │12 │</span><br><span class=\"line\">                    └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>访问二维数组的某个元素需要使用<code>array[row][col]</code>，例如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">System</span>.out.println(ns[<span class=\"number\">1</span>][<span class=\"number\">2</span>]); // <span class=\"number\">7</span></span><br></pre></td></tr></table></figure>\n\n<p>二维数组的每个数组元素的长度并不要求相同，例如，可以这么定义<code>ns</code>数组：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\">int[][] ns = </span><span class=\"template-variable\">&#123;</span></span><br><span class=\"line\"><span class=\"template-variable\">    &#123; 1, 2, 3, 4 &#125;</span><span class=\"xml\">,</span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"template-variable\">&#123; 5, 6 &#125;</span><span class=\"xml\">,</span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"template-variable\">&#123; 7, 8, 9 &#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">&#125;;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个二维数组在内存中的结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                    ┌───┬───┬───┬───┐</span><br><span class=\"line\">         ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │ 4 │</span><br><span class=\"line\">ns ─────&gt;│░░░│──┘   └───┴───┴───┴───┘</span><br><span class=\"line\">         ├───┤      ┌───┬───┐</span><br><span class=\"line\">         │░░░│─────&gt;│ 5 │ 6 │</span><br><span class=\"line\">         ├───┤      └───┴───┘</span><br><span class=\"line\">         │░░░│──┐   ┌───┬───┬───┐</span><br><span class=\"line\">         └───┘  └──&gt;│ 7 │ 8 │ 9 │</span><br><span class=\"line\">                    └───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>要打印一个二维数组，可以使用两层嵌套的for循环：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] arr : ns) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> n : arr) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.print(n);</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.print(<span class=\"string\">&#x27;, &#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者使用Java标准库的<code>Arrays.deepToString()</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 二维数组</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"三维数组\"><a href=\"#三维数组\" class=\"headerlink\" title=\"三维数组\"></a>三维数组</h3><p>三维数组就是二维数组的数组。可以这么定义一个三维数组：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\">int[][][] ns = </span><span class=\"template-variable\">&#123;</span></span><br><span class=\"line\"><span class=\"template-variable\">    &#123;</span></span><br><span class=\"line\"><span class=\"template-variable\">        &#123;1, 2, 3&#125;</span><span class=\"xml\">,</span></span><br><span class=\"line\"><span class=\"xml\">        </span><span class=\"template-variable\">&#123;4, 5, 6&#125;</span><span class=\"xml\">,</span></span><br><span class=\"line\"><span class=\"xml\">        </span><span class=\"template-variable\">&#123;7, 8, 9&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;,</span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"template-variable\">&#123;</span></span><br><span class=\"line\"><span class=\"template-variable\">        &#123;10, 11&#125;</span><span class=\"xml\">,</span></span><br><span class=\"line\"><span class=\"xml\">        </span><span class=\"template-variable\">&#123;12, 13&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;,</span></span><br><span class=\"line\"><span class=\"xml\">    </span><span class=\"template-variable\">&#123;</span></span><br><span class=\"line\"><span class=\"template-variable\">        &#123;14, 15, 16&#125;</span><span class=\"xml\">,</span></span><br><span class=\"line\"><span class=\"xml\">        </span><span class=\"template-variable\">&#123;17, 18&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    &#125;</span></span><br><span class=\"line\"><span class=\"xml\">&#125;;</span></span><br></pre></td></tr></table></figure>\n\n<p>它在内存中的结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                              ┌───┬───┬───┐</span><br><span class=\"line\">                   ┌───┐  ┌──&gt;│ 1 │ 2 │ 3 │</span><br><span class=\"line\">               ┌──&gt;│░░░│──┘   └───┴───┴───┘</span><br><span class=\"line\">               │   ├───┤      ┌───┬───┬───┐</span><br><span class=\"line\">               │   │░░░│─────&gt;│ 4 │ 5 │ 6 │</span><br><span class=\"line\">               │   ├───┤      └───┴───┴───┘</span><br><span class=\"line\">               │   │░░░│──┐   ┌───┬───┬───┐</span><br><span class=\"line\">        ┌───┐  │   └───┘  └──&gt;│ 7 │ 8 │ 9 │</span><br><span class=\"line\">ns ────&gt;│░░░│──┘              └───┴───┴───┘</span><br><span class=\"line\">        ├───┤      ┌───┐      ┌───┬───┐</span><br><span class=\"line\">        │░░░│─────&gt;│░░░│─────&gt;│10 │11 │</span><br><span class=\"line\">        ├───┤      ├───┤      └───┴───┘</span><br><span class=\"line\">        │░░░│──┐   │░░░│──┐   ┌───┬───┐</span><br><span class=\"line\">        └───┘  │   └───┘  └──&gt;│12 │13 │</span><br><span class=\"line\">               │              └───┴───┘</span><br><span class=\"line\">               │   ┌───┐      ┌───┬───┬───┐</span><br><span class=\"line\">               └──&gt;│░░░│─────&gt;│14 │15 │16 │</span><br><span class=\"line\">                   ├───┤      └───┴───┴───┘</span><br><span class=\"line\">                   │░░░│──┐   ┌───┬───┐</span><br><span class=\"line\">                   └───┘  └──&gt;│17 │18 │</span><br><span class=\"line\">                              └───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要访问三维数组的某个元素，例如，<code>ns[2][0][1]</code>，只需要顺着定位找到对应的最终元素<code>15</code>即可。</p>\n<p>理论上，我们可以定义任意的N维数组。但在实际应用中，除了二维数组在某些时候还能用得上，更高维度的数组很少使用。</p>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><p>Java程序的入口是<code>main</code>方法，而<code>main</code>方法可以接受一个命令行参数，它是一个<code>String[]</code>数组。</p>\n<p>这个命令行参数由JVM接收用户输入并传给<code>main</code>方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> arg : args) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(arg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以利用接收到的命令行参数，根据不同的参数执行不同的代码。例如，实现一个<code>-version</code>参数，打印程序版本号：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> arg : args) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;-version&quot;</span>.<span class=\"built_in\">equals</span>(arg)) &#123;</span><br><span class=\"line\">                System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;v 1.0&quot;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面这个程序必须在命令行执行，我们先编译它：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ javac <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java</span><br></pre></td></tr></table></figure>\n\n<p>然后，执行的时候，给它传递一个<code>-version</code>参数：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java Main -<span class=\"built_in\">version</span></span><br><span class=\"line\">v <span class=\"number\">1.0</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，程序就可以根据传入的命令行参数，作出不同的响应。</p>\n","categories":["Java","1.Java快速入门","01.入门"],"tags":["写作"]},{"title":"10.单元测试","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_10.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","content":"<h1 id=\"编写JUnit测试\"><a href=\"#编写JUnit测试\" class=\"headerlink\" title=\"编写JUnit测试\"></a>编写JUnit测试</h1><p>什么是单元测试呢？单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</p>\n<p>单元测试有什么好处呢？在学习单元测试前，我们可以先了解一下测试驱动开发。</p>\n<p>所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    编写接口</span><br><span class=\"line\">     │</span><br><span class=\"line\">     ▼</span><br><span class=\"line\">    编写测试</span><br><span class=\"line\">     │</span><br><span class=\"line\">     ▼</span><br><span class=\"line\">┌─&gt; 编写实现</span><br><span class=\"line\">│    │</span><br><span class=\"line\">│ N  ▼</span><br><span class=\"line\">└── 运行测试</span><br><span class=\"line\">     │ Y</span><br><span class=\"line\">     ▼</span><br><span class=\"line\">    任务完成</span><br></pre></td></tr></table></figure>\n\n<p>这就是传说中的……</p>\n<p><img src=\"/10.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/l.jpeg\" alt=\"tdd\"></p>\n<p>当然，这是一种理想情况。大部分情况是我们已经编写了实现代码，需要对已有的代码进行测试。</p>\n<p>我们先通过一个示例来看如何编写测试。假定我们编写了一个计算阶乘的类，它只有一个静态方法来计算阶乘：</p>\n<p>n!&#x3D;1\\times2\\times3\\times…\\times n<em>n</em>!&#x3D;1×2×3×…×<em>n</em></p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factorial</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">fact</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            r = r * i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要测试这个方法，一个很自然的想法是编写一个<code>main()</code>方法，然后运行一些测试代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">fact</span>(<span class=\"number\">10</span>) == <span class=\"number\">3628800</span>) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;pass&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;fail&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们就可以通过运行<code>main()</code>方法来运行测试代码。</p>\n<p>不过，使用<code>main()</code>方法测试有很多缺点：</p>\n<p>一是只能有一个<code>main()</code>方法，不能把测试代码分离，二是没有打印出测试结果和期望结果，例如，<code>expected: 3628800, but actual: 123456</code>，三是很难编写一组通用的测试代码。</p>\n<p>因此，我们需要一种测试框架，帮助我们编写测试。</p>\n<h3 id=\"JUnit\"><a href=\"#JUnit\" class=\"headerlink\" title=\"JUnit\"></a>JUnit</h3><p>JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试。</p>\n<p>使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p>\n<p>此外，几乎所有的IDE工具都集成了JUnit，这样我们就可以直接在IDE中编写并运行JUnit测试。JUnit目前最新版本是5。</p>\n<p>以Eclipse为例，当我们已经编写了一个<code>Factorial.java</code>文件后，我们想对其进行测试，需要编写一个对应的<code>FactorialTest.java</code>文件，以<code>Test</code>为后缀是一个惯例，并分别将其放入<code>src</code>和<code>test</code>目录中。最后，在<code>Project</code> - <code>Properties</code> - <code>Java Build Path</code> - <code>Libraries</code>中添加<code>JUnit 5</code>的库：</p>\n<p><img src=\"/10.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/l-164189409758412.png\" alt=\"junit-lib\"></p>\n<p>整个项目结构如下：</p>\n<p><img src=\"/10.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/l-164189409758413.png\" alt=\"junit-test-structure\"></p>\n<p>我们来看一下<code>FactorialTest.java</code>的内容：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.itranswarp.learnjava;</span><br><span class=\"line\"></span><br><span class=\"line\">import static org.junit.jupiter.api.Assertions.*;</span><br><span class=\"line\">import org.junit.jupiter.api.Test;</span><br><span class=\"line\"></span><br><span class=\"line\">public <span class=\"keyword\">class</span> FactorialTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    void test<span class=\"constructor\">Fact()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(1, Factorial.<span class=\"params\">fact</span>(1)</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(2, Factorial.<span class=\"params\">fact</span>(2)</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(6, Factorial.<span class=\"params\">fact</span>(3)</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(3628800, Factorial.<span class=\"params\">fact</span>(10)</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(2432902008176640000L, Factorial.<span class=\"params\">fact</span>(20)</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>核心测试方法<code>testFact()</code>加上了<code>@Test</code>注解，这是JUnit要求的，它会把带有<code>@Test</code>的方法识别为测试方法。在测试方法内部，我们用<code>assertEquals(1, Factorial.fact(1))</code>表示，期望<code>Factorial.fact(1)</code>返回<code>1</code>。<code>assertEquals(expected, actual)</code>是最常用的测试方法，它在<code>Assertion</code>类中定义。<code>Assertion</code>还定义了其他断言方法，例如：</p>\n<ul>\n<li><code>assertTrue()</code>: 期待结果为<code>true</code></li>\n<li><code>assertFalse()</code>: 期待结果为<code>false</code></li>\n<li><code>assertNotNull()</code>: 期待结果为非<code>null</code></li>\n<li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li>\n<li>…</li>\n</ul>\n<p>运行单元测试非常简单。选中<code>FactorialTest.java</code>文件，点击<code>Run</code> - <code>Run As</code> - <code>JUnit Test</code>，Eclipse会自动运行这个JUnit测试，并显示结果：</p>\n<p><img src=\"/10.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/l-164189409758414.png\" alt=\"junit-test-ok\"></p>\n<p>如果测试结果与预期不符，<code>assertEquals()</code>会抛出异常，我们就会得到一个测试失败的结果：</p>\n<p><img src=\"/10.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/l-164189409758415.png\" alt=\"junit-test-failed\"></p>\n<p>在Failure Trace中，JUnit会告诉我们详细的错误结果：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">org<span class=\"selector-class\">.opentest4j</span><span class=\"selector-class\">.AssertionFailedError</span>: expected: &lt;<span class=\"number\">3628800</span>&gt; but was: &lt;<span class=\"number\">362880</span>&gt;</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.junit</span><span class=\"selector-class\">.jupiter</span><span class=\"selector-class\">.api</span><span class=\"selector-class\">.AssertionUtils</span><span class=\"selector-class\">.fail</span>(AssertionUtils<span class=\"selector-class\">.java</span>:<span class=\"number\">55</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.junit</span><span class=\"selector-class\">.jupiter</span><span class=\"selector-class\">.api</span><span class=\"selector-class\">.AssertEquals</span><span class=\"selector-class\">.failNotEqual</span>(AssertEquals<span class=\"selector-class\">.java</span>:<span class=\"number\">195</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.junit</span><span class=\"selector-class\">.jupiter</span><span class=\"selector-class\">.api</span><span class=\"selector-class\">.AssertEquals</span><span class=\"selector-class\">.assertEquals</span>(AssertEquals<span class=\"selector-class\">.java</span>:<span class=\"number\">168</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.junit</span><span class=\"selector-class\">.jupiter</span><span class=\"selector-class\">.api</span><span class=\"selector-class\">.AssertEquals</span><span class=\"selector-class\">.assertEquals</span>(AssertEquals<span class=\"selector-class\">.java</span>:<span class=\"number\">163</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.junit</span><span class=\"selector-class\">.jupiter</span><span class=\"selector-class\">.api</span><span class=\"selector-class\">.Assertions</span><span class=\"selector-class\">.assertEquals</span>(Assertions<span class=\"selector-class\">.java</span>:<span class=\"number\">611</span>)</span><br><span class=\"line\">\tat com<span class=\"selector-class\">.itranswarp</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.FactorialTest</span><span class=\"selector-class\">.testFact</span>(FactorialTest<span class=\"selector-class\">.java</span>:<span class=\"number\">14</span>)</span><br><span class=\"line\">\tat java.base/jdk<span class=\"selector-class\">.internal</span><span class=\"selector-class\">.reflect</span><span class=\"selector-class\">.NativeMethodAccessorImpl</span><span class=\"selector-class\">.invoke0</span>(Native Method)</span><br><span class=\"line\">\tat ...</span><br></pre></td></tr></table></figure>\n\n<p>第一行的失败信息的意思是期待结果<code>3628800</code>但是实际返回是<code>362880</code>，此时，我们要么修正实现代码，要么修正测试代码，直到测试通过为止。</p>\n<p>使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用<code>assertEquals(double expected, double actual, double delta)</code>这个重载方法，指定一个误差值：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">assertEquals</span>(<span class=\"number\">0</span>.<span class=\"number\">1</span>, Math.abs(<span class=\"number\">1</span> - <span class=\"number\">9</span> / <span class=\"number\">10</span>.<span class=\"number\">0</span>), <span class=\"number\">0</span>.<span class=\"number\">0000001</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"单元测试的好处\"><a href=\"#单元测试的好处\" class=\"headerlink\" title=\"单元测试的好处\"></a>单元测试的好处</h3><p>单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p>\n<p>使用JUnit进行单元测试，我们可以使用断言（<code>Assertion</code>）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</p>\n<p>在编写单元测试的时候，我们要遵循一定的规范：</p>\n<p>一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p>\n<p>二是每个单元测试应当互相独立，不依赖运行的顺序；</p>\n<p>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为<code>0</code>，<code>null</code>，空字符串<code>&quot;&quot;</code>等情况。</p>\n<h1 id=\"使用Fixture\"><a href=\"#使用Fixture\" class=\"headerlink\" title=\"使用Fixture\"></a>使用Fixture</h1><p>在一个单元测试中，我们经常编写多个<code>@Test</code>方法，来分组、分类对目标代码进行测试。</p>\n<p>在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个<code>@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p>\n<p>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</p>\n<p>我们来看一个具体的<code>Calculator</code>的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Calculator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">long</span> x)</span> </span>&#123;</span><br><span class=\"line\">        n = n + x;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">sub</span><span class=\"params\">(<span class=\"keyword\">long</span> x)</span> </span>&#123;</span><br><span class=\"line\">        n = n - x;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个类的功能很简单，但是测试的时候，我们要先初始化对象，我们不必在每个测试方法中都写上初始化代码，而是通过<code>@BeforeEach</code>来初始化，通过<code>@AfterEach</code>来清理资源：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> CalculatorTest &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Calculator calculator;</span><br><span class=\"line\"></span><br><span class=\"line\">    @BeforeEach</span><br><span class=\"line\">    public void set<span class=\"constructor\">Up()</span> &#123;</span><br><span class=\"line\">        this.calculator = <span class=\"keyword\">new</span> <span class=\"constructor\">Calculator()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @AfterEach</span><br><span class=\"line\">    public void tear<span class=\"constructor\">Down()</span> &#123;</span><br><span class=\"line\">        this.calculator = null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    void test<span class=\"constructor\">Add()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(100, <span class=\"params\">this</span>.<span class=\"params\">calculator</span>.<span class=\"params\">add</span>(100)</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(150, <span class=\"params\">this</span>.<span class=\"params\">calculator</span>.<span class=\"params\">add</span>(50)</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(130, <span class=\"params\">this</span>.<span class=\"params\">calculator</span>.<span class=\"params\">add</span>(-20)</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Test</span><br><span class=\"line\">    void test<span class=\"constructor\">Sub()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(-100, <span class=\"params\">this</span>.<span class=\"params\">calculator</span>.<span class=\"params\">sub</span>(100)</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(-150, <span class=\"params\">this</span>.<span class=\"params\">calculator</span>.<span class=\"params\">sub</span>(50)</span>);</span><br><span class=\"line\">        <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(-130, <span class=\"params\">this</span>.<span class=\"params\">calculator</span>.<span class=\"params\">sub</span>(-20)</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>CalculatorTest</code>测试中，有两个标记为<code>@BeforeEach</code>和<code>@AfterEach</code>的方法，它们会在运行每个<code>@Test</code>方法前后自动运行。</p>\n<p>上面的测试代码在JUnit中运行顺序如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Method testMethod : find<span class=\"constructor\">TestMethods(CalculatorTest.<span class=\"params\">class</span>)</span>) &#123;</span><br><span class=\"line\">    var test = <span class=\"keyword\">new</span> <span class=\"constructor\">CalculatorTest()</span>; <span class=\"comment\">// 创建Test实例</span></span><br><span class=\"line\">    invoke<span class=\"constructor\">BeforeEach(<span class=\"params\">test</span>)</span>;</span><br><span class=\"line\">        invoke<span class=\"constructor\">TestMethod(<span class=\"params\">test</span>, <span class=\"params\">testMethod</span>)</span>;</span><br><span class=\"line\">    invoke<span class=\"constructor\">AfterEach(<span class=\"params\">test</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，<code>@BeforeEach</code>和<code>@AfterEach</code>会“环绕”在每个<code>@Test</code>方法前后。</p>\n<p>还有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，例如初始化数据库。JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有@Test前后运行，顺序如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">invoke<span class=\"constructor\">BeforeAll(CalculatorTest.<span class=\"params\">class</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Method testMethod : find<span class=\"constructor\">TestMethods(CalculatorTest.<span class=\"params\">class</span>)</span>) &#123;</span><br><span class=\"line\">    var test = <span class=\"keyword\">new</span> <span class=\"constructor\">CalculatorTest()</span>; <span class=\"comment\">// 创建Test实例</span></span><br><span class=\"line\">    invoke<span class=\"constructor\">BeforeEach(<span class=\"params\">test</span>)</span>;</span><br><span class=\"line\">        invoke<span class=\"constructor\">TestMethod(<span class=\"params\">test</span>, <span class=\"params\">testMethod</span>)</span>;</span><br><span class=\"line\">    invoke<span class=\"constructor\">AfterEach(<span class=\"params\">test</span>)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">invoke<span class=\"constructor\">AfterAll(CalculatorTest.<span class=\"params\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>@BeforeAll</code>和<code>@AfterAll</code>在所有<code>@Test</code>方法运行前后仅运行一次，因此，它们只能初始化静态变量，例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DatabaseTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> Database db;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeAll</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">initDatabase</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        db = createDb(...);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@AfterAll</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">dropDatabase</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>事实上，<code>@BeforeAll</code>和<code>@AfterAll</code>也只能标注在静态方法上。</p>\n<p>因此，我们总结出编写Fixture的套路如下：</p>\n<ol>\n<li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li>\n<li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li>\n</ol>\n<p>大多数情况下，使用<code>@BeforeEach</code>和<code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到<code>@BeforeAll</code>和<code>@AfterAll</code>。</p>\n<p>最后，注意到每次运行一个<code>@Test</code>方法前，JUnit首先创建一个<code>XxxTest</code>实例，因此，每个<code>@Test</code>方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个<code>@Test</code>方法带到另一个<code>@Test</code>方法。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/100.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.1255945269146912/20.%E4%BD%BF%E7%94%A8Fixture.1304049490067490/junit-fixture.zip?utm_source=blog_lxf\">使用Fixture</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<h1 id=\"异常测试\"><a href=\"#异常测试\" class=\"headerlink\" title=\"异常测试\"></a>异常测试</h1><p>在Java程序中，异常处理是非常重要的。</p>\n<p>我们自己编写的方法，也经常抛出各种异常。对于可能抛出的异常进行测试，本身就是测试的重要环节。</p>\n<p>因此，在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。</p>\n<p>我们仍然用<code>Factorial</code>举例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Factorial</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> <span class=\"title\">fact</span><span class=\"params\">(<span class=\"keyword\">long</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> r = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            r = r * i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在方法入口，我们增加了对参数<code>n</code>的检查，如果为负数，则直接抛出<code>IllegalArgumentException</code>。</p>\n<p>现在，我们希望对异常进行测试。在JUnit测试中，我们可以编写一个<code>@Test</code>方法专门测试异常：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">testNegative</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    assertThrows(IllegalArgumentException.class, <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">Executable</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> execute() throws Throwable &#123;</span><br><span class=\"line\">            Factorial.fact(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JUnit提供<code>assertThrows()</code>来期望捕获一个指定的异常。第二个参数<code>Executable</code>封装了我们要执行的会产生异常的代码。当我们执行<code>Factorial.fact(-1)</code>时，必定抛出<code>IllegalArgumentException</code>。<code>assertThrows()</code>在捕获到指定异常时表示通过测试，未捕获到异常，或者捕获到的异常类型不对，均表示测试失败。</p>\n<p>有些童鞋会觉得编写一个<code>Executable</code>的匿名类太繁琐了。实际上，Java 8开始引入了函数式编程，所有单方法接口都可以简写如下：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\"><span class=\"literal\">void</span> testNegative() &#123;</span><br><span class=\"line\">    assertThrows<span class=\"function\"><span class=\"params\">(IllegalArgumentException.<span class=\"keyword\">class</span>, () -&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        Factorial.fact(-<span class=\"number\">1</span>);</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    &#125;)</span>;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>上述奇怪的<code>-&gt;</code>语法就是函数式接口的实现代码，我们会在后面详细介绍。现在，我们只需要通过这种固定的代码编写能抛出异常的语句即可。</p>\n<h1 id=\"条件测试\"><a href=\"#条件测试\" class=\"headerlink\" title=\"条件测试\"></a>条件测试</h1><p>在运行测试的时候，有些时候，我们需要排出某些<code>@Test</code>方法，不要让它运行，这时，我们就可以给它标记一个<code>@Disabled</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Disabled</span></span><br><span class=\"line\"><span class=\"variable\">@Test</span></span><br><span class=\"line\">void testBug101() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这个测试不会运行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么我们不直接注释掉<code>@Test</code>，而是要加一个<code>@Disabled</code>？这是因为注释掉<code>@Test</code>，JUnit就不知道这是个测试方法，而加上<code>@Disabled</code>，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Tests</span> run: <span class=\"number\">68</span>, Failures: <span class=\"number\">2</span>, Errors: <span class=\"number\">0</span>, Skipped: <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n\n<p>类似<code>@Disabled</code>这种注解就称为条件测试，JUnit根据不同的条件注解，决定是否运行当前的<code>@Test</code>方法。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Config</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> getConfigFile(<span class=\"keyword\">String</span> filename) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> os = System.getProperty(<span class=\"string\">&quot;os.name&quot;</span>).toLowerCase();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (os.contains(<span class=\"string\">&quot;win&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;C:\\\\&quot;</span> + filename;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (os.contains(<span class=\"string\">&quot;mac&quot;</span>) || os.contains(<span class=\"string\">&quot;linux&quot;</span>) || os.contains(<span class=\"string\">&quot;unix&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;/usr/local/&quot;</span> + filename;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">UnsupportedOperationException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们想要测试<code>getConfigFile()</code>这个方法，但是在Windows上跑，和在Linux上跑的代码路径不同，因此，针对两个系统的测试方法，其中一个只能在Windows上跑，另一个只能在Mac&#x2F;Linux上跑：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Test</span><br><span class=\"line\">void test<span class=\"constructor\">Windows()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(<span class=\"string\">&quot;C:\\\\test.ini&quot;</span>, <span class=\"params\">config</span>.<span class=\"params\">getConfigFile</span>(<span class=\"string\">&quot;test.ini&quot;</span>)</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Test</span><br><span class=\"line\">void test<span class=\"constructor\">LinuxAndMac()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(<span class=\"string\">&quot;/usr/local/test.cfg&quot;</span>, <span class=\"params\">config</span>.<span class=\"params\">getConfigFile</span>(<span class=\"string\">&quot;test.cfg&quot;</span>)</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们给上述两个测试方法分别加上条件如下：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Test</span></span><br><span class=\"line\"><span class=\"variable\">@EnabledOnOs</span>(OS.WINDOWS)</span><br><span class=\"line\">void testWindows() &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">assertEquals</span>(<span class=\"string\">&quot;C:\\\\test.ini&quot;</span>, config.getConfigFile(<span class=\"string\">&quot;test.ini&quot;</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@<span class=\"selector-tag\">Test</span></span><br><span class=\"line\">@<span class=\"selector-tag\">EnabledOnOs</span>(&#123; <span class=\"selector-tag\">OS</span><span class=\"selector-class\">.LINUX</span>, <span class=\"selector-tag\">OS</span><span class=\"selector-class\">.MAC</span> &#125;)</span><br><span class=\"line\"><span class=\"selector-tag\">void</span> <span class=\"selector-tag\">testLinuxAndMac</span>() &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">assertEquals</span>(<span class=\"string\">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class=\"string\">&quot;test.cfg&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@EnableOnOs</code>就是一个条件测试判断。</p>\n<p>我们来看一些常用的条件测试：</p>\n<p>不在Windows平台执行的测试，可以加上<code>@DisabledOnOs(OS.WINDOWS)</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Test</span></span><br><span class=\"line\"><span class=\"variable\">@DisabledOnOs</span>(OS.WINDOWS)</span><br><span class=\"line\">void testOnNonWindowsOs() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> this test is disabled on windows</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只能在Java 9或更高版本执行的测试，可以加上<code>@DisabledOnJre(JRE.JAVA_8)</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Test</span></span><br><span class=\"line\"><span class=\"variable\">@DisabledOnJre</span>(JRE.JAVA_8)</span><br><span class=\"line\">void testOnJava9OrAbove() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> this test is disabled on java 8</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只能在64位操作系统上执行的测试，可以用<code>@EnabledIfSystemProperty</code>判断：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Test</span></span><br><span class=\"line\"><span class=\"variable\">@EnabledIfSystemProperty</span>(named = <span class=\"string\">&quot;os.arch&quot;</span>, matches = <span class=\"string\">&quot;.*64.*&quot;</span>)</span><br><span class=\"line\">void testOnlyOn64bitSystem() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> this test is only run on 64 bit system</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要传入环境变量<code>DEBUG=true</code>才能执行的测试，可以用<code>@EnabledIfEnvironmentVariable</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Test</span></span><br><span class=\"line\"><span class=\"variable\">@EnabledIfEnvironmentVariable</span>(named = <span class=\"string\">&quot;DEBUG&quot;</span>, matches = <span class=\"string\">&quot;true&quot;</span>)</span><br><span class=\"line\">void testOnlyOnDebugMode() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> this test is only run on DEBUG=true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们在JUnit中运行所有测试的时候，JUnit会给出执行的结果。在IDE中，我们能很容易地看到没有执行的测试：</p>\n<p><img src=\"/10.%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.assets/l-164189413157221.png\" alt=\"junit-conditional-test\"></p>\n<p>带有⊘标记的测试方法表示没有执行。</p>\n<h1 id=\"参数化测试\"><a href=\"#参数化测试\" class=\"headerlink\" title=\"参数化测试\"></a>参数化测试</h1><p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法</p>\n<p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p>\n<p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p>\n<p>假设我们想对<code>Math.abs()</code>进行测试，先用一组正数进行测试：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"variable\">@ValueSource</span>(ints = &#123; <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">100</span> &#125;)</span><br><span class=\"line\">void testAbs(int x) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">assertEquals</span>(x, Math.abs(x));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再用一组负数进行测试：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"variable\">@ValueSource</span>(ints = &#123; -<span class=\"number\">1</span>, -<span class=\"number\">5</span>, -<span class=\"number\">100</span> &#125;)</span><br><span class=\"line\">void testAbsNegative(int x) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">assertEquals</span>(-x, Math.abs(x));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到参数化测试的注解是<code>@ParameterizedTest</code>，而不是普通的<code>@Test</code>。</p>\n<p>实际的测试场景往往没有这么简单。假设我们自己编写了一个<code>StringUtils.capitalize()</code>方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringUtils</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">capitalize</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Character.toUpperCase(s.charAt(<span class=\"number\">0</span>)) + s.substring(<span class=\"number\">1</span>).toLowerCase();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@ParameterizedTest</span><br><span class=\"line\">void test<span class=\"constructor\">Capitalize(String <span class=\"params\">input</span>, String <span class=\"params\">result</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(<span class=\"params\">result</span>, StringUtils.<span class=\"params\">capitalize</span>(<span class=\"params\">input</span>)</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在问题来了：参数如何传入？</p>\n<p>最简单的方法是通过<code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@ParameterizedTest</span><br><span class=\"line\">@MethodSource</span><br><span class=\"line\">void test<span class=\"constructor\">Capitalize(String <span class=\"params\">input</span>, String <span class=\"params\">result</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span><span class=\"constructor\">Equals(<span class=\"params\">result</span>, StringUtils.<span class=\"params\">capitalize</span>(<span class=\"params\">input</span>)</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">static List&lt;Arguments&gt; test<span class=\"constructor\">Capitalize()</span> &#123;</span><br><span class=\"line\">    return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">List</span>.</span></span><span class=\"keyword\">of</span>( <span class=\"comment\">// arguments:</span></span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arguments</span>.</span></span>arguments(<span class=\"string\">&quot;abc&quot;</span>, <span class=\"string\">&quot;Abc&quot;</span>), <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arguments</span>.</span></span>arguments(<span class=\"string\">&quot;APPLE&quot;</span>, <span class=\"string\">&quot;Apple&quot;</span>), <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arguments</span>.</span></span>arguments(<span class=\"string\">&quot;gooD&quot;</span>, <span class=\"string\">&quot;Good&quot;</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码很容易理解：静态方法<code>testCapitalize()</code>返回了一组测试参数，每个参数都包含两个<code>String</code>，正好作为测试方法的两个参数传入。</p>\n<p> 如果静态方法和测试方法的名称不同，@MethodSource也允许指定方法名。但使用默认同名方法最方便。</p>\n<p>另一种传入测试参数的方法是使用<code>@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔，因此，上述测试又可以改写如下：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"variable\">@CsvSource</span>(&#123; <span class=\"string\">&quot;abc, Abc&quot;</span>, <span class=\"string\">&quot;APPLE, Apple&quot;</span>, <span class=\"string\">&quot;gooD, Good&quot;</span> &#125;)</span><br><span class=\"line\">void testCapitalize(String input, String result) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">assertEquals</span>(result, StringUtils.capitalize(input));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@ParameterizedTest</span></span><br><span class=\"line\"><span class=\"variable\">@CsvFileSource</span>(resources = &#123; <span class=\"string\">&quot;/test-capitalize.csv&quot;</span> &#125;)</span><br><span class=\"line\">void testCapitalizeUsingCsvFile(String input, String result) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">assertEquals</span>(result, StringUtils.capitalize(input));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JUnit只在classpath中查找指定的CSV文件，因此，<code>test-capitalize.csv</code>这个文件要放到<code>test</code>目录下，内容如下：</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">apple,</span> Apple</span><br><span class=\"line\"><span class=\"built_in\">HELLO,</span> Hello</span><br><span class=\"line\"><span class=\"built_in\">JUnit,</span> Junit</span><br><span class=\"line\"><span class=\"built_in\">reSource,</span> Resource</span><br></pre></td></tr></table></figure>\n","categories":["Java","1.Java快速入门","10.单元测试"],"tags":["写作"]},{"title":"11.正则表达式","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_11.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"<h1 id=\"正则表达式简介\"><a href=\"#正则表达式简介\" class=\"headerlink\" title=\"正则表达式简介\"></a>正则表达式简介</h1><p>在了解正则表达式之前，我们先看几个非常常见的问题：</p>\n<ul>\n<li>如何判断字符串是否是有效的电话号码？例如：<code>010-1234567</code>，<code>123ABC456</code>，<code>13510001000</code>等；</li>\n<li>如何判断字符串是否是有效的电子邮件地址？例如：<code>test@example.com</code>，<code>test#example</code>等；</li>\n<li>如何判断字符串是否是有效的时间？例如：<code>12:34</code>，<code>09:60</code>，<code>99:99</code>等。</li>\n</ul>\n<p>一种直观的想法是通过程序判断，这种方法需要为每种用例创建规则，然后用代码实现。下面是判断手机号的代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isValidMobileNumber</span><span class=\"params\">(<span class=\"keyword\">String</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 是否是11位？</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s.<span class=\"built_in\">length</span>() != <span class=\"number\">11</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 每一位都是0~9：</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;s.<span class=\"built_in\">length</span>(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c = s.<span class=\"built_in\">charAt</span>(i);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c &lt; <span class=\"string\">&#x27;0&#x27;</span> || c &gt; <span class=\"string\">&#x27;9&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码仅仅做了非常粗略的判断，并未考虑首位数字不能为<code>0</code>等更详细的情况。</p>\n<p>除了判断手机号，我们还需要判断电子邮件地址、电话、邮编等等：</p>\n<ul>\n<li>boolean isValidMobileNumber(String s) { … }</li>\n<li>boolean isValidEmail(String s) { … }</li>\n<li>boolean isValidPhoneNumber(String s) { … }</li>\n<li>boolean isValidZipCode(String s) { … }</li>\n<li>…</li>\n</ul>\n<p>为每一种判断逻辑编写代码实在是太繁琐了。有没有更简单的方法？</p>\n<p>有！用正则表达式！</p>\n<p>正则表达式可以用字符串来描述规则，并用来匹配字符串。例如，判断手机号，我们用正则表达式<code>\\d&#123;11&#125;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">isValidMobileNumber</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.matches(<span class=\"string\">&quot;\\\\d&#123;11&#125;&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用正则表达式的好处有哪些？一个正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。</p>\n<p>正则表达式是一套标准，它可以用于任何语言。Java标准库的<code>java.util.regex</code>包内置了正则表达式引擎，在Java程序中使用正则表达式非常简单。</p>\n<p>举个例子：要判断用户输入的年份是否是<code>20##</code>年，我们先写出规则如下：</p>\n<p>一共有4个字符，分别是：<code>2</code>，<code>0</code>，<code>0~9任意数字</code>，<code>0~9任意数字</code>。</p>\n<p>对应的正则表达式就是：<code>20\\d\\d</code>，其中<code>\\d</code>表示任意一个数字。</p>\n<p>把正则表达式转换为Java字符串就变成了<code>20\\\\d\\\\d</code>，注意Java字符串用<code>\\\\</code>表示<code>\\</code>。</p>\n<p>最后，用正则表达式匹配一个字符串的代码如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> regex</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>可见，使用正则表达式，不必编写复杂的代码来判断，只需给出一个字符串表达的正则规则即可。</p>\n<h1 id=\"匹配规则\"><a href=\"#匹配规则\" class=\"headerlink\" title=\"匹配规则\"></a>匹配规则</h1><p>正则表达式的匹配规则是从左到右按规则匹配。我们首先来看如何使用正则表达式来做精确匹配。</p>\n<p>对于正则表达式<code>abc</code>来说，它只能精确地匹配字符串<code>&quot;abc&quot;</code>，不能匹配<code>&quot;ab&quot;</code>，<code>&quot;Abc&quot;</code>，<code>&quot;abcd&quot;</code>等其他任何字符串。</p>\n<p>如果正则表达式有特殊字符，那就需要用<code>\\</code>转义。例如，正则表达式<code>a\\&amp;c</code>，其中<code>\\&amp;</code>是用来匹配特殊字符<code>&amp;</code>的，它能精确匹配字符串<code>&quot;a&amp;c&quot;</code>，但不能匹配<code>&quot;ac&quot;</code>、<code>&quot;a-c&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>等。</p>\n<p>要注意正则表达式在Java代码中也是一个字符串，所以，对于正则表达式<code>a\\&amp;c</code>来说，对应的Java字符串是<code>&quot;a\\\\&amp;c&quot;</code>，因为<code>\\</code>也是Java字符串的转义字符，两个<code>\\\\</code>实际上表示的是一个<code>\\</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> regex</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果想匹配非ASCII字符，例如中文，那就用<code>\\u####</code>的十六进制表示，例如：<code>a\\u548cc</code>匹配字符串<code>&quot;a和c&quot;</code>，中文字符<code>和</code>的Unicode编码是<code>548c</code>。</p>\n<h3 id=\"匹配任意字符\"><a href=\"#匹配任意字符\" class=\"headerlink\" title=\"匹配任意字符\"></a>匹配任意字符</h3><p>精确匹配实际上用处不大，因为我们直接用<code>String.equals()</code>就可以做到。大多数情况下，我们想要的匹配规则更多的是模糊匹配。我们可以用<code>.</code>匹配一个任意字符。</p>\n<p>例如，正则表达式<code>a.c</code>中间的<code>.</code>可以匹配一个任意字符，例如，下面的字符串都可以被匹配：</p>\n<ul>\n<li><code>&quot;abc&quot;</code>，因为<code>.</code>可以匹配字符<code>b</code>；</li>\n<li><code>&quot;a&amp;c&quot;</code>，因为<code>.</code>可以匹配字符<code>&amp;</code>；</li>\n<li><code>&quot;acc&quot;</code>，因为<code>.</code>可以匹配字符<code>c</code>。</li>\n</ul>\n<p>但它不能匹配<code>&quot;ac&quot;</code>、<code>&quot;a&amp;&amp;c&quot;</code>，因为<code>.</code>匹配一个字符且仅限一个字符。</p>\n<h3 id=\"匹配数字\"><a href=\"#匹配数字\" class=\"headerlink\" title=\"匹配数字\"></a>匹配数字</h3><p>用<code>.</code>可以匹配任意字符，这个口子开得有点大。如果我们只想匹配<code>0</code>~&#96;9<code>这样的数字，可以用</code>\\d<code>匹配。例如，正则表达式</code>00\\d&#96;可以匹配：</p>\n<ul>\n<li><code>&quot;007&quot;</code>，因为<code>\\d</code>可以匹配字符<code>7</code>；</li>\n<li><code>&quot;008&quot;</code>，因为<code>\\d</code>可以匹配字符<code>8</code>。</li>\n</ul>\n<p>它不能匹配<code>&quot;00A&quot;</code>，<code>&quot;0077&quot;</code>，因为<code>\\d</code>仅限单个数字字符。</p>\n<h3 id=\"匹配常用字符\"><a href=\"#匹配常用字符\" class=\"headerlink\" title=\"匹配常用字符\"></a>匹配常用字符</h3><p>用<code>\\w</code>可以匹配一个字母、数字或下划线，w的意思是word。例如，<code>java\\w</code>可以匹配：</p>\n<ul>\n<li><code>&quot;javac&quot;</code>，因为<code>\\w</code>可以匹配英文字符<code>c</code>；</li>\n<li><code>&quot;java9&quot;</code>，因为<code>\\w</code>可以匹配数字字符<code>9</code>；。</li>\n<li><code>&quot;java_&quot;</code>，因为<code>\\w</code>可以匹配下划线<code>_</code>。</li>\n</ul>\n<p>它不能匹配<code>&quot;java#&quot;</code>，<code>&quot;java &quot;</code>，因为<code>\\w</code>不能匹配<code>#</code>、空格等字符。</p>\n<h3 id=\"匹配空格字符\"><a href=\"#匹配空格字符\" class=\"headerlink\" title=\"匹配空格字符\"></a>匹配空格字符</h3><p>用<code>\\s</code>可以匹配一个空格字符，注意空格字符不但包括空格&#96;&#96;，还包括tab字符（在Java中用<code>\\t</code>表示）。例如，<code>a\\sc</code>可以匹配：</p>\n<ul>\n<li><code>&quot;a c&quot;</code>，因为<code>\\s</code>可以匹配空格字符&#96;&#96;；</li>\n<li><code>&quot;a c&quot;</code>，因为<code>\\s</code>可以匹配tab字符<code>\\t</code>。</li>\n</ul>\n<p>它不能匹配<code>&quot;ac&quot;</code>，<code>&quot;abc&quot;</code>等。</p>\n<h3 id=\"匹配非数字\"><a href=\"#匹配非数字\" class=\"headerlink\" title=\"匹配非数字\"></a>匹配非数字</h3><p>用<code>\\d</code>可以匹配一个数字，而<code>\\D</code>则匹配一个非数字。例如，<code>00\\D</code>可以匹配：</p>\n<ul>\n<li><code>&quot;00A&quot;</code>，因为<code>\\D</code>可以匹配非数字字符<code>A</code>；</li>\n<li><code>&quot;00#&quot;</code>，因为<code>\\D</code>可以匹配非数字字符<code>#</code>。</li>\n</ul>\n<p><code>00\\d</code>可以匹配的字符串<code>&quot;007&quot;</code>，<code>&quot;008&quot;</code>等，<code>00\\D</code>是不能匹配的。</p>\n<p>类似的，<code>\\W</code>可以匹配<code>\\w</code>不能匹配的字符，<code>\\S</code>可以匹配<code>\\s</code>不能匹配的字符，这几个正好是反着来的。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> regex</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"重复匹配\"><a href=\"#重复匹配\" class=\"headerlink\" title=\"重复匹配\"></a>重复匹配</h3><p>我们用<code>\\d</code>可以匹配一个数字，例如，<code>A\\d</code>可以匹配<code>&quot;A0&quot;</code>，<code>&quot;A1&quot;</code>，如果要匹配多个数字，比如<code>&quot;A380&quot;</code>，怎么办？</p>\n<p>修饰符<code>*</code>可以匹配任意个字符，包括0个字符。我们用<code>A\\d*</code>可以匹配：</p>\n<ul>\n<li><code>A</code>：因为<code>\\d*</code>可以匹配0个数字；</li>\n<li><code>A0</code>：因为<code>\\d*</code>可以匹配1个数字<code>0</code>；</li>\n<li><code>A380</code>：因为<code>\\d*</code>可以匹配多个数字<code>380</code>。</li>\n</ul>\n<p>修饰符<code>+</code>可以匹配至少一个字符。我们用<code>A\\d+</code>可以匹配：</p>\n<ul>\n<li><code>A0</code>：因为<code>\\d+</code>可以匹配1个数字<code>0</code>；</li>\n<li><code>A380</code>：因为<code>\\d+</code>可以匹配多个数字<code>380</code>。</li>\n</ul>\n<p>但它无法匹配<code>&quot;A&quot;</code>，因为修饰符<code>+</code>要求至少一个字符。</p>\n<p>修饰符<code>?</code>可以匹配0个或一个字符。我们用<code>A\\d?</code>可以匹配：</p>\n<ul>\n<li><code>A</code>：因为<code>\\d?</code>可以匹配0个数字；</li>\n<li><code>A0</code>：因为<code>\\d?</code>可以匹配1个数字<code>0</code>。</li>\n</ul>\n<p>但它无法匹配<code>&quot;A33&quot;</code>，因为修饰符<code>?</code>超过1个字符就不能匹配了。</p>\n<p>如果我们想精确指定n个字符怎么办？用修饰符<code>&#123;n&#125;</code>就可以。<code>A\\d&#123;3&#125;</code>可以精确匹配：</p>\n<ul>\n<li><code>A380</code>：因为<code>\\d&#123;3&#125;</code>可以匹配3个数字<code>380</code>。</li>\n</ul>\n<p>如果我们想指定匹配n~m个字符怎么办？用修饰符<code>&#123;n,m&#125;</code>就可以。<code>A\\d&#123;3,5&#125;</code>可以精确匹配：</p>\n<ul>\n<li><code>A380</code>：因为<code>\\d&#123;3,5&#125;</code>可以匹配3个数字<code>380</code>；</li>\n<li><code>A3800</code>：因为<code>\\d&#123;3,5&#125;</code>可以匹配4个数字<code>3800</code>；</li>\n<li><code>A38000</code>：因为<code>\\d&#123;3,5&#125;</code>可以匹配5个数字<code>38000</code>。</li>\n</ul>\n<p>如果没有上限，那么修饰符<code>&#123;n,&#125;</code>就可以匹配至少n个字符。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>请编写一个正则表达式匹配国内的电话号码规则：3<del>4位区号加7</del>8位电话，中间用<code>-</code>连接，例如：<code>010-12345678</code>。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// regex</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> s : List.<span class=\"built_in\">of</span>(<span class=\"string\">&quot;010-12345678&quot;</span>, <span class=\"string\">&quot;020-9999999&quot;</span>, <span class=\"string\">&quot;0755-7654321&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!s.<span class=\"built_in\">matches</span>(re)) &#123;</span><br><span class=\"line\">                System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;测试失败: &quot;</span> + s);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> s : List.<span class=\"built_in\">of</span>(<span class=\"string\">&quot;010 12345678&quot;</span>, <span class=\"string\">&quot;A20-9999999&quot;</span>, <span class=\"string\">&quot;0755-7654.321&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.<span class=\"built_in\">matches</span>(re)) &#123;</span><br><span class=\"line\">                System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;测试失败: &quot;</span> + s);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;测试成功!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/110.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.1252599548343744/20.%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99.1304066080636961/regex-tel.zip?utm_source=blog_lxf\">电话匹配练习</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<p>进阶：国内区号必须以0开头，而电话号码不能以0开头，试修改正则表达式，使之能更精确地匹配。</p>\n<p>提示：<code>\\d</code>和<code>\\D</code>这种简单的规则暂时做不到，我们需要更复杂规则，后面会详细讲解。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>单个字符的匹配规则如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">正则表达式</th>\n<th align=\"left\">规则</th>\n<th align=\"left\">可以匹配</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>A</code></td>\n<td align=\"left\">指定字符</td>\n<td align=\"left\"><code>A</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>\\u548c</code></td>\n<td align=\"left\">指定Unicode字符</td>\n<td align=\"left\"><code>和</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>.</code></td>\n<td align=\"left\">任意字符</td>\n<td align=\"left\"><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>\\d</code></td>\n<td align=\"left\">数字0~9</td>\n<td align=\"left\"><code>0</code>~&#96;9&#96;</td>\n</tr>\n<tr>\n<td align=\"left\"><code>\\w</code></td>\n<td align=\"left\">大小写字母，数字和下划线</td>\n<td align=\"left\"><code>a</code><del><code>z</code>，<code>A</code></del><code>Z</code>，<code>0</code>~&#96;9<code>，</code>_&#96;</td>\n</tr>\n<tr>\n<td align=\"left\"><code>\\s</code></td>\n<td align=\"left\">空格、Tab键</td>\n<td align=\"left\">空格，Tab</td>\n</tr>\n<tr>\n<td align=\"left\"><code>\\D</code></td>\n<td align=\"left\">非数字</td>\n<td align=\"left\"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>\n</tr>\n<tr>\n<td align=\"left\"><code>\\W</code></td>\n<td align=\"left\">非\\w</td>\n<td align=\"left\"><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td>\n</tr>\n<tr>\n<td align=\"left\"><code>\\S</code></td>\n<td align=\"left\">非\\s</td>\n<td align=\"left\"><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td>\n</tr>\n</tbody></table>\n<p>多个字符的匹配规则如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">正则表达式</th>\n<th align=\"left\">规则</th>\n<th align=\"left\">可以匹配</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>A*</code></td>\n<td align=\"left\">任意个数字符</td>\n<td align=\"left\">空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>\n</tr>\n<tr>\n<td align=\"left\"><code>A+</code></td>\n<td align=\"left\">至少1个字符</td>\n<td align=\"left\"><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td>\n</tr>\n<tr>\n<td align=\"left\"><code>A?</code></td>\n<td align=\"left\">0个或1个字符</td>\n<td align=\"left\">空，<code>A</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>A&#123;3&#125;</code></td>\n<td align=\"left\">指定个数字符</td>\n<td align=\"left\"><code>AAA</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>A&#123;2,3&#125;</code></td>\n<td align=\"left\">指定范围个数字符</td>\n<td align=\"left\"><code>AA</code>，<code>AAA</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>A&#123;2,&#125;</code></td>\n<td align=\"left\">至少n个字符</td>\n<td align=\"left\"><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td>\n</tr>\n<tr>\n<td align=\"left\"><code>A&#123;0,3&#125;</code></td>\n<td align=\"left\">最多n个字符</td>\n<td align=\"left\">空，<code>A</code>，<code>AA</code>，<code>AAA</code></td>\n</tr>\n</tbody></table>\n<h1 id=\"复杂匹配规则\"><a href=\"#复杂匹配规则\" class=\"headerlink\" title=\"复杂匹配规则\"></a>复杂匹配规则</h1><h3 id=\"匹配开头和结尾\"><a href=\"#匹配开头和结尾\" class=\"headerlink\" title=\"匹配开头和结尾\"></a>匹配开头和结尾</h3><p>用正则表达式进行多行匹配时，我们用<code>^</code>表示开头，<code>$</code>表示结尾。例如，<code>^A\\d&#123;3&#125;$</code>，可以匹配<code>&quot;A001&quot;</code>、<code>&quot;A380&quot;</code>。</p>\n<h3 id=\"匹配指定范围\"><a href=\"#匹配指定范围\" class=\"headerlink\" title=\"匹配指定范围\"></a>匹配指定范围</h3><p>如果我们规定一个7~8位数字的电话号码不能以<code>0</code>开头，应该怎么写匹配规则呢？<code>\\d&#123;7,8&#125;</code>是不行的，因为第一个<code>\\d</code>可以匹配到<code>0</code>。</p>\n<p>使用<code>[...]</code>可以匹配范围内的字符，例如，<code>[123456789]</code>可以匹配<code>1</code>~&#96;9<code>，这样就可以写出上述电话号码的规则：</code>[123456789]\\d{6,7}&#96;。</p>\n<p>把所有字符全列出来太麻烦，<code>[...]</code>还有一种写法，直接写<code>[1-9]</code>就可以。</p>\n<p>要匹配大小写不限的十六进制数，比如<code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</p>\n<ul>\n<li><code>0-9</code>：字符<code>0</code>~&#96;9&#96;；</li>\n<li><code>a-f</code>：字符<code>a</code>~&#96;f&#96;；</li>\n<li><code>A-F</code>：字符<code>A</code>~&#96;F&#96;。</li>\n</ul>\n<p>如果要匹配6位十六进制数，前面讲过的<code>&#123;n&#125;</code>仍然可以继续配合使用：<code>[0-9a-fA-F]&#123;6&#125;</code>。</p>\n<p><code>[...]</code>还有一种排除法，即不包含指定范围的字符。假设我们要匹配任意字符，但不包括数字，可以写<code>[^1-9]&#123;3&#125;</code>：</p>\n<ul>\n<li>可以匹配<code>&quot;ABC&quot;</code>，因为不包含字符<code>1</code>~&#96;9&#96;；</li>\n<li>可以匹配<code>&quot;A00&quot;</code>，因为不包含字符<code>1</code>~&#96;9&#96;；</li>\n<li>不能匹配<code>&quot;A01&quot;</code>，因为包含字符<code>1</code>；</li>\n<li>不能匹配<code>&quot;A05&quot;</code>，因为包含字符<code>5</code>。</li>\n</ul>\n<h3 id=\"或规则匹配\"><a href=\"#或规则匹配\" class=\"headerlink\" title=\"或规则匹配\"></a>或规则匹配</h3><p>用<code>|</code>连接的两个正则规则是<em>或</em>规则，例如，<code>AB|CD</code>表示可以匹配<code>AB</code>或<code>CD</code>。</p>\n<p>我们来看这个正则表达式<code>java|php</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> regex</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>它可以匹配<code>&quot;java&quot;</code>或<code>&quot;php&quot;</code>，但无法匹配<code>&quot;go&quot;</code>。</p>\n<p>要把<code>go</code>也加进来匹配，可以改写为<code>java|php|go</code>。</p>\n<h3 id=\"使用括号\"><a href=\"#使用括号\" class=\"headerlink\" title=\"使用括号\"></a>使用括号</h3><p>现在我们想要匹配字符串<code>learn java</code>、<code>learn php</code>和<code>learn go</code>怎么办？一个最简单的规则是<code>learn\\sjava|learn\\sphp|learn\\sgo</code>，但是这个规则太复杂了，可以把公共部分提出来，然后用<code>(...)</code>把子规则括起来表示成<code>learn\\\\s(java|php|go)</code>。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> regex</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上面的规则仍然不能匹配<code>learn Java</code>、<code>learn Go</code>这样的字符串。试修改正则，使之能匹配大写字母开头的<code>learn Java</code>、<code>learn Php</code>、<code>learn Go</code>。</p>\n<h3 id=\"小结-1\"><a href=\"#小结-1\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>复杂匹配规则主要有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">正则表达式</th>\n<th align=\"left\">规则</th>\n<th align=\"left\">可以匹配</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">^</td>\n<td align=\"left\">开头</td>\n<td align=\"left\">字符串开头</td>\n</tr>\n<tr>\n<td align=\"left\">$</td>\n<td align=\"left\">结尾</td>\n<td align=\"left\">字符串结束</td>\n</tr>\n<tr>\n<td align=\"left\">[ABC]</td>\n<td align=\"left\">[…]内任意字符</td>\n<td align=\"left\">A，B，C</td>\n</tr>\n<tr>\n<td align=\"left\">[A-F0-9xy]</td>\n<td align=\"left\">指定范围的字符</td>\n<td align=\"left\"><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td>\n</tr>\n<tr>\n<td align=\"left\">[^A-F]</td>\n<td align=\"left\">指定范围外的任意字符</td>\n<td align=\"left\">非<code>A</code>~&#96;F&#96;</td>\n</tr>\n<tr>\n<td align=\"left\">AB|CD|EF</td>\n<td align=\"left\">AB或CD或EF</td>\n<td align=\"left\"><code>AB</code>，<code>CD</code>，<code>EF</code></td>\n</tr>\n</tbody></table>\n<h1 id=\"分组匹配\"><a href=\"#分组匹配\" class=\"headerlink\" title=\"分组匹配\"></a>分组匹配</h1><p>我们前面讲到的<code>(...)</code>可以用来把一个子规则括起来，这样写<code>learn\\s(java|php|go)</code>就可以更方便地匹配长字符串了。</p>\n<p>实际上<code>(...)</code>还有一个重要作用，就是分组匹配。</p>\n<p>我们来看一下如何用正则匹配<code>区号-电话号</code>码这个规则。利用前面讲到的匹配规则，写出来很容易：</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">\\d</span>&#123;3,4&#125;<span class=\"symbol\">\\-</span><span class=\"symbol\">\\d</span>&#123;6,8&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然这个正则匹配规则很简单，但是往往匹配成功后，下一步是提取区号和电话号码，分别存入数据库。于是问题来了：如何提取匹配的子串？</p>\n<p>当然可以用<code>String</code>提供的<code>indexOf()</code>和<code>substring()</code>这些方法，但它们从正则匹配的字符串中提取子串没有通用性，下一次要提取<code>learn\\s(java|php)</code>还得改代码。</p>\n<p>正确的方法是用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\\d&#123;3,4&#125;)\\-(\\d&#123;6,8&#125;)</code>。</p>\n<p>现在问题又来了：匹配后，如何按括号提取子串？</p>\n<p>现在我们没办法用<code>String.matches()</code>这样简单的判断方法了，必须引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，会得到两个匹配上的子串<code>010</code>和<code>12345678</code>。</p>\n<p>要特别注意，<code>Matcher.group(index)</code>方法的参数用1表示第一个子串，2表示第二个子串。如果我们传入0会得到什么呢？答案是<code>010-12345678</code>，即整个正则匹配到的字符串。</p>\n<h3 id=\"Pattern\"><a href=\"#Pattern\" class=\"headerlink\" title=\"Pattern\"></a>Pattern</h3><p>我们在前面的代码中用到的正则表达式代码是<code>String.matches()</code>方法，而我们在分组提取的代码中用的是<code>java.util.regex</code>包里面的<code>Pattern</code>类和<code>Matcher</code>类。实际上这两种代码本质上是一样的，因为<code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p>\n<p>但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>使用<code>Matcher</code>时，必须首先调用<code>matches()</code>判断是否匹配成功，匹配成功后，才能调用<code>group()</code>提取子串。</p>\n<p>利用提取子串的功能，我们轻松获得了区号和号码两部分。</p>\n<h1 id=\"非贪婪匹配\"><a href=\"#非贪婪匹配\" class=\"headerlink\" title=\"非贪婪匹配\"></a>非贪婪匹配</h1><p>在介绍非贪婪匹配前，我们先看一个简单的问题：</p>\n<p>给定一个字符串表示的数字，判断该数字末尾<code>0</code>的个数。例如：</p>\n<ul>\n<li><code>&quot;123000&quot;</code>：3个<code>0</code></li>\n<li><code>&quot;10100&quot;</code>：2个<code>0</code></li>\n<li><code>&quot;1001&quot;</code>：0个<code>0</code></li>\n</ul>\n<p>可以很容易地写出该正则表达式：<code>(\\d+)(0*)</code>，Java代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>然而打印的第二个子串是空字符串<code>&quot;&quot;</code>。</p>\n<p>实际上，我们期望分组匹配结果是：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">input</th>\n<th align=\"left\"><code>\\d+</code></th>\n<th align=\"left\"><code>0*</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">123000</td>\n<td align=\"left\">“123”</td>\n<td align=\"left\">“000”</td>\n</tr>\n<tr>\n<td align=\"left\">10100</td>\n<td align=\"left\">“101”</td>\n<td align=\"left\">“00”</td>\n</tr>\n<tr>\n<td align=\"left\">1001</td>\n<td align=\"left\">“1001”</td>\n<td align=\"left\">“”</td>\n</tr>\n</tbody></table>\n<p>但实际的分组匹配结果是这样的：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">input</th>\n<th align=\"left\"><code>\\d+</code></th>\n<th align=\"left\"><code>0*</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">123000</td>\n<td align=\"left\">“123000”</td>\n<td align=\"left\">“”</td>\n</tr>\n<tr>\n<td align=\"left\">10100</td>\n<td align=\"left\">“10100”</td>\n<td align=\"left\">“”</td>\n</tr>\n<tr>\n<td align=\"left\">1001</td>\n<td align=\"left\">“1001”</td>\n<td align=\"left\">“”</td>\n</tr>\n</tbody></table>\n<p>仔细观察上述实际匹配结果，实际上它是完全合理的，因为<code>\\d+</code>确实可以匹配后面任意个<code>0</code>。</p>\n<p>这是因为正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\\d+</code>总是会把后面的<code>0</code>包含进来。</p>\n<p>要让<code>\\d+</code>尽量少匹配，让<code>0*</code>尽量多匹配，我们就必须让<code>\\d+</code>使用非贪婪匹配。在规则<code>\\d+</code>后面加个<code>?</code>即可表示非贪婪匹配。我们改写正则表达式如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因此，给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</p>\n<p>我们再来看这个正则表达式<code>(\\d??)(9*)</code>，注意<code>\\d?</code>表示匹配0个或1个数字，后面第二个<code>?</code>表示非贪婪匹配，因此，给定字符串<code>&quot;9999&quot;</code>，匹配到的两个子串分别是<code>&quot;&quot;</code>和<code>&quot;9999&quot;</code>，因为对于<code>\\d?</code>来说，可以匹配1个<code>9</code>，也可以匹配0个<code>9</code>，但是因为后面的<code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个<code>9</code>。</p>\n<h1 id=\"搜索和替换\"><a href=\"#搜索和替换\" class=\"headerlink\" title=\"搜索和替换\"></a>搜索和替换</h1><h3 id=\"分割字符串\"><a href=\"#分割字符串\" class=\"headerlink\" title=\"分割字符串\"></a>分割字符串</h3><p>使用正则表达式分割字符串可以实现更加灵活的功能。<code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;a b c&quot;</span>.split(<span class=\"string\">&quot;\\\\s&quot;</span>); <span class=\"regexp\">//</span> &#123; <span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span> &#125;</span><br><span class=\"line\"><span class=\"string\">&quot;a b  c&quot;</span>.split(<span class=\"string\">&quot;\\\\s&quot;</span>); <span class=\"regexp\">//</span> &#123; <span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;c&quot;</span> &#125;</span><br><span class=\"line\"><span class=\"string\">&quot;a, b ;; c&quot;</span>.split(<span class=\"string\">&quot;[\\\\,\\\\;\\\\s]+&quot;</span>); <span class=\"regexp\">//</span> &#123; <span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们想让用户输入一组标签，然后把标签提取出来，因为用户的输入往往是不规范的，这时，使用合适的正则表达式，就可以消除多个空格、混合<code>,</code>和<code>;</code>这些不规范的输入，直接提取出规范的字符串。</p>\n<h3 id=\"搜索字符串\"><a href=\"#搜索字符串\" class=\"headerlink\" title=\"搜索字符串\"></a>搜索字符串</h3><p>使用正则表达式还可以搜索字符串，我们来看例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.regex.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>我们获取到<code>Matcher</code>对象后，不需要调用<code>matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\\\wo\\\\w</code>规则的子串，并打印出来。这种方式比<code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是<code>o</code>，前后两个必须是字符<code>[A-Za-z0-9_]</code>。</p>\n<h3 id=\"替换字符串\"><a href=\"#替换字符串\" class=\"headerlink\" title=\"替换字符串\"></a>替换字符串</h3><p>使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。我们还是来看例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> regex</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上面的代码把不规范的连续空格分隔的句子变成了规范的句子。可见，灵活使用正则表达式可以大大降低代码量。</p>\n<h3 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h3><p>如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个<code>&lt;b&gt;xxxx&lt;/b&gt;</code>，这个时候，使用<code>replaceAll()</code>的时候，我们传入的第二个参数可以使用<code>$1</code>、<code>$2</code>来反向引用匹配到的子串。例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> regex</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码的运行结果是：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">the quick brown fox jumps <span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span>over<span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span> the <span class=\"tag\">&lt;<span class=\"name\">b</span>&gt;</span>lazy<span class=\"tag\">&lt;/<span class=\"name\">b</span>&gt;</span> dog.</span><br></pre></td></tr></table></figure>\n\n<p>它实际上把任何4字符单词的前后用<code>&lt;b&gt;xxxx&lt;/b&gt;</code>括起来。实现替换的关键就在于<code>&quot; &lt;b&gt;$1&lt;/b&gt; &quot;</code>，它用匹配的分组子串<code>([a-z]&#123;4&#125;)</code>替换了<code>$1</code>。</p>\n<h3 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>模板引擎是指，定义一个字符串作为模板：</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello, $&#123;<span class=\"keyword\">name</span>&#125;<span class=\"comment\">! You are learning $&#123;lang&#125;!</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，以<code>$&#123;key&#125;</code>表示的是变量，也就是将要被替换的内容</p>\n<p>当传入一个<code>Map&lt;String, String&gt;</code>给模板后，需要把对应的key替换为Map的value。</p>\n<p>例如，传入<code>Map</code>为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Bob&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;lang&quot;</span>: <span class=\"string\">&quot;Java&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，<code>$&#123;name&#125;</code>被替换为<code>Map</code>对应的值”Bob”，<code>$&#123;lang&#125;</code>被替换为<code>Map</code>对应的值”Java”，最终输出的结果为：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello, Bob! You are learning Java!</span><br></pre></td></tr></table></figure>\n\n<p>请编写一个简单的模板引擎，利用正则表达式实现这个功能。</p>\n<p>提示：参考<a href=\"https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuilder,java.lang.String)\">Matcher.appendReplacement()</a>方法。</p>\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/110.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.1252599548343744/60.%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2.1306046817632290/regex-template.zip?utm_source=blog_lxf\">模板引擎练习</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n","categories":["Java","1.Java快速入门","11.正则表达式"],"tags":["写作"]},{"title":"12.加密与安全","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_12.%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>在计算机系统中，什么是加密与安全呢？</p>\n<p>我们举个栗子：假设Bob要给Alice发一封邮件，在邮件传送的过程中，黑客可能会窃取到邮件的内容，所以需要防窃听。黑客还可能会篡改邮件的内容，Alice必须有能力识别出邮件有没有被篡改。最后，黑客可能假冒Bob给Alice发邮件，Alice必须有能力识别出伪造的邮件。</p>\n<p>所以，应对潜在的安全威胁，需要做到三防：</p>\n<ul>\n<li>防窃听</li>\n<li>防篡改</li>\n<li>防伪造</li>\n</ul>\n<p><img src=\"/12.%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8.assets/l.png\" alt=\"java-security\"></p>\n<p>计算机加密技术就是为了实现上述目标，而现代计算机密码学理论是建立在严格的数学理论基础上的，密码学已经逐渐发展成一门科学。对于绝大多数开发者来说，设计一个安全的加密算法非常困难，验证一个加密算法是否安全更加困难，当前被认为安全的加密算法仅仅是迄今为止尚未被攻破。因此，要编写安全的计算机程序，我们要做到：</p>\n<ul>\n<li>不要自己设计山寨的加密算法；</li>\n<li>不要自己实现已有的加密算法；</li>\n<li>不要自己修改已有的加密算法。</li>\n</ul>\n<p>本章我们会介绍最常用的加密算法，以及如何通过Java代码实现。</p>\n<h1 id=\"编码算法\"><a href=\"#编码算法\" class=\"headerlink\" title=\"编码算法\"></a>编码算法</h1><p>要学习编码算法，我们先来看一看什么是编码。</p>\n<p>ASCII码就是一种编码，字母<code>A</code>的编码是十六进制的<code>0x41</code>，字母<code>B</code>是<code>0x42</code>，以此类推：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字母</th>\n<th align=\"left\">ASCII编码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">A</td>\n<td align=\"left\">0x41</td>\n</tr>\n<tr>\n<td align=\"left\">B</td>\n<td align=\"left\">0x42</td>\n</tr>\n<tr>\n<td align=\"left\">C</td>\n<td align=\"left\">0x43</td>\n</tr>\n<tr>\n<td align=\"left\">D</td>\n<td align=\"left\">0x44</td>\n</tr>\n<tr>\n<td align=\"left\">…</td>\n<td align=\"left\">…</td>\n</tr>\n</tbody></table>\n<p>因为ASCII编码最多只能有127个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是<code>0x4e2d</code>，使用UTF-8则需要3个字节编码：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">汉字</th>\n<th align=\"left\">Unicode编码</th>\n<th align=\"left\">UTF-8编码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">中</td>\n<td align=\"left\">0x4e2d</td>\n<td align=\"left\">0xe4b8ad</td>\n</tr>\n<tr>\n<td align=\"left\">文</td>\n<td align=\"left\">0x6587</td>\n<td align=\"left\">0xe69687</td>\n</tr>\n<tr>\n<td align=\"left\">编</td>\n<td align=\"left\">0x7f16</td>\n<td align=\"left\">0xe7bc96</td>\n</tr>\n<tr>\n<td align=\"left\">码</td>\n<td align=\"left\">0x7801</td>\n<td align=\"left\">0xe7a081</td>\n</tr>\n<tr>\n<td align=\"left\">…</td>\n<td align=\"left\">…</td>\n<td align=\"left\">…</td>\n</tr>\n</tbody></table>\n<p>因此，最简单的编码是直接给每个字符指定一个若干字节表示的整数，复杂一点的编码就需要根据一个已有的编码推算出来。</p>\n<p>比如UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。</p>\n<h3 id=\"URL编码\"><a href=\"#URL编码\" class=\"headerlink\" title=\"URL编码\"></a>URL编码</h3><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，例如：</p>\n<p><a href=\"https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87\">https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87</a></p>\n<p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p>\n<ul>\n<li>如果字符是<code>A</code><del><code>Z</code>，<code>a</code></del><code>z</code>，<code>0</code>~&#96;9<code>以及</code>-<code>、</code>_<code>、</code>.<code>、</code>*&#96;，则保持不变；</li>\n<li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</li>\n</ul>\n<p>例如：字符<code>中</code>的UTF-8编码是<code>0xe4b8ad</code>，因此，它的URL编码是<code>%E4%B8%AD</code>。URL编码总是大写。</p>\n<p>Java标准库提供了一个<code>URLEncoder</code>类来对任意字符串进行URL编码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLEncoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码的运行结果是<code>%E4%B8%AD%E6%96%87%21</code>，<code>中</code>的URL编码是<code>%E4%B8%AD</code>，<code>文</code>的URL编码是<code>%E6%96%87</code>，<code>!</code>虽然是ASCII字符，也要对其编码为<code>%21</code>。</p>\n<p>和标准的URL编码稍有不同，URLEncoder把空格字符编码成<code>+</code>，而现在的URL编码标准要求空格被编码为<code>%20</code>，不过，服务器都可以处理这两种情况。</p>\n<p>如果服务器收到URL编码的字符串，就可以对其进行解码，还原成原始字符串。Java标准库的<code>URLDecoder</code>就可以解码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.net.URLDecoder;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>要特别注意：URL编码是编码算法，不是加密算法。URL编码的目的是把任意文本数据编码为<code>%</code>前缀表示的文本，编码后的文本仅包含<code>A</code><del><code>Z</code>，<code>a</code></del><code>z</code>，<code>0</code>~&#96;9<code>，</code>-<code>，</code>_<code>，</code>.<code>，</code>*<code>和</code>%&#96;，便于浏览器和服务器处理。</p>\n<h3 id=\"Base64编码\"><a href=\"#Base64编码\" class=\"headerlink\" title=\"Base64编码\"></a>Base64编码</h3><p>URL编码是对字符进行编码，表示成<code>%xx</code>的形式，而Base64编码是对二进制数据进行编码，表示成文本格式。</p>\n<p>Base64编码可以把任意长度的二进制数据变为纯文本，且只包含<code>A</code><del><code>Z</code>、<code>a</code></del><code>z</code>、<code>0</code>~&#96;9<code>、</code>+<code>、</code>&#x2F;<code>、</code>&#x3D;&#96;这些字符。它的原理是把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p>\n<p>举个例子：3个byte数据分别是<code>e4</code>、<code>b8</code>、<code>ad</code>，按6bit分组得到<code>39</code>、<code>0b</code>、<code>22</code>和<code>2d</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────────┬───────────────┬───────────────┐</span><br><span class=\"line\">│      e4       │      b8       │      ad       │</span><br><span class=\"line\">└───────────────┴───────────────┴───────────────┘</span><br><span class=\"line\">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class=\"line\">│1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│</span><br><span class=\"line\">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class=\"line\">┌───────────┬───────────┬───────────┬───────────┐</span><br><span class=\"line\">│    39     │    0b     │    22     │    2d     │</span><br><span class=\"line\">└───────────┴───────────┴───────────┴───────────┘</span><br></pre></td></tr></table></figure>\n\n<p>因为6位整数的范围总是<code>0</code><del><code>63</code>，所以，能用64个字符表示：字符<code>A</code></del><code>Z</code>对应索引<code>0</code><del><code>25</code>，字符<code>a</code></del><code>z</code>对应索引<code>26</code><del><code>51</code>，字符<code>0</code></del><code>9</code>对应索引<code>52</code>~&#96;61<code>，最后两个索引</code>62<code>、</code>63<code>分别用字符</code>+<code>和</code>&#x2F;&#96;表示。</p>\n<p>在Java中，二进制数据就是<code>byte[]</code>数组。Java标准库提供了<code>Base64</code>来对<code>byte[]</code>数组进行编解码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>编码后得到<code>5Lit</code>4个字符。要对<code>Base64</code>解码，仍然用<code>Base64</code>这个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>有的童鞋会问：如果输入的<code>byte[]</code>数组长度不是3的整数倍肿么办？这种情况下，需要对输入的末尾补一个或两个<code>0x00</code>，编码后，在结尾加一个<code>=</code>表示补充了1个<code>0x00</code>，加两个<code>=</code>表示补充了2个<code>0x00</code>，解码的时候，去掉末尾补充的一个或两个<code>0x00</code>即可。</p>\n<p>实际上，因为编码后的长度加上<code>=</code>总是4的倍数，所以即使不加<code>=</code>也可以计算出原始输入的<code>byte[]</code>。Base64编码的时候可以用<code>withoutPadding()</code>去掉<code>=</code>，解码出来的结果是一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为标准的Base64编码会出现<code>+</code>、<code>/</code>和<code>=</code>，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把<code>+</code>变成<code>-</code>，<code>/</code>变成<code>_</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>Base64编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据。例如，电子邮件协议就是文本协议，如果要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</p>\n<p>Base64编码的缺点是传输效率会降低，因为它把原始数据的长度增加了1&#x2F;3。</p>\n<p>和URL编码一样，Base64编码是一种编码算法，不是加密算法。</p>\n<p>如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。</p>\n<h1 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h1><p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</p>\n<p>哈希算法最重要的特点就是：</p>\n<ul>\n<li>相同的输入一定得到相同的输出；</li>\n<li>不同的输入大概率得到不同的输出。</li>\n</ul>\n<p>哈希算法的目的就是为了验证原始数据是否被篡改。</p>\n<p>Java字符串的<code>hashCode()</code>就是一个哈希算法，它的输入是任意字符串，输出是固定的4字节<code>int</code>整数：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;hello&quot;</span>.hashCode(); <span class=\"regexp\">//</span> <span class=\"number\">0</span>x5e918d2</span><br><span class=\"line\"><span class=\"string\">&quot;hello, java&quot;</span>.hashCode(); <span class=\"regexp\">//</span> <span class=\"number\">0</span>x7a9d88e8</span><br><span class=\"line\"><span class=\"string\">&quot;hello, bob&quot;</span>.hashCode(); <span class=\"regexp\">//</span> <span class=\"number\">0</span>xa0dbae2f</span><br></pre></td></tr></table></figure>\n\n<p>两个相同的字符串永远会计算出相同的<code>hashCode</code>，否则基于<code>hashCode</code>定位的<code>HashMap</code>就无法正常工作。这也是为什么当我们自定义一个class时，覆写<code>equals()</code>方法时我们必须正确覆写<code>hashCode()</code>方法。</p>\n<h3 id=\"哈希碰撞\"><a href=\"#哈希碰撞\" class=\"headerlink\" title=\"哈希碰撞\"></a>哈希碰撞</h3><p>哈希碰撞是指，两个不同的输入得到了相同的输出：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;AaAaAa&quot;</span>.hashCode(); <span class=\"regexp\">//</span> <span class=\"number\">0</span>x7460e8c0</span><br><span class=\"line\"><span class=\"string\">&quot;BBAaBB&quot;</span>.hashCode(); <span class=\"regexp\">//</span> <span class=\"number\">0</span>x7460e8c0</span><br></pre></td></tr></table></figure>\n\n<p>有童鞋会问：碰撞能不能避免？答案是不能。碰撞是一定会出现的，因为输出的字节长度是固定的，<code>String</code>的<code>hashCode()</code>输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</p>\n<p>碰撞不可怕，我们担心的不是碰撞，而是碰撞的概率，因为碰撞概率的高低关系到哈希算法的安全性。一个安全的哈希算法必须满足：</p>\n<ul>\n<li>碰撞概率低；</li>\n<li>不能猜测输出。</li>\n</ul>\n<p>不能猜测输出是指，输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。假设一种哈希算法有如下规律：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">hashA</span><span class=\"params\">(<span class=\"string\">&quot;java001&quot;</span>)</span></span> = <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">hashA</span><span class=\"params\">(<span class=\"string\">&quot;java002&quot;</span>)</span></span> = <span class=\"string\">&quot;123457&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">hashA</span><span class=\"params\">(<span class=\"string\">&quot;java003&quot;</span>)</span></span> = <span class=\"string\">&quot;123458&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>那么很容易从输出<code>123459</code>反推输入，这种哈希算法就不安全。安全的哈希算法从输出是看不出任何规律的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">hash<span class=\"constructor\">B(<span class=\"string\">&quot;java001&quot;</span>)</span> = <span class=\"string\">&quot;123456&quot;</span></span><br><span class=\"line\">hash<span class=\"constructor\">B(<span class=\"string\">&quot;java002&quot;</span>)</span> = <span class=\"string\">&quot;580271&quot;</span></span><br><span class=\"line\">hash<span class=\"constructor\">B(<span class=\"string\">&quot;java003&quot;</span>)</span> = ???</span><br></pre></td></tr></table></figure>\n\n<p>常用的哈希算法有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">算法</th>\n<th align=\"left\">输出长度（位）</th>\n<th align=\"left\">输出长度（字节）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">MD5</td>\n<td align=\"left\">128 bits</td>\n<td align=\"left\">16 bytes</td>\n</tr>\n<tr>\n<td align=\"left\">SHA-1</td>\n<td align=\"left\">160 bits</td>\n<td align=\"left\">20 bytes</td>\n</tr>\n<tr>\n<td align=\"left\">RipeMD-160</td>\n<td align=\"left\">160 bits</td>\n<td align=\"left\">20 bytes</td>\n</tr>\n<tr>\n<td align=\"left\">SHA-256</td>\n<td align=\"left\">256 bits</td>\n<td align=\"left\">32 bytes</td>\n</tr>\n<tr>\n<td align=\"left\">SHA-512</td>\n<td align=\"left\">512 bits</td>\n<td align=\"left\">64 bytes</td>\n</tr>\n</tbody></table>\n<p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p>\n<p>Java标准库提供了常用的哈希算法，并且有一套统一的接口。我们以MD5算法为例，看看如何对输入计算哈希：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.MessageDigest;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>使用<code>MessageDigest</code>时，我们首先根据哈希算法获取一个<code>MessageDigest</code>实例，然后，反复调用<code>update(byte[])</code>输入数据。当输入结束后，调用<code>digest()</code>方法获得byte[]数组表示的摘要，最后，把它转换为十六进制的字符串。</p>\n<p>运行上述代码，可以得到输入<code>HelloWorld</code>的MD5是<code>68e109f0f40ca72a15e05cc22786f8e6</code>。</p>\n<h3 id=\"哈希算法的用途\"><a href=\"#哈希算法的用途\" class=\"headerlink\" title=\"哈希算法的用途\"></a>哈希算法的用途</h3><p>因为相同的输入永远会得到相同的输出，因此，如果输入被修改了，得到的输出就会不同。</p>\n<p>我们在网站上下载软件的时候，经常看到下载页显示的哈希：</p>\n<p><img src=\"/12.%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8.assets/l-164189427878124.jpeg\" alt=\"file-md5\"></p>\n<p>如何判断下载到本地的软件是原始的、未经篡改的文件？我们只需要自己计算一下本地文件的哈希值，再与官网公开的哈希值对比，如果相同，说明文件下载正确，否则，说明文件已被篡改。</p>\n<p>哈希算法的另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险：</p>\n<ul>\n<li>数据库管理员能够看到用户明文口令；</li>\n<li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li>\n</ul>\n<p>不存储用户的原始口令，那么如何对用户进行认证？</p>\n<p>方法是存储用户口令的哈希，例如，MD5。</p>\n<p>在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p>\n<p>因此，数据库存储用户名和口令的表内容应该像下面这样：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">username</th>\n<th align=\"left\">password</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">bob</td>\n<td align=\"left\">f30aa7a662c728b7407c54ae6bfd27d1</td>\n</tr>\n<tr>\n<td align=\"left\">alice</td>\n<td align=\"left\">25d55ad283aa400af464c76d713c07ad</td>\n</tr>\n<tr>\n<td align=\"left\">tim</td>\n<td align=\"left\">bed128365216c019988915ed3add75fb</td>\n</tr>\n</tbody></table>\n<p>这样一来，数据库管理员看不到用户的原始口令。即使数据库泄漏，黑客也无法拿到用户的原始口令。想要拿到用户的原始口令，必须用暴力穷举的方法，一个口令一个口令地试，直到某个口令计算的MD5恰好等于指定值。</p>\n<p>使用哈希口令时，还要注意防止彩虹表攻击。</p>\n<p>什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法。</p>\n<p>然而黑客并不笨，暴力穷举会消耗大量的算力和时间。但是，如果有一个预先计算好的常用口令和它们的MD5的对照表：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">常用口令</th>\n<th align=\"left\">MD5</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">hello123</td>\n<td align=\"left\">f30aa7a662c728b7407c54ae6bfd27d1</td>\n</tr>\n<tr>\n<td align=\"left\">12345678</td>\n<td align=\"left\">25d55ad283aa400af464c76d713c07ad</td>\n</tr>\n<tr>\n<td align=\"left\">passw0rd</td>\n<td align=\"left\">bed128365216c019988915ed3add75fb</td>\n</tr>\n<tr>\n<td align=\"left\">19700101</td>\n<td align=\"left\">570da6d5277a646f6552b8832012f5dc</td>\n</tr>\n<tr>\n<td align=\"left\">…</td>\n<td align=\"left\">…</td>\n</tr>\n<tr>\n<td align=\"left\">20201231</td>\n<td align=\"left\">6879c0ae9117b50074ce0a0d4c843060</td>\n</tr>\n</tbody></table>\n<p>这个表就是彩虹表。如果用户使用了常用口令，黑客从MD5一下就能反查到原始口令：</p>\n<p>bob的MD5：<code>f30aa7a662c728b7407c54ae6bfd27d1</code>，原始口令：<code>hello123</code>；</p>\n<p>alice的MD5：<code>25d55ad283aa400af464c76d713c07ad</code>，原始口令：<code>12345678</code>；</p>\n<p>tim的MD5：<code>bed128365216c019988915ed3add75fb</code>，原始口令：<code>passw0rd</code>。</p>\n<p>这就是为什么不要使用常用密码，以及不要使用生日作为密码的原因。</p>\n<p>即使用户使用了常用口令，我们也可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">digest</span> = md5(salt+inputPassword)</span><br></pre></td></tr></table></figure>\n\n<p>经过加盐处理的数据库表，内容如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">username</th>\n<th align=\"left\">salt</th>\n<th align=\"left\">password</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">bob</td>\n<td align=\"left\">H1r0a</td>\n<td align=\"left\">a5022319ff4c56955e22a74abcc2c210</td>\n</tr>\n<tr>\n<td align=\"left\">alice</td>\n<td align=\"left\">7$p2w</td>\n<td align=\"left\">e5de688c99e961ed6e560b972dab8b6a</td>\n</tr>\n<tr>\n<td align=\"left\">tim</td>\n<td align=\"left\">z5Sk9</td>\n<td align=\"left\">1eee304b92dc0d105904e7ab58fd2f64</td>\n</tr>\n</tbody></table>\n<p>加盐的目的在于使黑客的彩虹表失效，即使用户使用常用口令，也无法从MD5反推原始口令。</p>\n<h3 id=\"SHA-1\"><a href=\"#SHA-1\" class=\"headerlink\" title=\"SHA-1\"></a>SHA-1</h3><p>SHA-1也是一种哈希算法，它的输出是160 bits，即20字节。SHA-1是由美国国家安全局开发的，SHA算法实际上是一个系列，包括SHA-0（已废弃）、SHA-1、SHA-256、SHA-512等。</p>\n<p>在Java中使用SHA-1，和MD5完全一样，只需要把算法名称改为<code>&quot;SHA-1&quot;</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.MessageDigest;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>类似的，计算SHA-256，我们需要传入名称<code>&quot;SHA-256&quot;</code>，计算SHA-512，我们需要传入名称<code>&quot;SHA-512&quot;</code>。Java标准库支持的所有哈希算法可以在<a href=\"https://docs.oracle.com/en/java/javase/14/docs/specs/security/standard-names.html#messagedigest-algorithms\">这里</a>查到。</p>\n<p> 注意：MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。</p>\n<h1 id=\"BouncyCastle\"><a href=\"#BouncyCastle\" class=\"headerlink\" title=\"BouncyCastle\"></a>BouncyCastle</h1><p>我们知道，Java标准库提供了一系列常用的哈希算法。</p>\n<p>但如果我们要用的某种算法，Java标准库没有提供怎么办？</p>\n<p>方法一：自己写一个，难度很大；</p>\n<p>方法二：找一个现成的第三方库，直接使用。</p>\n<p><a href=\"https://www.bouncycastle.org/\">BouncyCastle</a>就是一个提供了很多哈希算法和加密算法的第三方库。它提供了Java标准库没有的一些算法，例如，RipeMD160哈希算法。</p>\n<p>我们来看一下如何使用BouncyCastle这个第三方提供的算法。</p>\n<p>首先，我们必须把BouncyCastle提供的jar包放到classpath中。这个jar包就是<code>bcprov-jdk15on-xxx.jar</code>，可以从<a href=\"https://www.bouncycastle.org/latest_releases.html\">官方网站</a>下载。</p>\n<p>Java标准库的<code>java.security</code>包提供了一种标准机制，允许第三方提供商无缝接入。我们要使用BouncyCastle提供的RipeMD160算法，需要先把BouncyCastle注册一下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    public static void main(String<span class=\"literal\">[]</span> args) throws Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注册BouncyCastle:</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Security</span>.</span></span>add<span class=\"constructor\">Provider(<span class=\"params\">new</span> BouncyCastleProvider()</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 按名称正常调用:</span></span><br><span class=\"line\">        MessageDigest md = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">MessageDigest</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;RipeMD160&quot;</span>)</span>;</span><br><span class=\"line\">        md.update(<span class=\"string\">&quot;HelloWorld&quot;</span>.get<span class=\"constructor\">Bytes(<span class=\"string\">&quot;UTF-8&quot;</span>)</span>);</span><br><span class=\"line\">        byte<span class=\"literal\">[]</span> result = md.digest<span class=\"literal\">()</span>;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"keyword\">new</span> <span class=\"constructor\">BigInteger(1, <span class=\"params\">result</span>)</span>.<span class=\"keyword\">to</span><span class=\"constructor\">String(16)</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，注册BouncyCastle是通过下面的语句实现的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Security</span>.</span></span>add<span class=\"constructor\">Provider(<span class=\"params\">new</span> BouncyCastleProvider()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</p>\n<h1 id=\"Hmac算法\"><a href=\"#Hmac算法\" class=\"headerlink\" title=\"Hmac算法\"></a>Hmac算法</h1><p>在前面讲到哈希算法时，我们说，存储用户的哈希口令时，要加盐存储，目的就在于抵御彩虹表攻击。</p>\n<p>我们回顾一下哈希算法：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">digest</span> = hash(input)</span><br></pre></td></tr></table></figure>\n\n<p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">digest</span> = hash(salt + input)</span><br></pre></td></tr></table></figure>\n\n<p>这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”。</p>\n<p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p>\n<p>Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">HmacMD5 ≈ md5(secure_random_key, <span class=\"keyword\">input</span>)</span><br></pre></td></tr></table></figure>\n\n<p>因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：</p>\n<ul>\n<li>HmacMD5使用的key长度是64字节，更安全；</li>\n<li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li>\n<li>Hmac输出和原有的哈希算法长度一致。</li>\n</ul>\n<p>可见，Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。</p>\n<p>为了保证安全，我们不会自己指定key，而是通过Java标准库的KeyGenerator生成一个安全的随机的key。下面是使用HmacMD5的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.crypto.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>和MD5相比，使用HmacMD5的步骤是：</p>\n<ol>\n<li>通过名称<code>HmacMD5</code>获取<code>KeyGenerator</code>实例；</li>\n<li>通过<code>KeyGenerator</code>创建一个<code>SecretKey</code>实例；</li>\n<li>通过名称<code>HmacMD5</code>获取<code>Mac</code>实例；</li>\n<li>用<code>SecretKey</code>初始化<code>Mac</code>实例；</li>\n<li>对<code>Mac</code>实例反复调用<code>update(byte[])</code>输入数据；</li>\n<li>调用<code>Mac</code>实例的<code>doFinal()</code>获取最终的哈希值。</li>\n</ol>\n<p>我们可以用Hmac算法取代原有的自定义的加盐算法，因此，存储用户名和口令的数据库结构如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">username</th>\n<th align=\"left\">secret_key (64 bytes)</th>\n<th align=\"left\">password</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">bob</td>\n<td align=\"left\">a8c06e05f92e…5e16</td>\n<td align=\"left\">7e0387872a57c85ef6dddbaa12f376de</td>\n</tr>\n<tr>\n<td align=\"left\">alice</td>\n<td align=\"left\">e6a343693985…f4be</td>\n<td align=\"left\">c1f929ac2552642b302e739bc0cdbaac</td>\n</tr>\n<tr>\n<td align=\"left\">tim</td>\n<td align=\"left\">f27a973dfdc0…6003</td>\n<td align=\"left\">af57651c3a8a73303515804d4af43790</td>\n</tr>\n</tbody></table>\n<p>有了Hmac计算的哈希和<code>SecretKey</code>，我们想要验证怎么办？这时，<code>SecretKey</code>不能从<code>KeyGenerator</code>生成，而是从一个<code>byte[]</code>数组恢复：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.crypto.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.crypto.spec.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>恢复<code>SecretKey</code>的语句就是<code>new SecretKeySpec(hkey, &quot;HmacMD5&quot;)</code>。</p>\n<h1 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h1><p>对称加密算法就是传统的用一个密码进行加密和解密。例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法：</p>\n<p><img src=\"/12.%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8.assets/l-164189430796826.jpeg\" alt=\"winrar\"></p>\n<p>从程序的角度看，所谓加密，就是这样一个函数，它接收密码和明文，然后输出密文：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">secret</span> = encrypt(key, message)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>而解密则相反，它接收密码和密文，然后输出明文：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">plain</span> = decrypt(key, secret)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>在软件开发中，常用的对称加密算法有：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">算法</th>\n<th align=\"left\">密钥长度</th>\n<th align=\"left\">工作模式</th>\n<th align=\"left\">填充模式</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DES</td>\n<td align=\"left\">56&#x2F;64</td>\n<td align=\"left\">ECB&#x2F;CBC&#x2F;PCBC&#x2F;CTR&#x2F;…</td>\n<td align=\"left\">NoPadding&#x2F;PKCS5Padding&#x2F;…</td>\n</tr>\n<tr>\n<td align=\"left\">AES</td>\n<td align=\"left\">128&#x2F;192&#x2F;256</td>\n<td align=\"left\">ECB&#x2F;CBC&#x2F;PCBC&#x2F;CTR&#x2F;…</td>\n<td align=\"left\">NoPadding&#x2F;PKCS5Padding&#x2F;PKCS7Padding&#x2F;…</td>\n</tr>\n<tr>\n<td align=\"left\">IDEA</td>\n<td align=\"left\">128</td>\n<td align=\"left\">ECB</td>\n<td align=\"left\">PKCS5Padding&#x2F;PKCS7Padding&#x2F;…</td>\n</tr>\n</tbody></table>\n<p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。Java标准库提供的算法实现并不包括所有的工作模式和所有填充模式，但是通常我们只需要挑选常用的使用就可以了。</p>\n<p>最后注意，DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p>\n<h3 id=\"使用AES加密\"><a href=\"#使用AES加密\" class=\"headerlink\" title=\"使用AES加密\"></a>使用AES加密</h3><p>AES算法是目前应用最广泛的加密算法。我们先用ECB模式加密并解密：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>Java标准库提供的对称加密接口非常简单，使用时按以下步骤编写代码：</p>\n<ol>\n<li>根据算法名称&#x2F;工作模式&#x2F;填充模式获取Cipher实例；</li>\n<li>根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；</li>\n<li>使用SerectKey初始化Cipher实例，并设置加密或解密模式；</li>\n<li>传入明文或密文，获得密文或明文。</li>\n</ol>\n<p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.security.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Base64;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.crypto.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.crypto.spec.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>在CBC模式下，需要一个随机生成的16字节IV参数，必须使用<code>SecureRandom</code>生成。因为多了一个<code>IvParameterSpec</code>实例，因此，初始化方法需要调用<code>Cipher</code>的一个重载方法并传入<code>IvParameterSpec</code>。</p>\n<p>观察输出，可以发现每次生成的IV不同，密文也不同。</p>\n<h1 id=\"口令加密算法\"><a href=\"#口令加密算法\" class=\"headerlink\" title=\"口令加密算法\"></a>口令加密算法</h1><p>上一节我们讲的AES加密，细心的童鞋可能会发现，密钥长度是固定的128&#x2F;192&#x2F;256位，而不是我们用WinZip&#x2F;WinRAR那样，随便输入几位都可以。</p>\n<p>这是因为对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。</p>\n<p>但是我们平时使用的加密软件，输入6位、8位都可以，难道加密方式不一样？</p>\n<p>实际上用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128&#x2F;192&#x2F;256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。</p>\n<p>PBE就是Password Based Encryption的缩写，它的作用如下：</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\">key = <span class=\"keyword\">generate</span>(userPassword, secureRandomPassword);</span><br></pre></td></tr></table></figure>\n\n<p>PBE的作用就是把用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。以AES密钥为例，我们让用户输入一个口令，然后生成一个随机数，通过PBE算法计算出真正的AES口令，再进行加密，代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    public static void main(String<span class=\"literal\">[]</span> args) throws Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把BouncyCastle作为Provider添加到java.security:</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Security</span>.</span></span>add<span class=\"constructor\">Provider(<span class=\"params\">new</span> BouncyCastleProvider()</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 原文:</span></span><br><span class=\"line\">        String message = <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 加密口令:</span></span><br><span class=\"line\">        String password = <span class=\"string\">&quot;hello12345&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 16 bytes随机Salt:</span></span><br><span class=\"line\">        byte<span class=\"literal\">[]</span> salt = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">SecureRandom</span>.</span></span>get<span class=\"constructor\">InstanceStrong()</span>.generate<span class=\"constructor\">Seed(16)</span>;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.printf(<span class=\"string\">&quot;salt: %032x\\n&quot;</span>, <span class=\"keyword\">new</span> <span class=\"constructor\">BigInteger(1, <span class=\"params\">salt</span>)</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 加密:</span></span><br><span class=\"line\">        byte<span class=\"literal\">[]</span> data = message.get<span class=\"constructor\">Bytes(<span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\">        byte<span class=\"literal\">[]</span> encrypted = encrypt(password, salt, data);</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;encrypted: &quot;</span> + <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Base64</span>.</span></span>get<span class=\"constructor\">Encoder()</span>.encode<span class=\"constructor\">ToString(<span class=\"params\">encrypted</span>)</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 解密:</span></span><br><span class=\"line\">        byte<span class=\"literal\">[]</span> decrypted = decrypt(password, salt, encrypted);</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;decrypted: &quot;</span> + <span class=\"keyword\">new</span> <span class=\"constructor\">String(<span class=\"params\">decrypted</span>, <span class=\"string\">&quot;UTF-8&quot;</span>)</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 加密:</span></span><br><span class=\"line\">    public static byte<span class=\"literal\">[]</span> encrypt(String password, byte<span class=\"literal\">[]</span> salt, byte<span class=\"literal\">[]</span> input) throws GeneralSecurityException &#123;</span><br><span class=\"line\">        PBEKeySpec keySpec = <span class=\"keyword\">new</span> <span class=\"constructor\">PBEKeySpec(<span class=\"params\">password</span>.<span class=\"params\">toCharArray</span>()</span>);</span><br><span class=\"line\">        SecretKeyFactory skeyFactory = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">SecretKeyFactory</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>)</span>;</span><br><span class=\"line\">        SecretKey skey = skeyFactory.generate<span class=\"constructor\">Secret(<span class=\"params\">keySpec</span>)</span>;</span><br><span class=\"line\">        PBEParameterSpec pbeps = <span class=\"keyword\">new</span> <span class=\"constructor\">PBEParameterSpec(<span class=\"params\">salt</span>, 1000)</span>;</span><br><span class=\"line\">        Cipher cipher = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Cipher</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>)</span>;</span><br><span class=\"line\">        cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);</span><br><span class=\"line\">        return cipher.<span class=\"keyword\">do</span><span class=\"constructor\">Final(<span class=\"params\">input</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 解密:</span></span><br><span class=\"line\">    public static byte<span class=\"literal\">[]</span> decrypt(String password, byte<span class=\"literal\">[]</span> salt, byte<span class=\"literal\">[]</span> input) throws GeneralSecurityException &#123;</span><br><span class=\"line\">        PBEKeySpec keySpec = <span class=\"keyword\">new</span> <span class=\"constructor\">PBEKeySpec(<span class=\"params\">password</span>.<span class=\"params\">toCharArray</span>()</span>);</span><br><span class=\"line\">        SecretKeyFactory skeyFactory = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">SecretKeyFactory</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>)</span>;</span><br><span class=\"line\">        SecretKey skey = skeyFactory.generate<span class=\"constructor\">Secret(<span class=\"params\">keySpec</span>)</span>;</span><br><span class=\"line\">        PBEParameterSpec pbeps = <span class=\"keyword\">new</span> <span class=\"constructor\">PBEParameterSpec(<span class=\"params\">salt</span>, 1000)</span>;</span><br><span class=\"line\">        Cipher cipher = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Cipher</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;</span>)</span>;</span><br><span class=\"line\">        cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);</span><br><span class=\"line\">        return cipher.<span class=\"keyword\">do</span><span class=\"constructor\">Final(<span class=\"params\">input</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用PBE时，我们还需要引入BouncyCastle，并指定算法是<code>PBEwithSHA1and128bitAES-CBC-BC</code>。观察代码，实际上真正的AES密钥是调用<code>Cipher</code>的<code>init()</code>方法时同时传入<code>SecretKey</code>和<code>PBEParameterSpec</code>实现的。在创建<code>PBEParameterSpec</code>的时候，我们还指定了循环次数<code>1000</code>，循环次数越多，暴力破解需要的计算量就越大。</p>\n<p>如果我们把salt和循环次数固定，就得到了一个通用的“口令”加密软件。如果我们把随机生成的salt存储在U盘，就得到了一个“口令”加USB Key的加密软件，它的好处在于，即使用户使用了一个非常弱的口令，没有USB Key仍然无法解密，因为USB Key存储的随机数密钥安全性非常高。</p>\n<h1 id=\"密钥加密算法\"><a href=\"#密钥加密算法\" class=\"headerlink\" title=\"密钥加密算法\"></a>密钥加密算法</h1><p>对称加密算法解决了数据加密的问题。我们以AES加密为例，在现实世界中，小明要向路人甲发送一个加密文件，他可以先生成一个AES密钥，对文件进行加密，然后把加密文件发送给对方。因为对方要解密，就必须需要小明生成的密钥。</p>\n<p>现在问题来了：如何传递密钥？</p>\n<p>在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？</p>\n<p>要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。</p>\n<p>DH算法解决了密钥在双方不直接传递密钥的情况下完成密钥交换，这个神奇的交换原理完全由数学理论支持。</p>\n<p>我们来看DH算法交换密钥的步骤。假设甲乙双方需要传递密钥，他们之间可以这么做：</p>\n<ol>\n<li>甲首选选择一个素数<code>p</code>，例如509，底数<code>g</code>，任选，例如5，随机数<code>a</code>，例如123，然后计算<code>A=g^a mod p</code>，结果是215，然后，甲发送<code>p＝509</code>，<code>g=5</code>，<code>A=215</code>给乙；</li>\n<li>乙方收到后，也选择一个随机数<code>b</code>，例如，456，然后计算<code>B=g^b mod p</code>，结果是181，乙再同时计算<code>s=A^b mod p</code>，结果是121；</li>\n<li>乙把计算的<code>B=181</code>发给甲，甲计算<code>s＝B^a mod p</code>的余数，计算结果与乙算出的结果一样，都是121。</li>\n</ol>\n<p>所以最终双方协商出的密钥<code>s</code>是121。注意到这个密钥<code>s</code>并没有在网络上传输。而通过网络传输的<code>p</code>，<code>g</code>，<code>A</code>和<code>B</code>是无法推算出<code>s</code>的，因为实际算法选择的素数是非常大的。</p>\n<p>所以，更确切地说，DH算法是一个密钥协商算法，双方最终协商出一个共同的密钥，而这个密钥不会通过网络传输。</p>\n<p>如果我们把<code>a</code>看成甲的私钥，<code>A</code>看成甲的公钥，<code>b</code>看成乙的私钥，<code>B</code>看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥<code>secretKey</code>，DH算法通过数学定律保证了双方各自计算出的<code>secretKey</code>是相同的。</p>\n<p>使用Java实现DH算法的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.spec.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.crypto.KeyAgreement;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>但是DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。</p>\n<h1 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h1><p>从DH算法我们可以看到，公钥-私钥组成的密钥对是非常有用的加密方式，因为公钥是可以公开的，而私钥是完全保密的，由此奠定了非对称加密的基础。</p>\n<p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p>\n<p>因此，如果小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</p>\n<p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p>\n<p>非对称加密相比对称加密的显著优点在于，对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要<code>N*(N-1)/2</code>个密钥，因此每个人需要管理<code>N-1</code>个密钥，密钥管理难度大，而且非常容易泄漏。</p>\n<p>既然非对称加密这么好，那我们抛弃对称加密，完全使用非对称加密行不行？也不行。因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多。</p>\n<p>所以，在实际应用的时候，非对称加密总是和对称加密一起使用。假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥，然后：</p>\n<ol>\n<li>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</li>\n<li>小红用自己的RSA私钥解密得到AES口令；</li>\n<li>双方使用这个共享的AES口令用AES加密通信。</li>\n</ol>\n<p>可见非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</p>\n<p>Java标准库提供了RSA算法的实现，示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.crypto.Cipher;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>RSA的公钥和私钥都可以通过<code>getEncoded()</code>方法获得以<code>byte[]</code>表示的二进制数据，并根据需要保存到文件中。要从<code>byte[]</code>数组恢复公钥或私钥，可以这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">byte<span class=\"literal\">[]</span> pkData =<span class=\"operator\"> ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>byte<span class=\"literal\">[]</span> skData =<span class=\"operator\"> ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>KeyFactory kf = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">KeyFactory</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;RSA&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 恢复公钥:</span></span><br><span class=\"line\">X509EncodedKeySpec pkSpec = <span class=\"keyword\">new</span> <span class=\"constructor\">X509EncodedKeySpec(<span class=\"params\">pkData</span>)</span>;</span><br><span class=\"line\">PublicKey pk = kf.generate<span class=\"constructor\">Public(<span class=\"params\">pkSpec</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 恢复私钥:</span></span><br><span class=\"line\">PKCS8EncodedKeySpec skSpec = <span class=\"keyword\">new</span> <span class=\"constructor\">PKCS8EncodedKeySpec(<span class=\"params\">skData</span>)</span>;</span><br><span class=\"line\">PrivateKey sk = kf.generate<span class=\"constructor\">Private(<span class=\"params\">skSpec</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>以RSA算法为例，它的密钥有256&#x2F;512&#x2F;1024&#x2F;2048&#x2F;4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p>\n<p>如果修改待加密的<code>byte[]</code>数据的大小，可以发现，使用512bit的RSA加密时，明文长度不能超过53字节，使用1024bit的RSA加密时，明文长度不能超过117字节，这也是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。</p>\n<p>此外，只使用非对称加密算法不能防止中间人攻击。</p>\n<h1 id=\"签字算法\"><a href=\"#签字算法\" class=\"headerlink\" title=\"签字算法\"></a>签字算法</h1><p>我们使用非对称加密算法的时候，对于一个公钥-私钥对，通常是用公钥加密，私钥解密。</p>\n<p>如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。</p>\n<p>不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？</p>\n<p>这个加密的意义在于，如果小明用自己的私钥加密了一条消息，比如<code>小明喜欢小红</code>，然后他公开了加密消息，由于任何人都可以用小明的公钥解密，从而使得任何人都可以确认<code>小明喜欢小红</code>这条消息肯定是小明发出的，其他人不能伪造这个消息，小明也不能抵赖这条消息不是自己写的。</p>\n<p>因此，私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p>\n<p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名，即：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature</span> = encrypt(privateKey, sha256(message))</span><br></pre></td></tr></table></figure>\n\n<p>对签名进行验证实际上就是用公钥解密：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">hash</span> = decrypt(publicKey, signature)</span><br></pre></td></tr></table></figure>\n\n<p>然后把解密后的哈希与原始消息的哈希进行对比。</p>\n<p>因为用户总是使用自己的私钥进行签名，所以，私钥就相当于用户身份。而公钥用来给外部验证用户身份。</p>\n<p>常用数字签名算法有：</p>\n<ul>\n<li>MD5withRSA</li>\n<li>SHA1withRSA</li>\n<li>SHA256withRSA</li>\n</ul>\n<p>它们实际上就是指定某种哈希算法进行RSA签名的方式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.charset.StandardCharsets;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>使用其他公钥，或者验证签名的时候修改原始信息，都无法验证成功。</p>\n<h3 id=\"DSA签名\"><a href=\"#DSA签名\" class=\"headerlink\" title=\"DSA签名\"></a>DSA签名</h3><p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p>\n<p>DSA只能配合SHA使用，常用的算法有：</p>\n<ul>\n<li>SHA1withDSA</li>\n<li>SHA256withDSA</li>\n<li>SHA512withDSA</li>\n</ul>\n<p>和RSA数字签名相比，DSA的优点是更快。</p>\n<h3 id=\"ECDSA签名\"><a href=\"#ECDSA签名\" class=\"headerlink\" title=\"ECDSA签名\"></a>ECDSA签名</h3><p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现。</p>\n<h1 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h1><p>我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p>\n<p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p>\n<p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p>\n<p>我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性：</p>\n<p><img src=\"/12.%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8.assets/l-164189436546328.jpeg\" alt=\"cert\"></p>\n<p>要使用数字证书，首先需要创建证书。正常情况下，一个合法的数字证书需要经过CA签名，这需要认证域名并支付一定的费用。开发的时候，我们可以使用自签名的证书，这种证书可以正常开发调试，但不能对外作为服务使用，因为其他客户端并不认可未经CA签名的证书。</p>\n<p>在Java程序中，数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。我们用下面的命令创建一个key store，并设定口令123456：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">keytool</span> -storepass <span class=\"number\">123456</span> -genkeypair -keyalg RSA -keysize <span class=\"number\">1024</span> -sigalg SHA<span class=\"number\">1</span>withRSA -validity <span class=\"number\">3650</span> -alias mycert -keystore my.keystore -dname <span class=\"string\">&quot;CN=www.sample.com, OU=sample, O=sample, L=BJ, ST=BJ, C=CN&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>几个主要的参数是：</p>\n<ul>\n<li>keyalg：指定RSA加密算法；</li>\n<li>sigalg：指定SHA1withRSA签名算法；</li>\n<li>validity：指定证书有效期3650天；</li>\n<li>alias：指定证书在程序中引用的名称；</li>\n<li>dname：最重要的<code>CN=www.sample.com</code>指定了<code>Common Name</code>，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li>\n</ul>\n<p>执行上述命令，JDK会在当前目录创建一个<code>my.keystore</code>文件，并存储创建成功的一个私钥和一个证书，它的别名是<code>mycert</code>。</p>\n<p>有了key store存储的证书，我们就可以通过数字证书进行加解密和签名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.cert.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.crypto.Cipher;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] message = <span class=\"string\">&quot;Hello, use X.509 cert!&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 读取KeyStore:</span></span><br><span class=\"line\">        KeyStore ks = loadKeyStore(<span class=\"string\">&quot;/my.keystore&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 读取私钥:</span></span><br><span class=\"line\">        PrivateKey privateKey = (PrivateKey) ks.getKey(<span class=\"string\">&quot;mycert&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>.toCharArray());</span><br><span class=\"line\">        <span class=\"comment\">// 读取证书:</span></span><br><span class=\"line\">        X509Certificate certificate = (X509Certificate) ks.getCertificate(<span class=\"string\">&quot;mycert&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 加密:</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] encrypted = encrypt(certificate, message);</span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;encrypted: %x&quot;</span>, <span class=\"keyword\">new</span> BigInteger(<span class=\"number\">1</span>, encrypted)));</span><br><span class=\"line\">        <span class=\"comment\">// 解密:</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] decrypted = decrypt(privateKey, encrypted);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;decrypted: &quot;</span> + <span class=\"keyword\">new</span> String(decrypted, <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">        <span class=\"comment\">// 签名:</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] sign = sign(privateKey, certificate, message);</span><br><span class=\"line\">        System.out.println(String.format(<span class=\"string\">&quot;signature: %x&quot;</span>, <span class=\"keyword\">new</span> BigInteger(<span class=\"number\">1</span>, sign)));</span><br><span class=\"line\">        <span class=\"comment\">// 验证签名:</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> verified = verify(certificate, message, sign);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;verify: &quot;</span> + verified);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> KeyStore <span class=\"title\">loadKeyStore</span><span class=\"params\">(String keyStoreFile, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream input = Main.class.getResourceAsStream(keyStoreFile)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (input == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;file not found in classpath: &quot;</span> + keyStoreFile);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());</span><br><span class=\"line\">            ks.load(input, password.toCharArray());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ks;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] encrypt(X509Certificate certificate, <span class=\"keyword\">byte</span>[] message) <span class=\"keyword\">throws</span> GeneralSecurityException &#123;</span><br><span class=\"line\">        Cipher cipher = Cipher.getInstance(certificate.getPublicKey().getAlgorithm());</span><br><span class=\"line\">        cipher.init(Cipher.ENCRYPT_MODE, certificate.getPublicKey());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cipher.doFinal(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] decrypt(PrivateKey privateKey, <span class=\"keyword\">byte</span>[] data) <span class=\"keyword\">throws</span> GeneralSecurityException &#123;</span><br><span class=\"line\">        Cipher cipher = Cipher.getInstance(privateKey.getAlgorithm());</span><br><span class=\"line\">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cipher.doFinal(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">byte</span>[] sign(PrivateKey privateKey, X509Certificate certificate, <span class=\"keyword\">byte</span>[] message)</span><br><span class=\"line\">            <span class=\"keyword\">throws</span> GeneralSecurityException &#123;</span><br><span class=\"line\">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class=\"line\">        signature.initSign(privateKey);</span><br><span class=\"line\">        signature.update(message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> signature.sign();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">verify</span><span class=\"params\">(X509Certificate certificate, <span class=\"keyword\">byte</span>[] message, <span class=\"keyword\">byte</span>[] sig)</span> <span class=\"keyword\">throws</span> GeneralSecurityException </span>&#123;</span><br><span class=\"line\">        Signature signature = Signature.getInstance(certificate.getSigAlgName());</span><br><span class=\"line\">        signature.initVerify(certificate);</span><br><span class=\"line\">        signature.update(message);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> signature.verify(sig);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述代码中，我们从key store直接读取了私钥-公钥对，私钥以<code>PrivateKey</code>实例表示，公钥以<code>X509Certificate</code>表示，实际上数字证书只包含公钥，因此，读取证书并不需要口令，只有读取私钥才需要。如果部署到Web服务器上，例如Nginx，需要把私钥导出为Private Key格式，把证书导出为X509Certificate格式。</p>\n<p>以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：</p>\n<ol>\n<li>浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；</li>\n<li>浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；</li>\n<li>服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。</li>\n</ol>\n<p>上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。</p>\n<p>注意：数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。如果CA证书的私钥泄漏，那么该CA证书签发的所有证书将不可信。数字证书服务商<a href=\"https://en.wikipedia.org/wiki/DigiNotar\">DigiNotar</a>就发生过私钥泄漏导致公司破产的事故。</p>\n","categories":["Java","1.Java快速入门","12.加密与安全"],"tags":["写作"]},{"title":"13.多线程","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_13.%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"<h1 id=\"多线程基础\"><a href=\"#多线程基础\" class=\"headerlink\" title=\"多线程基础\"></a>多线程基础</h1><p>多线程是Java最基本的一种并发模型，本章我们将详细介绍Java多线程编程。</p>\n<p>现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务，例如：</p>\n<p>CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。</p>\n<p>例如，假设我们有语文、数学、英语3门作业要做，每个作业需要30分钟。我们把这3门作业看成是3个任务，可以做1分钟语文作业，再做1分钟数学作业，再做1分钟英语作业：</p>\n<p><img src=\"/13.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/m.jpeg\" alt=\"fast\"></p>\n<p>这样轮流做下去，在某些人眼里看来，做作业的速度就非常快，看上去就像同时在做3门作业一样</p>\n<p><img src=\"/13.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/l.gif\" alt=\"ooops\"></p>\n<p>类似的，操作系统轮流让多个任务交替执行，例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</p>\n<p>即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。</p>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>\n<p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>\n<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                        ┌──────────┐</span><br><span class=\"line\">                        │Process   │</span><br><span class=\"line\">                        │┌────────┐│</span><br><span class=\"line\">            ┌──────────┐││ Thread ││┌──────────┐</span><br><span class=\"line\">            │Process   ││└────────┘││Process   │</span><br><span class=\"line\">            │┌────────┐││┌────────┐││┌────────┐│</span><br><span class=\"line\">┌──────────┐││ Thread ││││ Thread ││││ Thread ││</span><br><span class=\"line\">│Process   ││└────────┘││└────────┘││└────────┘│</span><br><span class=\"line\">│┌────────┐││┌────────┐││┌────────┐││┌────────┐│</span><br><span class=\"line\">││ Thread ││││ Thread ││││ Thread ││││ Thread ││</span><br><span class=\"line\">│└────────┘││└────────┘││└────────┘││└────────┘│</span><br><span class=\"line\">└──────────┘└──────────┘└──────────┘└──────────┘</span><br><span class=\"line\">┌──────────────────────────────────────────────┐</span><br><span class=\"line\">│               Operating System               │</span><br><span class=\"line\">└──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p>\n<p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p>\n<p>多进程模式（每个进程只有一个线程）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌──────────┐ ┌──────────┐ ┌──────────┐</span><br><span class=\"line\">│Process   │ │Process   │ │Process   │</span><br><span class=\"line\">│┌────────┐│ │┌────────┐│ │┌────────┐│</span><br><span class=\"line\">││ Thread ││ ││ Thread ││ ││ Thread ││</span><br><span class=\"line\">│└────────┘│ │└────────┘│ │└────────┘│</span><br><span class=\"line\">└──────────┘ └──────────┘ └──────────┘</span><br></pre></td></tr></table></figure>\n\n<p>多线程模式（一个进程有多个线程）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌────────────────────┐</span><br><span class=\"line\">│Process             │</span><br><span class=\"line\">│┌────────┐┌────────┐│</span><br><span class=\"line\">││ Thread ││ Thread ││</span><br><span class=\"line\">│└────────┘└────────┘│</span><br><span class=\"line\">│┌────────┐┌────────┐│</span><br><span class=\"line\">││ Thread ││ Thread ││</span><br><span class=\"line\">│└────────┘└────────┘│</span><br><span class=\"line\">└────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>多进程＋多线程模式（复杂度最高）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌──────────┐┌──────────┐┌──────────┐</span><br><span class=\"line\">│Process   ││Process   ││Process   │</span><br><span class=\"line\">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class=\"line\">││ Thread ││││ Thread ││││ Thread ││</span><br><span class=\"line\">│└────────┘││└────────┘││└────────┘│</span><br><span class=\"line\">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class=\"line\">││ Thread ││││ Thread ││││ Thread ││</span><br><span class=\"line\">│└────────┘││└────────┘││└────────┘│</span><br><span class=\"line\">└──────────┘└──────────┘└──────────┘</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"进程-vs-线程\"><a href=\"#进程-vs-线程\" class=\"headerlink\" title=\"进程 vs 线程\"></a>进程 vs 线程</h3><p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p>\n<p>具体采用哪种方式，要考虑到进程和线程的特点。</p>\n<p>和多线程相比，多进程的缺点在于：</p>\n<ul>\n<li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>\n<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li>\n</ul>\n<p>而多进程的优点在于：</p>\n<p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行<code>main()</code>方法，在<code>main()</code>方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>\n<p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p>\n<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p>\n<p>Java多线程编程的特点又在于：</p>\n<ul>\n<li>多线程模型是Java程序最基本的并发模型；</li>\n<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>\n</ul>\n<p>因此，必须掌握Java多线程编程才能继续深入学习其他内容。</p>\n<h1 id=\"创建新线程\"><a href=\"#创建新线程\" class=\"headerlink\" title=\"创建新线程\"></a>创建新线程</h1><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行<code>main()</code>方法。在<code>main()</code>方法中，我们又可以启动其他线程。</p>\n<p>要创建一个新线程非常容易，我们需要实例化一个<code>Thread</code>实例，然后调用它的<code>start()</code>方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：</p>\n<p>方法一：从<code>Thread</code>派生一个自定义类，然后覆写<code>run()</code>方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>执行上述代码，注意到<code>start()</code>方法会在内部自动调用实例的<code>run()</code>方法。</p>\n<p>方法二：创建<code>Thread</code>实例时，传入一个<code>Runnable</code>实例：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>或者用Java8引入的lambda语法进一步简写为：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>有童鞋会问，使用线程执行的打印语句，和直接在<code>main()</code>方法执行有区别吗？</p>\n<p>区别大了去了。我们看以下代码：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    <span class=\"built_in\">public</span> static <span class=\"type\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;main start...&quot;);</span><br><span class=\"line\">        Thread t = <span class=\"built_in\">new</span> Thread() &#123;</span><br><span class=\"line\">            <span class=\"built_in\">public</span> <span class=\"type\">void</span> run() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;thread run...&quot;);</span><br><span class=\"line\">                <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;thread end.&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        t.<span class=\"keyword\">start</span>();</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;main end...&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们用蓝色表示主线程，也就是<code>main</code>线程，<code>main</code>线程执行的代码有4行，首先打印<code>main start</code>，然后创建<code>Thread</code>对象，紧接着调用<code>start()</code>启动新线程。当<code>start()</code>方法被调用时，JVM就创建了一个新线程，我们通过实例变量<code>t</code>来表示这个新线程对象，并开始执行。</p>\n<p>接着，<code>main</code>线程继续执行打印<code>main end</code>语句，而<code>t</code>线程在<code>main</code>线程执行的同时会并发执行，打印<code>thread run</code>和<code>thread end</code>语句。</p>\n<p>当<code>run()</code>方法结束时，新线程就结束了。而<code>main()</code>方法结束时，主线程也结束了。</p>\n<p>我们再来看线程的执行顺序：</p>\n<ol>\n<li><code>main</code>线程肯定是先打印<code>main start</code>，再打印<code>main end</code>；</li>\n<li><code>t</code>线程肯定是先打印<code>thread run</code>，再打印<code>thread end</code>。</li>\n</ol>\n<p>但是，除了可以肯定，<code>main start</code>会先打印外，<code>main end</code>打印在<code>thread run</code>之前、<code>thread end</code>之后或者之间，都无法确定。因为从<code>t</code>线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。</p>\n<p>要模拟并发执行的效果，我们可以在线程中调用<code>Thread.sleep()</code>，强迫当前线程暂停一段时间：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>sleep()</code>传入的参数是毫秒。调整暂停时间的大小，我们可以看到<code>main</code>线程和<code>t</code>线程执行的先后顺序。</p>\n<p>要特别注意：直接调用<code>Thread</code>实例的<code>run()</code>方法是无效的：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">main</span>(<span class=\"params\"><span class=\"built_in\">String</span>[] args</span>)</span> &#123;</span><br><span class=\"line\">        Thread t = <span class=\"keyword\">new</span> MyThread();</span><br><span class=\"line\">        t.run();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">run</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接调用<code>run()</code>方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在<code>main()</code>方法内部又调用了<code>run()</code>方法，打印<code>hello</code>语句是在<code>main</code>线程中执行的，没有任何新线程被创建。</p>\n<p>必须调用<code>Thread</code>实例的<code>start()</code>方法才能启动新线程，如果我们查看<code>Thread</code>类的源代码，会看到<code>start()</code>方法内部调用了一个<code>private native void start0()</code>方法，<code>native</code>修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>\n<h3 id=\"线程的优先级\"><a href=\"#线程的优先级\" class=\"headerlink\" title=\"线程的优先级\"></a>线程的优先级</h3><p>可以对线程设定优先级，设定优先级的方法是：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Thread</span>.</span></span>set<span class=\"constructor\">Priority(<span class=\"params\">int</span> <span class=\"params\">n</span>)</span> <span class=\"comment\">// 1~10, 默认值5</span></span><br></pre></td></tr></table></figure>\n\n<p>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</p>\n<h1 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h1><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p>\n<ul>\n<li>New：新创建的线程，尚未执行；</li>\n<li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li>\n<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>\n<li>Waiting：运行中的线程，因为某些操作在等待中；</li>\n<li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li>\n<li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li>\n</ul>\n<p>用一个状态转移图表示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">         ┌─────────────┐</span><br><span class=\"line\">         │     New     │</span><br><span class=\"line\">         └─────────────┘</span><br><span class=\"line\">                │</span><br><span class=\"line\">                ▼</span><br><span class=\"line\">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\"> ┌─────────────┐ ┌─────────────┐</span><br><span class=\"line\">││  Runnable   │ │   Blocked   ││</span><br><span class=\"line\"> └─────────────┘ └─────────────┘</span><br><span class=\"line\">│┌─────────────┐ ┌─────────────┐│</span><br><span class=\"line\"> │   Waiting   │ │Timed Waiting│</span><br><span class=\"line\">│└─────────────┘ └─────────────┘│</span><br><span class=\"line\"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class=\"line\">                │</span><br><span class=\"line\">                ▼</span><br><span class=\"line\">         ┌─────────────┐</span><br><span class=\"line\">         │ Terminated  │</span><br><span class=\"line\">         └─────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p>\n<p>线程终止的原因有：</p>\n<ul>\n<li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li>\n<li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li>\n<li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li>\n</ul>\n<p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>当<code>main</code>线程对线程对象<code>t</code>调用<code>join()</code>方法时，主线程将等待变量<code>t</code>表示的线程运行结束，即<code>join</code>就是指等待该线程结束，然后才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是<code>main</code>线程先打印<code>start</code>，<code>t</code>线程再打印<code>hello</code>，<code>main</code>线程最后再打印<code>end</code>。</p>\n<p>如果<code>t</code>线程已经结束，对实例<code>t</code>调用<code>join()</code>会立刻返回。此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p>\n<h1 id=\"中断线程\"><a href=\"#中断线程\" class=\"headerlink\" title=\"中断线程\"></a>中断线程</h1><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行<code>run()</code>方法，使得自身线程能立刻结束运行。</p>\n<p>我们举个栗子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p>\n<p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>\n<p>我们还是看示例代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 中断线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>仔细看上述代码，<code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于<code>t</code>线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测<code>isInterrupted()</code>，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p>\n<p>如果线程处于等待状态，例如，<code>t.join()</code>会让<code>main</code>线程进入等待状态，此时，如果对<code>main</code>线程调用<code>interrupt()</code>，<code>join()</code>方法会立刻抛出<code>InterruptedException</code>，因此，目标线程只要捕获到<code>join()</code>方法抛出的<code>InterruptedException</code>，就说明有其他线程对其调用了<code>interrupt()</code>方法，通常情况下该线程应该立刻结束运行。</p>\n<p>我们来看下面的示例代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 中断线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>main</code>线程通过调用<code>t.interrupt()</code>从而通知<code>t</code>线程中断，而此时<code>t</code>线程正位于<code>hello.join()</code>的等待中，此方法会立刻结束等待并抛出<code>InterruptedException</code>。由于我们在<code>t</code>线程中捕获了<code>InterruptedException</code>，因此，就可以准备结束该线程。在<code>t</code>线程结束前，对<code>hello</code>线程也进行了<code>interrupt()</code>调用通知其中断。如果去掉这一行代码，可以发现<code>hello</code>线程仍然会继续运行，且JVM不会退出。</p>\n<p>另一个常用的中断线程的方法是设置标志位。我们通常会用一个<code>running</code>标志位来标识线程是否应该继续运行，在外部线程中，通过把<code>HelloThread.running</code>置为<code>false</code>，就可以让线程结束：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 中断线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用<code>volatile</code>关键字标记，确保每个线程都能读取到更新后的变量值。</p>\n<p>为什么要对线程间共享的变量用关键字<code>volatile</code>声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">           Main Memory</span><br><span class=\"line\">│                               │</span><br><span class=\"line\">   ┌───────┐┌───────┐┌───────┐</span><br><span class=\"line\">│  │ var A ││ var B ││ var C │  │</span><br><span class=\"line\">   └───────┘└───────┘└───────┘</span><br><span class=\"line\">│     │ ▲               │ ▲     │</span><br><span class=\"line\"> ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─</span><br><span class=\"line\">      │ │               │ │</span><br><span class=\"line\">┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐</span><br><span class=\"line\">      ▼ │               ▼ │</span><br><span class=\"line\">│  ┌───────┐  │   │  ┌───────┐  │</span><br><span class=\"line\">   │ var A │         │ var C │</span><br><span class=\"line\">│  └───────┘  │   │  └───────┘  │</span><br><span class=\"line\">   Thread 1          Thread 2</span><br><span class=\"line\">└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量<code>a = true</code>，线程1执行<code>a = false</code>时，它在此刻仅仅是把变量<code>a</code>的副本变成了<code>false</code>，主内存的变量<code>a</code>还是<code>true</code>，在JVM把修改后的<code>a</code>回写到主内存之前，其他线程读取到的<code>a</code>的值仍然是<code>true</code>，这就造成了多线程之间共享的变量不一致。</p>\n<p>因此，<code>volatile</code>关键字的目的是告诉虚拟机：</p>\n<ul>\n<li>每次访问变量时，总是获取主内存的最新值；</li>\n<li>每次修改变量后，立刻回写到主内存。</li>\n</ul>\n<p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>\n<p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p>\n<h1 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h1><p>Java程序入口就是由JVM启动<code>main</code>线程，<code>main</code>线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p>\n<p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p>\n<p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">System</span>.out.println(<span class=\"type\">LocalTime</span>.now());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"type\">Thread</span>.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (<span class=\"type\">InterruptedException</span> e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p>\n<p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p>\n<p>答案是使用守护线程（Daemon Thread）。</p>\n<p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>\n<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>\n<p>如何创建守护线程呢？方法和普通线程一样，只是在调用<code>start()</code>方法前，调用<code>setDaemon(true)</code>把该线程标记为守护线程：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Thread t = <span class=\"keyword\">new</span> <span class=\"constructor\">MyThread()</span>;</span><br><span class=\"line\">t.set<span class=\"constructor\">Daemon(<span class=\"params\">true</span>)</span>;</span><br><span class=\"line\">t.start<span class=\"literal\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>\n<h1 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h1><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>\n<p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上面的代码很简单，两个线程同时对一个<code>int</code>变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p>\n<p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p>\n<p>例如，对于语句：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">n</span> = n + <span class=\"number\">1</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>看上去是一行语句，实际上对应了3条指令：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ILOAD</span></span><br><span class=\"line\"><span class=\"attribute\">IADD</span></span><br><span class=\"line\"><span class=\"attribute\">ISTORE</span></span><br></pre></td></tr></table></figure>\n\n<p>我们假设<code>n</code>的值是<code>100</code>，如果两个线程同时执行<code>n = n + 1</code>，得到的结果很可能不是<code>102</code>，而是<code>101</code>，原因在于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────┐    ┌───────┐</span><br><span class=\"line\">│Thread1│    │Thread2│</span><br><span class=\"line\">└───┬───┘    └───┬───┘</span><br><span class=\"line\">    │            │</span><br><span class=\"line\">    │ILOAD (100) │</span><br><span class=\"line\">    │            │ILOAD (100)</span><br><span class=\"line\">    │            │IADD</span><br><span class=\"line\">    │            │ISTORE (101)</span><br><span class=\"line\">    │IADD        │</span><br><span class=\"line\">    │ISTORE (101)│</span><br><span class=\"line\">    ▼            ▼</span><br></pre></td></tr></table></figure>\n\n<p>如果线程1在执行<code>ILOAD</code>后被操作系统中断，此刻如果线程2被调度执行，它执行<code>ILOAD</code>后获取的值仍然是<code>100</code>，最终结果被两个线程的<code>ISTORE</code>写入后变成了<code>101</code>，而不是期待的<code>102</code>。</p>\n<p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────┐     ┌───────┐</span><br><span class=\"line\">│Thread1│     │Thread2│</span><br><span class=\"line\">└───┬───┘     └───┬───┘</span><br><span class=\"line\">    │             │</span><br><span class=\"line\">    │-- lock --   │</span><br><span class=\"line\">    │ILOAD (100)  │</span><br><span class=\"line\">    │IADD         │</span><br><span class=\"line\">    │ISTORE (101) │</span><br><span class=\"line\">    │-- unlock -- │</span><br><span class=\"line\">    │             │-- lock --</span><br><span class=\"line\">    │             │ILOAD (101)</span><br><span class=\"line\">    │             │IADD</span><br><span class=\"line\">    │             │ISTORE (102)</span><br><span class=\"line\">    │             │-- unlock --</span><br><span class=\"line\">    ▼             ▼</span><br></pre></td></tr></table></figure>\n\n<p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</p>\n<p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用<code>synchronized</code>关键字对一个对象进行加锁：</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><span class=\"line\">synchronized(lock) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">n</span> = <span class=\"built_in\">n</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>synchronized</code>保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用<code>synchronized</code>改写如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到代码：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">synchronized</span><span class=\"params\">(Counter.lock)</span></span> &#123; <span class=\"comment\">// 获取锁</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"comment\">// 释放锁</span></span><br></pre></td></tr></table></figure>\n\n<p>它表示用<code>Counter.lock</code>实例作为锁，两个线程在执行各自的<code>synchronized(Counter.lock) &#123; ... &#125;</code>代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在<code>synchronized</code>语句块结束会自动释放锁。这样一来，对<code>Counter.count</code>变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p>\n<p>使用<code>synchronized</code>解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为<code>synchronized</code>代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，<code>synchronized</code>会降低程序的执行效率。</p>\n<p>我们来概括一下如何使用<code>synchronized</code>：</p>\n<ol>\n<li>找出修改共享变量的线程代码块；</li>\n<li>选择一个共享实例作为锁；</li>\n<li>使用<code>synchronized(lockObject) &#123; ... &#125;</code>。</li>\n</ol>\n<p>在使用<code>synchronized</code>的时候，不必担心抛出异常。因为无论是否有异常，都会在<code>synchronized</code>结束处正确释放锁：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span> (obj) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value += m;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 无论有无异常，都会在此释放锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再来看一个错误使用<code>synchronized</code>的例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>结果并不是0，这是因为两个线程各自的<code>synchronized</code>锁住的<em>不是同一个对象</em>！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。</p>\n<p>因此，使用<code>synchronized</code>的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p>\n<p>我们再看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 多线程</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是<code>Counter.lock</code>这一个对象，这就造成了原本可以并发执行的<code>Counter.studentCount += 1</code>和<code>Counter.teacherCount += 1</code>，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：<code>AddStudentThread</code>和<code>DecStudentThread</code>，<code>AddTeacherThread</code>和<code>DecTeacherThread</code>，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p>\n<p><code>AddStudentThread</code>和<code>DecStudentThread</code>使用<code>lockStudent</code>锁：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">synchronized</span><span class=\"params\">(Counter.lockStudent)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>AddTeacherThread</code>和<code>DecTeacherThread</code>使用<code>lockTeacher</code>锁：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">synchronized</span><span class=\"params\">(Counter.lockTeacher)</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样才能最大化地提高执行效率。</p>\n<h3 id=\"不需要synchronized的操作\"><a href=\"#不需要synchronized的操作\" class=\"headerlink\" title=\"不需要synchronized的操作\"></a>不需要synchronized的操作</h3><p>JVM规范定义了几种原子操作：</p>\n<ul>\n<li>基本类型（<code>long</code>和<code>double</code>除外）赋值，例如：<code>int n = m</code>；</li>\n<li>引用类型赋值，例如：<code>List&lt;String&gt; list = anotherList</code>。</li>\n</ul>\n<p><code>long</code>和<code>double</code>是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把<code>long</code>和<code>double</code>的赋值作为原子操作实现的。</p>\n<p>单条原子操作的语句不需要同步。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\">int m</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">synchronized</span>(<span class=\"params\">lock</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value = m;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就不需要同步。</p>\n<p>对引用也是类似。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">set</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.value = s;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述赋值语句并不需要同步。</p>\n<p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> first;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] pair;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> first, <span class=\"keyword\">int</span> last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] ps = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; first, last &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.pair = ps;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就不再需要同步，因为<code>this.pair = ps</code>是引用赋值的原子操作。而语句：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>[] ps = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[] &#123; first, last &#125;;</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>ps</code>是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p>\n<h1 id=\"同步方法\"><a href=\"#同步方法\" class=\"headerlink\" title=\"同步方法\"></a>同步方法</h1><p>我们知道Java程序依靠<code>synchronized</code>对线程进行同步，使用<code>synchronized</code>的时候，锁住的是哪个对象非常重要。</p>\n<p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把<code>synchronized</code>逻辑封装起来。例如，我们编写一个计数器如下：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> Counter &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"keyword\">count</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> add(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">count</span> += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> dec(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">count</span> -= n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> get() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">count</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，线程调用<code>add()</code>、<code>dec()</code>方法时，它不必关心同步逻辑，因为<code>synchronized</code>代码块在<code>add()</code>、<code>dec()</code>方法内部。并且，我们注意到，<code>synchronized</code>锁住的对象是<code>this</code>，即当前实例，这又使得创建多个<code>Counter</code>实例的时候，它们之间互不影响，可以并发执行：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">var c1 = Counter();</span><br><span class=\"line\">var c2 = Counter();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span> 对c1进行操作的线程:</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"function\"><span class=\"params\">()</span> -&gt;</span> &#123;</span><br><span class=\"line\">    c1.add();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"function\"><span class=\"params\">()</span> -&gt;</span> &#123;</span><br><span class=\"line\">    c1.dec();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span> 对c2进行操作的线程:</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"function\"><span class=\"params\">()</span> -&gt;</span> &#123;</span><br><span class=\"line\">    c2.add();</span><br><span class=\"line\">&#125;).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> Thread(<span class=\"function\"><span class=\"params\">()</span> -&gt;</span> &#123;</span><br><span class=\"line\">    c2.dec();</span><br><span class=\"line\">&#125;).start();</span><br></pre></td></tr></table></figure>\n\n<p>现在，对于<code>Counter</code>类，多线程可以正确调用。</p>\n<p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的<code>Counter</code>类就是线程安全的。Java标准库的<code>java.lang.StringBuffer</code>也是线程安全的。</p>\n<p>还有一些不变类，例如<code>String</code>，<code>Integer</code>，<code>LocalDate</code>，它们的所有成员变量都是<code>final</code>，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>\n<p>最后，类似<code>Math</code>这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>\n<p>除了上述几种少数情况，大部分类，例如<code>ArrayList</code>，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么<code>ArrayList</code>是可以安全地在线程间共享的。</p>\n<p> 没有特殊说明时，一个类默认是非线程安全的。</p>\n<p>我们再观察<code>Counter</code>的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们锁住的是<code>this</code>实例时，实际上可以用<code>synchronized</code>修饰这个方法。下面两种写法是等价的：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123; <span class=\"comment\">// 锁住this</span></span><br><span class=\"line\">        count += n;</span><br><span class=\"line\">    &#125; <span class=\"comment\">// 解锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123; <span class=\"comment\">// 锁住this</span></span><br><span class=\"line\">    count += n;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 解锁</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，用<code>synchronized</code>修饰的方法就是同步方法，它表示整个方法都必须用<code>this</code>实例加锁。</p>\n<p>我们再思考一下，如果对一个静态方法添加<code>synchronized</code>修饰符，它锁住的是哪个对象？</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>static</code>方法，是没有<code>this</code>实例的，因为<code>static</code>方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的<code>Class</code>实例，因此，对<code>static</code>方法添加<code>synchronized</code>，锁住的是该类的<code>Class</code>实例。上述<code>synchronized static</code>方法实际上相当于：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">test</span>(<span class=\"params\">int n</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">synchronized</span>(<span class=\"params\">Counter.<span class=\"keyword\">class</span></span>)</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们再考察<code>Counter</code>的<code>get()</code>方法：</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> <span class=\"keyword\">count</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> get() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">count</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它没有同步，因为读一个<code>int</code>变量不需要同步。</p>\n<p>然而，如果我们把代码稍微改一下，返回一个包含两个<code>int</code>的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> last;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Pair <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Pair p = <span class=\"keyword\">new</span> Pair();</span><br><span class=\"line\">        p.first = first;</span><br><span class=\"line\">        p.last = last;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就必须要同步了。</p>\n<h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><p>Java的线程锁是可重入的锁。</p>\n<p>什么是可重入的锁？我们还是来看例子：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> Counter &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"keyword\">count</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> add(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            dec(-n);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">count</span> += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> dec(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">count</span> += n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察<code>synchronized</code>修饰的<code>add()</code>方法，一旦线程执行到<code>add()</code>方法内部，说明它已经获取了当前实例的<code>this</code>锁。如果传入的<code>n &lt; 0</code>，将在<code>add()</code>方法内部调用<code>dec()</code>方法。由于<code>dec()</code>方法也需要获取<code>this</code>锁，现在问题来了：</p>\n<p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p>\n<p>答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</p>\n<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出<code>synchronized</code>块，记录-1，减到0的时候，才会真正释放锁。</p>\n<h3 id=\"死锁-1\"><a href=\"#死锁-1\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">int m</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">synchronized</span>(<span class=\"params\">lockA</span>)</span> &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value += m;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">synchronized</span>(<span class=\"params\">lockB</span>)</span> &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.another += m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">dec</span>(<span class=\"params\">int m</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">synchronized</span>(<span class=\"params\">lockB</span>)</span> &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.another -= m;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">synchronized</span>(<span class=\"params\">lockA</span>)</span> &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.value -= m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行<code>add()</code>和<code>dec()</code>方法时：</p>\n<ul>\n<li>线程1：进入<code>add()</code>，获得<code>lockA</code>；</li>\n<li>线程2：进入<code>dec()</code>，获得<code>lockB</code>。</li>\n</ul>\n<p>随后：</p>\n<ul>\n<li>线程1：准备获得<code>lockB</code>，失败，等待中；</li>\n<li>线程2：准备获得<code>lockA</code>，失败，等待中。</li>\n</ul>\n<p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p>\n<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p>\n<p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p>\n<p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取<code>lockA</code>，再获取<code>lockB</code>的顺序，改写<code>dec()</code>方法如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">dec</span>(<span class=\"params\">int m</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">synchronized</span>(<span class=\"params\">lockA</span>)</span> &#123; <span class=\"comment\">// 获得lockA的锁</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.value -= m;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"title\">synchronized</span>(<span class=\"params\">lockB</span>)</span> &#123; <span class=\"comment\">// 获得lockB的锁</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.another -= m;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// 释放lockB的锁</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 释放lockA的锁</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用wait和notify\"><a href=\"#使用wait和notify\" class=\"headerlink\" title=\"使用wait和notify\"></a>使用wait和notify</h1><p>在Java程序中，<code>synchronized</code>解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用<code>synchronized</code>加锁：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> &#123;</span></span><br><span class=\"line\">    Queue&lt;<span class=\"keyword\">String</span>&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> synchronized <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(<span class=\"keyword\">String</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue.<span class=\"built_in\">add</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是<code>synchronized</code>并没有解决多线程协调的问题。</p>\n<p>仍然以上面的<code>TaskQueue</code>为例，我们再编写一个<code>getTask()</code>方法取出队列的第一个任务：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> &#123;</span></span><br><span class=\"line\">    Queue&lt;<span class=\"keyword\">String</span>&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> synchronized <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(<span class=\"keyword\">String</span> s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.queue.<span class=\"built_in\">add</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> synchronized <span class=\"keyword\">String</span> <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (queue.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码看上去没有问题：<code>getTask()</code>内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，<code>while()</code>循环退出，就可以返回队列的元素了。</p>\n<p>但实际上<code>while()</code>循环永远不会退出。因为线程在执行<code>while()</code>循环时，已经在<code>getTask()</code>入口获取了<code>this</code>锁，其他线程根本无法调用<code>addTask()</code>，因为<code>addTask()</code>执行条件也是获取<code>this</code>锁。</p>\n<p>因此，执行上述代码，线程会在<code>getTask()</code>中因为死循环而100%占用CPU资源。</p>\n<p>如果深入思考一下，我们想要的执行效果是：</p>\n<ul>\n<li>线程1可以调用<code>addTask()</code>不断往队列中添加任务；</li>\n<li>线程2可以调用<code>getTask()</code>从队列中获取任务。如果队列为空，则<code>getTask()</code>应该等待，直到队列中至少有一个任务时再返回。</li>\n</ul>\n<p>因此，多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>\n<p>对于上述<code>TaskQueue</code>，我们先改造<code>getTask()</code>方法，在条件不满足时，线程进入等待状态：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> synchronized <span class=\"keyword\">String</span> <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个线程执行到<code>getTask()</code>方法内部的<code>while</code>循环时，它必定已经获取到了<code>this</code>锁，此时，线程执行<code>while</code>条件判断，如果条件成立（队列为空），线程将执行<code>this.wait()</code>，进入等待状态。</p>\n<p>这里的关键是：<code>wait()</code>方法必须在当前获取的锁对象上调用，这里获取的是<code>this</code>锁，因此调用<code>this.wait()</code>。</p>\n<p>调用<code>wait()</code>方法后，线程进入等待状态，<code>wait()</code>方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，<code>wait()</code>方法才会返回，然后，继续执行下一条语句。</p>\n<p>有些仔细的童鞋会指出：即使线程在<code>getTask()</code>内部等待，其他线程如果拿不到<code>this</code>锁，照样无法执行<code>addTask()</code>，肿么办？</p>\n<p>这个问题的关键就在于<code>wait()</code>方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在<code>Object</code>类的一个<code>native</code>方法，也就是由JVM的C代码实现的。其次，必须在<code>synchronized</code>块中才能调用<code>wait()</code>方法，因为<code>wait()</code>方法调用时，会<em>释放</em>线程获得的锁，<code>wait()</code>方法返回后，线程又会重新试图获得锁。</p>\n<p>因此，只能在锁对象上调用<code>wait()</code>方法。因为在<code>getTask()</code>中，我们获得了<code>this</code>锁，因此，只能在<code>this</code>对象上调用<code>wait()</code>方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> synchronized <span class=\"keyword\">String</span> <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 释放this锁:</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 重新获取this锁</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个线程在<code>this.wait()</code>等待时，它就会释放<code>this</code>锁，从而使得其他线程能够在<code>addTask()</code>方法获得<code>this</code>锁。</p>\n<p>现在我们面临第二个问题：如何让等待的线程被重新唤醒，然后从<code>wait()</code>方法返回？答案是在相同的锁对象上调用<code>notify()</code>方法。我们修改<code>addTask()</code>如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> synchronized <span class=\"keyword\">void</span> <span class=\"title\">addTask</span><span class=\"params\">(<span class=\"keyword\">String</span> s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.queue.<span class=\"built_in\">add</span>(s);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">notify</span>(); <span class=\"comment\">// 唤醒在this锁等待的线程</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到在往队列中添加了任务后，线程立刻对<code>this</code>锁对象调用<code>notify()</code>方法，这个方法会唤醒一个正在<code>this</code>锁等待的线程（就是在<code>getTask()</code>中位于<code>this.wait()</code>的线程），从而使得等待线程从<code>this.wait()</code>方法返回。</p>\n<p>我们来看一个完整的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这个例子中，我们重点关注<code>addTask()</code>方法，内部调用了<code>this.notifyAll()</code>而不是<code>this.notify()</code>，使用<code>notifyAll()</code>将唤醒所有当前正在<code>this</code>锁等待的线程，而<code>notify()</code>只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在<code>getTask()</code>方法内部的<code>wait()</code>中等待，使用<code>notifyAll()</code>将一次性全部唤醒。通常来说，<code>notifyAll()</code>更安全。有些时候，如果我们的代码逻辑考虑不周，用<code>notify()</code>会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>\n<p>但是，注意到<code>wait()</code>方法返回时需要<em>重新</em>获得<code>this</code>锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行<code>addTask()</code>的线程结束此方法后，才能释放<code>this</code>锁，随后，这3个线程中只能有一个获取到<code>this</code>锁，剩下两个将继续等待。</p>\n<p>再注意到我们在<code>while()</code>循环中调用<code>wait()</code>，而不是<code>if</code>语句：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> synchronized <span class=\"keyword\">String</span> <span class=\"title\">getTask</span><span class=\"params\">()</span> throws InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (queue.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> queue.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种写法实际上是错误的，因为线程被唤醒时，需要再次获取<code>this</code>锁。多个线程被唤醒后，只有一个线程能获取<code>this</code>锁，此刻，该线程执行<code>queue.remove()</code>可以获取到队列的元素，然而，剩下的线程如果获取<code>this</code>锁后执行<code>queue.remove()</code>，此刻队列可能已经没有任何元素了，所以，要始终在<code>while</code>循环中<code>wait()</code>，并且每次被唤醒后拿到<code>this</code>锁就必须再次判断：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (queue.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.<span class=\"built_in\">wait</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，正确编写多线程代码是非常困难的，需要仔细考虑的条件非常多，任何一个地方考虑不周，都会导致多线程运行时不正常。</p>\n<p><img src=\"/13.%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/l-164189457240132.jpeg\" alt=\"multithread\"></p>\n<h1 id=\"使用ReentrantLock\"><a href=\"#使用ReentrantLock\" class=\"headerlink\" title=\"使用ReentrantLock\"></a>使用ReentrantLock</h1><p>从Java 5开始，引入了一个高级的处理并发的<code>java.util.concurrent</code>包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>\n<p>我们知道Java语言直接提供了<code>synchronized</code>关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p>\n<p><code>java.util.concurrent.locks</code>包提供的<code>ReentrantLock</code>用于替代<code>synchronized</code>加锁，我们来看一下传统的<code>synchronized</code>代码：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> Counter &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"keyword\">count</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> add(<span class=\"keyword\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span>(<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">count</span> += n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用<code>ReentrantLock</code>替代，可以把代码改造为：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final Lock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span>(<span class=\"params\"><span class=\"built_in\">int</span> n</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            count += n;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>synchronized</code>是Java语言层面提供的语法，所以我们不需要考虑异常，而<code>ReentrantLock</code>是Java代码实现的锁，我们就必须先获取锁，然后在<code>finally</code>中正确释放锁。</p>\n<p>顾名思义，<code>ReentrantLock</code>是可重入锁，它和<code>synchronized</code>一样，一个线程可以多次获取同一个锁。</p>\n<p>和<code>synchronized</code>不同的是，<code>ReentrantLock</code>可以尝试获取锁：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">lock</span>.tryLock(<span class=\"number\">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，<code>tryLock()</code>返回<code>false</code>，程序就可以做一些额外处理，而不是无限等待下去。</p>\n<p>所以，使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，线程在<code>tryLock()</code>失败的时候不会导致死锁。</p>\n<h1 id=\"使用Condition\"><a href=\"#使用Condition\" class=\"headerlink\" title=\"使用Condition\"></a>使用Condition</h1><p>使用<code>ReentrantLock</code>比直接使用<code>synchronized</code>更安全，可以替代<code>synchronized</code>进行线程同步。</p>\n<p>但是，<code>synchronized</code>可以配合<code>wait</code>和<code>notify</code>实现线程在条件不满足时等待，条件满足时唤醒，用<code>ReentrantLock</code>我们怎么编写<code>wait</code>和<code>notify</code>的功能呢？</p>\n<p>答案是使用<code>Condition</code>对象来实现<code>wait</code>和<code>notify</code>的功能。</p>\n<p>我们仍然以<code>TaskQueue</code>为例，把前面用<code>synchronized</code>实现的功能通过<code>ReentrantLock</code>和<code>Condition</code>来实现：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final Lock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final Condition condition = <span class=\"keyword\">lock</span>.newCondition();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Queue</span>&lt;<span class=\"title\">String</span>&gt; queue</span> = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span>(<span class=\"params\">String s</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            queue.<span class=\"keyword\">add</span>(s);</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTask</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">                condition.<span class=\"keyword\">await</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> queue.<span class=\"keyword\">remove</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，使用<code>Condition</code>时，引用的<code>Condition</code>对象必须从<code>Lock</code>实例的<code>newCondition()</code>返回，这样才能获得一个绑定了<code>Lock</code>实例的<code>Condition</code>实例。</p>\n<p><code>Condition</code>提供的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>原理和<code>synchronized</code>锁对象的<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>是一致的，并且其行为也是一样的：</p>\n<ul>\n<li><code>await()</code>会释放当前锁，进入等待状态；</li>\n<li><code>signal()</code>会唤醒某个等待线程；</li>\n<li><code>signalAll()</code>会唤醒所有等待线程；</li>\n<li>唤醒线程从<code>await()</code>返回后需要重新获得锁。</li>\n</ul>\n<p>此外，和<code>tryLock()</code>类似，<code>await()</code>可以在等待指定时间后，如果还没有被其他线程通过<code>signal()</code>或<code>signalAll()</code>唤醒，可以自己醒来：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (condition.await(<span class=\"number\">1</span>, TimeUnit.SECOND)) &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span> 被其他线程唤醒</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"regexp\">//</span> 指定时间内没有被其他线程唤醒</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，使用<code>Condition</code>配合<code>Lock</code>，我们可以实现更灵活的线程同步。</p>\n<h1 id=\"使用ReadWriteLock\"><a href=\"#使用ReadWriteLock\" class=\"headerlink\" title=\"使用ReadWriteLock\"></a>使用ReadWriteLock</h1><p>前面讲到的<code>ReentrantLock</code>保证了只有一个线程可以执行临界区代码：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Counter</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final Lock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inc</span>(<span class=\"params\"><span class=\"built_in\">int</span> index</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            counts[index] += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span>[] <span class=\"title\">get</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Arrays.copyOf(counts, counts.length);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用<code>inc()</code>方法是必须获取锁，但是，<code>get()</code>方法只读取数据，不修改数据，它实际上允许多个线程同时调用。</p>\n<p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">读</th>\n<th align=\"left\">写</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">读</td>\n<td align=\"left\">允许</td>\n<td align=\"left\">不允许</td>\n</tr>\n<tr>\n<td align=\"left\">写</td>\n<td align=\"left\">不允许</td>\n<td align=\"left\">不允许</td>\n</tr>\n</tbody></table>\n<p>使用<code>ReadWriteLock</code>可以解决这个问题，它保证：</p>\n<ul>\n<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>\n<li>没有写入时，多个线程允许同时读（提高性能）。</li>\n</ul>\n<p>用<code>ReadWriteLock</code>实现这个功能十分容易。我们需要创建一个<code>ReadWriteLock</code>实例，然后分别获取读锁和写锁：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReadWriteLock rwlock = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock rlock = rwlock.readLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Lock wlock = rwlock.writeLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span>[] counts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">inc</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        wlock.lock(); <span class=\"comment\">// 加写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            counts[index] += <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            wlock.unlock(); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] get() &#123;</span><br><span class=\"line\">        rlock.lock(); <span class=\"comment\">// 加读锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">return</span> Arrays.<span class=\"title\">copyOf</span><span class=\"params\">(counts, counts.length)</span></span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            rlock.unlock(); <span class=\"comment\">// 释放读锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p>\n<p>使用<code>ReadWriteLock</code>时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>\n<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用<code>ReadWriteLock</code>。</p>\n<h1 id=\"使用StampedLock\"><a href=\"#使用StampedLock\" class=\"headerlink\" title=\"使用StampedLock\"></a>使用StampedLock</h1><p>前面介绍的<code>ReadWriteLock</code>可以解决多线程同时读，但只有一个线程能写的问题。</p>\n<p>如果我们深入分析<code>ReadWriteLock</code>，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>\n<p>要进一步提升并发执行效率，Java 8引入了新的读写锁：<code>StampedLock</code>。</p>\n<p><code>StampedLock</code>和<code>ReadWriteLock</code>相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p>\n<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>\n<p>我们来看例子：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> StampedLock stampedLock = <span class=\"keyword\">new</span> StampedLock();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"keyword\">double</span> deltaX, <span class=\"keyword\">double</span> deltaY)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> stamp = stampedLock.writeLock(); <span class=\"comment\">// 获取写锁</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            x += deltaX;</span><br><span class=\"line\">            y += deltaY;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            stampedLock.unlockWrite(stamp); <span class=\"comment\">// 释放写锁</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">distanceFromOrigin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> stamp = stampedLock.tryOptimisticRead(); <span class=\"comment\">// 获得一个乐观读锁</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意下面两行代码不是原子操作</span></span><br><span class=\"line\">        <span class=\"comment\">// 假设x,y = (100,200)</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> currentX = x;</span><br><span class=\"line\">        <span class=\"comment\">// 此处已读取到x=100，但x,y可能被写线程修改为(300,400)</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> currentY = y;</span><br><span class=\"line\">        <span class=\"comment\">// 此处已读取到y，如果没有写入，读取是正确的(100,200)</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果有写入，读取是错误的(100,400)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!stampedLock.validate(stamp)) &#123; <span class=\"comment\">// 检查乐观读锁后是否有其他写锁发生</span></span><br><span class=\"line\">            stamp = stampedLock.readLock(); <span class=\"comment\">// 获取一个悲观读锁</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                currentX = x;</span><br><span class=\"line\">                currentY = y;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                stampedLock.unlockRead(stamp); <span class=\"comment\">// 释放悲观读锁</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">return</span> Math.<span class=\"title\">sqrt</span><span class=\"params\">(currentX * currentX + currentY * currentY)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和<code>ReadWriteLock</code>相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过<code>tryOptimisticRead()</code>获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过<code>validate()</code>去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p>\n<p>可见，<code>StampedLock</code>把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是<code>StampedLock</code>是不可重入锁，不能在一个线程中反复获取同一个锁。</p>\n<p><code>StampedLock</code>还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p>\n<h1 id=\"使用Concurrent集合\"><a href=\"#使用Concurrent集合\" class=\"headerlink\" title=\"使用Concurrent集合\"></a>使用Concurrent集合</h1><p>我们在前面已经通过<code>ReentrantLock</code>和<code>Condition</code>实现了一个<code>BlockingQueue</code>：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">TaskQueue</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final Lock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final Condition condition = <span class=\"keyword\">lock</span>.newCondition();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Queue</span>&lt;<span class=\"title\">String</span>&gt; queue</span> = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addTask</span>(<span class=\"params\">String s</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            queue.<span class=\"keyword\">add</span>(s);</span><br><span class=\"line\">            condition.signalAll();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getTask</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (queue.isEmpty()) &#123;</span><br><span class=\"line\">                condition.<span class=\"keyword\">await</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> queue.<span class=\"keyword\">remove</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>BlockingQueue</code>的意思就是说，当一个线程调用这个<code>TaskQueue</code>的<code>getTask()</code>方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，<code>getTask()</code>方法才会返回。</p>\n<p>因为<code>BlockingQueue</code>非常有用，所以我们不必自己编写，可以直接使用Java标准库的<code>java.util.concurrent</code>包提供的线程安全的集合：<code>ArrayBlockingQueue</code>。</p>\n<p>除了<code>BlockingQueue</code>外，针对<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Deque</code>等，<code>java.util.concurrent</code>包也提供了对应的并发集合类。我们归纳一下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">interface</th>\n<th align=\"left\">non-thread-safe</th>\n<th align=\"left\">thread-safe</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">List</td>\n<td align=\"left\">ArrayList</td>\n<td align=\"left\">CopyOnWriteArrayList</td>\n</tr>\n<tr>\n<td align=\"left\">Map</td>\n<td align=\"left\">HashMap</td>\n<td align=\"left\">ConcurrentHashMap</td>\n</tr>\n<tr>\n<td align=\"left\">Set</td>\n<td align=\"left\">HashSet &#x2F; TreeSet</td>\n<td align=\"left\">CopyOnWriteArraySet</td>\n</tr>\n<tr>\n<td align=\"left\">Queue</td>\n<td align=\"left\">ArrayDeque &#x2F; LinkedList</td>\n<td align=\"left\">ArrayBlockingQueue &#x2F; LinkedBlockingQueue</td>\n</tr>\n<tr>\n<td align=\"left\">Deque</td>\n<td align=\"left\">ArrayDeque &#x2F; LinkedList</td>\n<td align=\"left\">LinkedBlockingDeque</td>\n</tr>\n</tbody></table>\n<p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以<code>ConcurrentHashMap</code>为例：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; map = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 在不同的线程读写:</span></span><br><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\">map.<span class=\"built_in\">get</span>(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"literal\">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>改为：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; <span class=\"built_in\">map</span> = <span class=\"literal\">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>就可以了。</p>\n<p><code>java.util.Collections</code>工具类还提供了一个旧的线程安全集合转换器，可以这么用：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map unsafeMap = <span class=\"keyword\">new</span> <span class=\"constructor\">HashMap()</span>;</span><br><span class=\"line\">Map threadSafeMap = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Collections</span>.</span></span>synchronized<span class=\"constructor\">Map(<span class=\"params\">unsafeMap</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>但是它实际上是用一个包装类包装了非线程安全的<code>Map</code>，然后对所有读写方法都用<code>synchronized</code>加锁，这样获得的线程安全集合的性能比<code>java.util.concurrent</code>集合要低很多，所以不推荐使用。</p>\n<h1 id=\"使用Atomic\"><a href=\"#使用Atomic\" class=\"headerlink\" title=\"使用Atomic\"></a>使用Atomic</h1><p>Java的<code>java.util.concurrent</code>包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于<code>java.util.concurrent.atomic</code>包。</p>\n<p>我们以<code>AtomicInteger</code>为例，它提供的主要操作有：</p>\n<ul>\n<li>增加值并返回新值：<code>int addAndGet(int delta)</code></li>\n<li>加1后返回新值：<code>int incrementAndGet()</code></li>\n<li>获取当前值：<code>int get()</code></li>\n<li>用CAS方式设置：<code>int compareAndSet(int expect, int update)</code></li>\n</ul>\n<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>\n<p>如果我们自己通过CAS编写<code>incrementAndGet()</code>，它大概长这样：</p>\n<figure class=\"highlight q\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"type\">int</span> incrementAndGet(AtomicInteger <span class=\"built_in\">var</span>) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"built_in\">prev</span>, <span class=\"built_in\">next</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">prev</span> = <span class=\"built_in\">var</span>.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">        <span class=\"built_in\">next</span> = <span class=\"built_in\">prev</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> ( ! <span class=\"built_in\">var</span>.compareAndSet(<span class=\"built_in\">prev</span>, <span class=\"built_in\">next</span>));</span><br><span class=\"line\">    return <span class=\"built_in\">next</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>CAS是指，在这个操作中，如果<code>AtomicInteger</code>的当前值是<code>prev</code>，那么就更新为<code>next</code>，返回<code>true</code>。如果<code>AtomicInteger</code>的当前值不是<code>prev</code>，就什么也不干，返回<code>false</code>。通过CAS操作并配合<code>do ... while</code>循环，即使其他线程修改了<code>AtomicInteger</code>的值，最终的结果也是正确的。</p>\n<p>我们利用<code>AtomicLong</code>可以编写一个多线程安全的全局唯一ID生成器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IdGenerator</span> </span>&#123;</span><br><span class=\"line\">    AtomicLong <span class=\"keyword\">var</span> = <span class=\"keyword\">new</span> AtomicLong(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">getNextId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">var</span>.incrementAndGet();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通常情况下，我们并不需要直接用<code>do ... while</code>循环调用<code>compareAndSet</code>实现复杂的并发操作，而是用<code>incrementAndGet()</code>这样的封装好的方法，因此，使用起来非常简单。</p>\n<p>在高度竞争的情况下，还可以使用Java 8提供的<code>LongAdder</code>和<code>LongAccumulator</code>。</p>\n<h1 id=\"使用线程池\"><a href=\"#使用线程池\" class=\"headerlink\" title=\"使用线程池\"></a>使用线程池</h1><p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p>\n<p>如果可以复用一组线程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────┐ execute  ┌──────────────────┐</span><br><span class=\"line\">│Task1│─────────&gt;│ThreadPool        │</span><br><span class=\"line\">├─────┤          │┌───────┐┌───────┐│</span><br><span class=\"line\">│Task2│          ││Thread1││Thread2││</span><br><span class=\"line\">├─────┤          │└───────┘└───────┘│</span><br><span class=\"line\">│Task3│          │┌───────┐┌───────┐│</span><br><span class=\"line\">├─────┤          ││Thread3││Thread4││</span><br><span class=\"line\">│Task4│          │└───────┘└───────┘│</span><br><span class=\"line\">├─────┤          └──────────────────┘</span><br><span class=\"line\">│Task5│</span><br><span class=\"line\">├─────┤</span><br><span class=\"line\">│Task6│</span><br><span class=\"line\">└─────┘</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n<p>那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。</p>\n<p>简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>\n<p>Java标准库提供了<code>ExecutorService</code>接口表示线程池，它的典型用法如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建固定大小的线程池:</span></span><br><span class=\"line\">ExecutorService executor = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Executors</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">FixedThreadPool(3)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 提交任务:</span></span><br><span class=\"line\">executor.submit(task1);</span><br><span class=\"line\">executor.submit(task2);</span><br><span class=\"line\">executor.submit(task3);</span><br><span class=\"line\">executor.submit(task4);</span><br><span class=\"line\">executor.submit(task5);</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>ExecutorService</code>只是接口，Java标准库提供的几个常用实现类有：</p>\n<ul>\n<li>FixedThreadPool：线程数固定的线程池；</li>\n<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>\n<li>SingleThreadExecutor：仅单线程执行的线程池。</li>\n</ul>\n<p>创建这些线程池的方法都被封装到<code>Executors</code>这个类中。我们以<code>FixedThreadPool</code>为例，看看线程池的执行逻辑：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> thread-pool</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>我们观察执行结果，一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。</p>\n<p>线程池在程序结束的时候要关闭。使用<code>shutdown()</code>方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。<code>shutdownNow()</code>会立刻停止正在执行的任务，<code>awaitTermination()</code>则会等待指定的时间让线程池关闭。</p>\n<p>如果我们把线程池改为<code>CachedThreadPool</code>，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。</p>\n<p>如果我们想把线程池的大小限制在4～10个之间动态调整怎么办？我们查看<code>Executors.newCachedThreadPool()</code>方法的源码：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"keyword\">new</span><span class=\"type\">CachedThreadPool</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                    <span class=\"number\">60</span>L, TimeUnit.SECONDS,</span><br><span class=\"line\">                                    <span class=\"keyword\">new</span> <span class=\"type\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，想创建指定动态范围的线程池，可以这么写：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> min = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> max = <span class=\"number\">10</span>;</span><br><span class=\"line\">ExecutorService es = <span class=\"keyword\">new</span> <span class=\"built_in\">ThreadPoolExecutor</span>(min, max,</span><br><span class=\"line\">        <span class=\"number\">60L</span>, TimeUnit.SECONDS, <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ScheduledThreadPool\"><a href=\"#ScheduledThreadPool\" class=\"headerlink\" title=\"ScheduledThreadPool\"></a>ScheduledThreadPool</h3><p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用<code>ScheduledThreadPool</code>。放入<code>ScheduledThreadPool</code>的任务可以定期反复执行。</p>\n<p>创建一个<code>ScheduledThreadPool</code>仍然是通过<code>Executors</code>类：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">ScheduledExecutorService ses = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Executors</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">ScheduledThreadPool(4)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1秒后执行一次性任务:</span></span><br><span class=\"line\">ses.<span class=\"built_in\">schedule</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"built_in\">Task</span></span>(<span class=\"string\">&quot;one-time&quot;</span>), <span class=\"number\">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n\n<p>如果任务以固定的每3秒执行，我们可以这样写：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2秒后开始执行定时任务，每3秒执行:</span></span><br><span class=\"line\">ses.<span class=\"built_in\">scheduleAtFixedRate</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"built_in\">Task</span></span>(<span class=\"string\">&quot;fixed-rate&quot;</span>), <span class=\"number\">2</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n\n<p>如果任务以固定的3秒为间隔执行，我们可以这样写：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 2秒后开始执行定时任务，以3秒为间隔执行:</span></span><br><span class=\"line\">ses.<span class=\"built_in\">scheduleWithFixedDelay</span>(<span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"built_in\">Task</span></span>(<span class=\"string\">&quot;fixed-delay&quot;</span>), <span class=\"number\">2</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>\n\n<p>注意FixedRate和FixedDelay的区别。FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  </span><br><span class=\"line\">├───────┼───────┼───────┼───────┼────&gt;</span><br><span class=\"line\">│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│</span><br></pre></td></tr></table></figure>\n\n<p>而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│░░░│       │░░░░░│       │░░│       │░</span><br><span class=\"line\">└───┼───────┼─────┼───────┼──┼───────┼──&gt;</span><br><span class=\"line\">    │&lt;─────&gt;│     │&lt;─────&gt;│  │&lt;─────&gt;│</span><br></pre></td></tr></table></figure>\n\n<p>因此，使用<code>ScheduledThreadPool</code>时，我们要根据需要选择执行一次、FixedRate执行还是FixedDelay执行。</p>\n<p>细心的童鞋还可以思考下面的问题：</p>\n<ul>\n<li>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</li>\n<li>如果任务抛出了异常，后续任务是否继续执行？</li>\n</ul>\n<p>Java标准库还提供了一个<code>java.util.Timer</code>类，这个类也可以定期执行任务，但是，一个<code>Timer</code>会对应一个<code>Thread</code>，所以，一个<code>Timer</code>只能定期执行一个任务，多个定时任务必须启动多个<code>Timer</code>，而一个<code>ScheduledThreadPool</code>就可以调度多个定时任务，所以，我们完全可以用<code>ScheduledThreadPool</code>取代旧的<code>Timer</code>。</p>\n<h1 id=\"使用Future\"><a href=\"#使用Future\" class=\"headerlink\" title=\"使用Future\"></a>使用Future</h1><p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现<code>Runnable</code>接口，就可以让线程池去执行：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Task</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">Runnable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String result;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> run() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.result = longTimeCalculation(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Runnable</code>接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个<code>Callable</code>接口，和<code>Runnable</code>接口比，它多了一个返回值：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Task</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">Callable</span>&lt;<span class=\"symbol\">String</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String call() throws Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> longTimeCalculation(); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且<code>Callable</code>接口是一个泛型接口，可以返回指定类型的结果。</p>\n<p>现在的问题是，如何获得异步执行的结果？</p>\n<p>如果仔细看<code>ExecutorService.submit()</code>方法，可以看到，它返回了一个<code>Future</code>类型，一个<code>Future</code>类型的实例代表一个未来能获取结果的对象：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">ExecutorService executor = Executors.<span class=\"built_in\">newFixedThreadPool</span>(<span class=\"number\">4</span>); </span><br><span class=\"line\"><span class=\"comment\">// 定义任务:</span></span><br><span class=\"line\">Callable&lt;<span class=\"keyword\">String</span>&gt; task = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"built_in\">Task</span></span>();</span><br><span class=\"line\"><span class=\"comment\">// 提交任务并获得Future:</span></span><br><span class=\"line\">Future&lt;<span class=\"keyword\">String</span>&gt; future = executor.<span class=\"built_in\">submit</span>(task);</span><br><span class=\"line\"><span class=\"comment\">// 从Future获取异步执行返回的结果:</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> result = future.<span class=\"built_in\">get</span>(); <span class=\"comment\">// 可能阻塞</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们提交一个<code>Callable</code>任务后，我们会同时获得一个<code>Future</code>对象，然后，我们在主线程某个时刻调用<code>Future</code>对象的<code>get()</code>方法，就可以获得异步执行的结果。在调用<code>get()</code>时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么<code>get()</code>会阻塞，直到任务完成后才返回结果。</p>\n<p>一个<code>Future&lt;V&gt;</code>接口表示一个未来可能会返回的结果，它定义的方法有：</p>\n<ul>\n<li><code>get()</code>：获取结果（可能会等待）</li>\n<li><code>get(long timeout, TimeUnit unit)</code>：获取结果，但只等待指定的时间；</li>\n<li><code>cancel(boolean mayInterruptIfRunning)</code>：取消当前任务；</li>\n<li><code>isDone()</code>：判断任务是否已完成。</li>\n</ul>\n<h1 id=\"使用CompletableFuture\"><a href=\"#使用CompletableFuture\" class=\"headerlink\" title=\"使用CompletableFuture\"></a>使用CompletableFuture</h1><p>使用<code>Future</code>获得异步执行结果时，要么调用阻塞方法<code>get()</code>，要么轮询看<code>isDone()</code>是否为<code>true</code>，这两种方法都不是很好，因为主线程也会被迫等待。</p>\n<p>从Java 8开始引入了<code>CompletableFuture</code>，它针对<code>Future</code>做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>\n<p>我们以获取股票价格为例，看看如何使用<code>CompletableFuture</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CompletableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>创建一个<code>CompletableFuture</code>是通过<code>CompletableFuture.supplyAsync()</code>实现的，它需要一个实现了<code>Supplier</code>接口的对象：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"symbol\">Supplier</span>&lt;<span class=\"symbol\">T</span>&gt; &#123;</span><br><span class=\"line\">    T <span class=\"keyword\">get</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们用lambda语法简化了一下，直接传入<code>Main::fetchPrice</code>，因为<code>Main.fetchPrice()</code>静态方法的签名符合<code>Supplier</code>接口的定义（除了方法名外）。</p>\n<p>紧接着，<code>CompletableFuture</code>已经被提交给默认的线程池执行了，我们需要定义的是<code>CompletableFuture</code>完成时和异常时需要回调的实例。完成时，<code>CompletableFuture</code>会调用<code>Consumer</code>对象：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"symbol\">Consumer</span>&lt;<span class=\"symbol\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"built_in\">void</span> accept(T t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异常时，<code>CompletableFuture</code>会调用<code>Function</code>对象：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"symbol\">Function</span>&lt;<span class=\"symbol\">T</span>, <span class=\"symbol\">R</span>&gt; &#123;</span><br><span class=\"line\">    R apply(T t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里我们都用lambda语法简化了代码。</p>\n<p>可见<code>CompletableFuture</code>的优点是：</p>\n<ul>\n<li>异步任务结束时，会自动回调某个对象的方法；</li>\n<li>异步任务出错时，会自动回调某个对象的方法；</li>\n<li>主线程设置好回调后，不再关心异步任务的执行。</li>\n</ul>\n<p>如果只是实现了异步回调机制，我们还看不出<code>CompletableFuture</code>相比<code>Future</code>的优势。<code>CompletableFuture</code>更强大的功能是，多个<code>CompletableFuture</code>可以串行执行，例如，定义两个<code>CompletableFuture</code>，第一个<code>CompletableFuture</code>根据证券名称查询证券代码，第二个<code>CompletableFuture</code>根据证券代码查询证券价格，这两个<code>CompletableFuture</code>实现串行操作如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CompletableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>除了串行执行外，多个<code>CompletableFuture</code>还可以并行执行。例如，我们考虑这样的场景：</p>\n<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CompletableFuture</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.CompletableFuture;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述逻辑实现的异步查询规则实际上是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────┐ ┌─────────────┐</span><br><span class=\"line\">│ Query Code  │ │ Query Code  │</span><br><span class=\"line\">│  from sina  │ │  from 163   │</span><br><span class=\"line\">└─────────────┘ └─────────────┘</span><br><span class=\"line\">       │               │</span><br><span class=\"line\">       └───────┬───────┘</span><br><span class=\"line\">               ▼</span><br><span class=\"line\">        ┌─────────────┐</span><br><span class=\"line\">        │    anyOf    │</span><br><span class=\"line\">        └─────────────┘</span><br><span class=\"line\">               │</span><br><span class=\"line\">       ┌───────┴────────┐</span><br><span class=\"line\">       ▼                ▼</span><br><span class=\"line\">┌─────────────┐  ┌─────────────┐</span><br><span class=\"line\">│ Query Price │  │ Query Price │</span><br><span class=\"line\">│  from sina  │  │  from 163   │</span><br><span class=\"line\">└─────────────┘  └─────────────┘</span><br><span class=\"line\">       │                │</span><br><span class=\"line\">       └────────┬───────┘</span><br><span class=\"line\">                ▼</span><br><span class=\"line\">         ┌─────────────┐</span><br><span class=\"line\">         │    anyOf    │</span><br><span class=\"line\">         └─────────────┘</span><br><span class=\"line\">                │</span><br><span class=\"line\">                ▼</span><br><span class=\"line\">         ┌─────────────┐</span><br><span class=\"line\">         │Display Price│</span><br><span class=\"line\">         └─────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>除了<code>anyOf()</code>可以实现“任意个<code>CompletableFuture</code>只要一个成功”，<code>allOf()</code>可以实现“所有<code>CompletableFuture</code>都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>\n<p>最后我们注意<code>CompletableFuture</code>的命名规则：</p>\n<ul>\n<li><code>xxx()</code>：表示该方法将继续在已有的线程中执行；</li>\n<li><code>xxxAsync()</code>：表示将异步在线程池中执行。</li>\n</ul>\n<h1 id=\"使用ForkJoin\"><a href=\"#使用ForkJoin\" class=\"headerlink\" title=\"使用ForkJoin\"></a>使用ForkJoin</h1><p>Java 7开始引入了一种新的Fork&#x2F;Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>\n<p>我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class=\"line\">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure>\n\n<p>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class=\"line\">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br><span class=\"line\">┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐</span><br><span class=\"line\">└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure>\n\n<p>如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─┬─┬─┬─┬─┬─┐</span><br><span class=\"line\">└─┴─┴─┴─┴─┴─┘</span><br><span class=\"line\">┌─┬─┬─┬─┬─┬─┐</span><br><span class=\"line\">└─┴─┴─┴─┴─┴─┘</span><br><span class=\"line\">┌─┬─┬─┬─┬─┬─┐</span><br><span class=\"line\">└─┴─┴─┴─┴─┴─┘</span><br><span class=\"line\">┌─┬─┬─┬─┬─┬─┐</span><br><span class=\"line\">└─┴─┴─┴─┴─┴─┘</span><br></pre></td></tr></table></figure>\n\n<p>这就是Fork&#x2F;Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p>\n<p>我们来看如何使用Fork&#x2F;Join对大数据进行并行求和：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>观察上述代码的执行过程，一个大的计算任务0<del>2000首先分裂为两个小任务0</del>1000和1000<del>2000，这两个小任务仍然太大，继续分裂为更小的0</del>500，500<del>1000，1000</del>1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p>\n<p>因此，核心代码<code>SumTask</code>继承自<code>RecursiveTask</code>，在<code>compute()</code>方法中，关键是如何“分裂”出子任务并且提交子任务：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SumTask</span> <span class=\"keyword\">extends</span> <span class=\"title\">RecursiveTask&lt;Long&gt;</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">Long</span> compute() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// “分裂”子任务:</span></span><br><span class=\"line\">        <span class=\"type\">SumTask</span> subtask1 = <span class=\"keyword\">new</span> <span class=\"type\">SumTask</span>(...);</span><br><span class=\"line\">        <span class=\"type\">SumTask</span> subtask2 = <span class=\"keyword\">new</span> <span class=\"type\">SumTask</span>(...);</span><br><span class=\"line\">        <span class=\"comment\">// invokeAll会并行运行两个子任务:</span></span><br><span class=\"line\">        invokeAll(subtask1, subtask2);</span><br><span class=\"line\">        <span class=\"comment\">// 获得子任务的结果:</span></span><br><span class=\"line\">        <span class=\"type\">Long</span> subresult1 = subtask1.join();</span><br><span class=\"line\">        <span class=\"type\">Long</span> subresult2 = subtask2.join();</span><br><span class=\"line\">        <span class=\"comment\">// 汇总结果:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> subresult1 + subresult2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Fork&#x2F;Join线程池在Java标准库中就有应用。Java标准库提供的<code>java.util.Arrays.parallelSort(array)</code>可以进行并行排序，它的原理就是内部通过Fork&#x2F;Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>\n<h1 id=\"使用ThreadLocal\"><a href=\"#使用ThreadLocal\" class=\"headerlink\" title=\"使用ThreadLocal\"></a>使用ThreadLocal</h1><p>多线程是Java实现多任务的基础，<code>Thread</code>对象代表一个线程，我们可以在代码中调用<code>Thread.currentThread()</code>获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Thread</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：</p>\n<figure class=\"highlight isbl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">public</span> <span class=\"variable\">void</span> <span class=\"function\"><span class=\"title\">process</span>(<span class=\"variable\">User</span> <span class=\"variable\">user</span>) &#123;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">checkPermission</span>();</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">doWork</span>();</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">saveStatus</span>();</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">sendResponse</span>();</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后，通过线程池去执行这些任务。</p>\n<p>观察<code>process()</code>方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？</p>\n<p><code>process()</code>方法需要传递的状态就是<code>User</code>实例。有的童鞋会想，简单地传入<code>User</code>就可以了：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void process(User user) &#123;</span><br><span class=\"line\">    check<span class=\"constructor\">Permission(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">    <span class=\"keyword\">do</span><span class=\"constructor\">Work(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">    save<span class=\"constructor\">Status(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">    send<span class=\"constructor\">Response(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是往往一个方法又会调用其他很多方法，这样会导致<code>User</code>传递到所有地方：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">void <span class=\"keyword\">do</span><span class=\"constructor\">Work(User <span class=\"params\">user</span>)</span> &#123;</span><br><span class=\"line\">    query<span class=\"constructor\">Status(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">    check<span class=\"constructor\">Status()</span>;</span><br><span class=\"line\">    set<span class=\"constructor\">NewStatus(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">    log<span class=\"literal\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。</p>\n<p>给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，<code>User</code>对象就传不进去了。</p>\n<p>Java标准库提供了一个特殊的<code>ThreadLocal</code>，它可以在一个线程中传递同一个对象。</p>\n<p><code>ThreadLocal</code>实例通常总是以静态字段初始化如下：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"title\">ThreadLocal</span>&lt;<span class=\"title\">User</span>&gt; threadLocalUser</span> = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>它的典型使用方式如下：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">processUser</span>(<span class=\"params\">user</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        threadLocalUser.<span class=\"keyword\">set</span>(user);</span><br><span class=\"line\">        step1();</span><br><span class=\"line\">        step2();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        threadLocalUser.<span class=\"keyword\">remove</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过设置一个<code>User</code>实例关联到<code>ThreadLocal</code>中，在移除之前，所有方法都可以随时获取到该<code>User</code>实例：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> step1() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">User</span> u = threadLocalUser.<span class=\"keyword\">get</span>();</span><br><span class=\"line\">    log();</span><br><span class=\"line\">    printUser();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> log() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">User</span> u = threadLocalUser.<span class=\"keyword\">get</span>();</span><br><span class=\"line\">    println(u.name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> step2() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">User</span> u = threadLocalUser.<span class=\"keyword\">get</span>();</span><br><span class=\"line\">    checkUser(u.id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到普通的方法调用一定是同一个线程执行的，所以，<code>step1()</code>、<code>step2()</code>以及<code>log()</code>方法内，<code>threadLocalUser.get()</code>获取的<code>User</code>对象是同一个实例。</p>\n<p>实际上，可以把<code>ThreadLocal</code>看成一个全局<code>Map&lt;Thread, Object&gt;</code>：每个线程获取<code>ThreadLocal</code>变量时，总是使用<code>Thread</code>自身作为key：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object threadLocalValue = threadLocalMap.get(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Thread</span>.</span></span>current<span class=\"constructor\">Thread()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>ThreadLocal</code>相当于给每个线程都开辟了一个独立的存储空间，各个线程的<code>ThreadLocal</code>关联的实例互不干扰。</p>\n<p>最后，特别注意<code>ThreadLocal</code>一定要在<code>finally</code>中清除：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    threadLocalUser.<span class=\"keyword\">set</span>(user);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    threadLocalUser.<span class=\"keyword\">remove</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果<code>ThreadLocal</code>没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p>\n<p>为了保证能释放<code>ThreadLocal</code>关联的实例，我们可以通过<code>AutoCloseable</code>接口配合<code>try (resource) &#123;...&#125;</code>结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的<code>ThreadLocal</code>可以封装为一个<code>UserContext</code>对象：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserContext</span> <span class=\"title\">implements</span> <span class=\"title\">AutoCloseable</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;<span class=\"keyword\">String</span>&gt; ctx = <span class=\"keyword\">new</span> ThreadLocal&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserContext</span><span class=\"params\">(<span class=\"keyword\">String</span> user)</span> </span>&#123;</span><br><span class=\"line\">        ctx.<span class=\"built_in\">set</span>(user);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> <span class=\"title\">currentUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ctx.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"function\">Override</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ctx.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，我们借助<code>try (resource) &#123;...&#125;</code>结构，可以这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (var ctx = <span class=\"keyword\">new</span> <span class=\"constructor\">UserContext(<span class=\"string\">&quot;Bob&quot;</span>)</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 可任意调用UserContext.currentUser():</span></span><br><span class=\"line\">    String currentUser = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UserContext</span>.</span></span>current<span class=\"constructor\">User()</span>;</span><br><span class=\"line\">&#125; <span class=\"comment\">// 在此自动调用UserContext.close()方法释放ThreadLocal关联对象</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就在<code>UserContext</code>中完全封装了<code>ThreadLocal</code>，外部代码在<code>try (resource) &#123;...&#125;</code>内部可以随时调用<code>UserContext.currentUser()</code>获取当前线程绑定的用户名。</p>\n","categories":["Java","1.Java快速入门","13.多线程"],"tags":["写作"]},{"title":"4.反射","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_4.%E5%8F%8D%E5%B0%84/","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>什么是反射？</p>\n<p>反射就是Reflection，Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p>\n<p>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.itranswarp.learnjava.Person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getFullName</span>(<span class=\"params\">Person p</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p.getFirstName() + <span class=\"string\">&quot; &quot;</span> + p.getLastName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果不能获得<code>Person</code>类，只有一个<code>Object</code>实例，比如这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getFullName</span>(<span class=\"params\"><span class=\"built_in\">Object</span> obj</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ???</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>怎么办？有童鞋会说：强制转型啊！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getFullName</span>(<span class=\"params\"><span class=\"built_in\">Object</span> obj</span>)</span> &#123;</span><br><span class=\"line\">    Person p = (Person) obj;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.getFirstName() + <span class=\"string\">&quot; &quot;</span> + p.getLastName();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用<code>Person</code>类。不然，去掉<code>import</code>语句，你看能不能编译通过？</p>\n<p>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</p>\n<h1 id=\"Class类\"><a href=\"#Class类\" class=\"headerlink\" title=\"Class类\"></a>Class类</h1><p>除了<code>int</code>等基本类型外，Java的其他类型全部都是<code>class</code>（包括<code>interface</code>）。例如：</p>\n<ul>\n<li><code>String</code></li>\n<li><code>Object</code></li>\n<li><code>Runnable</code></li>\n<li><code>Exception</code></li>\n<li>…</li>\n</ul>\n<p>仔细思考，我们可以得出结论：<code>class</code>（包括<code>interface</code>）的本质是数据类型（<code>Type</code>）。无继承关系的数据类型无法赋值：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">Number n = <span class=\"keyword\">new</span> <span class=\"type\">Double</span>(<span class=\"number\">123.456</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> s = <span class=\"keyword\">new</span> <span class=\"type\">Double</span>(<span class=\"number\">123.456</span>); <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>而<code>class</code>是由JVM在执行过程中动态加载的。JVM在第一次读取到一种<code>class</code>类型时，将其加载进内存。</p>\n<p>每加载一种<code>class</code>，JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。注意：这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。它长这样：</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"keyword\">Class</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">Class</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以<code>String</code>类为例，当JVM加载<code>String</code>类时，它首先读取<code>String.class</code>文件到内存，然后，为<code>String</code>类创建一个<code>Class</code>实例并关联起来：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Class</span> cls = <span class=\"built_in\">new</span> <span class=\"keyword\">Class</span>(<span class=\"type\">String</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>Class</code>实例是JVM内部创建的，如果我们查看JDK源码，可以发现<code>Class</code>类的构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的Java程序是无法创建<code>Class</code>实例的。</p>\n<p>所以，JVM持有的每个<code>Class</code>实例都指向一个数据类型（<code>class</code>或<code>interface</code>）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────────────────────┐</span><br><span class=\"line\">│      Class Instance       │──────&gt; String</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│name = &quot;java.lang.String&quot;  │</span><br><span class=\"line\">└───────────────────────────┘</span><br><span class=\"line\">┌───────────────────────────┐</span><br><span class=\"line\">│      Class Instance       │──────&gt; Random</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│name = &quot;java.util.Random&quot;  │</span><br><span class=\"line\">└───────────────────────────┘</span><br><span class=\"line\">┌───────────────────────────┐</span><br><span class=\"line\">│      Class Instance       │──────&gt; Runnable</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│name = &quot;java.lang.Runnable&quot;│</span><br><span class=\"line\">└───────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>一个<code>Class</code>实例包含了该<code>class</code>的所有完整信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────────────────────┐</span><br><span class=\"line\">│      Class Instance       │──────&gt; String</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│name = &quot;java.lang.String&quot;  │</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│package = &quot;java.lang&quot;      │</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│super = &quot;java.lang.Object&quot; │</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│interface = CharSequence...│</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│field = value[],hash,...   │</span><br><span class=\"line\">├───────────────────────────┤</span><br><span class=\"line\">│method = indexOf()...      │</span><br><span class=\"line\">└───────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>由于JVM为每个加载的<code>class</code>创建了对应的<code>Class</code>实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个<code>Class</code>实例，我们就可以通过这个<code>Class</code>实例获取到该实例对应的<code>class</code>的所有信息。</p>\n<p>这种通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。</p>\n<p>如何获取一个<code>class</code>的<code>Class</code>实例？有三个方法：</p>\n<p>方法一：直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Class</span> cls = <span class=\"keyword\">String</span>.<span class=\"keyword\">class</span>;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;Hello&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\">Class cls = s.getClass()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>方法三：如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class cls = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Class</span>.</span></span><span class=\"keyword\">for</span><span class=\"constructor\">Name(<span class=\"string\">&quot;java.lang.String&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>Class</code>实例在JVM中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class <span class=\"attr\">cls1</span> = String.class;</span><br><span class=\"line\"></span><br><span class=\"line\">String <span class=\"attr\">s</span> = <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">Class <span class=\"attr\">cls2</span> = s.getClass();</span><br><span class=\"line\"></span><br><span class=\"line\">boolean <span class=\"attr\">sameClass</span> = <span class=\"attr\">cls1</span> == cls2; // <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<p>注意一下<code>Class</code>实例比较和<code>instanceof</code>的差别：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> n = <span class=\"built_in\">new</span> <span class=\"type\">Integer</span>(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">boolean</span> b1 = n instanceof <span class=\"type\">Integer</span>; // <span class=\"keyword\">true</span>，因为n是<span class=\"type\">Integer</span>类型</span><br><span class=\"line\"><span class=\"type\">boolean</span> b2 = n instanceof Number; // <span class=\"keyword\">true</span>，因为n是Number类型的子类</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">boolean</span> b3 = n.getClass() == <span class=\"type\">Integer</span>.<span class=\"keyword\">class</span>; // <span class=\"keyword\">true</span>，因为n.getClass()返回<span class=\"type\">Integer</span>.<span class=\"keyword\">class</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> b4 = n.getClass() == Number.<span class=\"keyword\">class</span>; // <span class=\"keyword\">false</span>，因为<span class=\"type\">Integer</span>.<span class=\"keyword\">class</span>!=Number.<span class=\"keyword\">class</span></span><br></pre></td></tr></table></figure>\n\n<p>用<code>instanceof</code>不但匹配指定类型，还匹配指定类型的子类。而用<code>==</code>判断<code>class</code>实例可以精确地判断数据类型，但不能作子类型比较。</p>\n<p>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p>\n<p>因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个<code>Object</code>实例时，我们可以通过反射获取该<code>Object</code>的<code>class</code>信息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"title\">printObjectInfo</span>(<span class=\"params\"><span class=\"built_in\">Object</span> obj</span>)</span> &#123;</span><br><span class=\"line\">    Class cls = obj.getClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要从<code>Class</code>实例获取获取的基本信息，参考下面的代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> reflection</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到数组（例如<code>String[]</code>）也是一种<code>Class</code>，而且不同于<code>String.class</code>，它的类名是<code>[Ljava.lang.String</code>。此外，JVM为每一种基本类型如int也创建了<code>Class</code>，通过<code>int.class</code>访问。</p>\n<p>如果获取到了一个<code>Class</code>实例，我们就可以通过该<code>Class</code>实例来创建对应类型的实例：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取String的Class实例:</span></span><br><span class=\"line\"><span class=\"keyword\">Class</span> cls = <span class=\"keyword\">String</span>.<span class=\"keyword\">class</span>;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个String实例:</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> s = (<span class=\"keyword\">String</span>) cls.newInstance();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码相当于<code>new String()</code>。通过<code>Class.newInstance()</code>可以创建类实例，它的局限是：只能调用<code>public</code>的无参数构造方法。带参数的构造方法，或者非<code>public</code>的构造方法都无法通过<code>Class.newInstance()</code>被调用。</p>\n<h3 id=\"动态加载\"><a href=\"#动态加载\" class=\"headerlink\" title=\"动态加载\"></a>动态加载</h3><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">main</span>(<span class=\"params\"><span class=\"built_in\">String</span>[] args</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (args.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            create(args[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        Person p = <span class=\"keyword\">new</span> Person(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当执行<code>Main.java</code>时，由于用到了<code>Main</code>，因此，JVM首先会把<code>Main.class</code>加载到内存。然而，并不会加载<code>Person.class</code>，除非程序执行到<code>create()</code>方法，JVM发现需要加载<code>Person</code>类时，才会首次加载<code>Person.class</code>。如果没有执行<code>create()</code>方法，那么<code>Person.class</code>根本就不会被加载。</p>\n<p>这就是JVM动态加载<code>class</code>的特性。</p>\n<p>动态加载<code>class</code>的特性对于Java程序非常重要。利用JVM动态加载<code>class</code>的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。利用JVM动态加载特性，大致的实现代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Commons Logging优先使用Log4j:</span></span><br><span class=\"line\">LogFactory factory = null;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (is<span class=\"constructor\">ClassPresent(<span class=\"string\">&quot;org.apache.logging.log4j.Logger&quot;</span>)</span>) &#123;</span><br><span class=\"line\">    factory = create<span class=\"constructor\">Log4j()</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    factory = create<span class=\"constructor\">JdkLog()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">boolean is<span class=\"constructor\">ClassPresent(String <span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Class</span>.</span></span><span class=\"keyword\">for</span><span class=\"constructor\">Name(<span class=\"params\">name</span>)</span>;</span><br><span class=\"line\">        return <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        return <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是为什么我们只需要把Log4j的jar包放到classpath中，Commons Logging就会自动使用Log4j的原因。</p>\n<h1 id=\"访问字段\"><a href=\"#访问字段\" class=\"headerlink\" title=\"访问字段\"></a>访问字段</h1><p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。</p>\n<p>我们先看看如何通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p>\n<ul>\n<li>Field getField(name)：根据字段名获取某个public的field（包括父类）</li>\n<li>Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）</li>\n<li>Field[] getFields()：获取所有public的field（包括父类）</li>\n<li>Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</li>\n</ul>\n<p>我们来看一下示例代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> reflection</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>字段、继承的<code>public</code>字段以及<code>private</code>字段，打印出的<code>Field</code>类似：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"built_in\">int</span> <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Student</span>.</span></span>score</span><br><span class=\"line\">public java.lang.String <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Person</span>.</span></span>name</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Student</span>.</span></span>grade</span><br></pre></td></tr></table></figure>\n\n<p>一个<code>Field</code>对象包含了一个字段的所有信息：</p>\n<ul>\n<li><code>getName()</code>：返回字段名称，例如，<code>&quot;name&quot;</code>；</li>\n<li><code>getType()</code>：返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>\n<li><code>getModifiers()</code>：返回字段的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>\n</ul>\n<p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们用反射获取该字段的信息，代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Field f = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span><span class=\"keyword\">class</span>.get<span class=\"constructor\">DeclaredField(<span class=\"string\">&quot;value&quot;</span>)</span>;</span><br><span class=\"line\">f.get<span class=\"constructor\">Name()</span>; <span class=\"comment\">// &quot;value&quot;</span></span><br><span class=\"line\">f.get<span class=\"constructor\">Type()</span>; <span class=\"comment\">// class [B 表示byte[]类型</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> m = f.get<span class=\"constructor\">Modifiers()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Modifier</span>.</span></span>is<span class=\"constructor\">Final(<span class=\"params\">m</span>)</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Modifier</span>.</span></span>is<span class=\"constructor\">Public(<span class=\"params\">m</span>)</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Modifier</span>.</span></span>is<span class=\"constructor\">Protected(<span class=\"params\">m</span>)</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Modifier</span>.</span></span>is<span class=\"constructor\">Private(<span class=\"params\">m</span>)</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Modifier</span>.</span></span>is<span class=\"constructor\">Static(<span class=\"params\">m</span>)</span>; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取字段值\"><a href=\"#获取字段值\" class=\"headerlink\" title=\"获取字段值\"></a>获取字段值</h3><p>利用反射拿到字段的一个<code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p>\n<p>例如，对于一个<code>Person</code>实例，我们可以先拿到<code>name</code>字段对应的<code>Field</code>，再获取这个实例的<code>name</code>字段的值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reflection</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p>\n<p>运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">f.set<span class=\"constructor\">Accessible(<span class=\"params\">true</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p>\n<p>可以试着加上上述语句，再运行代码，就可以打印出<code>private</code>字段的值。</p>\n<p>有童鞋会问：如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</p>\n<p>答案是正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p>\n<p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p>\n<p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>\n<h3 id=\"设置字段值\"><a href=\"#设置字段值\" class=\"headerlink\" title=\"设置字段值\"></a>设置字段值</h3><p>通过Field实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p>\n<p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的，其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reflection</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Field;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，打印的<code>name</code>字段从<code>Xiao Ming</code>变成了<code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p>\n<p>同样的，修改非<code>public</code>字段，需要首先调用<code>setAccessible(true)</code>。</p>\n<h1 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h1><p>我们已经能通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method</code>：</p>\n<ul>\n<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>\n<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>\n<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>\n<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>\n</ul>\n<p>我们来看一下示例代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> reflection</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>方法、继承的<code>public</code>方法以及<code>private</code>方法，打印出的<code>Method</code>类似：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"built_in\">int</span> <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Student</span>.</span></span>get<span class=\"constructor\">Score(<span class=\"params\">java</span>.<span class=\"params\">lang</span>.String)</span></span><br><span class=\"line\">public java.lang.String <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Person</span>.</span></span>get<span class=\"constructor\">Name()</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">int</span> <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Student</span>.</span></span>get<span class=\"constructor\">Grade(<span class=\"params\">int</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>\n<ul>\n<li><code>getName()</code>：返回方法名称，例如：<code>&quot;getScore&quot;</code>；</li>\n<li><code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：<code>String.class</code>；</li>\n<li><code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：<code>&#123;String.class, int.class&#125;</code>；</li>\n<li><code>getModifiers()</code>：返回方法的修饰符，它是一个<code>int</code>，不同的bit表示不同的含义。</li>\n</ul>\n<h3 id=\"调用方法-1\"><a href=\"#调用方法-1\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h3><p>当我们获取到一个<code>Method</code>对象时，就可以对它进行调用。我们以下面的代码为例：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> s = <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">String</span> r = s.<span class=\"built_in\">substring</span>(<span class=\"number\">6</span>); <span class=\"comment\">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果用反射来调用<code>substring</code>方法，需要以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reflection</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到<code>substring()</code>有两个重载方法，我们获取的是<code>String substring(int)</code>这个方法。思考一下如何获取<code>String substring(int, int)</code>方法。</p>\n<p>对<code>Method</code>实例调用<code>invoke</code>就相当于调用该方法，<code>invoke</code>的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。</p>\n<h3 id=\"调用静态方法\"><a href=\"#调用静态方法\" class=\"headerlink\" title=\"调用静态方法\"></a>调用静态方法</h3><p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>。我们以<code>Integer.parseInt(String)</code>为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reflection</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"调用非public方法\"><a href=\"#调用非public方法\" class=\"headerlink\" title=\"调用非public方法\"></a>调用非public方法</h3><p>和Field类似，对于非public方法，我们虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个<code>IllegalAccessException</code>。为了调用非public方法，我们通过<code>Method.setAccessible(true)</code>允许其调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reflection</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>此外，<code>setAccessible(true)</code>可能会失败。如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>\n<h3 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>我们来考察这样一种情况：一个<code>Person</code>类定义了<code>hello()</code>方法，并且它的子类<code>Student</code>也覆写了<code>hello()</code>方法，那么，从<code>Person.class</code>获取的<code>Method</code>，作用于<code>Student</code>实例时，调用的方法到底是哪个？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reflection</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，发现打印出的是<code>Student:hello</code>，因此，使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。上述的反射代码：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">m</span> = <span class=\"title\">Person</span>.<span class=\"title\">class</span>.<span class=\"title\">getMethod</span><span class=\"params\">(&quot;hello&quot;)</span>;</span></span><br><span class=\"line\">m.invoke(<span class=\"keyword\">new</span> Student());</span><br></pre></td></tr></table></figure>\n\n<p>实际上相当于：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = new Student()<span class=\"comment\">;</span></span><br><span class=\"line\">p.hello()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"调用构造方法\"><a href=\"#调用构造方法\" class=\"headerlink\" title=\"调用构造方法\"></a>调用构造方法</h1><p>我们通常使用<code>new</code>操作符创建新的实例：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Person p</span> = new Person();</span><br></pre></td></tr></table></figure>\n\n<p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Person</span>.</span></span><span class=\"keyword\">class</span>.<span class=\"keyword\">new</span><span class=\"constructor\">Instance()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p>\n<p>为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例。Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Constructor;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>通过Class实例获取Constructor的方法如下：</p>\n<ul>\n<li><code>getConstructor(Class...)</code>：获取某个<code>public</code>的<code>Constructor</code>；</li>\n<li><code>getDeclaredConstructor(Class...)</code>：获取某个<code>Constructor</code>；</li>\n<li><code>getConstructors()</code>：获取所有<code>public</code>的<code>Constructor</code>；</li>\n<li><code>getDeclaredConstructors()</code>：获取所有<code>Constructor</code>。</li>\n</ul>\n<p>注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p>\n<p>调用非<code>public</code>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p>\n<h1 id=\"获取继承关系\"><a href=\"#获取继承关系\" class=\"headerlink\" title=\"获取继承关系\"></a>获取继承关系</h1><p>当我们获取到某个<code>Class</code>对象时，实际上就获取到了一个类的类型：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Class</span> cls = <span class=\"keyword\">String</span>.<span class=\"keyword\">class</span>; <span class=\"comment\">// 获取到String的Class</span></span><br></pre></td></tr></table></figure>\n\n<p>还可以用实例的<code>getClass()</code>方法获取：</p>\n<figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> s = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">Class cls = s.getClass(); // s是<span class=\"keyword\">String</span>，因此获取到<span class=\"keyword\">String</span>的Class</span><br></pre></td></tr></table></figure>\n\n<p>最后一种获取<code>Class</code>的方法是通过<code>Class.forName(&quot;&quot;)</code>，传入<code>Class</code>的完整类名获取：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class s = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Class</span>.</span></span><span class=\"keyword\">for</span><span class=\"constructor\">Name(<span class=\"string\">&quot;java.lang.String&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这三种方式获取的<code>Class</code>实例都是同一个实例，因为JVM对每个加载的<code>Class</code>只创建一个<code>Class</code>实例来表示它的类型。</p>\n<h3 id=\"获取父类的Class\"><a href=\"#获取父类的Class\" class=\"headerlink\" title=\"获取父类的Class\"></a>获取父类的Class</h3><p>有了<code>Class</code>实例，我们还可以获取它的父类的<code>Class</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> reflection</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，可以看到，<code>Integer</code>的父类类型是<code>Number</code>，<code>Number</code>的父类是<code>Object</code>，<code>Object</code>的父类是<code>null</code>。除<code>Object</code>外，其他任何非<code>interface</code>的<code>Class</code>都必定存在一个父类类型。</p>\n<h3 id=\"获取interface\"><a href=\"#获取interface\" class=\"headerlink\" title=\"获取interface\"></a>获取interface</h3><p>由于一个类可能实现一个或多个接口，通过<code>Class</code>我们就可以查询到实现的接口类型。例如，查询<code>Integer</code>实现的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reflection</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码可知，<code>Integer</code>实现的接口有：</p>\n<ul>\n<li>java.lang.Comparable</li>\n<li>java.lang.constant.Constable</li>\n<li>java.lang.constant.ConstantDesc</li>\n</ul>\n<p>要特别注意：<code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// reflection</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>Integer</code>的父类是<code>Number</code>，<code>Number</code>实现的接口是<code>java.io.Serializable</code>。</p>\n<p>此外，对所有<code>interface</code>的<code>Class</code>调用<code>getSuperclass()</code>返回的是<code>null</code>，获取接口的父接口要用<code>getInterfaces()</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(java.io.<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DataInputStream</span>.</span></span><span class=\"keyword\">class</span>.get<span class=\"constructor\">Superclass()</span>); <span class=\"comment\">// java.io.FilterInputStream，因为DataInputStream继承自FilterInputStream</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(java.io.<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Closeable</span>.</span></span><span class=\"keyword\">class</span>.get<span class=\"constructor\">Superclass()</span>); <span class=\"comment\">// null，对接口调用getSuperclass()总是返回null，获取接口的父接口要用getInterfaces()</span></span><br></pre></td></tr></table></figure>\n\n<p>如果一个类没有实现任何<code>interface</code>，那么<code>getInterfaces()</code>返回空数组。</p>\n<h3 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h3><p>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Object</span> n = <span class=\"keyword\">Integer</span>.valueOf(<span class=\"number\">123</span>);</span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isDouble = n <span class=\"keyword\">instanceof</span> <span class=\"keyword\">Double</span>; <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isInteger = n <span class=\"keyword\">instanceof</span> <span class=\"keyword\">Integer</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isNumber = n <span class=\"keyword\">instanceof</span> Number; <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">boolean</span> isSerializable = n <span class=\"keyword\">instanceof</span> java.io.<span class=\"built_in\">Serializable</span>; <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>如果是两个<code>Class</code>实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Integer i = ?</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span><span class=\"keyword\">class</span>.is<span class=\"constructor\">AssignableFrom(Integer.<span class=\"params\">class</span>)</span>; <span class=\"comment\">// true，因为Integer可以赋值给Integer</span></span><br><span class=\"line\"><span class=\"comment\">// Number n = ?</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Number</span>.</span></span><span class=\"keyword\">class</span>.is<span class=\"constructor\">AssignableFrom(Integer.<span class=\"params\">class</span>)</span>; <span class=\"comment\">// true，因为Integer可以赋值给Number</span></span><br><span class=\"line\"><span class=\"comment\">// Object o = ?</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Object</span>.</span></span><span class=\"keyword\">class</span>.is<span class=\"constructor\">AssignableFrom(Integer.<span class=\"params\">class</span>)</span>; <span class=\"comment\">// true，因为Integer可以赋值给Object</span></span><br><span class=\"line\"><span class=\"comment\">// Integer i = ?</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span><span class=\"keyword\">class</span>.is<span class=\"constructor\">AssignableFrom(Number.<span class=\"params\">class</span>)</span>; <span class=\"comment\">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><p>我们来比较Java的<code>class</code>和<code>interface</code>的区别：</p>\n<ul>\n<li>可以实例化<code>class</code>（非<code>abstract</code>）；</li>\n<li>不能实例化<code>interface</code>。</li>\n</ul>\n<p>所有<code>interface</code>类型的变量总是通过某个实例向上转型并赋值给接口类型变量的：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">CharSequence cs</span> = new StringBuilder();</span><br></pre></td></tr></table></figure>\n\n<p>有没有可能不编写实现类，直接在运行期创建某个<code>interface</code>的实例呢？</p>\n<p>这是可能的，因为Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</p>\n<p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写：</p>\n<p>定义接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">morning</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写实现类：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">class</span> HelloWorld implements Hello &#123;</span><br><span class=\"line\">    <span class=\"built_in\">public</span> <span class=\"type\">void</span> morning(String <span class=\"type\">name</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Good morning, &quot; + <span class=\"type\">name</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建实例，转型为接口并调用：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hello hello = new HelloWorld()<span class=\"comment\">;</span></span><br><span class=\"line\">hello.morning(<span class=\"string\">&quot;Bob&quot;</span>)<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>这种方式就是我们通常编写代码的方式。</p>\n<p>还有一种方式是动态代码，我们仍然先定义了接口<code>Hello</code>，但是我们并不去编写实现类，而是直接通过JDK提供的一个<code>Proxy.newProxyInstance()</code>创建了一个<code>Hello</code>接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p>\n<p>一个最简单的动态代理实现如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.InvocationHandler;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Method;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Proxy;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>在运行期动态创建一个<code>interface</code>实例的方法如下：</p>\n<ol>\n<li><p>定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；</p>\n</li>\n<li><p>通过</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Proxy</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">ProxyInstance()</span></span><br></pre></td></tr></table></figure>\n\n<p>创建</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span></span></span><br></pre></td></tr></table></figure>\n\n<p>实例，它需要3个参数：</p>\n<ol>\n<li>使用的<code>ClassLoader</code>，通常就是接口类的<code>ClassLoader</code>；</li>\n<li>需要实现的接口数组，至少需要传入一个接口进去；</li>\n<li>用来处理接口方法调用的<code>InvocationHandler</code>实例。</li>\n</ol>\n</li>\n<li><p>将返回的<code>Object</code>强制转型为接口。</p>\n</li>\n</ol>\n<p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，它并没有什么黑魔法，把上面的动态代理改写为静态实现类大概长这样：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloDynamicProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    InvocationHandler <span class=\"keyword\">handler</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">HelloDynamicProxy</span><span class=\"params\">(InvocationHandler <span class=\"keyword\">handler</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">handler</span> = <span class=\"keyword\">handler</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">morning</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">handler</span>.invoke(</span><br><span class=\"line\">           <span class=\"keyword\">this</span>,</span><br><span class=\"line\">           Hello.class.getMethod(<span class=\"string\">&quot;morning&quot;</span>, String.class),</span><br><span class=\"line\">           <span class=\"keyword\">new</span> Object[] &#123; name &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其实就是JVM帮我们自动编写了一个上述类（不需要源码，可以直接生成字节码），并不存在可以直接实例化接口的黑魔法。</p>\n","categories":["Java","1.Java快速入门","04.反射"],"tags":["写作"]},{"title":"3.异常处理","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_3.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"<h1 id=\"Java的异常\"><a href=\"#Java的异常\" class=\"headerlink\" title=\"Java的异常\"></a>Java的异常</h1><p>在计算机程序运行的过程中，总是会出现各种各样的错误。</p>\n<p>有一些错误是用户造成的，比如，希望用户输入一个<code>int</code>类型的年龄，但是用户的输入是<code>abc</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设用户输入了abc：</span></span><br><span class=\"line\">String s = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> n = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(<span class=\"params\">s</span>)</span>; <span class=\"comment\">// NumberFormatException!</span></span><br></pre></td></tr></table></figure>\n\n<p>程序想要读写某个文件的内容，但是用户已经把它删除了：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 用户删除了该文件：</span><br><span class=\"line\">String t = readFile(<span class=\"string\">&quot;C:\\\\abc.txt&quot;</span>); <span class=\"regexp\">//</span> FileNotFoundException!</span><br></pre></td></tr></table></figure>\n\n<p>还有一些错误是随机出现，并且永远不可能避免的。比如：</p>\n<ul>\n<li>网络突然断了，连接不到远程服务器；</li>\n<li>内存耗尽，程序崩溃了；</li>\n<li>用户点“打印”，但根本没有打印机；</li>\n<li>……</li>\n</ul>\n<p>所以，一个健壮的程序必须处理各种各样的错误。</p>\n<p>所谓错误，就是程序调用某个函数的时候，如果失败了，就表示出错。</p>\n<p>调用方如何获知调用失败的信息？有两种方法：</p>\n<p>方法一：约定返回错误码。</p>\n<p>例如，处理一个文件，如果返回<code>0</code>，表示成功，返回其他整数，表示约定的错误码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> code = <span class=\"built_in\">processFile</span>(<span class=\"string\">&quot;C:\\\\test.txt&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (code == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ok:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error:</span></span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (code) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"comment\">// file not found:</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"comment\">// no read permission:</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"comment\">// unknown error:</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为使用<code>int</code>类型的错误码，想要处理就非常麻烦。这种方式常见于底层C函数。</p>\n<p>方法二：在语言层面上提供一个异常处理机制。</p>\n<p>Java内置了一套异常处理机制，总是使用异常来表示错误。</p>\n<p>异常是一种<code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> s = processFile(“C:\\\\test.txt”);</span><br><span class=\"line\">    <span class=\"comment\">// ok:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// file not found:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (SecurityException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// no read permission:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// io error:</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (<span class=\"built_in\">Exception</span> e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// other error:</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为Java的异常是<code>class</code>，它的继承关系如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                     ┌───────────┐</span><br><span class=\"line\">                     │  Object   │</span><br><span class=\"line\">                     └───────────┘</span><br><span class=\"line\">                           ▲</span><br><span class=\"line\">                           │</span><br><span class=\"line\">                     ┌───────────┐</span><br><span class=\"line\">                     │ Throwable │</span><br><span class=\"line\">                     └───────────┘</span><br><span class=\"line\">                           ▲</span><br><span class=\"line\">                 ┌─────────┴─────────┐</span><br><span class=\"line\">                 │                   │</span><br><span class=\"line\">           ┌───────────┐       ┌───────────┐</span><br><span class=\"line\">           │   Error   │       │ Exception │</span><br><span class=\"line\">           └───────────┘       └───────────┘</span><br><span class=\"line\">                 ▲                   ▲</span><br><span class=\"line\">         ┌───────┘              ┌────┴──────────┐</span><br><span class=\"line\">         │                      │               │</span><br><span class=\"line\">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class=\"line\">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class=\"line\">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class=\"line\">                                ▲</span><br><span class=\"line\">                    ┌───────────┴─────────────┐</span><br><span class=\"line\">                    │                         │</span><br><span class=\"line\">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class=\"line\">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class=\"line\">         └─────────────────────┘ └─────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>从继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p>\n<ul>\n<li><code>OutOfMemoryError</code>：内存耗尽</li>\n<li><code>NoClassDefFoundError</code>：无法加载某个Class</li>\n<li><code>StackOverflowError</code>：栈溢出</li>\n</ul>\n<p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p>\n<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p>\n<ul>\n<li><code>NumberFormatException</code>：数值类型的格式错误</li>\n<li><code>FileNotFoundException</code>：未找到文件</li>\n<li><code>SocketException</code>：读取网络失败</li>\n</ul>\n<p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p>\n<ul>\n<li><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</li>\n<li><code>IndexOutOfBoundsException</code>：数组索引越界</li>\n</ul>\n<p><code>Exception</code>又分为两大类：</p>\n<ol>\n<li><code>RuntimeException</code>以及它的子类；</li>\n<li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li>\n</ol>\n<p>Java规定：</p>\n<ul>\n<li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为Checked Exception。</li>\n<li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li>\n</ul>\n<p> 注意：编译器对RuntimeException及其子类不做强制捕获要求，不是指应用程序本身不应该捕获并处理RuntimeException。是否需要捕获，具体问题具体分析。</p>\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p>捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try...catch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果我们不捕获<code>UnsupportedEncodingException</code>，会出现编译失败的问题：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try...catch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是<code>return s.getBytes(&quot;GBK&quot;);</code>。意思是说，像<code>UnsupportedEncodingException</code>这样的Checked Exception，必须被捕获。</p>\n<p>这是因为<code>String.getBytes(String)</code>方法定义是：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">byte</span>[] getBytes(<span class=\"keyword\">String</span> charsetName) <span class=\"keyword\">throws</span> UnsupportedEncodingException &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p>\n<p>在<code>toGBK()</code>方法中，因为调用了<code>String.getBytes(String)</code>方法，就必须捕获<code>UnsupportedEncodingException</code>。我们也可以不捕获它，而是在方法定义处用throws表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>，就可以让<code>toGBK()</code>方法通过编译器检查：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try...catch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码仍然会得到编译错误，但这一次，编译器提示的不是调用<code>return s.getBytes(&quot;GBK&quot;);</code>的问题，而是<code>byte[] bs = toGBK(&quot;中文&quot;);</code>。因为在<code>main()</code>方法中，调用<code>toGBK()</code>，没有捕获它声明的可能抛出的<code>UnsupportedEncodingException</code>。</p>\n<p>修复方法是在<code>main()</code>方法中捕获异常并处理：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try...catch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>可见，只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p>\n<p>如果是测试代码，上面的写法就略显麻烦。如果不想写任何<code>try</code>代码，可以直接把<code>main()</code>方法定义为<code>throws Exception</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// try...catch</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为<code>main()</code>方法声明了可能抛出<code>Exception</code>，也就声明了可能抛出所有的<code>Exception</code>，因此在内部就无需捕获了。代价就是一旦发生异常，程序会立刻退出。</p>\n<p>还有一些童鞋喜欢在<code>toGBK()</code>内部“消化”异常：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> byte[] <span class=\"function\"><span class=\"title\">toGBK</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 什么也不干</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这种捕获后不处理的方式是非常不好的，即使真的什么也做不了，也要先把异常记录下来：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> byte[] <span class=\"function\"><span class=\"title\">toGBK</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.getBytes(<span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先记下来再说:</span></span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p>\n<h1 id=\"捕获异常-1\"><a href=\"#捕获异常-1\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h1><p>在Java中，凡是可能抛出异常的语句，都可以用<code>try ... catch</code>捕获。把可能发生异常的语句放在<code>try &#123; ... &#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类。</p>\n<h3 id=\"多catch语句\"><a href=\"#多catch语句\" class=\"headerlink\" title=\"多catch语句\"></a>多catch语句</h3><p>可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后<em>不再</em>继续匹配。</p>\n<p>简单地说就是：多个<code>catch</code>语句只有一个能被执行。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">process1</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process2</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process3</span>();</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(e);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (NumberFormatException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：子类必须写在前面。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">process1</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process2</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process3</span>();</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;IO error&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (UnsupportedEncodingException e) &#123; <span class=\"comment\">// 永远捕获不到</span></span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Bad encoding&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于上面的代码，<code>UnsupportedEncodingException</code>异常是永远捕获不到的，因为它是<code>IOException</code>的子类。当抛出<code>UnsupportedEncodingException</code>异常时，会被<code>catch (IOException e) &#123; ... &#125;</code>捕获并执行。</p>\n<p>因此，正确的写法是把子类放到前面：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">process1</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process2</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process3</span>();</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Bad encoding&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;IO error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finally语句\"><a href=\"#finally语句\" class=\"headerlink\" title=\"finally语句\"></a>finally语句</h3><p>无论是否有异常发生，如果我们都希望执行一些语句，例如清理工作，怎么写？</p>\n<p>可以把执行语句写若干遍：正常执行的放到<code>try</code>中，每个<code>catch</code>再写一遍。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">process1</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process2</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process3</span>();</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;END&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Bad encoding&quot;</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;END&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;IO error&quot;</span>);</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;END&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码无论是否发生异常，都会执行<code>System.out.println(&quot;END&quot;);</code>这条语句。</p>\n<p>那么如何消除这些重复的代码？Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。上述代码可以改写如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">process1</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process2</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process3</span>();</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (UnsupportedEncodingException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Bad encoding&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;IO error&quot;</span>);</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;END&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意<code>finally</code>有几个特点：</p>\n<ol>\n<li><code>finally</code>语句不是必须的，可写可不写；</li>\n<li><code>finally</code>总是最后执行。</li>\n</ol>\n<p>如果没有发生异常，就正常执行<code>try &#123; ... &#125;</code>语句块，然后执行<code>finally</code>。如果发生了异常，就中断执行<code>try &#123; ... &#125;</code>语句块，然后跳转执行匹配的<code>catch</code>语句块，最后执行<code>finally</code>。</p>\n<p>可见，<code>finally</code>是用来保证一些代码必须执行的。</p>\n<p>某些情况下，可以没有<code>catch</code>，只使用<code>try ... finally</code>结构。例如：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> process(String <span class=\"keyword\">file</span>) <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">&quot;END&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为方法声明了可能抛出的异常，所以可以不写<code>catch</code>。</p>\n<h3 id=\"捕获多种异常\"><a href=\"#捕获多种异常\" class=\"headerlink\" title=\"捕获多种异常\"></a>捕获多种异常</h3><p>如果某些异常的处理逻辑相同，但是异常本身不存在继承关系，那么就得编写多条<code>catch</code>子句：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">process1</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process2</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process3</span>();</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (IOException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Bad input&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (NumberFormatException e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Bad input&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (Exception e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Unknown error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为处理<code>IOException</code>和<code>NumberFormatException</code>的代码是相同的，所以我们可以把它两用<code>|</code>合并到一起：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">process1</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process2</span>();</span><br><span class=\"line\">        <span class=\"built_in\">process3</span>();</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (IOException | NumberFormatException e) &#123; <span class=\"comment\">// IOException或NumberFormatException</span></span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Bad input&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (Exception e) &#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Unknown error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h1><h3 id=\"异常的传播\"><a href=\"#异常的传播\" class=\"headerlink\" title=\"异常的传播\"></a>异常的传播</h3><p>当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> exception</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>通过<code>printStackTrace()</code>可以打印出方法的调用栈，类似：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.NumberFormatException: null</span><br><span class=\"line\">    at java.base/java.lang.<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(Integer.<span class=\"params\">java</span>:614)</span></span><br><span class=\"line\">    at java.base/java.lang.<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(Integer.<span class=\"params\">java</span>:770)</span></span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>process2(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">16</span>)</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>process1(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">12</span>)</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>main(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p>\n<ol>\n<li><code>main()</code>调用<code>process1()</code>；</li>\n<li><code>process1()</code>调用<code>process2()</code>；</li>\n<li><code>process2()</code>调用<code>Integer.parseInt(String)</code>；</li>\n<li><code>Integer.parseInt(String)</code>调用<code>Integer.parseInt(String, int)</code>。</li>\n</ol>\n<p>查看<code>Integer.java</code>源码可知，抛出异常的方法代码如下：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">parseInt</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> radix)</span> <span class=\"keyword\">throws</span> NumberFormatException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NumberFormatException(<span class=\"string\">&quot;null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且，每层调用均给出了源代码的行号，可直接定位。</p>\n<h3 id=\"抛出异常-1\"><a href=\"#抛出异常-1\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h3><p>当发生错误时，例如，用户输入了非法的字符，我们就可以抛出异常。</p>\n<p>如何抛出异常？参考<code>Integer.parseInt()</code>方法，抛出异常分两步：</p>\n<ol>\n<li>创建某个<code>Exception</code>的实例；</li>\n<li>用<code>throw</code>语句抛出。</li>\n</ol>\n<p>下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"title\">process2</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        NullPointerException e = <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，绝大部分抛出异常的代码都会合并写成一行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"title\">process2</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"title\">process1</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        process2();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (NullPointerException e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"title\">process2</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s==<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当<code>process2()</code>抛出<code>NullPointerException</code>后，被<code>process1()</code>捕获，然后抛出<code>IllegalArgumentException()</code>。</p>\n<p>如果在<code>main()</code>中捕获<code>IllegalArgumentException</code>，我们看看打印的异常栈：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> exception</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>打印出的异常栈类似：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>process1(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">15</span>)</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>main(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这说明新的异常丢失了原始异常信息，我们已经看不到原始异常<code>NullPointerException</code>的信息了。</p>\n<p>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。对上述代码改进如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> exception</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，打印出的异常栈类似：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>process1(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">15</span>)</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>main(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">5</span>)</span><br><span class=\"line\">Caused by: java.lang.NullPointerException</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>process2(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">20</span>)</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>process1(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">13</span>)</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>Caused by: Xxx</code>，说明捕获的<code>IllegalArgumentException</code>并不是造成问题的根源，根源在于<code>NullPointerException</code>，是在<code>Main.process2()</code>方法抛出的。</p>\n<p>在代码中获取原始异常可以使用<code>Throwable.getCause()</code>方法。如果返回<code>null</code>，说明已经是“根异常”了。</p>\n<p>有了完整的异常栈的信息，我们才能快速定位并修复代码的问题。</p>\n<p> 捕获到异常并再次抛出时，一定要留住原始异常，否则很难定位第一案发现场！</p>\n<p>如果我们在<code>try</code>或者<code>catch</code>语句块中抛出异常，<code>finally</code>语句是否会执行？例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> exception</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码执行结果如下：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">catched</span><br><span class=\"line\">finally</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.RuntimeException</span>: java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.NumberFormatException</span>: For <span class=\"selector-tag\">input</span> string: <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">    at Main<span class=\"selector-class\">.main</span>(Main<span class=\"selector-class\">.java</span>:<span class=\"number\">8</span>)</span><br><span class=\"line\">Caused by: java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.NumberFormatException</span>: For <span class=\"selector-tag\">input</span> string: <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">    at ...</span><br></pre></td></tr></table></figure>\n\n<p>第一行打印了<code>catched</code>，说明进入了<code>catch</code>语句块。第二行打印了<code>finally</code>，说明执行了<code>finally</code>语句块。</p>\n<p>因此，在<code>catch</code>中抛出异常，不会影响<code>finally</code>的执行。JVM会先执行<code>finally</code>，然后抛出异常。</p>\n<h3 id=\"异常屏蔽\"><a href=\"#异常屏蔽\" class=\"headerlink\" title=\"异常屏蔽\"></a>异常屏蔽</h3><p>如果在执行<code>finally</code>语句时抛出异常，那么，<code>catch</code>语句的异常还能否继续抛出？例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> exception</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>执行上述代码，发现异常信息如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">catched</span><br><span class=\"line\">finally</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java.lang.IllegalArgumentException</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>main(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">11</span>)</span><br></pre></td></tr></table></figure>\n\n<p>这说明<code>finally</code>抛出异常后，原来在<code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）。</p>\n<p>在极少数的情况下，我们需要获知所有的异常。如何保存所有的异常信息？方法是先用<code>origin</code>变量保存原始异常，然后调用<code>Throwable.addSuppressed()</code>，把原始异常添加进来，最后在<code>finally</code>抛出：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> exception</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>当<code>catch</code>和<code>finally</code>都抛出了异常时，虽然<code>catch</code>的异常被屏蔽了，但是，<code>finally</code>抛出的异常仍然包含了它：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java.lang.IllegalArgumentException</span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>main(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">11</span>)</span><br><span class=\"line\">Suppressed: java.lang.NumberFormatException: For input <span class=\"built_in\">string</span>: <span class=\"string\">&quot;abc&quot;</span></span><br><span class=\"line\">    at java.base/java.lang.<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">NumberFormatException</span>.</span></span><span class=\"keyword\">for</span><span class=\"constructor\">InputString(NumberFormatException.<span class=\"params\">java</span>:65)</span></span><br><span class=\"line\">    at java.base/java.lang.<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(Integer.<span class=\"params\">java</span>:652)</span></span><br><span class=\"line\">    at java.base/java.lang.<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(Integer.<span class=\"params\">java</span>:770)</span></span><br><span class=\"line\">    at <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>main(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">6</span>)</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>Throwable.getSuppressed()</code>可以获取所有的<code>Suppressed Exception</code>。</p>\n<p>绝大多数情况下，在<code>finally</code>中不要抛出异常。因此，我们通常不需要关心<code>Suppressed Exception</code>。</p>\n<h3 id=\"提问时贴出异常\"><a href=\"#提问时贴出异常\" class=\"headerlink\" title=\"提问时贴出异常\"></a>提问时贴出异常</h3><p>异常打印的详细的栈信息是找出问题的关键，许多初学者在提问时只贴代码，不贴异常，相当于只报案不给线索，福尔摩斯也无能为力。</p>\n<p><img src=\"/3.%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.assets/l.png\" alt=\"谁教你提问不贴异常栈\"></p>\n<p>还有的童鞋只贴部分异常信息，最关键的<code>Caused by: xxx</code>给省略了，这都属于不正确的提问方式，得改。</p>\n<h1 id=\"自定义异常\"><a href=\"#自定义异常\" class=\"headerlink\" title=\"自定义异常\"></a>自定义异常</h1><p>Java标准库定义的常用异常包括：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception</span><br><span class=\"line\">│</span><br><span class=\"line\">├─ RuntimeException</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─ NullPointerException</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─ IndexOutOfBoundsException</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─ SecurityException</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─ IllegalArgumentException</span><br><span class=\"line\">│     │</span><br><span class=\"line\">│     └─ NumberFormatException</span><br><span class=\"line\">│</span><br><span class=\"line\">├─ IOException</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─ UnsupportedCharsetException</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  ├─ FileNotFoundException</span><br><span class=\"line\">│  │</span><br><span class=\"line\">│  └─ SocketException</span><br><span class=\"line\">│</span><br><span class=\"line\">├─ ParseException</span><br><span class=\"line\">│</span><br><span class=\"line\">├─ GeneralSecurityException</span><br><span class=\"line\">│</span><br><span class=\"line\">├─ SQLException</span><br><span class=\"line\">│</span><br><span class=\"line\">└─ TimeoutException</span><br></pre></td></tr></table></figure>\n\n<p>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型。例如，参数检查不合法，应该抛出<code>IllegalArgumentException</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">process1</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (age &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">IllegalArgumentException</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p>\n<p>一个常见的做法是自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</p>\n<p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseException</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserNotFoundException</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginFailedException</span> <span class=\"keyword\">extends</span> <span class=\"title\">BaseException</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>自定义的<code>BaseException</code>应该提供多个构造方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaseException</span> <span class=\"keyword\">extends</span> <span class=\"title\">RuntimeException</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">BaseException</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">BaseException</span>(<span class=\"params\"><span class=\"built_in\">String</span> message, Throwable cause</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message, cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">BaseException</span>(<span class=\"params\"><span class=\"built_in\">String</span> message</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">BaseException</span>(<span class=\"params\">Throwable cause</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(cause);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述构造方法实际上都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p>\n<h1 id=\"NullPointerException\"><a href=\"#NullPointerException\" class=\"headerlink\" title=\"NullPointerException\"></a>NullPointerException</h1><p>在所有的<code>RuntimeException</code>异常中，Java程序员最熟悉的恐怕就是<code>NullPointerException</code>了。</p>\n<p><code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生<code>NullPointerException</code>，这个异常通常是由JVM抛出的，例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> NullPointerException</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>指针这个概念实际上源自C语言，Java语言中并无指针。我们定义的变量实际上是引用，Null Pointer更确切地说是Null Reference，不过两者区别不大。</p>\n<h3 id=\"处理NullPointerException\"><a href=\"#处理NullPointerException\" class=\"headerlink\" title=\"处理NullPointerException\"></a>处理NullPointerException</h3><p>如果遇到<code>NullPointerException</code>，我们应该如何处理？首先，必须明确，<code>NullPointerException</code>是一种代码逻辑错误，遇到<code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用<code>catch</code>来隐藏这种编码错误：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误示例: 捕获NullPointerException</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    transfer<span class=\"constructor\">Money(<span class=\"params\">from</span>, <span class=\"params\">to</span>, <span class=\"params\">amount</span>)</span>;</span><br><span class=\"line\">&#125; catch (NullPointerException e) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好的编码习惯可以极大地降低<code>NullPointerException</code>的产生，例如：</p>\n<p>成员变量在定义时初始化：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> name = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用空字符串<code>&quot;&quot;</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>，编写业务逻辑时，用空字符串<code>&quot;&quot;</code>表示未填写比<code>null</code>安全得多。</p>\n<p>返回空字符串<code>&quot;&quot;</code>、空数组而不是<code>null</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">String</span>[] <span class=\"function\"><span class=\"title\">readLinesFromFile</span>(<span class=\"params\"><span class=\"built_in\">String</span> file</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getFileSize(file) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 返回空数组而不是null:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样可以使得调用方无需检查结果是否为<code>null</code>。</p>\n<p>如果调用方一定要根据<code>null</code>判断，比如返回<code>null</code>表示文件不存在，那么考虑返回<code>Optional&lt;T&gt;</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public Optional&lt;String&gt; read<span class=\"constructor\">FromFile(String <span class=\"params\">file</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!file<span class=\"constructor\">Exist(<span class=\"params\">file</span>)</span>) &#123;</span><br><span class=\"line\">        return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Optional</span>.</span></span>empty<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样调用方必须通过<code>Optional.isPresent()</code>判断是否有结果。</p>\n<h3 id=\"定位NullPointerException\"><a href=\"#定位NullPointerException\" class=\"headerlink\" title=\"定位NullPointerException\"></a>定位NullPointerException</h3><p>如果产生了<code>NullPointerException</code>，例如，调用<code>a.b.c.x()</code>时产生了<code>NullPointerException</code>，原因可能是：</p>\n<ul>\n<li><code>a</code>是<code>null</code>；</li>\n<li><code>a.b</code>是<code>null</code>；</li>\n<li><code>a.b.c</code>是<code>null</code>；</li>\n</ul>\n<p>确定到底是哪个对象是<code>null</code>以前只能打印这样的日志：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(a);</span><br><span class=\"line\"><span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(a.b);</span><br><span class=\"line\"><span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(a.b.c);</span><br></pre></td></tr></table></figure>\n\n<p>从Java 14开始，如果产生了<code>NullPointerException</code>，JVM可以给出详细的信息告诉我们<code>null</code>对象到底是谁。我们来看例子：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>可以在<code>NullPointerException</code>的详细信息中看到类似<code>... because &quot;&lt;local1&gt;.address.city&quot; is null</code>，意思是<code>city</code>字段为<code>null</code>，这样我们就能快速定位问题所在。</p>\n<p>这种增强的<code>NullPointerException</code>详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个<code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">java </span>-XX:+<span class=\"keyword\">ShowCodeDetailsInExceptionMessages </span>Main.<span class=\"keyword\">java</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用断言\"><a href=\"#使用断言\" class=\"headerlink\" title=\"使用断言\"></a>使用断言</h1><p>断言（Assertion）是一种调试程序的方式。在Java中，使用<code>assert</code>关键字来实现断言。</p>\n<p>我们先看一个例子：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x = Math.<span class=\"built_in\">abs</span>(<span class=\"number\">-123.45</span>);</span><br><span class=\"line\">    assert x &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。</p>\n<p>使用<code>assert</code>语句时，还可以添加一个可选的断言消息：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">assert</span> x &gt;= <span class=\"number\">0</span> : <span class=\"string\">&quot;x must &gt;= 0&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试。</p>\n<p>Java断言的特点是：断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</p>\n<p>对于可恢复的程序错误，不应该使用断言。例如：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> arr != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>应该抛出异常并在上层捕获：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (arr == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;array cannot be null&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们在程序中使用<code>assert</code>时，例如，一个简单的断言：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> assert</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>断言<code>x</code>必须大于<code>0</code>，实际上<code>x</code>为<code>-1</code>，断言肯定失败。执行上述代码，发现程序并未抛出<code>AssertionError</code>，而是正常打印了<code>x</code>的值。</p>\n<p>这是怎么肥四？为什么<code>assert</code>语句不起作用？</p>\n<p>这是因为JVM默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。</p>\n<p>要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java -ea <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java</span><br><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class=\"line\">\tat <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>main(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span>java:<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n\n<p>还可以有选择地对特定地类启用断言，命令行参数是：<code>-ea:com.itranswarp.sample.Main</code>，表示只对<code>com.itranswarp.sample.Main</code>这个类启用断言。</p>\n<p>或者对特定地包启用断言，命令行参数是：<code>-ea:com.itranswarp.sample...</code>（注意结尾有3个<code>.</code>），表示对<code>com.itranswarp.sample</code>这个包启动断言。</p>\n<p>实际开发中，很少使用断言。更好的方法是编写单元测试，后续我们会讲解<code>JUnit</code>的使用。</p>\n<h1 id=\"使用JDK-Logging\"><a href=\"#使用JDK-Logging\" class=\"headerlink\" title=\"使用JDK. Logging\"></a>使用JDK. Logging</h1><p>在编写程序的过程中，发现程序运行结果与预期不符，怎么办？当然是用<code>System.out.println()</code>打印出执行过程中的某些变量，观察每一步的结果与代码逻辑是否符合，然后有针对性地修改代码。</p>\n<p>代码改好了怎么办？当然是删除没有用的<code>System.out.println()</code>语句了。</p>\n<p>如果改代码又改出问题怎么办？再加上<code>System.out.println()</code>。</p>\n<p>反复这么搞几次，很快大家就发现使用<code>System.out.println()</code>非常麻烦。</p>\n<p>怎么办？</p>\n<p>解决方法是使用日志。</p>\n<p>那什么是日志？日志就是Logging，它的目的是为了取代<code>System.out.println()</code>。</p>\n<p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p>\n<ol>\n<li>可以设置输出样式，避免自己每次都写<code>&quot;ERROR: &quot; + var</code>；</li>\n<li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li>\n<li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li>\n<li>可以按包名控制日志级别，只输出某些包打的日志；</li>\n<li>可以……</li>\n</ol>\n<p>总之就是好处很多啦。</p>\n<p>那如何使用日志？</p>\n<p>因为Java标准库内置了日志包<code>java.util.logging</code>，我们可以直接用。先看一个简单的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// logging</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Level;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，得到类似如下的输出：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Mar</span> <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\"><span class=\"attribute\">INFO</span>: start process...</span><br><span class=\"line\"><span class=\"attribute\">Mar</span> <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\"><span class=\"attribute\">WARNING</span>: memory is running out...</span><br><span class=\"line\"><span class=\"attribute\">Mar</span> <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">6</span>:<span class=\"number\">32</span>:<span class=\"number\">13</span> PM Hello main</span><br><span class=\"line\"><span class=\"attribute\">SEVERE</span>: process will be terminated...</span><br></pre></td></tr></table></figure>\n\n<p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。</p>\n<p>再仔细观察发现，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：</p>\n<ul>\n<li>SEVERE</li>\n<li>WARNING</li>\n<li>INFO</li>\n<li>CONFIG</li>\n<li>FINE</li>\n<li>FINER</li>\n<li>FINEST</li>\n</ul>\n<p>因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p>\n<p>使用Java标准库内置的Logging有以下局限：</p>\n<p>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p>\n<p>配置不太方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p>\n<p>因此，Java标准库内置的Logging使用并不是非常广泛。更方便的日志系统我们稍后介绍。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>使用logger.severe()打印异常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h1 id=\"使用Commons-Logging\"><a href=\"#使用Commons-Logging\" class=\"headerlink\" title=\"使用Commons. Logging\"></a>使用Commons. Logging</h1><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p>\n<p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。</p>\n<p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>\n<p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； 第二步，使用<code>Log</code>实例的方法打日志。</p>\n<p>示例代码如下：</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.<span class=\"built_in\">Log</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.commons.logging.LogFactory;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，肯定会得到编译错误，类似<code>error: package org.apache.commons.logging does not exist</code>（找不到<code>org.apache.commons.logging</code>这个包）。因为Commons Logging是一个第三方提供的库，所以，必须先把它<a href=\"https://commons.apache.org/proper/commons-logging/download_logging.cgi\">下载</a>下来。下载后，解压，找到<code>commons-logging-1.2.jar</code>这个文件，再把Java源码<code>Main.java</code>放到一个目录下，例如<code>work</code>目录：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">work</span><br><span class=\"line\">│</span><br><span class=\"line\">├─ commons-logging-1.2.jar</span><br><span class=\"line\">│</span><br><span class=\"line\">└─ Main.java</span><br></pre></td></tr></table></figure>\n\n<p>然后用<code>javac</code>编译<code>Main.java</code>，编译的时候要指定<code>classpath</code>，不然编译器找不到我们引用的<code>org.apache.commons.logging</code>包。编译命令如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">javac</span> -cp commons-logging-<span class=\"number\">1</span>.<span class=\"number\">2</span>.jar Main.java</span><br></pre></td></tr></table></figure>\n\n<p>如果编译成功，那么当前目录下就会多出一个<code>Main.class</code>文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">work</span><br><span class=\"line\">│</span><br><span class=\"line\">├─ commons-logging-1.2.jar</span><br><span class=\"line\">│</span><br><span class=\"line\">├─ Main.java</span><br><span class=\"line\">│</span><br><span class=\"line\">└─ Main.class</span><br></pre></td></tr></table></figure>\n\n<p>现在可以执行这个<code>Main.class</code>，使用<code>java</code>命令，也必须指定<code>classpath</code>，命令如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">java</span> -cp .;commons-logging-<span class=\"number\">1</span>.<span class=\"number\">2</span>.jar Main</span><br></pre></td></tr></table></figure>\n\n<p>注意到传入的<code>classpath</code>有两部分：一个是<code>.</code>，一个是<code>commons-logging-1.2.jar</code>，用<code>;</code>分割。<code>.</code>表示当前目录，如果没有这个<code>.</code>，JVM不会在当前目录搜索<code>Main.class</code>，就会报错。</p>\n<p>如果在Linux或macOS下运行，注意<code>classpath</code>的分隔符不是<code>;</code>，而是<code>:</code>：</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -cp .<span class=\"symbol\">:commons-logging-</span><span class=\"number\">1.2</span>.jar Main</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Mar</span> <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">7</span>:<span class=\"number\">15</span>:<span class=\"number\">31</span> PM Main main</span><br><span class=\"line\"><span class=\"attribute\">INFO</span>: start...</span><br><span class=\"line\"><span class=\"attribute\">Mar</span> <span class=\"number\">02</span>, <span class=\"number\">2019</span> <span class=\"number\">7</span>:<span class=\"number\">15</span>:<span class=\"number\">31</span> PM Main main</span><br><span class=\"line\"><span class=\"attribute\">WARNING</span>: end.</span><br></pre></td></tr></table></figure>\n\n<p>Commons Logging定义了6个日志级别：</p>\n<ul>\n<li>FATAL</li>\n<li>ERROR</li>\n<li>WARNING</li>\n<li>INFO</li>\n<li>DEBUG</li>\n<li>TRACE</li>\n</ul>\n<p>默认级别是<code>INFO</code>。</p>\n<p>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常直接定义一个静态类型变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在静态方法中引用Log:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Log log = LogFactory.<span class=\"built_in\">getLog</span>(Main.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.<span class=\"built_in\">info</span>(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实例方法中引用<code>Log</code>，通常定义一个实例变量：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在实例方法中引用Log:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> Log log = LogFactory.<span class=\"built_in\">getLog</span>(<span class=\"built_in\">getClass</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.<span class=\"built_in\">info</span>(<span class=\"string\">&quot;foo&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到实例变量log的获取方式是<code>LogFactory.getLog(getClass())</code>，虽然也可以用<code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该<code>log</code>实例。例如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在子类中使用父类实例化的log:</span></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    void bar() &#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;bar&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于Java类的动态特性，子类获取的<code>log</code>字段实际上相当于<code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p>\n<p>此外，Commons Logging的日志方法，例如<code>info()</code>，除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p>\n<figure class=\"highlight monkey\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">log</span>.<span class=\"built_in\">error</span>(<span class=\"string\">&quot;got exception!&quot;</span>, e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用Log4j\"><a href=\"#使用Log4j\" class=\"headerlink\" title=\"使用Log4j\"></a>使用Log4j</h1><p>前面介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p>\n<p>Log4j是一种非常流行的日志框架，最新版本是2.x。</p>\n<p>Log4j是一个组件化设计的日志系统，它的架构大致如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">log.info(&quot;User signed in.&quot;);</span><br><span class=\"line\"> │</span><br><span class=\"line\"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class=\"line\"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │</span><br><span class=\"line\"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class=\"line\"> │</span><br><span class=\"line\"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class=\"line\"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │</span><br><span class=\"line\"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class=\"line\"> │</span><br><span class=\"line\"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class=\"line\"> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │</span><br><span class=\"line\">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure>\n\n<p>当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p>\n<ul>\n<li>console：输出到屏幕；</li>\n<li>file：输出到文件；</li>\n<li>socket：通过网络输出到远程计算机；</li>\n<li>jdbc：输出到数据库</li>\n</ul>\n<p>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出<code>ERROR</code>级别的日志。</p>\n<p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p>\n<p>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</p>\n<p>以XML配置为例，使用Log4j的时候，我们把一个<code>log4j2.xml</code>的文件放到<code>classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Configuration</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">Properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- 定义日志格式 --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">Property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;log.pattern&quot;</span>&gt;</span>%d</span><span class=\"template-variable\">&#123;MM-dd HH:mm:ss.SSS&#125;</span><span class=\"xml\"> [%t] %-5level %logger</span><span class=\"template-variable\">&#123;36&#125;</span><span class=\"xml\">%n%msg%n%n<span class=\"tag\">&lt;/<span class=\"name\">Property</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- 定义文件名变量 --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">Property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class=\"tag\">&lt;/<span class=\"name\">Property</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">Property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class=\"tag\">&lt;/<span class=\"name\">Property</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">Properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"comment\">&lt;!-- 定义Appender，即目的地 --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">Appenders</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- 定义输出到屏幕 --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">Console</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;console&quot;</span> <span class=\"attr\">target</span>=<span class=\"string\">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"comment\">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;$</span></span></span><span class=\"template-variable\">&#123;log.pattern&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">Console</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"comment\">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">RollingFile</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;err&quot;</span> <span class=\"attr\">bufferedIO</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">fileName</span>=<span class=\"string\">&quot;$</span></span></span><span class=\"template-variable\">&#123;file.err.filename&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">&quot;</span> <span class=\"attr\">filePattern</span>=<span class=\"string\">&quot;$</span></span></span><span class=\"template-variable\">&#123;file.err.pattern&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">PatternLayout</span> <span class=\"attr\">pattern</span>=<span class=\"string\">&quot;$</span></span></span><span class=\"template-variable\">&#123;log.pattern&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">Policies</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"comment\">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">SizeBasedTriggeringPolicy</span> <span class=\"attr\">size</span>=<span class=\"string\">&quot;1 MB&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">Policies</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"comment\">&lt;!-- 保留最近10份 --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">DefaultRolloverStrategy</span> <span class=\"attr\">max</span>=<span class=\"string\">&quot;10&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">RollingFile</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">Appenders</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">Loggers</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">Root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"comment\">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;console&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"comment\">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">AppenderRef</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;err&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;error&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">Root</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">Loggers</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">Configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是<code>INFO</code>级别的日志，会自动输出到屏幕，而<code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p>\n<p>有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从<a href=\"https://logging.apache.org/log4j/2.x/download.html\">这里</a>下载Log4j，解压后，把以下3个jar包放到<code>classpath</code>中：</p>\n<ul>\n<li>log4j-api-2.x.jar</li>\n<li>log4j-core-2.x.jar</li>\n<li>log4j-jcl-2.x.jar</li>\n</ul>\n<p>因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的<code>commons-logging-1.2.jar</code>也放到<code>classpath</code>中。</p>\n<p>要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">03</span>-<span class=\"number\">03</span> <span class=\"number\">12</span>:<span class=\"number\">09</span>:<span class=\"number\">45</span>.<span class=\"number\">880</span><span class=\"meta\"> [main] INFO  com.itranswarp.learnjava.Main</span></span><br><span class=\"line\"><span class=\"meta\">Start process...</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入<code>classpath</code>，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p>\n<h1 id=\"使用SLF4J和Logback\"><a href=\"#使用SLF4J和Logback\" class=\"headerlink\" title=\"使用SLF4J和Logback\"></a>使用SLF4J和Logback</h1><p>前面介绍了Commons Logging和Log4j这一对好基友，它们一个负责充当日志API，一个负责实现日志底层，搭配使用非常便于开发。</p>\n<p>有的童鞋可能还听说过SLF4J和Logback。这两个东东看上去也像日志，它们又是啥？</p>\n<p>其实SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p>\n<p>为什么有了Commons Logging和Log4j，又会蹦出来SLF4J和Logback？这是因为Java有着非常悠久的开源历史，不但OpenJDK本身是开源的，而且我们用到的第三方库，几乎全部都是开源的。开源生态丰富的一个特定就是，同一个功能，可以找到若干种互相竞争的开源库。</p>\n<p>因为对Commons Logging的接口不满意，有人就搞了SLF4J。因为对Log4j的性能不满意，有人就搞了Logback。</p>\n<p>我们先来看看SLF4J对Commons Logging的接口有何改进。在Commons Logging中，我们要打印日志，有时候得这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> score = <span class=\"number\">99</span>;</span><br><span class=\"line\">p.set<span class=\"constructor\">Score(<span class=\"params\">score</span>)</span>;</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;Set score &quot;</span> + score + <span class=\"string\">&quot; for Person &quot;</span> + p.get<span class=\"constructor\">Name()</span> + <span class=\"string\">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> score = <span class=\"number\">99</span>;</span><br><span class=\"line\">p.set<span class=\"constructor\">Score(<span class=\"params\">score</span>)</span>;</span><br><span class=\"line\">logger.info(<span class=\"string\">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.get<span class=\"constructor\">Name()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们靠猜也能猜出来，SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p>\n<p>如何使用SLF4J？它的接口实际上和Commons Logging几乎一模一样：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.Logger;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.slf4j.LoggerFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Main</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对比一下Commons Logging和SLF4J的接口：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Commons Logging</th>\n<th align=\"left\">SLF4J</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">org.apache.commons.logging.Log</td>\n<td align=\"left\">org.slf4j.Logger</td>\n</tr>\n<tr>\n<td align=\"left\">org.apache.commons.logging.LogFactory</td>\n<td align=\"left\">org.slf4j.LoggerFactory</td>\n</tr>\n</tbody></table>\n<p>不同之处就是Log变成了Logger，LogFactory变成了LoggerFactory。</p>\n<p>使用SLF4J和Logback和前面讲到的使用Commons Logging加Log4j是类似的，先分别下载<a href=\"https://www.slf4j.org/download.html\">SLF4J</a>和<a href=\"https://logback.qos.ch/download.html\">Logback</a>，然后把以下jar包放到classpath下：</p>\n<ul>\n<li>slf4j-api-1.7.x.jar</li>\n<li>logback-classic-1.2.x.jar</li>\n<li>logback-core-1.2.x.jar</li>\n</ul>\n<p>然后使用SLF4J的Logger和LoggerFactory即可。和Log4j类似，我们仍然需要一个Logback的配置文件，把<code>logback.xml</code>放到classpath下，配置如下：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;CONSOLE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d</span><span class=\"template-variable\">&#123;HH:mm:ss.SSS&#125;</span><span class=\"xml\"> [%thread] %-5level %logger</span><span class=\"template-variable\">&#123;36&#125;</span><span class=\"xml\"> - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;FILE&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">encoder</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">pattern</span>&gt;</span>%d</span><span class=\"template-variable\">&#123;HH:mm:ss.SSS&#125;</span><span class=\"xml\"> [%thread] %-5level %logger</span><span class=\"template-variable\">&#123;36&#125;</span><span class=\"xml\"> - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">pattern</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">charset</span>&gt;</span>utf-8<span class=\"tag\">&lt;/<span class=\"name\">charset</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">encoder</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">file</span>&gt;</span>log/output.log<span class=\"tag\">&lt;/<span class=\"name\">file</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">rollingPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">fileNamePattern</span>&gt;</span>log/output.log.%i<span class=\"tag\">&lt;/<span class=\"name\">fileNamePattern</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">rollingPolicy</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">triggeringPolicy</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">MaxFileSize</span>&gt;</span>1MB<span class=\"tag\">&lt;/<span class=\"name\">MaxFileSize</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">triggeringPolicy</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;INFO&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;CONSOLE&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;FILE&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>运行即可获得类似如下的输出：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">15</span>:<span class=\"number\">25.328</span> <span class=\"selector-attr\">[main]</span> INFO  com<span class=\"selector-class\">.itranswarp</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.Main</span> - Start process...</span><br></pre></td></tr></table></figure>\n\n<p>从目前的趋势来看，越来越多的开源项目从Commons Logging加Log4j转向了SLF4J加Logback。</p>\n","categories":["Java","1.Java快速入门","03.异常处理"],"tags":["写作"]},{"title":"5.注解","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_5.%E6%B3%A8%E8%A7%A3/","content":"<h1 id=\"使用注解\"><a href=\"#使用注解\" class=\"headerlink\" title=\"使用注解\"></a>使用注解</h1><p>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this is a component:</span></span><br><span class=\"line\"><span class=\"meta\">@Resource</span>(<span class=\"string\">&quot;hello&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Inject</span></span><br><span class=\"line\">    int n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">hello</span>(<span class=\"params\"><span class=\"meta\">@Param</span> <span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        System.out.println(name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>\n<h3 id=\"注解的作用\"><a href=\"#注解的作用\" class=\"headerlink\" title=\"注解的作用\"></a>注解的作用</h3><p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>\n<p>Java的注解可以分为三类：</p>\n<p>第一类是由编译器使用的注解，例如：</p>\n<ul>\n<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>\n<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</li>\n</ul>\n<p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>\n<p>第二类是由工具处理<code>.class</code>文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>\n<p>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>\n<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>\n<ul>\n<li>所有基本类型；</li>\n<li>String；</li>\n<li>枚举类型；</li>\n<li>基本类型、String、Class以及枚举的数组。</li>\n</ul>\n<p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p>\n<p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。</p>\n<p>此外，大部分注解会有一个名为<code>value</code>的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。</p>\n<p>如果只写注解，相当于全部使用默认值。</p>\n<p>举个栗子，对以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Check(min=0, max=100, value=55)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check(value=99)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check(99)</span> <span class=\"comment\">// @Check(value=99)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Check</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>@Check</code>就是一个注解。第一个<code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个<code>@Check(value=99)</code>只定义了一个<code>value</code>参数，它实际上和<code>@Check(99)</code>是完全一样的。最后一个<code>@Check</code>表示所有参数都使用默认值。</p>\n<h1 id=\"定义注解\"><a href=\"#定义注解\" class=\"headerlink\" title=\"定义注解\"></a>定义注解</h1><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> @<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Report</span> </span>&#123;</span><br><span class=\"line\">    int type() <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> level() <span class=\"keyword\">default</span> <span class=\"string\">&quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> value() <span class=\"keyword\">default</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>\n<h3 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h3><p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>\n<h4 id=\"Target\"><a href=\"#Target\" class=\"headerlink\" title=\"@Target\"></a>@Target</h4><p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>\n<ul>\n<li>类或接口：<code>ElementType.TYPE</code>；</li>\n<li>字段：<code>ElementType.FIELD</code>；</li>\n<li>方法：<code>ElementType.METHOD</code>；</li>\n<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>\n<li>方法参数：<code>ElementType.PARAMETER</code>。</li>\n</ul>\n<p>例如，定义注解<code>@Report</code>可用在方法上，我们必须添加一个<code>@Target(ElementType.METHOD)</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义注解<code>@Report</code>可用在方法或字段上，可以把<code>@Target</code>注解参数变为数组<code>&#123; ElementType.METHOD, ElementType.FIELD &#125;</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Target</span>(&#123;</span><br><span class=\"line\">    ElementType.METHOD,</span><br><span class=\"line\">    ElementType.FIELD</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">public <span class=\"variable\">@interface</span> Report &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p>\n<h4 id=\"Retention\"><a href=\"#Retention\" class=\"headerlink\" title=\"@Retention\"></a>@Retention</h4><p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>\n<ul>\n<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>\n<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>\n<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>\n</ul>\n<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Repeatable\"><a href=\"#Repeatable\" class=\"headerlink\" title=\"@Repeatable\"></a>@Repeatable</h4><p>使用<code>@Repeatable</code>这个元注解可以定义<code>Annotation</code>是否可重复。这个注解应用不是特别广泛。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Repeatable(Reports.class)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Reports &#123;</span><br><span class=\"line\">    Report[] value();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>经过<code>@Repeatable</code>修饰后，在某个类型声明处，就可以添加多个<code>@Report</code>注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Report</span>(type=<span class=\"number\">1</span>, level=<span class=\"string\">&quot;debug&quot;</span>)</span><br><span class=\"line\"><span class=\"variable\">@Report</span>(type=<span class=\"number\">2</span>, level=<span class=\"string\">&quot;warning&quot;</span>)</span><br><span class=\"line\">public class Hello &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Inherited\"><a href=\"#Inherited\" class=\"headerlink\" title=\"@Inherited\"></a>@Inherited</h4><p>使用<code>@Inherited</code>定义子类是否可继承父类定义的<code>Annotation</code>。<code>@Inherited</code>仅针对<code>@Target(ElementType.TYPE)</code>类型的<code>annotation</code>有效，并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Inherited</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在使用的时候，如果一个类用到了<code>@Report</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Report(type=1)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>则它的子类默认也定义了该注解：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"如何定义Annotation\"><a href=\"#如何定义Annotation\" class=\"headerlink\" title=\"如何定义Annotation\"></a>如何定义Annotation</h3><p>我们总结一下定义<code>Annotation</code>的步骤：</p>\n<p>第一步，用<code>@interface</code>定义注解：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> @<span class=\"keyword\">interface</span> <span class=\"symbol\">Report</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二步，添加参数、默认值：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> @<span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Report</span> </span>&#123;</span><br><span class=\"line\">    int type() <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> level() <span class=\"keyword\">default</span> <span class=\"string\">&quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> value() <span class=\"keyword\">default</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>\n<p>第三步，用元注解配置注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Target(ElementType.TYPE)</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Report &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">type</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> 0</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">level</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;info&quot;</span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> &quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，必须设置<code>@Target</code>和<code>@Retention</code>，<code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>\n<h1 id=\"处理注解\"><a href=\"#处理注解\" class=\"headerlink\" title=\"处理注解\"></a>处理注解</h1><p>Java的注解本身对代码逻辑没有任何影响。根据<code>@Retention</code>的配置：</p>\n<ul>\n<li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li>\n<li><code>CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>\n<li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>\n</ul>\n<p>如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>\n<p>因此，我们只讨论如何读取<code>RUNTIME</code>类型的注解。</p>\n<p>因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>\n<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>\n<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>\n<ul>\n<li><code>Class.isAnnotationPresent(Class)</code></li>\n<li><code>Field.isAnnotationPresent(Class)</code></li>\n<li><code>Method.isAnnotationPresent(Class)</code></li>\n<li><code>Constructor.isAnnotationPresent(Class)</code></li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 判断@Report是否存在于Person类:</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Person</span>.</span></span><span class=\"keyword\">class</span>.is<span class=\"constructor\">AnnotationPresent(Report.<span class=\"params\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用反射API读取Annotation：</p>\n<ul>\n<li><code>Class.getAnnotation(Class)</code></li>\n<li><code>Field.getAnnotation(Class)</code></li>\n<li><code>Method.getAnnotation(Class)</code></li>\n<li><code>Constructor.getAnnotation(Class)</code></li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取Person定义的@Report注解:</span></span><br><span class=\"line\"><span class=\"keyword\">Report</span> <span class=\"keyword\">report</span> = Person.<span class=\"keyword\">class</span>.getAnnotation(<span class=\"keyword\">Report</span>.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">int <span class=\"keyword\">type</span> = <span class=\"keyword\">report</span>.<span class=\"keyword\">type</span>();</span><br><span class=\"line\">String level = <span class=\"keyword\">report</span>.level();</span><br></pre></td></tr></table></figure>\n\n<p>使用反射API读取<code>Annotation</code>有两种方法。方法一是先判断<code>Annotation</code>是否存在，如果存在，就直接读取：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Class</span> cls = Person.<span class=\"keyword\">class</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (cls.isAnnotationPresent(<span class=\"keyword\">Report</span>.<span class=\"keyword\">class</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">Report</span> <span class=\"keyword\">report</span> = cls.getAnnotation(<span class=\"keyword\">Report</span>.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第二种方法是直接读取<code>Annotation</code>，如果<code>Annotation</code>不存在，将返回<code>null</code>：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Class</span> cls = Person.<span class=\"keyword\">class</span>;</span><br><span class=\"line\"><span class=\"keyword\">Report</span> <span class=\"keyword\">report</span> = cls.getAnnotation(<span class=\"keyword\">Report</span>.<span class=\"keyword\">class</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">report</span> != null) &#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>读取方法、字段和构造方法的<code>Annotation</code>和Class类似。但要读取方法参数的<code>Annotation</code>就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">public</span> <span class=\"selector-tag\">void</span> <span class=\"selector-tag\">hello</span>(<span class=\"variable\">@NotNull</span> <span class=\"variable\">@Range</span>(max=<span class=\"number\">5</span>) String name, <span class=\"variable\">@NotNull</span> String prefix) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要读取方法参数的注解，我们先用反射获取<code>Method</code>实例，然后读取方法参数的所有注解：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取Method实例:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Method</span> <span class=\"title\">m</span> = ...</span></span><br><span class=\"line\"><span class=\"function\">// 获取所有参数的<span class=\"title\">Annotation</span>:</span></span><br><span class=\"line\">Annotation[][] annos = m.getParameterAnnotations();</span><br><span class=\"line\"><span class=\"comment\">// 第一个参数（索引为0）的所有Annotation:</span></span><br><span class=\"line\">Annotation[] annosOfName = annos[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Annotation anno : annosOfName) <span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    if (anno instanceof Range) &#123; // @Range注解</span></span><br><span class=\"line\"><span class=\"comment\">        Range r = (Range) anno;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anno instanceof NotNull) <span class=\"comment\">&#123; // @NotNull注解</span></span><br><span class=\"line\"><span class=\"comment\">        NotNull n = (NotNull) anno;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用注解-1\"><a href=\"#使用注解-1\" class=\"headerlink\" title=\"使用注解\"></a>使用注解</h3><p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>\n<p>我们来看一个<code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"variable\">@Target</span>(ElementType.FIELD)</span><br><span class=\"line\">public <span class=\"variable\">@interface</span> Range &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">int</span> <span class=\"selector-tag\">min</span>() <span class=\"selector-tag\">default</span> <span class=\"selector-tag\">0</span>;</span><br><span class=\"line\">    <span class=\"selector-tag\">int</span> <span class=\"selector-tag\">max</span>() <span class=\"selector-tag\">default</span> <span class=\"selector-tag\">255</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在某个JavaBean中，我们可以使用该注解：</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> Person &#123;</span><br><span class=\"line\">    @<span class=\"built_in\">Range</span>(<span class=\"built_in\">min</span>=<span class=\"number\">1</span>, <span class=\"built_in\">max</span>=<span class=\"number\">20</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"keyword\">name</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"built_in\">Range</span>(<span class=\"built_in\">max</span>=<span class=\"number\">10</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String city;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> check(Person person) <span class=\"keyword\">throws</span> IllegalArgumentException, ReflectiveOperationException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历所有Field:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Field field : person.getClass().getFields()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Field定义的@Range:</span></span><br><span class=\"line\">        Range range = field.getAnnotation(Range.class);</span><br><span class=\"line\">        <span class=\"comment\">// 如果@Range存在:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (range != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获取Field的值:</span></span><br><span class=\"line\">            <span class=\"keyword\">Object</span> value = field.<span class=\"built_in\">get</span>(person);</span><br><span class=\"line\">            <span class=\"comment\">// 如果值是String:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value <span class=\"keyword\">instanceof</span> <span class=\"keyword\">String</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">String</span> s = (<span class=\"keyword\">String</span>) value;</span><br><span class=\"line\">                <span class=\"comment\">// 判断值是否满足@Range的min/max:</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.length() &lt; range.<span class=\"built_in\">min</span>() || s.length() &gt; range.<span class=\"built_in\">max</span>()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Invalid field: &quot;</span> + field.getName());</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>\n","categories":["Java","1.Java快速入门","05.注解"],"tags":["写作"]},{"title":"6.泛型","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_6.%E6%B3%9B%E5%9E%8B/","content":"<h1 id=\"什么是泛型\"><a href=\"#什么是泛型\" class=\"headerlink\" title=\"什么是泛型\"></a>什么是泛型</h1><p>泛型是一种“代码模板”，可以用一套代码套用各种类型。</p>\n<p>在讲解什么是泛型之前，我们先观察Java标准库提供的<code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p>\n<p>实际上<code>ArrayList</code>内部就是一个<code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class <span class=\"type\">ArrayList</span> &#123;</span><br><span class=\"line\">    private <span class=\"type\">Object</span>[] <span class=\"built_in\">array</span>;</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> size;</span><br><span class=\"line\">    public <span class=\"built_in\">void</span> add(<span class=\"type\">Object</span> e) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> remove(<span class=\"built_in\">int</span> index) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"type\">Object</span> get(<span class=\"built_in\">int</span> index) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用上述<code>ArrayList</code>存储<code>String</code>类型，会有这么几个缺点：</p>\n<ul>\n<li>需要强制转型；</li>\n<li>不方便，易出错。</li>\n</ul>\n<p>例如，代码必须这么写：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayList list = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取到Object，必须强制转型为String:</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> first = (<span class=\"keyword\">String</span>) list.<span class=\"keyword\">get</span>(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n<p>很容易出现ClassCastException，因为容易“误转型”：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">list.<span class=\"built_in\">add</span>(<span class=\"keyword\">new</span> Integer(<span class=\"number\">123</span>));</span><br><span class=\"line\"><span class=\"comment\">// ERROR: ClassCastException:</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> <span class=\"built_in\">second</span> = (<span class=\"keyword\">String</span>) list.<span class=\"built_in\">get</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>要解决上述问题，我们可以为<code>String</code>单独编写一种<code>ArrayList</code>：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class <span class=\"type\">StringArrayList</span> &#123;</span><br><span class=\"line\">    private <span class=\"type\">String</span>[] <span class=\"built_in\">array</span>;</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> size;</span><br><span class=\"line\">    public <span class=\"built_in\">void</span> add(<span class=\"type\">String</span> e) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> remove(<span class=\"built_in\">int</span> index) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"type\">String</span> get(<span class=\"built_in\">int</span> index) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，存入的必须是<code>String</code>，取出的也一定是<code>String</code>，不需要强制转型，因为编译器会强制检查放入的类型：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">StringArrayList list = <span class=\"keyword\">new</span> <span class=\"type\">StringArrayList</span>();</span><br><span class=\"line\">list.add(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">String</span> first = list.<span class=\"keyword\">get</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 编译错误: 不允许放入非String类型:</span></span><br><span class=\"line\">list.add(<span class=\"keyword\">new</span> <span class=\"type\">Integer</span>(<span class=\"number\">123</span>));</span><br></pre></td></tr></table></figure>\n\n<p>问题暂时解决。</p>\n<p>然而，新的问题是，如果要存储<code>Integer</code>，还需要为<code>Integer</code>单独编写一种<code>ArrayList</code>：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class <span class=\"type\">IntegerArrayList</span> &#123;</span><br><span class=\"line\">    private <span class=\"type\">Integer</span>[] <span class=\"built_in\">array</span>;</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> size;</span><br><span class=\"line\">    public <span class=\"built_in\">void</span> add(<span class=\"type\">Integer</span> e) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> remove(<span class=\"built_in\">int</span> index) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"type\">Integer</span> get(<span class=\"built_in\">int</span> index) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，还需要为其他所有class单独编写一种<code>ArrayList</code>：</p>\n<ul>\n<li>LongArrayList</li>\n<li>DoubleArrayList</li>\n<li>PersonArrayList</li>\n<li>…</li>\n</ul>\n<p>这是不可能的，JDK的class就有上千个，而且它还不知道其他人编写的class。</p>\n<p>为了解决新的问题，我们必须把<code>ArrayList</code>变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class <span class=\"type\">ArrayList</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    private T[] <span class=\"built_in\">array</span>;</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> size;</span><br><span class=\"line\">    public <span class=\"built_in\">void</span> add(T e) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> remove(<span class=\"built_in\">int</span> index) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public T get(<span class=\"built_in\">int</span> index) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>T</code>可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的<code>ArrayList</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建可以存储String的ArrayList:</span></span><br><span class=\"line\">ArrayList&lt;<span class=\"keyword\">String</span>&gt; strList = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>&lt;<span class=\"keyword\">String</span>&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 创建可以存储Float的ArrayList:</span></span><br><span class=\"line\">ArrayList&lt;<span class=\"keyword\">Float</span>&gt; floatList = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>&lt;<span class=\"keyword\">Float</span>&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 创建可以存储Person的ArrayList:</span></span><br><span class=\"line\">ArrayList&lt;Person&gt; personList = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>&lt;Person&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>因此，泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;<span class=\"keyword\">String</span>&gt; strList = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>&lt;<span class=\"keyword\">String</span>&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>由编译器针对类型作检查：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">strList.<span class=\"built_in\">add</span>(<span class=\"string\">&quot;hello&quot;</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> s = strList.<span class=\"built_in\">get</span>(<span class=\"number\">0</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\">strList.<span class=\"built_in\">add</span>(<span class=\"keyword\">new</span> Integer(<span class=\"number\">123</span>)); <span class=\"comment\">// compile error!</span></span><br><span class=\"line\">Integer n = strList.<span class=\"built_in\">get</span>(<span class=\"number\">0</span>); <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p>\n<h3 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h3><p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">List</span></span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;<span class=\"keyword\">String</span>&gt; list = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>&lt;<span class=\"keyword\">String</span>&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>即类型<code>ArrayList&lt;T&gt;</code>可以向上转型为<code>List&lt;T&gt;</code>。</p>\n<p>要<em>特别注意</em>：不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>或<code>List&lt;Number&gt;</code>。</p>\n<p>这是为什么呢？假设<code>ArrayList&lt;Integer&gt;</code>可以向上转型为<code>ArrayList&lt;Number&gt;</code>，观察一下代码：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 创建ArrayList&lt;<span class=\"type\">Integer</span>&gt;类型：</span><br><span class=\"line\">ArrayList&lt;<span class=\"type\">Integer</span>&gt; integerList = <span class=\"built_in\">new</span> ArrayList&lt;<span class=\"type\">Integer</span>&gt;();</span><br><span class=\"line\">// 添加一个<span class=\"type\">Integer</span>：</span><br><span class=\"line\">integerList.<span class=\"keyword\">add</span>(<span class=\"built_in\">new</span> <span class=\"type\">Integer</span>(<span class=\"number\">123</span>));</span><br><span class=\"line\">// “向上转型”为ArrayList&lt;Number&gt;：</span><br><span class=\"line\">ArrayList&lt;Number&gt; numberList = integerList;</span><br><span class=\"line\">// 添加一个<span class=\"type\">Float</span>，因为<span class=\"type\">Float</span>也是Number：</span><br><span class=\"line\">numberList.<span class=\"keyword\">add</span>(<span class=\"built_in\">new</span> <span class=\"type\">Float</span>(<span class=\"number\">12.34</span>));</span><br><span class=\"line\">// 从ArrayList&lt;<span class=\"type\">Integer</span>&gt;获取索引为<span class=\"number\">1</span>的元素（即添加的<span class=\"type\">Float</span>）：</span><br><span class=\"line\"><span class=\"type\">Integer</span> n = integerList.<span class=\"keyword\">get</span>(<span class=\"number\">1</span>); // ClassCastException!</span><br></pre></td></tr></table></figure>\n\n<p>我们把一个<code>ArrayList&lt;Integer&gt;</code>转型为<code>ArrayList&lt;Number&gt;</code>类型后，这个<code>ArrayList&lt;Number&gt;</code>就可以接受<code>Float</code>类型，因为<code>Float</code>是<code>Number</code>的子类。但是，<code>ArrayList&lt;Number&gt;</code>实际上和<code>ArrayList&lt;Integer&gt;</code>是同一个对象，也就是<code>ArrayList&lt;Integer&gt;</code>类型，它不可能接受<code>Float</code>类型， 所以在获取<code>Integer</code>的时候将产生<code>ClassCastException</code>。</p>\n<p>实际上，编译器为了避免这种错误，根本就不允许把<code>ArrayList&lt;Integer&gt;</code>转型为<code>ArrayList&lt;Number&gt;</code>。</p>\n<p> ArrayList<Integer>和ArrayList<Number>两者完全没有继承关系。</p>\n<h1 id=\"使用泛型\"><a href=\"#使用泛型\" class=\"headerlink\" title=\"使用泛型\"></a>使用泛型</h1><p>使用<code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code>Object</code>：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 编译器警告:</span></span><br><span class=\"line\">List list = <span class=\"keyword\">new</span> ArrayList();</span><br><span class=\"line\">list.<span class=\"built_in\">add</span>(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">list.<span class=\"built_in\">add</span>(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">String</span> first = (<span class=\"keyword\">String</span>) list.<span class=\"built_in\">get</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">String</span> <span class=\"built_in\">second</span> = (<span class=\"keyword\">String</span>) list.<span class=\"built_in\">get</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>此时，只能把<code>&lt;T&gt;</code>当作<code>Object</code>使用，没有发挥泛型的优势。</p>\n<p>当我们定义泛型类型<code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;String&gt;</code>：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 无编译器警告:</span></span><br><span class=\"line\">List&lt;<span class=\"keyword\">String</span>&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">String</span>&gt;();</span><br><span class=\"line\">list.<span class=\"built_in\">add</span>(<span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">list.<span class=\"built_in\">add</span>(<span class=\"string\">&quot;World&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 无强制转型:</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> first = list.<span class=\"built_in\">get</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">String</span> <span class=\"built_in\">second</span> = list.<span class=\"built_in\">get</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当我们定义泛型类型<code>&lt;Number&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;Number&gt;</code>：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Number&gt; list = <span class=\"built_in\">new</span> ArrayList&lt;Number&gt;();</span><br><span class=\"line\">list.<span class=\"keyword\">add</span>(<span class=\"built_in\">new</span> <span class=\"type\">Integer</span>(<span class=\"number\">123</span>));</span><br><span class=\"line\">list.<span class=\"keyword\">add</span>(<span class=\"built_in\">new</span> <span class=\"type\">Double</span>(<span class=\"number\">12.34</span>));</span><br><span class=\"line\">Number first = list.<span class=\"keyword\">get</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">Number second = list.<span class=\"keyword\">get</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;<span class=\"built_in\">Number</span>&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"built_in\">Number</span>&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class=\"line\">List&lt;<span class=\"built_in\">Number</span>&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型接口\"><a href=\"#泛型接口\" class=\"headerlink\" title=\"泛型接口\"></a>泛型接口</h3><p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"symbol\">Comparable</span>&lt;<span class=\"symbol\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回负数: 当前实例比参数o小</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回0: 当前实例与参数o相等</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回正数: 当前实例比参数o大</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> compareTo(T o);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以直接对<code>String</code>数组进行排序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sort</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这是因为<code>String</code>本身已经实现了<code>Comparable&lt;String&gt;</code>接口。如果换成我们自定义的<code>Person</code>类型试试：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sort</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">main</span>(<span class=\"params\"><span class=\"built_in\">String</span>[] args</span>)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    int score;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">Person</span>(<span class=\"params\"><span class=\"built_in\">String</span> name, int score</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name + <span class=\"string\">&quot;,&quot;</span> + <span class=\"built_in\">this</span>.score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行程序，我们会得到<code>ClassCastException</code>，即无法将<code>Person</code>转型为<code>Comparable</code>。我们修改代码，让<code>Person</code>实现<code>Comparable&lt;T&gt;</code>接口：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sort</span></span><br><span class=\"line\">import java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\">public <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    public static void main(String<span class=\"literal\">[]</span> args) &#123;</span><br><span class=\"line\">        Person<span class=\"literal\">[]</span> ps = <span class=\"keyword\">new</span> Person<span class=\"literal\">[]</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"constructor\">Person(<span class=\"string\">&quot;Bob&quot;</span>, 61)</span>,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"constructor\">Person(<span class=\"string\">&quot;Alice&quot;</span>, 88)</span>,</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"constructor\">Person(<span class=\"string\">&quot;Lily&quot;</span>, 75)</span>,</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span>sort(ps);</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span><span class=\"keyword\">to</span><span class=\"constructor\">String(<span class=\"params\">ps</span>)</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，可以正确实现按<code>name</code>进行排序。</p>\n<p>也可以修改比较逻辑，例如，按<code>score</code>从高到低排序。请自行修改测试。</p>\n<h1 id=\"编写泛型\"><a href=\"#编写泛型\" class=\"headerlink\" title=\"编写泛型\"></a>编写泛型</h1><p>编写泛型类比普通类要复杂。通常来说，泛型类一般用在集合类中，例如<code>ArrayList&lt;T&gt;</code>，我们很少需要编写泛型类。</p>\n<p>如果我们确实需要编写一个泛型类，那么，应该如何编写它？</p>\n<p>可以按照以下步骤来编写一个泛型类。</p>\n<p>首先，按照某种类型，例如：<code>String</code>，来编写类：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\"><span class=\"built_in\">String</span> first, <span class=\"built_in\">String</span> last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，标记所有的特定类型，这里是<code>String</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\"><span class=\"built_in\">String</span> first, <span class=\"built_in\">String</span> last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，把特定类型<code>String</code>替换为<code>T</code>，并申明<code>&lt;T&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>熟练后即可直接从<code>T</code>开始编写。</p>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>编写泛型类时，要特别注意，泛型类型<code>&lt;T&gt;</code>不能用于静态方法。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 对静态方法使用&lt;T&gt;:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Pair&lt;T&gt; <span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;T&gt;(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码会导致编译错误，我们无法在静态方法<code>create()</code>的方法参数和返回类型上使用泛型类型<code>T</code>。</p>\n<p>有些同学在网上搜索发现，可以在<code>static</code>修饰符后面加一个<code>&lt;T&gt;</code>，编译就能通过：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 可以编译通过:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Pair&lt;T&gt; <span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;T&gt;(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但实际上，这个<code>&lt;T&gt;</code>和<code>Pair&lt;T&gt;</code>类型的<code>&lt;T&gt;</code>已经没有任何关系了。</p>\n<p>对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。对于上面的<code>create()</code>静态方法，我们应该把它改为另一种泛型类型，例如，<code>&lt;K&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态泛型方法应该使用其他类型区分:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;K&gt; Pair&lt;K&gt; <span class=\"function\"><span class=\"title\">create</span>(<span class=\"params\">K first, K last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;K&gt;(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样才能清楚地将静态方法的泛型类型和实例类型的泛型类型区分开。</p>\n<h3 id=\"多个泛型类型\"><a href=\"#多个泛型类型\" class=\"headerlink\" title=\"多个泛型类型\"></a>多个泛型类型</h3><p>泛型还可以定义多种类型。例如，我们希望<code>Pair</code>不总是存储两个类型一样的对象，就可以使用类型<code>&lt;T, K&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">K</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> K last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, K last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> K <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，需要指出两种类型：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Integer</span>&gt; p = <span class=\"literal\">new</span> <span class=\"built_in\">Pair</span>&lt;&gt;(<span class=\"string\">&quot;test&quot;</span>, <span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Java标准库的<code>Map&lt;K, V&gt;</code>就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</p>\n<h1 id=\"擦拭法\"><a href=\"#擦拭法\" class=\"headerlink\" title=\"擦拭法\"></a>擦拭法</h1><p>泛型是一种类似”模板代码“的技术，不同语言的泛型实现方式不一定相同。</p>\n<p>Java语言的泛型实现方式是擦拭法（Type Erasure）。</p>\n<p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>\n<p>例如，我们编写了一个泛型类<code>Pair&lt;T&gt;</code>，这是编译器看到的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而虚拟机根本不知道泛型。这是虚拟机执行的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">Object</span> first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">Object</span> last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\"><span class=\"built_in\">Object</span> first, <span class=\"built_in\">Object</span> last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">Object</span> <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">Object</span> <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，Java使用擦拭法实现泛型，导致了：</p>\n<ul>\n<li>编译器把类型<code>&lt;T&gt;</code>视为<code>Object</code>；</li>\n<li>编译器根据<code>&lt;T&gt;</code>实现安全的强制转型。</li>\n</ul>\n<p>使用泛型的时候，我们编写的代码也是编译器看到的代码：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt; p = <span class=\"literal\">new</span> <span class=\"built_in\">Pair</span>&lt;&gt;(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">String</span> first = p.getFirst();</span><br><span class=\"line\"><span class=\"built_in\">String</span> last = p.getLast();</span><br></pre></td></tr></table></figure>\n\n<p>而虚拟机执行的代码并没有泛型：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span> p = <span class=\"literal\">new</span> <span class=\"built_in\">Pair</span>(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;world&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">String</span> first = (<span class=\"built_in\">String</span>) p.getFirst();</span><br><span class=\"line\"><span class=\"built_in\">String</span> last = (<span class=\"built_in\">String</span>) p.getLast();</span><br></pre></td></tr></table></figure>\n\n<p>所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型<code>T</code>视为<code>Object</code>处理，但是，在需要转型的时候，编译器会根据<code>T</code>的类型自动为我们实行安全地强制转型。</p>\n<p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p>\n<p>局限一：<code>&lt;T&gt;</code>不能是基本类型，例如<code>int</code>，因为实际类型是<code>Object</code>，<code>Object</code>类型无法持有基本类型：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;int&gt; p = <span class=\"literal\">new</span> <span class=\"built_in\">Pair</span>&lt;&gt;(<span class=\"number\">1</span>, <span class=\"number\">2</span>); <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>局限二：无法取得带泛型的<code>Class</code>。观察以下代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">main</span>(<span class=\"params\"><span class=\"built_in\">String</span>[] args</span>)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为<code>T</code>是<code>Object</code>，我们对<code>Pair&lt;String&gt;</code>和<code>Pair&lt;Integer&gt;</code>类型获取<code>Class</code>时，获取到的是同一个<code>Class</code>，也就是<code>Pair</code>类的<code>Class</code>。</p>\n<p>换句话说，所有泛型实例，无论<code>T</code>的类型是什么，<code>getClass()</code>返回同一个<code>Class</code>实例，因为编译后它们全部都是<code>Pair&lt;Object&gt;</code>。</p>\n<p>局限三：无法判断带泛型的类型：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">Integer</span>&gt; p = <span class=\"literal\">new</span> <span class=\"built_in\">Pair</span>&lt;&gt;(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br><span class=\"line\"><span class=\"comment\">// Compile error:</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (p instanceof <span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原因和前面一样，并不存在<code>Pair&lt;String&gt;.class</code>，而是只有唯一的<code>Pair.class</code>。</p>\n<p>局限四：不能实例化<code>T</code>类型：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Pair() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Compile error:</span></span><br><span class=\"line\">        first = <span class=\"keyword\">new</span> <span class=\"type\">T</span>();</span><br><span class=\"line\">        last = <span class=\"keyword\">new</span> <span class=\"type\">T</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码无法通过编译，因为构造方法的两行语句：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">first</span> = new T()<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"attr\">last</span> = new T()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>擦拭后实际上变成了：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">first</span> = new Object()<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"attr\">last</span> = new Object()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样一来，创建<code>new Pair&lt;String&gt;()</code>和创建<code>new Pair&lt;Integer&gt;()</code>就全部成了<code>Object</code>，显然编译器要阻止这种类型不对的代码。</p>\n<p>要实例化<code>T</code>类型，我们必须借助额外的<code>Class&lt;T&gt;</code>参数：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Pair(Class&lt;T&gt; clazz) &#123;</span><br><span class=\"line\">        first = clazz.<span class=\"keyword\">new</span><span class=\"type\">Instance</span>();</span><br><span class=\"line\">        last = clazz.<span class=\"keyword\">new</span><span class=\"type\">Instance</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码借助<code>Class&lt;T&gt;</code>参数并通过反射来实例化<code>T</code>类型，使用的时候，也必须传入<code>Class&lt;T&gt;</code>。例如：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt; <span class=\"built_in\">pair</span> = <span class=\"literal\">new</span> <span class=\"built_in\">Pair</span>&lt;&gt;(<span class=\"built_in\">String</span>.class);</span><br></pre></td></tr></table></figure>\n\n<p>因为传入了<code>Class&lt;String&gt;</code>的实例，所以我们借助<code>String.class</code>就可以实例化<code>String</code>类型。</p>\n<h3 id=\"不恰当的覆写方法\"><a href=\"#不恰当的覆写方法\" class=\"headerlink\" title=\"不恰当的覆写方法\"></a>不恰当的覆写方法</h3><p>有些时候，一个看似正确定义的方法会无法通过编译。例如：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">Pair</span>&lt;<span class=\"symbol\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span>ean equals(T t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> == t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是因为，定义的<code>equals(T t)</code>方法实际上会被擦拭成<code>equals(Object t)</code>，而这个方法是继承自<code>Object</code>的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</p>\n<p>换个方法名，避开与<code>Object.equals(Object)</code>的冲突就可以成功编译：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">Pair</span>&lt;<span class=\"symbol\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span>ean same(T t) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span> == t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"泛型继承\"><a href=\"#泛型继承\" class=\"headerlink\" title=\"泛型继承\"></a>泛型继承</h3><p>一个类可以继承自一个泛型类。例如：父类的类型是<code>Pair&lt;Integer&gt;</code>，子类的类型是<code>IntPair</code>，可以这么继承：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntPair</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pair&lt;Integer&gt;</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，因为子类<code>IntPair</code>并没有泛型类型，所以，正常使用即可：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">IntPair</span> ip = new IntPair(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure>\n\n<p>前面讲了，我们无法获取<code>Pair&lt;T&gt;</code>的<code>T</code>类型，即给定一个变量<code>Pair&lt;Integer&gt; p</code>，无法从<code>p</code>中获取到<code>Integer</code>类型。</p>\n<p>但是，在父类是泛型类型的情况下，编译器就必须把类型<code>T</code>（对<code>IntPair</code>来说，也就是<code>Integer</code>类型）保存到子类的class文件中，不然编译器就不知道<code>IntPair</code>只能存取<code>Integer</code>这种类型。</p>\n<p>在继承了泛型类型的情况下，子类可以获取父类的泛型类型。例如：<code>IntPair</code>可以获取到父类的泛型类型<code>Integer</code>。获取父类的泛型类型代码比较复杂：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.ParameterizedType;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.lang.reflect.Type;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Pair</span><span class=\"params\">(T first, T last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getFirst</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getLast</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntPair</span> <span class=\"keyword\">extends</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">Integer</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IntPair</span><span class=\"params\">(Integer first, Integer last)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(first, last);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为Java引入了泛型，所以，只用<code>Class</code>来标识类型已经不够了。实际上，Java的类型系统结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                      ┌────┐</span><br><span class=\"line\">                      │Type│</span><br><span class=\"line\">                      └────┘</span><br><span class=\"line\">                         ▲</span><br><span class=\"line\">                         │</span><br><span class=\"line\">   ┌────────────┬────────┴─────────┬───────────────┐</span><br><span class=\"line\">   │            │                  │               │</span><br><span class=\"line\">┌─────┐┌─────────────────┐┌────────────────┐┌────────────┐</span><br><span class=\"line\">│Class││ParameterizedType││GenericArrayType││WildcardType│</span><br><span class=\"line\">└─────┘└─────────────────┘└────────────────┘└────────────┘</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"extends通配符\"><a href=\"#extends通配符\" class=\"headerlink\" title=\"extends通配符\"></a>extends通配符</h1><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。</p>\n<p>假设我们定义了<code>Pair&lt;T&gt;</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">Pair</span>&lt;<span class=\"symbol\">T</span>&gt; &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们又针对<code>Pair&lt;Number&gt;</code>类型写了一个静态方法，它接收的参数类型是<code>Pair&lt;Number&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PairHelper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> int <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">Pair&lt;<span class=\"built_in\">Number</span>&gt; p</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Number</span> first = p.getFirst();</span><br><span class=\"line\">        <span class=\"built_in\">Number</span> last = p.getLast();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first.intValue() + last.intValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码是可以正常编译的。使用的时候，我们传入：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> sum = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">PairHelper</span>.</span></span>add(<span class=\"keyword\">new</span> Pair&lt;Number&gt;(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br></pre></td></tr></table></figure>\n\n<p>注意：传入的类型是<code>Pair&lt;Number&gt;</code>，实际参数类型是<code>(Integer, Integer)</code>。</p>\n<p>既然实际参数是<code>Integer</code>类型，试试传入<code>Pair&lt;Integer&gt;</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>直接运行，会得到一个编译错误：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">incompatible <span class=\"built_in\">type</span><span class=\"variable\">s:</span> Pair<span class=\"symbol\">&lt;Integer&gt;</span> cannot <span class=\"keyword\">be</span> converted <span class=\"keyword\">to</span> Pair<span class=\"symbol\">&lt;Number&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>原因很明显，因为<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类，因此，<code>add(Pair&lt;Number&gt;)</code>不接受参数类型<code>Pair&lt;Integer&gt;</code>。</p>\n<p>但是从<code>add()</code>方法的代码可知，传入<code>Pair&lt;Integer&gt;</code>是完全符合内部代码的类型规范，因为语句：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Number</span> first = p.getFirst();</span><br><span class=\"line\"><span class=\"attribute\">Number</span> <span class=\"literal\">last</span> = p.getLast();</span><br></pre></td></tr></table></figure>\n\n<p>实际类型是<code>Integer</code>，引用类型是<code>Number</code>，没有问题。问题在于方法参数类型定死了只能传入<code>Pair&lt;Number&gt;</code>。</p>\n<p>有没有办法使得方法参数接受<code>Pair&lt;Integer&gt;</code>？办法是有的，这就是使用<code>Pair&lt;? extends Number&gt;</code>使得方法接收所有泛型类型为<code>Number</code>或<code>Number</code>子类的<code>Pair</code>类型。我们把代码改写如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这样一来，给方法传入<code>Pair&lt;Integer&gt;</code>类型时，它符合参数<code>Pair&lt;? extends Number&gt;</code>类型。这种使用<code>&lt;? extends Number&gt;</code>的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型<code>T</code>的上界限定在<code>Number</code>了。</p>\n<p>除了可以传入<code>Pair&lt;Integer&gt;</code>类型，我们还可以传入<code>Pair&lt;Double&gt;</code>类型，<code>Pair&lt;BigDecimal&gt;</code>类型等等，因为<code>Double</code>和<code>BigDecimal</code>都是<code>Number</code>的子类。</p>\n<p>如果我们考察对<code>Pair&lt;? extends Number&gt;</code>类型调用<code>getFirst()</code>方法，实际的方法签名变成了：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;? <span class=\"keyword\">extends</span> <span class=\"built_in\">Number</span>&gt; getFirst();</span><br></pre></td></tr></table></figure>\n\n<p>即返回值是<code>Number</code>或<code>Number</code>的子类，因此，可以安全赋值给<code>Number</code>类型的变量：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">Number x = p.getFirst()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后，我们不可预测实际类型就是<code>Integer</code>，例如，下面的代码是无法通过编译的：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer x = p.getFirst()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为实际的返回类型可能是<code>Integer</code>，也可能是<code>Double</code>或者其他类型，编译器只能确定类型一定是<code>Number</code>的子类（包括<code>Number</code>类型本身），但具体类型无法确定。</p>\n<p>我们再来考察一下<code>Pair&lt;T&gt;</code>的<code>set</code>方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setFirst</span>(<span class=\"params\">T first</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setLast</span>(<span class=\"params\">T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>不出意外，我们会得到一个编译错误：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"code\"><pre><span class=\"line\">incompatible types: Integer cannot be converted <span class=\"keyword\">to</span> CAP<span class=\"string\">#1</span></span><br><span class=\"line\"><span class=\"keyword\">where</span> CAP<span class=\"string\">#1</span> <span class=\"keyword\">is</span> a fresh <span class=\"keyword\">type</span>-variable:</span><br><span class=\"line\">    CAP<span class=\"string\">#1</span> extends Number <span class=\"keyword\">from</span> capture <span class=\"keyword\">of</span> ? extends Number</span><br></pre></td></tr></table></figure>\n\n<p>编译错误发生在<code>p.setFirst()</code>传入的参数是<code>Integer</code>类型。有些童鞋会问了，既然<code>p</code>的定义是<code>Pair&lt;? extends Number&gt;</code>，那么<code>setFirst(? extends Number)</code>为什么不能传入<code>Integer</code>？</p>\n<p>原因还在于擦拭法。如果我们传入的<code>p</code>是<code>Pair&lt;Double&gt;</code>，显然它满足参数定义<code>Pair&lt;? extends Number&gt;</code>，然而，<code>Pair&lt;Double&gt;</code>的<code>setFirst()</code>显然无法接受<code>Integer</code>类型。</p>\n<p>这就是<code>&lt;? extends Number&gt;</code>通配符的一个重要限制：方法参数签名<code>setFirst(? extends Number)</code>无法传递任何<code>Number</code>的子类型给<code>setFirst(? extends Number)</code>。</p>\n<p>这里唯一的例外是可以给方法参数传入<code>null</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-class\">.setFirst</span>(null); <span class=\"comment\">// ok, 但是后面会抛出NullPointerException</span></span><br><span class=\"line\"><span class=\"selector-tag\">p</span><span class=\"selector-class\">.getFirst</span>()<span class=\"selector-class\">.intValue</span>(); <span class=\"comment\">// NullPointerException</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"extends通配符的作用\"><a href=\"#extends通配符的作用\" class=\"headerlink\" title=\"extends通配符的作用\"></a>extends通配符的作用</h3><p>如果我们考察Java标准库的<code>java.util.List&lt;T&gt;</code>接口，它实现的是一个类似“可变数组”的列表，主要功能包括：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">List</span>&lt;<span class=\"title\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"built_in\">int</span> <span class=\"title\">size</span>(<span class=\"params\"></span>)</span>; <span class=\"comment\">// 获取个数</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">get</span>(<span class=\"params\"><span class=\"built_in\">int</span> index</span>)</span>; <span class=\"comment\">// 根据索引获取指定元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span>(<span class=\"params\">T t</span>)</span>; <span class=\"comment\">// 添加一个新元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove</span>(<span class=\"params\">T t</span>)</span>; <span class=\"comment\">// 删除一个已有元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，让我们定义一个方法来处理列表的每个元素：</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> sumOfList(List&lt;? <span class=\"keyword\">extends</span> <span class=\"keyword\">Integer</span>&gt; list) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> <span class=\"built_in\">sum</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    for (<span class=\"built_in\">int</span> i=<span class=\"number\">0</span>; i&lt;list.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">Integer</span> n = list.get(i);</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span> + n;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">sum</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为什么我们定义的方法参数类型是<code>List&lt;? extends Integer&gt;</code>而不是<code>List&lt;Integer&gt;</code>？从方法内部代码看，传入<code>List&lt;? extends Integer&gt;</code>或者<code>List&lt;Integer&gt;</code>是完全一样的，但是，注意到<code>List&lt;? extends Integer&gt;</code>的限制：</p>\n<ul>\n<li>允许调用<code>get()</code>方法获取<code>Integer</code>的引用；</li>\n<li>不允许调用<code>set(? extends Integer)</code>方法并传入任何<code>Integer</code>的引用（<code>null</code>除外）。</li>\n</ul>\n<p>因此，方法参数类型<code>List&lt;? extends Integer&gt;</code>表明了该方法内部只会读取<code>List</code>的元素，不会修改<code>List</code>的元素（因为无法调用<code>add(? extends Integer)</code>、<code>remove(? extends Integer)</code>这些方法。换句话说，这是一个对参数<code>List&lt;? extends Integer&gt;</code>进行只读的方法（恶意调用<code>set(null)</code>除外）。</p>\n<h3 id=\"使用extends限定T类型\"><a href=\"#使用extends限定T类型\" class=\"headerlink\" title=\"使用extends限定T类型\"></a>使用extends限定T类型</h3><p>在定义泛型类型<code>Pair&lt;T&gt;</code>的时候，也可以使用<code>extends</code>通配符来限定<code>T</code>的类型：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair&lt;T</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number&gt;</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们只能定义：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;Number&gt; p1 = <span class=\"built_in\">null</span>;</span><br><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">Integer</span>&gt; p2 = <span class=\"literal\">new</span> <span class=\"built_in\">Pair</span>&lt;&gt;(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;Double&gt; p3 = <span class=\"built_in\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>Number</code>、<code>Integer</code>和<code>Double</code>都符合<code>&lt;T extends Number&gt;</code>。</p>\n<p>非<code>Number</code>类型将无法通过编译：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt; p1 = <span class=\"built_in\">null</span>; <span class=\"comment\">// compile error!</span></span><br><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;Object&gt; p2 = <span class=\"built_in\">null</span>; <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>因为<code>String</code>、<code>Object</code>都不符合<code>&lt;T extends Number&gt;</code>，因为它们不是<code>Number</code>类型或<code>Number</code>的子类。</p>\n<h1 id=\"super通配符\"><a href=\"#super通配符\" class=\"headerlink\" title=\"super通配符\"></a>super通配符</h1><p>我们前面已经讲到了泛型的继承关系：<code>Pair&lt;Integer&gt;</code>不是<code>Pair&lt;Number&gt;</code>的子类。</p>\n<p>考察下面的<code>set</code>方法：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">void</span> <span class=\"built_in\">set</span>(<span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">Integer</span>&gt; p, <span class=\"built_in\">Integer</span> first, <span class=\"built_in\">Integer</span> last) &#123;</span><br><span class=\"line\">    p.setFirst(first);</span><br><span class=\"line\">    p.setLast(last);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>传入<code>Pair&lt;Integer&gt;</code>是允许的，但是传入<code>Pair&lt;Number&gt;</code>是不允许的。</p>\n<p>和<code>extends</code>通配符相反，这次，我们希望接受<code>Pair&lt;Integer&gt;</code>类型，以及<code>Pair&lt;Number&gt;</code>、<code>Pair&lt;Object&gt;</code>，因为<code>Number</code>和<code>Object</code>是<code>Integer</code>的父类，<code>setFirst(Number)</code>和<code>setFirst(Object)</code>实际上允许接受<code>Integer</code>类型。</p>\n<p>我们使用<code>super</code>通配符来改写这个方法：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">void</span> <span class=\"built_in\">set</span>(<span class=\"built_in\">Pair</span>&lt;? super <span class=\"built_in\">Integer</span>&gt; p, <span class=\"built_in\">Integer</span> first, <span class=\"built_in\">Integer</span> last) &#123;</span><br><span class=\"line\">    p.setFirst(first);</span><br><span class=\"line\">    p.setLast(last);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>Pair&lt;? super Integer&gt;</code>表示，方法参数接受所有泛型类型为<code>Integer</code>或<code>Integer</code>父类的<code>Pair</code>类型。</p>\n<p>下面的代码可以被正常编译：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setFirst</span>(<span class=\"params\">T first</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setLast</span>(<span class=\"params\">T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>考察<code>Pair&lt;? super Integer&gt;</code>的<code>setFirst()</code>方法，它的方法签名实际上是：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setFirst</span><span class=\"params\">(? <span class=\"keyword\">super</span> Integer)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>因此，可以安全地传入<code>Integer</code>类型。</p>\n<p>再考察<code>Pair&lt;? super Integer&gt;</code>的<code>getFirst()</code>方法，它的方法签名实际上是：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\">? <span class=\"keyword\">super</span> <span class=\"function\">Integer <span class=\"title\">getFirst</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这里注意到我们无法使用<code>Integer</code>类型来接收<code>getFirst()</code>的返回值，即下面的语句将无法通过编译：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer x = p.getFirst()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为如果传入的实际类型是<code>Pair&lt;Number&gt;</code>，编译器无法将<code>Number</code>类型转型为<code>Integer</code>。</p>\n<p>注意：虽然<code>Number</code>是一个抽象类，我们无法直接实例化它。但是，即便<code>Number</code>不是抽象类，这里仍然无法通过编译。此外，传入<code>Pair&lt;Object&gt;</code>类型时，编译器也无法将<code>Object</code>类型转型为<code>Integer</code>。</p>\n<p>唯一可以接收<code>getFirst()</code>方法返回值的是<code>Object</code>类型：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">Object obj = p.getFirst()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，使用<code>&lt;? super Integer&gt;</code>通配符表示：</p>\n<ul>\n<li>允许调用<code>set(? super Integer)</code>方法传入<code>Integer</code>的引用；</li>\n<li>不允许调用<code>get()</code>方法获得<code>Integer</code>的引用。</li>\n</ul>\n<p>唯一例外是可以获取<code>Object</code>的引用：<code>Object o = p.getFirst()</code>。</p>\n<p>换句话说，使用<code>&lt;? super Integer&gt;</code>通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p>\n<h3 id=\"对比extends和super通配符\"><a href=\"#对比extends和super通配符\" class=\"headerlink\" title=\"对比extends和super通配符\"></a>对比extends和super通配符</h3><p>我们再回顾一下<code>extends</code>通配符。作为方法参数，<code>&lt;? extends T&gt;</code>类型和<code>&lt;? super T&gt;</code>类型的区别在于：</p>\n<ul>\n<li><code>&lt;? extends T&gt;</code>允许调用读方法<code>T get()</code>获取<code>T</code>的引用，但不允许调用写方法<code>set(T)</code>传入<code>T</code>的引用（传入<code>null</code>除外）；</li>\n<li><code>&lt;? super T&gt;</code>允许调用写方法<code>set(T)</code>传入<code>T</code>的引用，但不允许调用读方法<code>T get()</code>获取<code>T</code>的引用（获取<code>Object</code>除外）。</li>\n</ul>\n<p>一个是允许读不允许写，另一个是允许写不允许读。</p>\n<p>先记住上面的结论，我们来看Java标准库的<code>Collections</code>类定义的<code>copy()</code>方法：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> Collections &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把src的每个元素复制到dest中:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"keyword\">void</span> <span class=\"keyword\">copy</span>(List&lt;? <span class=\"keyword\">super</span> T&gt; dest, List&lt;? <span class=\"keyword\">extends</span> T&gt; src) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;src.<span class=\"keyword\">size</span>(); i++) &#123;</span><br><span class=\"line\">            T t = src.get(i);</span><br><span class=\"line\">            dest.add(t);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的作用是把一个<code>List</code>的每个元素依次添加到另一个<code>List</code>中。它的第一个参数是<code>List&lt;? super T&gt;</code>，表示目标<code>List</code>，第二个参数<code>List&lt;? extends T&gt;</code>，表示要复制的<code>List</code>。我们可以简单地用<code>for</code>循环实现复制。在<code>for</code>循环中，我们可以看到，对于类型<code>&lt;? extends T&gt;</code>的变量<code>src</code>，我们可以安全地获取类型<code>T</code>的引用，而对于类型<code>&lt;? super T&gt;</code>的变量<code>dest</code>，我们可以安全地传入<code>T</code>的引用。</p>\n<p>这个<code>copy()</code>方法的定义就完美地展示了<code>extends</code>和<code>super</code>的意图：</p>\n<ul>\n<li><code>copy()</code>方法内部不会读取<code>dest</code>，因为不能调用<code>dest.get()</code>来获取<code>T</code>的引用；</li>\n<li><code>copy()</code>方法内部也不会修改<code>src</code>，因为不能调用<code>src.add(T)</code>。</li>\n</ul>\n<p>这是由编译器检查来实现的。如果在方法代码中意外修改了<code>src</code>，或者意外读取了<code>dest</code>，就会导致一个编译错误：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Collections</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 把src的每个元素复制到dest中:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">copy</span>(<span class=\"params\">List&lt;? <span class=\"built_in\">super</span> T&gt; dest, List&lt;? <span class=\"keyword\">extends</span> T&gt; src</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        T t = dest.get(<span class=\"number\">0</span>); <span class=\"comment\">// compile error!</span></span><br><span class=\"line\">        src.add(t); <span class=\"comment\">// compile error!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>copy()</code>方法的另一个好处是可以安全地把一个<code>List&lt;Integer&gt;</code>添加到<code>List&lt;Number&gt;</code>，但是无法反过来添加：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"operator\">//</span> <span class=\"variable\">copy</span> <span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">Integer</span><span class=\"operator\">&gt;</span> <span class=\"variable\">to</span> <span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">Number</span><span class=\"operator\">&gt;</span> <span class=\"variable\">ok</span><span class=\"operator\">:</span></span><br><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">Number</span><span class=\"operator\">&gt;</span> <span class=\"variable\">numList</span> <span class=\"operator\">=</span> <span class=\"operator\">...;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">Integer</span><span class=\"operator\">&gt;</span> <span class=\"variable\">intList</span> <span class=\"operator\">=</span> <span class=\"operator\">...;</span></span><br><span class=\"line\"><span class=\"variable\">Collections</span><span class=\"operator\">.</span><span class=\"variable\">copy</span><span class=\"punctuation\">(</span><span class=\"variable\">numList</span><span class=\"operator\">,</span> <span class=\"variable\">intList</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">//</span> <span class=\"variable\">ERROR</span><span class=\"operator\">:</span> <span class=\"variable\">cannot</span> <span class=\"variable\">copy</span> <span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">Number</span><span class=\"operator\">&gt;</span> <span class=\"variable\">to</span> <span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">Integer</span><span class=\"operator\">&gt;:</span></span><br><span class=\"line\"><span class=\"variable\">Collections</span><span class=\"operator\">.</span><span class=\"variable\">copy</span><span class=\"punctuation\">(</span><span class=\"variable\">intList</span><span class=\"operator\">,</span> <span class=\"variable\">numList</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>而这些都是通过<code>super</code>和<code>extends</code>通配符，并由编译器强制检查来实现的。</p>\n<h3 id=\"PECS原则\"><a href=\"#PECS原则\" class=\"headerlink\" title=\"PECS原则\"></a>PECS原则</h3><p>何时使用<code>extends</code>，何时使用<code>super</code>？为了便于记忆，我们可以用PECS原则：Producer Extends Consumer Super。</p>\n<p>即：如果需要返回<code>T</code>，它是生产者（Producer），要使用<code>extends</code>通配符；如果需要写入<code>T</code>，它是消费者（Consumer），要使用<code>super</code>通配符。</p>\n<p>还是以<code>Collections</code>的<code>copy()</code>方法为例：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> Collections &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"keyword\">void</span> <span class=\"keyword\">copy</span>(List&lt;? <span class=\"keyword\">super</span> T&gt; dest, List&lt;? <span class=\"keyword\">extends</span> T&gt; src) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;src.<span class=\"keyword\">size</span>(); i++) &#123;</span><br><span class=\"line\">            T t = src.get(i); <span class=\"comment\">// src是producer</span></span><br><span class=\"line\">            dest.add(t); <span class=\"comment\">// dest是consumer</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要返回<code>T</code>的<code>src</code>是生产者，因此声明为<code>List&lt;? extends T&gt;</code>，需要写入<code>T</code>的<code>dest</code>是消费者，因此声明为<code>List&lt;? super T&gt;</code>。</p>\n<h3 id=\"无限定通配符\"><a href=\"#无限定通配符\" class=\"headerlink\" title=\"无限定通配符\"></a>无限定通配符</h3><p>我们已经讨论了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>作为方法参数的作用。实际上，Java的泛型还允许使用无限定通配符（Unbounded Wildcard Type），即只定义一个<code>?</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"function\"><span class=\"title\">sample</span>(<span class=\"params\">Pair&lt;?&gt; p</span>)</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>&lt;?&gt;</code>通配符既没有<code>extends</code>，也没有<code>super</code>，因此：</p>\n<ul>\n<li>不允许调用<code>set(T)</code>方法并传入引用（<code>null</code>除外）；</li>\n<li>不允许调用<code>T get()</code>方法并获取<code>T</code>引用（只能获取<code>Object</code>引用）。</li>\n</ul>\n<p>换句话说，既不能读，也不能写，那只能做一些<code>null</code>判断：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">isNull</span>(<span class=\"params\">Pair&lt;?&gt; p</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.getFirst() == <span class=\"literal\">null</span> || p.getLast() == <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大多数情况下，可以引入泛型参数<code>&lt;T&gt;</code>消除<code>&lt;?&gt;</code>通配符：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">isNull</span>(<span class=\"params\">Pair&lt;T&gt; p</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.getFirst() == <span class=\"literal\">null</span> || p.getLast() == <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>&lt;?&gt;</code>通配符有一个独特的特点，就是：<code>Pair&lt;?&gt;</code>是所有<code>Pair&lt;T&gt;</code>的超类：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Pair</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T first;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T last;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Pair</span>(<span class=\"params\">T first, T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getFirst</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"function\"><span class=\"title\">getLast</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setFirst</span>(<span class=\"params\">T first</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.first = first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setLast</span>(<span class=\"params\">T last</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.last = last;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码是可以正常编译运行的，因为<code>Pair&lt;Integer&gt;</code>是<code>Pair&lt;?&gt;</code>的子类，可以安全地向上转型。</p>\n<h1 id=\"泛型和反射\"><a href=\"#泛型和反射\" class=\"headerlink\" title=\"泛型和反射\"></a>泛型和反射</h1><p>Java的部分反射API也是泛型。例如：<code>Class&lt;T&gt;</code>就是泛型：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compile warning:</span></span><br><span class=\"line\"><span class=\"keyword\">Class</span> clazz = <span class=\"keyword\">String</span>.<span class=\"keyword\">class</span>;</span><br><span class=\"line\"><span class=\"keyword\">String</span> str = (<span class=\"keyword\">String</span>) clazz.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// no warning:</span></span><br><span class=\"line\"><span class=\"keyword\">Class</span>&lt;<span class=\"keyword\">String</span>&gt; clazz = <span class=\"keyword\">String</span>.<span class=\"keyword\">class</span>;</span><br><span class=\"line\"><span class=\"keyword\">String</span> str = clazz.newInstance();</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>Class</code>的<code>getSuperclass()</code>方法返回的<code>Class</code>类型是<code>Class&lt;? super T&gt;</code>：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Class&lt;? <span class=\"built_in\">super</span> <span class=\"built_in\">String</span>&gt; sup = <span class=\"built_in\">String</span>.<span class=\"keyword\">class</span>.getSuperclass();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法<code>Constructor&lt;T&gt;</code>也是泛型：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Class</span>&lt;Integer&gt; clazz = Integer.<span class=\"keyword\">class</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Constructor</span>&lt;<span class=\"title\">Integer</span>&gt; <span class=\"title\">cons</span> = <span class=\"title\">clazz</span>.<span class=\"title\">getConstructor</span><span class=\"params\">(int.<span class=\"keyword\">class</span>)</span>;</span></span><br><span class=\"line\">Integer i = cons.newInstance(<span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p>我们可以声明带泛型的数组，但不能用<code>new</code>操作符创建带泛型的数组：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">Pair&lt;<span class=\"keyword\">String</span>&gt;[] ps = <span class=\"literal\">null</span>; <span class=\"comment\">// ok</span></span><br><span class=\"line\">Pair&lt;<span class=\"keyword\">String</span>&gt;[] ps = <span class=\"keyword\">new</span> <span class=\"type\">Pair</span>&lt;<span class=\"keyword\">String</span>&gt;[<span class=\"number\">2</span>]; <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>必须通过强制转型实现带泛型的数组：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">&quot;unchecked&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;[] ps = (<span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;[]) new <span class=\"built_in\">Pair</span>[<span class=\"number\">2</span>];</span><br></pre></td></tr></table></figure>\n\n<p>使用泛型数组要特别小心，因为数组实际上在运行期没有泛型，编译器可以强制检查变量<code>ps</code>，因为它的类型是泛型数组。但是，编译器不会检查变量<code>arr</code>，因为它不是泛型数组。因为这两个变量实际上指向同一个数组，所以，操作<code>arr</code>可能导致从<code>ps</code>获取元素时报错，例如，以下代码演示了不安全地使用带泛型的数组：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>[] arr = new <span class=\"built_in\">Pair</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;[] ps = (<span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;[]) arr;</span><br><span class=\"line\"></span><br><span class=\"line\">ps[<span class=\"number\">0</span>] = new <span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">arr[<span class=\"number\">1</span>] = new <span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">Integer</span>&gt;(<span class=\"number\">1</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">// ClassCastException:</span><br><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt; p = ps[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"built_in\">String</span> s = p.getFirst();</span><br></pre></td></tr></table></figure>\n\n<p>要安全地使用泛型数组，必须扔掉<code>arr</code>的引用：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">&quot;unchecked&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;[] ps = (<span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;[]) new <span class=\"built_in\">Pair</span>[<span class=\"number\">2</span>];</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码中，由于拿不到原始数组的引用，就只能对泛型数组<code>ps</code>进行操作，这种操作就是安全的。</p>\n<p>带泛型的数组实际上是编译器的类型擦除：</p>\n<figure class=\"highlight julia\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Pair</span>[] arr = new <span class=\"built_in\">Pair</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;[] ps = (<span class=\"built_in\">Pair</span>&lt;<span class=\"built_in\">String</span>&gt;[]) arr;</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(ps.getClass() == <span class=\"built_in\">Pair</span>[].class); // <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">String</span> s1 = (<span class=\"built_in\">String</span>) arr[<span class=\"number\">0</span>].getFirst();</span><br><span class=\"line\"><span class=\"built_in\">String</span> s2 = ps[<span class=\"number\">0</span>].getFirst();</span><br></pre></td></tr></table></figure>\n\n<p>所以我们不能直接创建泛型数组<code>T[]</code>，因为擦拭后代码变为<code>Object[]</code>：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compile error:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Abc</span>&lt;<span class=\"title\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"function\">T[] <span class=\"title\">createArray</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> T[<span class=\"number\">5</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>必须借助<code>Class&lt;T&gt;</code>来创建泛型数组：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">T<span class=\"literal\">[]</span> create<span class=\"constructor\">Array(Class&lt;T&gt; <span class=\"params\">cls</span>)</span> &#123;</span><br><span class=\"line\">    return (T<span class=\"literal\">[]</span>) <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Array</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">Instance(<span class=\"params\">cls</span>, 5)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们还可以利用可变参数创建泛型数组<code>T[]</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> ArrayHelper &#123;</span><br><span class=\"line\">    @SafeVarargs</span><br><span class=\"line\">    static &lt;T&gt; T<span class=\"literal\">[]</span> <span class=\"keyword\">as</span><span class=\"constructor\">Array(T<span class=\"operator\">...</span> <span class=\"params\">objs</span>)</span> &#123;</span><br><span class=\"line\">        return objs;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">String<span class=\"literal\">[]</span> ss = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ArrayHelper</span>.</span></span><span class=\"keyword\">as</span><span class=\"constructor\">Array(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>)</span>;</span><br><span class=\"line\">Integer<span class=\"literal\">[]</span> ns = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ArrayHelper</span>.</span></span><span class=\"keyword\">as</span><span class=\"constructor\">Array(1, 2, 3)</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"谨慎使用泛型可变参数\"><a href=\"#谨慎使用泛型可变参数\" class=\"headerlink\" title=\"谨慎使用泛型可变参数\"></a>谨慎使用泛型可变参数</h3><p>在上面的例子中，我们看到，通过：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; T[] <span class=\"function\"><span class=\"title\">asArray</span>(<span class=\"params\">T... objs</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objs;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>似乎可以安全地创建一个泛型数组。但实际上，这种方法非常危险。以下代码来自《Effective Java》的示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>直接调用<code>asArray(T...)</code>似乎没有问题，但是在另一个方法中，我们返回一个泛型数组就会产生<code>ClassCastException</code>，原因还是因为擦拭法，在<code>pickTwo()</code>方法内部，编译器无法检测<code>K[]</code>的正确类型，因此返回了<code>Object[]</code>。</p>\n<p>如果仔细观察，可以发现编译器对所有可变泛型参数都会发出警告，除非确认完全没有问题，才可以用<code>@SafeVarargs</code>消除警告。</p>\n<p> 如果在方法内部创建了泛型数组，最好不要将它返回给外部使用。</p>\n<p>更详细的解释请参考《<a href=\"https://www.oreilly.com/library/view/effective-java-3rd/9780134686097/\">Effective Java</a>》“Item 32: Combine generics and varargs judiciously”。</p>\n","categories":["Java","1.Java快速入门","06.泛型"],"tags":["写作"]},{"title":"8.IO","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_8.IO/","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>IO是指Input&#x2F;Output，即输入和输出。以内存为中心：</p>\n<ul>\n<li>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</li>\n<li>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</li>\n</ul>\n<p>为什么要把数据读到内存才能处理这些数据？因为代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。</p>\n<p>从Java代码来看，输入实际上就是从外部，例如，硬盘上的某个文件，把内容读到内存，并且以Java提供的某种数据类型表示，例如，<code>byte[]</code>，<code>String</code>，这样，后续代码才能处理这些数据。</p>\n<p>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output实际上就是把Java表示的数据格式，例如，<code>byte[]</code>，<code>String</code>等输出到某个地方。</p>\n<p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p>\n<p><img src=\"/8.IO.assets/l.jpeg\" alt=\"java-io\"></p>\n<h3 id=\"InputStream-x2F-OutputStream\"><a href=\"#InputStream-x2F-OutputStream\" class=\"headerlink\" title=\"InputStream &#x2F; OutputStream\"></a>InputStream &#x2F; OutputStream</h3><p>IO流以<code>byte</code>（字节）为最小单位，因此也称为<em>字节流</em>。例如，我们要从磁盘读入一个文件，包含6个字节，就相当于读入了6个字节的数据：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">╔════════════╗</span><br><span class=\"line\">║   Memory   ║</span><br><span class=\"line\">╚════════════╝</span><br><span class=\"line\">       ▲</span><br><span class=\"line\">       │0x48</span><br><span class=\"line\">       │0x65</span><br><span class=\"line\">       │0x6c</span><br><span class=\"line\">       │0x6c</span><br><span class=\"line\">       │0x6f</span><br><span class=\"line\">       │0x21</span><br><span class=\"line\"> ╔═══════════╗</span><br><span class=\"line\"> ║ Hard Disk ║</span><br><span class=\"line\"> ╚═══════════╝</span><br></pre></td></tr></table></figure>\n\n<p>这6个字节是按顺序读入的，所以是输入字节流。</p>\n<p>反过来，我们把6个字节从内存写入磁盘文件，就是输出字节流：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">╔════════════╗</span><br><span class=\"line\">║   Memory   ║</span><br><span class=\"line\">╚════════════╝</span><br><span class=\"line\">       │0x21</span><br><span class=\"line\">       │0x6f</span><br><span class=\"line\">       │0x6c</span><br><span class=\"line\">       │0x6c</span><br><span class=\"line\">       │0x65</span><br><span class=\"line\">       │0x48</span><br><span class=\"line\">       ▼</span><br><span class=\"line\"> ╔═══════════╗</span><br><span class=\"line\"> ║ Hard Disk ║</span><br><span class=\"line\"> ╚═══════════╝</span><br></pre></td></tr></table></figure>\n\n<p>在Java中，<code>InputStream</code>代表输入字节流，<code>OuputStream</code>代表输出字节流，这是最基本的两种IO流。</p>\n<h3 id=\"Reader-x2F-Writer\"><a href=\"#Reader-x2F-Writer\" class=\"headerlink\" title=\"Reader &#x2F; Writer\"></a>Reader &#x2F; Writer</h3><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照<code>char</code>来读写显然更方便，这种流称为<em>字符流</em>。</p>\n<p>Java提供了<code>Reader</code>和<code>Writer</code>表示字符流，字符流传输的最小数据单位是<code>char</code>。</p>\n<p>例如，我们把<code>char[]</code>数组<code>Hi你好</code>这4个字符用<code>Writer</code>字符流写入文件，并且使用UTF-8编码，得到的最终文件内容是8个字节，英文字符<code>H</code>和<code>i</code>各占一个字节，中文字符<code>你好</code>各占3个字节：</p>\n<figure class=\"highlight x86asm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x48</span></span><br><span class=\"line\"><span class=\"number\">0x69</span></span><br><span class=\"line\"><span class=\"number\">0xe4bda0</span></span><br><span class=\"line\"><span class=\"number\">0xe5a5bd</span></span><br></pre></td></tr></table></figure>\n\n<p>反过来，我们用<code>Reader</code>读取以UTF-8编码的这8个字节，会从<code>Reader</code>中得到<code>Hi你好</code>这4个字符。</p>\n<p>因此，<code>Reader</code>和<code>Writer</code>本质上是一个能自动编解码的<code>InputStream</code>和<code>OutputStream</code>。</p>\n<p>使用<code>Reader</code>，数据源虽然是字节，但我们读入的数据都是<code>char</code>类型的字符，原因是<code>Reader</code>内部把读入的<code>byte</code>做了解码，转换成了<code>char</code>。使用<code>InputStream</code>，我们读入的数据和原始二进制数据一模一样，是<code>byte[]</code>数组，但是我们可以自己把二进制<code>byte[]</code>数组按照某种编码转换为字符串。究竟使用<code>Reader</code>还是<code>InputStream</code>，要取决于具体的使用场景。如果数据源不是文本，就只能使用<code>InputStream</code>，如果数据源是文本，使用Reader更方便一些。<code>Writer</code>和<code>OutputStream</code>是类似的。</p>\n<h3 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h3><p>同步IO是指，读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</p>\n<p>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</p>\n<p>Java标准库的包<code>java.io</code>提供了同步IO，而<code>java.nio</code>则是异步IO。上面我们讨论的<code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>和<code>Writer</code>都是同步IO的抽象类，对应的具体实现类，以文件为例，有<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>FileReader</code>和<code>FileWriter</code>。</p>\n<p>本节我们只讨论Java的同步IO，即输入&#x2F;输出流的IO模型。</p>\n<h1 id=\"File对象\"><a href=\"#File对象\" class=\"headerlink\" title=\"File对象\"></a>File对象</h1><p>在计算机系统中，文件是非常重要的存储方式。Java的标准库<code>java.io</code>提供了<code>File</code>对象来操作文件和目录。</p>\n<p>要构造一个<code>File</code>对象，需要传入文件路径：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">File</span> f = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"built_in\">File</span></span>(<span class=\"string\">&quot;C:\\\\Windows\\\\notepad.exe&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意Windows平台使用<code>\\</code>作为路径分隔符，在Java字符串中需要用<code>\\\\</code>表示一个<code>\\</code>。Linux平台使用<code>/</code>作为路径分隔符：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">File</span> f = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"built_in\">File</span></span>(<span class=\"string\">&quot;/usr/bin/javac&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>传入相对路径时，相对路径前面加上当前目录就是绝对路径：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 假设当前目录是C:\\Docs</span><br><span class=\"line\">File f1 = new File(<span class=\"string\">&quot;sub\\\\javac&quot;</span>); <span class=\"regexp\">//</span> 绝对路径是C:\\Docs\\<span class=\"function\"><span class=\"keyword\">sub</span>\\<span class=\"title\">javac</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">File</span> <span class=\"title\">f3</span> = <span class=\"title\">new</span> <span class=\"title\">File</span></span>(&quot;.\\\\<span class=\"keyword\">sub</span>\\\\javac&quot;); // 绝对路径是C:\\Docs\\<span class=\"function\"><span class=\"keyword\">sub</span>\\<span class=\"title\">javac</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">File</span> <span class=\"title\">f3</span> = <span class=\"title\">new</span> <span class=\"title\">File</span></span>(&quot;..\\\\<span class=\"keyword\">sub</span>\\\\javac&quot;); // 绝对路径是C:\\<span class=\"function\"><span class=\"keyword\">sub</span>\\<span class=\"title\">javac</span></span></span><br></pre></td></tr></table></figure>\n\n<p>可以用<code>.</code>表示当前目录，<code>..</code>表示上级目录。</p>\n<p>File对象有3种形式表示的路径，一种是<code>getPath()</code>，返回构造方法传入的路径，一种是<code>getAbsolutePath()</code>，返回绝对路径，一种是<code>getCanonicalPath</code>，它和绝对路径类似，但是返回的是规范路径。</p>\n<p>什么是规范路径？我们看以下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>绝对路径可以表示成<code>C:\\Windows\\System32\\..\\notepad.exe</code>，而规范路径就是把<code>.</code>和<code>..</code>转换成标准的绝对路径后的路径：<code>C:\\Windows\\notepad.exe</code>。</p>\n<p>因为Windows和Linux的路径分隔符不同，File对象有一个静态变量用于表示当前平台的系统分隔符：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">File</span>.</span></span>separator); <span class=\"comment\">// 根据当前平台打印&quot;\\&quot;或&quot;/&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"文件和目录\"><a href=\"#文件和目录\" class=\"headerlink\" title=\"文件和目录\"></a>文件和目录</h3><p><code>File</code>对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个<code>File</code>对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个<code>File</code>对象，并不会导致任何磁盘操作。只有当我们调用<code>File</code>对象的某些方法的时候，才真正进行磁盘操作。</p>\n<p>例如，调用<code>isFile()</code>，判断该<code>File</code>对象是否是一个已存在的文件，调用<code>isDirectory()</code>，判断该<code>File</code>对象是否是一个已存在的目录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>用<code>File</code>对象获取到一个文件时，还可以进一步判断文件的权限和大小：</p>\n<ul>\n<li><code>boolean canRead()</code>：是否可读；</li>\n<li><code>boolean canWrite()</code>：是否可写；</li>\n<li><code>boolean canExecute()</code>：是否可执行；</li>\n<li><code>long length()</code>：文件字节大小。</li>\n</ul>\n<p>对目录而言，是否可执行表示能否列出它包含的文件和子目录。</p>\n<h3 id=\"创建和删除文件\"><a href=\"#创建和删除文件\" class=\"headerlink\" title=\"创建和删除文件\"></a>创建和删除文件</h3><p>当File对象表示一个文件时，可以通过<code>createNewFile()</code>创建一个新文件，用<code>delete()</code>删除该文件：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">File</span> <span class=\"keyword\">file</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">File</span>(<span class=\"string\">&quot;/path/to/file&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">file</span>.createNewFile()) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 文件创建成功:</span></span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">file</span>.<span class=\"keyword\">delete</span>()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 删除文件成功:</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有些时候，程序需要读写一些临时文件，File对象提供了<code>createTempFile()</code>来创建一个临时文件，以及<code>deleteOnExit()</code>在JVM退出时自动删除该文件。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"遍历文件和目录\"><a href=\"#遍历文件和目录\" class=\"headerlink\" title=\"遍历文件和目录\"></a>遍历文件和目录</h3><p>当File对象表示一个目录时，可以使用<code>list()</code>和<code>listFiles()</code>列出目录下的文件和子目录名。<code>listFiles()</code>提供了一系列重载方法，可以过滤不想要的文件和目录：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：</p>\n<ul>\n<li><code>boolean mkdir()</code>：创建当前File对象表示的目录；</li>\n<li><code>boolean mkdirs()</code>：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；</li>\n<li><code>boolean delete()</code>：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</li>\n</ul>\n<h3 id=\"Path\"><a href=\"#Path\" class=\"headerlink\" title=\"Path\"></a>Path</h3><p>Java标准库还提供了一个<code>Path</code>对象，它位于<code>java.nio.file</code>包。<code>Path</code>对象和<code>File</code>对象类似，但操作更加简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果需要对目录进行复杂的拼接、遍历等操作，使用<code>Path</code>对象更方便。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>请利用<code>File</code>对象列出指定目录下的所有子目录和文件，并按层次打印。</p>\n<p>例如，输出：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">Documents/</span><br><span class=\"line\">  word/</span><br><span class=\"line\">    <span class=\"number\">1</span><span class=\"selector-class\">.docx</span></span><br><span class=\"line\">    <span class=\"number\">2</span><span class=\"selector-class\">.docx</span></span><br><span class=\"line\">    work/</span><br><span class=\"line\">      abc<span class=\"selector-class\">.doc</span></span><br><span class=\"line\">  ppt/</span><br><span class=\"line\">  other/</span><br></pre></td></tr></table></figure>\n\n<p>如果不指定参数，则使用当前目录，如果指定参数，则使用指定目录。</p>\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/80.IO.1255945227202752/10.File%E5%AF%B9%E8%B1%A1.1298069154955297/io-file.zip?utm_source=blog_lxf\">io-file</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<h1 id=\"InputStream\"><a href=\"#InputStream\" class=\"headerlink\" title=\"InputStream\"></a>InputStream</h1><p><code>InputStream</code>就是Java标准库提供的最基本的输入流。它位于<code>java.io</code>这个包里。<code>java.io</code>包提供了所有同步IO的功能。</p>\n<p>要特别注意的一点是，<code>InputStream</code>并不是一个接口，而是一个抽象类，它是所有输入流的超类。这个抽象类定义的一个最重要的方法就是<code>int read()</code>，签名如下：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法会读取输入流的下一个字节，并返回字节表示的<code>int</code>值（0~255）。如果已读到末尾，返回<code>-1</code>表示不能继续读取了。</p>\n<p><code>FileInputStream</code>是<code>InputStream</code>的一个子类。顾名思义，<code>FileInputStream</code>就是从文件流中读取数据。下面的代码演示了如何完整地读取一个<code>FileInputStream</code>的所有字节：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> throws IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个FileInputStream对象:</span></span><br><span class=\"line\">    InputStream input = <span class=\"keyword\">new</span> <span class=\"built_in\">FileInputStream</span>(<span class=\"string\">&quot;src/readme.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = input.<span class=\"built_in\">read</span>(); <span class=\"comment\">// 反复调用read()方法，直到返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(n); <span class=\"comment\">// 打印byte的值</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    input.<span class=\"built_in\">close</span>(); <span class=\"comment\">// 关闭流</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在计算机中，类似文件、网络端口这些资源，都是由操作系统统一管理的。应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</p>\n<p><code>InputStream</code>和<code>OutputStream</code>都是通过<code>close()</code>方法来关闭流。关闭流就会释放对应的底层资源。</p>\n<p>我们还要注意到在读取或写入IO流的过程中，可能会发生错误，例如，文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成<code>IOException</code>异常并抛出。因此，所有与IO操作相关的代码都必须正确处理<code>IOException</code>。</p>\n<p>仔细观察上面的代码，会发现一个潜在的问题：如果读取过程中发生了IO错误，<code>InputStream</code>就没法正确地关闭，资源也就没法及时释放。</p>\n<p>因此，我们需要用<code>try ... finally</code>来保证<code>InputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"type\">void</span> readFile() throws IOException &#123;</span><br><span class=\"line\">    InputStream input = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        input = <span class=\"built_in\">new</span> FileInputStream(&quot;src/readme.txt&quot;);</span><br><span class=\"line\">        <span class=\"type\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = <span class=\"keyword\">input</span>.<span class=\"keyword\">read</span>()) != <span class=\"number\">-1</span>) &#123; // 利用<span class=\"keyword\">while</span>同时读取并判断</span><br><span class=\"line\">            <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">input</span> != <span class=\"keyword\">null</span>) &#123; <span class=\"keyword\">input</span>.<span class=\"keyword\">close</span>(); &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>try ... finally</code>来编写上述代码会感觉比较复杂，更好的写法是利用Java 7引入的新的<code>try(resource)</code>的语法，只需要编写<code>try</code>语句，让编译器自动为我们关闭资源。推荐的写法如下：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"type\">void</span> readFile() throws IOException &#123;</span><br><span class=\"line\">    try (InputStream input = <span class=\"built_in\">new</span> FileInputStream(&quot;src/readme.txt&quot;)) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = <span class=\"keyword\">input</span>.<span class=\"keyword\">read</span>()) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; // 编译器在此自动为我们写入finally并调用<span class=\"keyword\">close</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，编译器并不会特别地为<code>InputStream</code>加上自动关闭。编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。<code>InputStream</code>和<code>OutputStream</code>都实现了这个接口，因此，都可以用在<code>try(resource)</code>中。</p>\n<h3 id=\"缓冲\"><a href=\"#缓冲\" class=\"headerlink\" title=\"缓冲\"></a>缓冲</h3><p>在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。<code>InputStream</code>提供了两个重载方法来支持读取多个字节：</p>\n<ul>\n<li><code>int read(byte[] b)</code>：读取若干字节并填充到<code>byte[]</code>数组，返回读取的字节数</li>\n<li><code>int read(byte[] b, int off, int len)</code>：指定<code>byte[]</code>数组的偏移量和最大填充数</li>\n</ul>\n<p>利用上述方法一次读取多个字节时，需要先定义一个<code>byte[]</code>数组作为缓冲区，<code>read()</code>方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。<code>read()</code>方法的返回值不再是字节的<code>int</code>值，而是返回实际读取了多少个字节。如果返回<code>-1</code>，表示没有更多的数据了。</p>\n<p>利用缓冲区一次读取多个字节的代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> throws IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">try</span></span> (InputStream input = <span class=\"keyword\">new</span> <span class=\"built_in\">FileInputStream</span>(<span class=\"string\">&quot;src/readme.txt&quot;</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义1000个字节大小的缓冲区:</span></span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = input.<span class=\"built_in\">read</span>(buffer)) != <span class=\"number\">-1</span>) &#123; <span class=\"comment\">// 读取到缓冲区</span></span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;read &quot;</span> + n + <span class=\"string\">&quot; bytes.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h3><p>在调用<code>InputStream</code>的<code>read()</code>方法读取数据时，我们说<code>read()</code>方法是阻塞（Blocking）的。它的意思是，对于下面的代码：</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> <span class=\"built_in\">n</span>;</span><br><span class=\"line\"><span class=\"built_in\">n</span> = input.read(); // 必须等待read()方法返回才能执行下一行代码</span><br><span class=\"line\"><span class=\"built_in\">int</span> m = <span class=\"built_in\">n</span>;</span><br></pre></td></tr></table></figure>\n\n<p>执行到第二行代码时，必须等<code>read()</code>方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定<code>read()</code>方法调用到底要花费多长时间。</p>\n<h3 id=\"InputStream实现类\"><a href=\"#InputStream实现类\" class=\"headerlink\" title=\"InputStream实现类\"></a>InputStream实现类</h3><p>用<code>FileInputStream</code>可以从文件获取输入流，这是<code>InputStream</code>常用的一个实现类。此外，<code>ByteArrayInputStream</code>可以在内存中模拟一个<code>InputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>ByteArrayInputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>InputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>InputStream</code>。</p>\n<p>举个栗子：我们想从文件中读取所有字节，并转换成<code>char</code>然后拼成一个字符串，可以这么写：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">try</span></span> (InputStream input = <span class=\"keyword\">new</span> <span class=\"built_in\">FileInputStream</span>(<span class=\"string\">&quot;C:\\\\test\\\\README.txt&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">            StringBuilder sb = <span class=\"keyword\">new</span> <span class=\"built_in\">StringBuilder</span>();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((n = input.<span class=\"built_in\">read</span>()) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                sb.<span class=\"built_in\">append</span>((<span class=\"keyword\">char</span>) n);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            s = sb.<span class=\"built_in\">toString</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要测试上面的程序，就真的需要在本地硬盘上放一个真实的文本文件。如果我们把代码稍微改造一下，提取一个<code>readAsString()</code>的方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> s;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">try</span></span> (InputStream input = <span class=\"keyword\">new</span> <span class=\"built_in\">FileInputStream</span>(<span class=\"string\">&quot;C:\\\\test\\\\README.txt&quot;</span>)) &#123;</span><br><span class=\"line\">            s = <span class=\"built_in\">readAsString</span>(input);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">String</span> <span class=\"title\">readAsString</span><span class=\"params\">(InputStream input)</span> throws IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> <span class=\"built_in\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = input.<span class=\"built_in\">read</span>()) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            sb.<span class=\"built_in\">append</span>((<span class=\"keyword\">char</span>) n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.<span class=\"built_in\">toString</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对这个<code>String readAsString(InputStream input)</code>方法进行测试就相当简单，因为不一定要传入一个真的<code>FileInputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这就是面向抽象编程原则的应用：接受<code>InputStream</code>抽象类型，而不是具体的<code>FileInputStream</code>类型，从而使得代码可以处理<code>InputStream</code>的任意实现类。</p>\n<h1 id=\"OutputStream\"><a href=\"#OutputStream\" class=\"headerlink\" title=\"OutputStream\"></a>OutputStream</h1><p>和<code>InputStream</code>相反，<code>OutputStream</code>是Java标准库提供的最基本的输出流。</p>\n<p>和<code>InputStream</code>类似，<code>OutputStream</code>也是抽象类，它是所有输出流的超类。这个抽象类定义的一个最重要的方法就是<code>void write(int b)</code>，签名如下：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法会写入一个字节到输出流。要注意的是，虽然传入的是<code>int</code>参数，但只会写入一个字节，即只写入<code>int</code>最低8位表示字节的部分（相当于<code>b &amp; 0xff</code>）。</p>\n<p>和<code>InputStream</code>类似，<code>OutputStream</code>也提供了<code>close()</code>方法关闭输出流，以便释放系统资源。要特别注意：<code>OutputStream</code>还提供了一个<code>flush()</code>方法，它的目的是将缓冲区的内容真正输出到目的地。</p>\n<p>为什么要有<code>flush()</code>？因为向磁盘、网络写入数据的时候，出于效率的考虑，操作系统并不是输出一个字节就立刻写入到文件或者发送到网络，而是把输出的字节先放到内存的一个缓冲区里（本质上就是一个<code>byte[]</code>数组），等到缓冲区写满了，再一次性写入文件或者网络。对于很多IO设备来说，一次写一个字节和一次写1000个字节，花费的时间几乎是完全一样的，所以<code>OutputStream</code>有个<code>flush()</code>方法，能强制把缓冲区内容输出。</p>\n<p>通常情况下，我们不需要调用这个<code>flush()</code>方法，因为缓冲区写满了<code>OutputStream</code>会自动调用它，并且，在调用<code>close()</code>方法关闭<code>OutputStream</code>之前，也会自动调用<code>flush()</code>方法。</p>\n<p>但是，在某些情况下，我们必须手动调用<code>flush()</code>方法。举个栗子：</p>\n<p>小明正在开发一款在线聊天软件，当用户输入一句话后，就通过<code>OutputStream</code>的<code>write()</code>方法写入网络流。小明测试的时候发现，发送方输入后，接收方根本收不到任何信息，怎么肥四？</p>\n<p>原因就在于写入网络流是先写入内存缓冲区，等缓冲区满了才会一次性发送到网络。如果缓冲区大小是4K，则发送方要敲几千个字符后，操作系统才会把缓冲区的内容发送出去，这个时候，接收方会一次性收到大量消息。</p>\n<p>解决办法就是每输入一句话后，立刻调用<code>flush()</code>，不管当前缓冲区是否已满，强迫操作系统把缓冲区的内容立刻发送出去。</p>\n<p>实际上，<code>InputStream</code>也有缓冲区。例如，从<code>FileInputStream</code>读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用<code>int read()</code>读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用<code>read()</code>，则会触发操作系统的下一次读取并再次填满缓冲区。</p>\n<h3 id=\"FileOutputStream\"><a href=\"#FileOutputStream\" class=\"headerlink\" title=\"FileOutputStream\"></a>FileOutputStream</h3><p>我们以<code>FileOutputStream</code>为例，演示如何将若干个字节写入文件流：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">()</span> throws IOException </span>&#123;</span><br><span class=\"line\">    OutputStream output = <span class=\"keyword\">new</span> <span class=\"built_in\">FileOutputStream</span>(<span class=\"string\">&quot;out/readme.txt&quot;</span>);</span><br><span class=\"line\">    output.<span class=\"built_in\">write</span>(<span class=\"number\">72</span>); <span class=\"comment\">// H</span></span><br><span class=\"line\">    output.<span class=\"built_in\">write</span>(<span class=\"number\">101</span>); <span class=\"comment\">// e</span></span><br><span class=\"line\">    output.<span class=\"built_in\">write</span>(<span class=\"number\">108</span>); <span class=\"comment\">// l</span></span><br><span class=\"line\">    output.<span class=\"built_in\">write</span>(<span class=\"number\">108</span>); <span class=\"comment\">// l</span></span><br><span class=\"line\">    output.<span class=\"built_in\">write</span>(<span class=\"number\">111</span>); <span class=\"comment\">// o</span></span><br><span class=\"line\">    output.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。这时，可以用<code>OutputStream</code>提供的重载方法<code>void write(byte[])</code>来实现：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">()</span> throws IOException </span>&#123;</span><br><span class=\"line\">    OutputStream output = <span class=\"keyword\">new</span> <span class=\"built_in\">FileOutputStream</span>(<span class=\"string\">&quot;out/readme.txt&quot;</span>);</span><br><span class=\"line\">    output.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;Hello&quot;</span>.<span class=\"built_in\">getBytes</span>(<span class=\"string\">&quot;UTF-8&quot;</span>)); <span class=\"comment\">// Hello</span></span><br><span class=\"line\">    output.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和<code>InputStream</code>一样，上述代码没有考虑到在发生异常的情况下如何正确地关闭资源。写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。我们需要用<code>try(resource)</code>来保证<code>OutputStream</code>在无论是否发生IO错误的时候都能够正确地关闭：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">writeFile</span><span class=\"params\">()</span> throws IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">try</span></span> (OutputStream output = <span class=\"keyword\">new</span> <span class=\"built_in\">FileOutputStream</span>(<span class=\"string\">&quot;out/readme.txt&quot;</span>)) &#123;</span><br><span class=\"line\">        output.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;Hello&quot;</span>.<span class=\"built_in\">getBytes</span>(<span class=\"string\">&quot;UTF-8&quot;</span>)); <span class=\"comment\">// Hello</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// 编译器在此自动为我们写入finally并调用close()</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"阻塞-1\"><a href=\"#阻塞-1\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h3><p>和<code>InputStream</code>一样，<code>OutputStream</code>的<code>write()</code>方法也是阻塞的。</p>\n<h3 id=\"OutputStream实现类\"><a href=\"#OutputStream实现类\" class=\"headerlink\" title=\"OutputStream实现类\"></a>OutputStream实现类</h3><p>用<code>FileOutputStream</code>可以从文件获取输出流，这是<code>OutputStream</code>常用的一个实现类。此外，<code>ByteArrayOutputStream</code>可以在内存中模拟一个<code>OutputStream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>ByteArrayOutputStream</code>实际上是把一个<code>byte[]</code>数组在内存中变成一个<code>OutputStream</code>，虽然实际应用不多，但测试的时候，可以用它来构造一个<code>OutputStream</code>。</p>\n<p>同时操作多个<code>AutoCloseable</code>资源时，在<code>try(resource) &#123; ... &#125;</code>语句中可以同时写出多个资源，用<code>;</code>隔开。例如，同时读写两个文件：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读取input.txt，写入output.txt:</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> <span class=\"constructor\">FileInputStream(<span class=\"string\">&quot;input.txt&quot;</span>)</span>;</span><br><span class=\"line\">     OutputStream output = <span class=\"keyword\">new</span> <span class=\"constructor\">FileOutputStream(<span class=\"string\">&quot;output.txt&quot;</span>)</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    input.transfer<span class=\"constructor\">To(<span class=\"params\">output</span>)</span>; <span class=\"comment\">// transferTo的作用是?</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>请利用<code>InputStream</code>和<code>OutputStream</code>，编写一个复制文件的程序，它可以带参数运行：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\">java CopyFile.java <span class=\"keyword\">source</span>.txt <span class=\"keyword\">copy</span>.txt</span><br></pre></td></tr></table></figure>\n\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/80.IO.1255945227202752/30.OutputStream.1298069169635361/io-copy.zip?utm_source=blog_lxf\">CopyFile练习</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<h1 id=\"Filter模式\"><a href=\"#Filter模式\" class=\"headerlink\" title=\"Filter模式\"></a>Filter模式</h1><p>Java的IO标准库提供的<code>InputStream</code>根据来源可以包括：</p>\n<ul>\n<li><code>FileInputStream</code>：从文件读取数据，是最终数据源；</li>\n<li><code>ServletInputStream</code>：从HTTP请求读取数据，是最终数据源；</li>\n<li><code>Socket.getInputStream()</code>：从TCP连接读取数据，是最终数据源；</li>\n<li>…</li>\n</ul>\n<p>如果我们要给<code>FileInputStream</code>添加缓冲功能，则可以从<code>FileInputStream</code>派生一个类：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">BufferedFileInputStream </span><span class=\"keyword\">extends </span>FileInputStream</span><br></pre></td></tr></table></figure>\n\n<p>如果要给<code>FileInputStream</code>添加计算签名的功能，类似的，也可以从<code>FileInputStream</code>派生一个类：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DigestFileInputStream </span><span class=\"keyword\">extends </span>FileInputStream</span><br></pre></td></tr></table></figure>\n\n<p>如果要给<code>FileInputStream</code>添加加密&#x2F;解密功能，还是可以从<code>FileInputStream</code>派生一个类：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">CipherFileInputStream <span class=\"keyword\">extends</span> FileInputStream</span><br></pre></td></tr></table></figure>\n\n<p>如果要给<code>FileInputStream</code>添加缓冲和签名的功能，那么我们还需要派生<code>BufferedDigestFileInputStream</code>。如果要给<code>FileInputStream</code>添加缓冲和加解密的功能，则需要派生<code>BufferedCipherFileInputStream</code>。</p>\n<p>我们发现，给<code>FileInputStream</code>添加3种功能，至少需要3个子类。这3种功能的组合，又需要更多的子类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                          ┌─────────────────┐</span><br><span class=\"line\">                          │ FileInputStream │</span><br><span class=\"line\">                          └─────────────────┘</span><br><span class=\"line\">                                   ▲</span><br><span class=\"line\">             ┌───────────┬─────────┼─────────┬───────────┐</span><br><span class=\"line\">             │           │         │         │           │</span><br><span class=\"line\">┌───────────────────────┐│┌─────────────────┐│┌─────────────────────┐</span><br><span class=\"line\">│BufferedFileInputStream│││DigestInputStream│││CipherFileInputStream│</span><br><span class=\"line\">└───────────────────────┘│└─────────────────┘│└─────────────────────┘</span><br><span class=\"line\">                         │                   │</span><br><span class=\"line\">    ┌─────────────────────────────┐ ┌─────────────────────────────┐</span><br><span class=\"line\">    │BufferedDigestFileInputStream│ │BufferedCipherFileInputStream│</span><br><span class=\"line\">    └─────────────────────────────┘ └─────────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>这还只是针对<code>FileInputStream</code>设计，如果针对另一种<code>InputStream</code>设计，很快会出现子类爆炸的情况。</p>\n<p>因此，直接使用继承，为各种<code>InputStream</code>附加更多的功能，根本无法控制代码的复杂度，很快就会失控。</p>\n<p>为了解决依赖继承会导致子类数量失控的问题，JDK首先将<code>InputStream</code>分为两大类：</p>\n<p>一类是直接提供数据的基础<code>InputStream</code>，例如：</p>\n<ul>\n<li>FileInputStream</li>\n<li>ByteArrayInputStream</li>\n<li>ServletInputStream</li>\n<li>…</li>\n</ul>\n<p>一类是提供额外附加功能的<code>InputStream</code>，例如：</p>\n<ul>\n<li>BufferedInputStream</li>\n<li>DigestInputStream</li>\n<li>CipherInputStream</li>\n<li>…</li>\n</ul>\n<p>当我们需要给一个“基础”<code>InputStream</code>附加各种功能时，我们先确定这个能提供数据源的<code>InputStream</code>，因为我们需要的数据总得来自某个地方，例如，<code>FileInputStream</code>，数据来源自文件：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">InputStream file</span> = new FileInputStream(<span class=\"string\">&quot;test.gz&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>紧接着，我们希望<code>FileInputStream</code>能提供缓冲的功能来提高读取的效率，因此我们用<code>BufferedInputStream</code>包装这个<code>InputStream</code>，得到的包装类型是<code>BufferedInputStream</code>，但它仍然被视为一个<code>InputStream</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputStream buffered = <span class=\"keyword\">new</span> <span class=\"constructor\">BufferedInputStream(<span class=\"params\">file</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>最后，假设该文件已经用gzip压缩了，我们希望直接读取解压缩的内容，就可以再包装一个<code>GZIPInputStream</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputStream gzip = <span class=\"keyword\">new</span> <span class=\"constructor\">GZIPInputStream(<span class=\"params\">buffered</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>无论我们包装多少次，得到的对象始终是<code>InputStream</code>，我们直接用<code>InputStream</code>来引用它，就可以正常读取：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────────────────┐</span><br><span class=\"line\">│GZIPInputStream          │</span><br><span class=\"line\">│┌───────────────────────┐│</span><br><span class=\"line\">││BufferedFileInputStream││</span><br><span class=\"line\">││┌─────────────────────┐││</span><br><span class=\"line\">│││   FileInputStream   │││</span><br><span class=\"line\">││└─────────────────────┘││</span><br><span class=\"line\">│└───────────────────────┘│</span><br><span class=\"line\">└─────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>上述这种通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。它可以让我们通过少量的类来实现各种功能的组合：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                 ┌─────────────┐</span><br><span class=\"line\">                 │ InputStream │</span><br><span class=\"line\">                 └─────────────┘</span><br><span class=\"line\">                       ▲ ▲</span><br><span class=\"line\">┌────────────────────┐ │ │ ┌─────────────────┐</span><br><span class=\"line\">│  FileInputStream   │─┤ └─│FilterInputStream│</span><br><span class=\"line\">└────────────────────┘ │   └─────────────────┘</span><br><span class=\"line\">┌────────────────────┐ │     ▲ ┌───────────────────┐</span><br><span class=\"line\">│ByteArrayInputStream│─┤     ├─│BufferedInputStream│</span><br><span class=\"line\">└────────────────────┘ │     │ └───────────────────┘</span><br><span class=\"line\">┌────────────────────┐ │     │ ┌───────────────────┐</span><br><span class=\"line\">│ ServletInputStream │─┘     ├─│  DataInputStream  │</span><br><span class=\"line\">└────────────────────┘       │ └───────────────────┘</span><br><span class=\"line\">                             │ ┌───────────────────┐</span><br><span class=\"line\">                             └─│CheckedInputStream │</span><br><span class=\"line\">                               └───────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>类似的，<code>OutputStream</code>也是以这种模式来提供各种功能：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                  ┌─────────────┐</span><br><span class=\"line\">                  │OutputStream │</span><br><span class=\"line\">                  └─────────────┘</span><br><span class=\"line\">                        ▲ ▲</span><br><span class=\"line\">┌─────────────────────┐ │ │ ┌──────────────────┐</span><br><span class=\"line\">│  FileOutputStream   │─┤ └─│FilterOutputStream│</span><br><span class=\"line\">└─────────────────────┘ │   └──────────────────┘</span><br><span class=\"line\">┌─────────────────────┐ │     ▲ ┌────────────────────┐</span><br><span class=\"line\">│ByteArrayOutputStream│─┤     ├─│BufferedOutputStream│</span><br><span class=\"line\">└─────────────────────┘ │     │ └────────────────────┘</span><br><span class=\"line\">┌─────────────────────┐ │     │ ┌────────────────────┐</span><br><span class=\"line\">│ ServletOutputStream │─┘     ├─│  DataOutputStream  │</span><br><span class=\"line\">└─────────────────────┘       │ └────────────────────┘</span><br><span class=\"line\">                              │ ┌────────────────────┐</span><br><span class=\"line\">                              └─│CheckedOutputStream │</span><br><span class=\"line\">                                └────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编写FilterInputStream\"><a href=\"#编写FilterInputStream\" class=\"headerlink\" title=\"编写FilterInputStream\"></a>编写FilterInputStream</h3><p>我们也可以自己编写<code>FilterInputStream</code>，以便可以把自己的<code>FilterInputStream</code>“叠加”到任何一个<code>InputStream</code>中。</p>\n<p>下面的例子演示了如何编写一个<code>CountInputStream</code>，它的作用是对输入的字节进行计数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到在叠加多个<code>FilterInputStream</code>，我们只需要持有最外层的<code>InputStream</code>，并且，当最外层的<code>InputStream</code>关闭时（在<code>try(resource)</code>块的结束处自动关闭），内层的<code>InputStream</code>的<code>close()</code>方法也会被自动调用，并最终调用到最核心的“基础”<code>InputStream</code>，因此不存在资源泄露。</p>\n<h1 id=\"操作Zip\"><a href=\"#操作Zip\" class=\"headerlink\" title=\"操作Zip\"></a>操作Zip</h1><p><code>ZipInputStream</code>是一种<code>FilterInputStream</code>，它可以直接读取zip包的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────────────┐</span><br><span class=\"line\">│    InputStream    │</span><br><span class=\"line\">└───────────────────┘</span><br><span class=\"line\">          ▲</span><br><span class=\"line\">          │</span><br><span class=\"line\">┌───────────────────┐</span><br><span class=\"line\">│ FilterInputStream │</span><br><span class=\"line\">└───────────────────┘</span><br><span class=\"line\">          ▲</span><br><span class=\"line\">          │</span><br><span class=\"line\">┌───────────────────┐</span><br><span class=\"line\">│InflaterInputStream│</span><br><span class=\"line\">└───────────────────┘</span><br><span class=\"line\">          ▲</span><br><span class=\"line\">          │</span><br><span class=\"line\">┌───────────────────┐</span><br><span class=\"line\">│  ZipInputStream   │</span><br><span class=\"line\">└───────────────────┘</span><br><span class=\"line\">          ▲</span><br><span class=\"line\">          │</span><br><span class=\"line\">┌───────────────────┐</span><br><span class=\"line\">│  JarInputStream   │</span><br><span class=\"line\">└───────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>另一个<code>JarInputStream</code>是从<code>ZipInputStream</code>派生，它增加的主要功能是直接读取jar文件里面的<code>MANIFEST.MF</code>文件。因为本质上jar包就是zip包，只是额外附加了一些固定的描述文件。</p>\n<h3 id=\"读取zip包\"><a href=\"#读取zip包\" class=\"headerlink\" title=\"读取zip包\"></a>读取zip包</h3><p>我们来看看<code>ZipInputStream</code>的基本用法。</p>\n<p>我们要创建一个<code>ZipInputStream</code>，通常是传入一个<code>FileInputStream</code>作为数据源，然后，循环调用<code>getNextEntry()</code>，直到返回<code>null</code>，表示zip流结束。</p>\n<p>一个<code>ZipEntry</code>表示一个压缩文件或目录，如果是压缩文件，我们就用<code>read()</code>方法不断读取，直到返回<code>-1</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ZipInputStream zip = <span class=\"keyword\">new</span> <span class=\"type\">ZipInputStream</span>(<span class=\"keyword\">new</span> <span class=\"type\">FileInputStream</span>(...))) &#123;</span><br><span class=\"line\">    ZipEntry entry = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((entry = zip.getNextEntry()) != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> name = entry.getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!entry.isDirectory()) &#123;</span><br><span class=\"line\">            int n;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((n = zip.read()) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">                ...</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"写入zip包\"><a href=\"#写入zip包\" class=\"headerlink\" title=\"写入zip包\"></a>写入zip包</h3><p><code>ZipOutputStream</code>是一种<code>FilterOutputStream</code>，它可以直接写入内容到zip包。我们要先创建一个<code>ZipOutputStream</code>，通常是包装一个<code>FileOutputStream</code>，然后，每写入一个文件前，先调用<code>putNextEntry()</code>，然后用<code>write()</code>写入<code>byte[]</code>数据，写入完毕后调用<code>closeEntry()</code>结束这个文件的打包。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ZipOutputStream zip = <span class=\"keyword\">new</span> <span class=\"constructor\">ZipOutputStream(<span class=\"params\">new</span> FileOutputStream(<span class=\"operator\">...</span>)</span>)) &#123;</span><br><span class=\"line\">    File<span class=\"literal\">[]</span> files =<span class=\"operator\"> ...</span></span><br><span class=\"line\"><span class=\"operator\">    </span><span class=\"keyword\">for</span> (File file : files) &#123;</span><br><span class=\"line\">        zip.put<span class=\"constructor\">NextEntry(<span class=\"params\">new</span> ZipEntry(<span class=\"params\">file</span>.<span class=\"params\">getName</span>()</span>));</span><br><span class=\"line\">        zip.write(get<span class=\"constructor\">FileDataAsBytes(<span class=\"params\">file</span>)</span>);</span><br><span class=\"line\">        zip.close<span class=\"constructor\">Entry()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码没有考虑文件的目录结构。如果要实现目录层次结构，<code>new ZipEntry(name)</code>传入的<code>name</code>要用相对路径。</p>\n<h1 id=\"读取classpath资源\"><a href=\"#读取classpath资源\" class=\"headerlink\" title=\"读取classpath资源\"></a>读取classpath资源</h1><p>很多Java程序启动的时候，都需要读取配置文件。例如，从一个<code>.properties</code>文件中读取配置：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> conf = <span class=\"string\">&quot;C:\\\\conf\\\\default.properties&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> <span class=\"type\">FileInputStream</span>(conf)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这段代码要正常执行，必须在C盘创建<code>conf</code>目录，然后在目录里创建<code>default.properties</code>文件。但是，在Linux系统上，路径和Windows的又不一样。</p>\n<p>因此，从磁盘的固定目录读取配置文件，不是一个好的办法。</p>\n<p>有没有路径无关的读取文件的方式呢？</p>\n<p>我们知道，Java存放<code>.class</code>的目录或jar包也可以包含任意其他类型的文件，例如：</p>\n<ul>\n<li>配置文件，例如<code>.properties</code>；</li>\n<li>图片文件，例如<code>.jpg</code>；</li>\n<li>文本文件，例如<code>.txt</code>，<code>.csv</code>；</li>\n<li>……</li>\n</ul>\n<p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题：如果我们把<code>default.properties</code>文件放到classpath中，就不用关心它的实际存放路径。</p>\n<p>在classpath中的资源文件，路径总是以<code>／</code>开头，我们先获取当前的<code>Class</code>对象，然后调用<code>getResourceAsStream()</code>就可以直接从classpath读取任意的资源文件：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream input = get<span class=\"constructor\">Class()</span>.get<span class=\"constructor\">ResourceAsStream(<span class=\"string\">&quot;/default.properties&quot;</span>)</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用<code>getResourceAsStream()</code>需要特别注意的一点是，如果资源文件不存在，它将返回<code>null</code>。因此，我们需要检查返回的<code>InputStream</code>是否为<code>null</code>，如果为<code>null</code>，表示资源文件在classpath中没有找到：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (InputStream input = get<span class=\"constructor\">Class()</span>.get<span class=\"constructor\">ResourceAsStream(<span class=\"string\">&quot;/default.properties&quot;</span>)</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input != null) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties <span class=\"built_in\">props</span> = <span class=\"built_in\">new</span> Properties();</span><br><span class=\"line\"><span class=\"built_in\">props</span>.<span class=\"built_in\">load</span>(inputStreamFromClassPath(<span class=\"string\">&quot;/default.properties&quot;</span>));</span><br><span class=\"line\"><span class=\"built_in\">props</span>.<span class=\"built_in\">load</span>(inputStreamFromFile(<span class=\"string\">&quot;./conf.properties&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>这样读取配置文件，应用程序启动就更加灵活。</p>\n<h1 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h1><p>序列化是指把一个Java对象变成二进制内容，本质上就是一个<code>byte[]</code>数组。</p>\n<p>为什么要把Java对象序列化呢？因为序列化后可以把<code>byte[]</code>保存到文件中，或者把<code>byte[]</code>通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</p>\n<p>有序列化，就有反序列化，即把一个二进制内容（也就是<code>byte[]</code>数组）变回Java对象。有了反序列化，保存到文件中的<code>byte[]</code>数组又可以“变回”Java对象，或者从网络上读取<code>byte[]</code>并把它“变回”Java对象。</p>\n<p>我们来看看如何把一个Java对象序列化。</p>\n<p>一个Java对象要能序列化，必须实现一个特殊的<code>java.io.Serializable</code>接口，它的定义如下：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"symbol\">Serializable</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Serializable</code>接口没有定义任何方法，它是一个空接口。我们把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。</p>\n<h3 id=\"序列化-1\"><a href=\"#序列化-1\" class=\"headerlink\" title=\"序列化\"></a>序列化</h3><p>把一个Java对象变为<code>byte[]</code>数组，需要使用<code>ObjectOutputStream</code>。它负责把一个Java对象写入一个字节流：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>ObjectOutputStream</code>既可以写入基本类型，如<code>int</code>，<code>boolean</code>，也可以写入<code>String</code>（以UTF-8编码），还可以写入实现了<code>Serializable</code>接口的<code>Object</code>。</p>\n<p>因为写入<code>Object</code>时需要大量的类型信息，所以写入的内容很大。</p>\n<h3 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h3><p>和<code>ObjectOutputStream</code>相反，<code>ObjectInputStream</code>负责从一个字节流读取Java对象：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (ObjectInputStream input = <span class=\"keyword\">new</span> <span class=\"constructor\">ObjectInputStream(<span class=\"operator\">...</span>)</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> n = input.read<span class=\"constructor\">Int()</span>;</span><br><span class=\"line\">    String s = input.read<span class=\"constructor\">UTF()</span>;</span><br><span class=\"line\">    Double d = (Double) input.read<span class=\"constructor\">Object()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了能读取基本类型和<code>String</code>类型外，调用<code>readObject()</code>可以直接返回一个<code>Object</code>对象。要把它变成一个特定类型，必须强制转型。</p>\n<p><code>readObject()</code>可能抛出的异常有：</p>\n<ul>\n<li><code>ClassNotFoundException</code>：没有找到对应的Class；</li>\n<li><code>InvalidClassException</code>：Class不匹配。</li>\n</ul>\n<p>对于<code>ClassNotFoundException</code>，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，<code>Person</code>对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义<code>Person</code>类，所以无法反序列化。</p>\n<p>对于<code>InvalidClassException</code>，这种情况常见于序列化的<code>Person</code>对象定义了一个<code>int</code>类型的<code>age</code>字段，但是反序列化时，<code>Person</code>类定义的<code>age</code>字段被改成了<code>long</code>类型，所以导致class不兼容。</p>\n<p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的<code>serialVersionUID</code>静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变<code>serialVersionUID</code>的值，这样就能自动阻止不匹配的class版本：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">2709425275741743919L</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要特别注意反序列化的几个重要特点：</p>\n<p>反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</p>\n<h3 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h3><p>因为Java的序列化机制可以导致一个实例能直接从<code>byte[]</code>数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的<code>byte[]</code>数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</p>\n<p>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</p>\n<h1 id=\"Reader\"><a href=\"#Reader\" class=\"headerlink\" title=\"Reader\"></a>Reader</h1><p><code>Reader</code>是Java的IO库提供的另一个输入流接口。和<code>InputStream</code>的区别是，<code>InputStream</code>是一个字节流，即以<code>byte</code>为单位读取，而<code>Reader</code>是一个字符流，即以<code>char</code>为单位读取：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">InputStream</th>\n<th align=\"left\">Reader</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">字节流，以<code>byte</code>为单位</td>\n<td align=\"left\">字符流，以<code>char</code>为单位</td>\n</tr>\n<tr>\n<td align=\"left\">读取字节（-1，0~255）：<code>int read()</code></td>\n<td align=\"left\">读取字符（-1，0~65535）：<code>int read()</code></td>\n</tr>\n<tr>\n<td align=\"left\">读到字节数组：<code>int read(byte[] b)</code></td>\n<td align=\"left\">读到字符数组：<code>int read(char[] c)</code></td>\n</tr>\n</tbody></table>\n<p><code>java.io.Reader</code>是所有字符输入流的超类，它最主要的方法是：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法读取字符流的下一个字符，并返回字符表示的<code>int</code>，范围是<code>0</code>~&#96;65535<code>。如果已读到末尾，返回</code>-1&#96;。</p>\n<h3 id=\"FileReader\"><a href=\"#FileReader\" class=\"headerlink\" title=\"FileReader\"></a>FileReader</h3><p><code>FileReader</code>是<code>Reader</code>的一个子类，它可以打开文件并获取<code>Reader</code>。下面的代码演示了如何完整地读取一个<code>FileReader</code>的所有字符：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> throws IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个FileReader对象:</span></span><br><span class=\"line\">    Reader reader = <span class=\"keyword\">new</span> <span class=\"built_in\">FileReader</span>(<span class=\"string\">&quot;src/readme.txt&quot;</span>); <span class=\"comment\">// 字符编码是???</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = reader.<span class=\"built_in\">read</span>(); <span class=\"comment\">// 反复调用read()方法，直到返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>((<span class=\"keyword\">char</span>)n); <span class=\"comment\">// 打印char</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.<span class=\"built_in\">close</span>(); <span class=\"comment\">// 关闭流</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们读取一个纯ASCII编码的文本文件，上述代码工作是没有问题的。但如果文件中包含中文，就会出现乱码，因为<code>FileReader</code>默认的编码与系统相关，例如，Windows系统的默认编码可能是<code>GBK</code>，打开一个<code>UTF-8</code>编码的文本文件就会出现乱码。</p>\n<p>要避免乱码问题，我们需要在创建<code>FileReader</code>时指定编码：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">Reader reader = <span class=\"keyword\">new</span> <span class=\"type\">FileReader</span>(<span class=\"string\">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>\n\n<p>和<code>InputStream</code>类似，<code>Reader</code>也是一种资源，需要保证出错的时候也能正确关闭，所以我们需要用<code>try (resource)</code>来保证<code>Reader</code>在无论有没有IO错误的时候都能够正确地关闭：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">FileReader</span>(<span class=\"params\"><span class=\"string\">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// TODO</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Reader</code>还提供了一次性读取若干字符并填充到<code>char[]</code>数组的方法：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"keyword\">read</span>(<span class=\"keyword\">char</span>[] c) <span class=\"keyword\">throws</span> IOException</span><br></pre></td></tr></table></figure>\n\n<p>它返回实际读入的字符个数，最大不超过<code>char[]</code>数组的长度。返回<code>-1</code>表示流结束。</p>\n<p>利用这个方法，我们可以先设置一个缓冲区，然后，每次尽可能地填充缓冲区：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">readFile</span><span class=\"params\">()</span> throws IOException </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">try</span></span> (Reader reader = <span class=\"keyword\">new</span> <span class=\"built_in\">FileReader</span>(<span class=\"string\">&quot;src/readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">1000</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((n = reader.<span class=\"built_in\">read</span>(buffer)) != <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;read &quot;</span> + n + <span class=\"string\">&quot; chars.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CharArrayReader\"><a href=\"#CharArrayReader\" class=\"headerlink\" title=\"CharArrayReader\"></a>CharArrayReader</h3><p><code>CharArrayReader</code>可以在内存中模拟一个<code>Reader</code>，它的作用实际上是把一个<code>char[]</code>数组变成一个<code>Reader</code>，这和<code>ByteArrayInputStream</code>非常类似：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> <span class=\"constructor\">CharArrayReader(<span class=\"string\">&quot;Hello&quot;</span>.<span class=\"params\">toCharArray</span>()</span>)) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"StringReader\"><a href=\"#StringReader\" class=\"headerlink\" title=\"StringReader\"></a>StringReader</h3><p><code>StringReader</code>可以直接把<code>String</code>作为数据源，它和<code>CharArrayReader</code>几乎一样：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> <span class=\"type\">StringReader</span>(<span class=\"string\">&quot;Hello&quot;</span>)) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"InputStreamReader\"><a href=\"#InputStreamReader\" class=\"headerlink\" title=\"InputStreamReader\"></a>InputStreamReader</h3><p><code>Reader</code>和<code>InputStream</code>有什么关系？</p>\n<p>除了特殊的<code>CharArrayReader</code>和<code>StringReader</code>，普通的<code>Reader</code>实际上是基于<code>InputStream</code>构造的，因为<code>Reader</code>需要从<code>InputStream</code>中读入字节流（<code>byte</code>），然后，根据编码设置，再转换为<code>char</code>就可以实现字符流。如果我们查看<code>FileReader</code>的源码，它在内部实际上持有一个<code>FileInputStream</code>。</p>\n<p>既然<code>Reader</code>本质上是一个基于<code>InputStream</code>的<code>byte</code>到<code>char</code>的转换器，那么，如果我们已经有一个<code>InputStream</code>，想把它转换为<code>Reader</code>，是完全可行的。<code>InputStreamReader</code>就是这样一个转换器，它可以把任何<code>InputStream</code>转换为<code>Reader</code>。示例代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 持有InputStream:</span></span><br><span class=\"line\">InputStream input = <span class=\"keyword\">new</span> <span class=\"constructor\">FileInputStream(<span class=\"string\">&quot;src/readme.txt&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 变换为Reader:</span></span><br><span class=\"line\">Reader reader = <span class=\"keyword\">new</span> <span class=\"constructor\">InputStreamReader(<span class=\"params\">input</span>, <span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>构造<code>InputStreamReader</code>时，我们需要传入<code>InputStream</code>，还需要指定编码，就可以得到一个<code>Reader</code>对象。上述代码可以通过<code>try (resource)</code>更简洁地改写如下：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Reader reader = <span class=\"keyword\">new</span> <span class=\"type\">InputStreamReader</span>(<span class=\"keyword\">new</span> <span class=\"type\">FileInputStream</span>(<span class=\"string\">&quot;src/readme.txt&quot;</span>), <span class=\"string\">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码实际上就是<code>FileReader</code>的一种实现方式。</p>\n<p>使用<code>try (resource)</code>结构时，当我们关闭<code>Reader</code>时，它会在内部自动调用<code>InputStream</code>的<code>close()</code>方法，所以，只需要关闭最外层的<code>Reader</code>对象即可。</p>\n<p> 使用InputStreamReader，可以把一个InputStream转换成一个Reader。</p>\n<h1 id=\"Writer\"><a href=\"#Writer\" class=\"headerlink\" title=\"Writer\"></a>Writer</h1><p><code>Reader</code>是带编码转换器的<code>InputStream</code>，它把<code>byte</code>转换为<code>char</code>，而<code>Writer</code>就是带编码转换器的<code>OutputStream</code>，它把<code>char</code>转换为<code>byte</code>并输出。</p>\n<p><code>Writer</code>和<code>OutputStream</code>的区别如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">OutputStream</th>\n<th align=\"left\">Writer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">字节流，以<code>byte</code>为单位</td>\n<td align=\"left\">字符流，以<code>char</code>为单位</td>\n</tr>\n<tr>\n<td align=\"left\">写入字节（0~255）：<code>void write(int b)</code></td>\n<td align=\"left\">写入字符（0~65535）：<code>void write(int c)</code></td>\n</tr>\n<tr>\n<td align=\"left\">写入字节数组：<code>void write(byte[] b)</code></td>\n<td align=\"left\">写入字符数组：<code>void write(char[] c)</code></td>\n</tr>\n<tr>\n<td align=\"left\">无对应方法</td>\n<td align=\"left\">写入String：<code>void write(String s)</code></td>\n</tr>\n</tbody></table>\n<p><code>Writer</code>是所有字符输出流的超类，它提供的方法主要有：</p>\n<ul>\n<li>写入一个字符（0~65535）：<code>void write(int c)</code>；</li>\n<li>写入字符数组的所有字符：<code>void write(char[] c)</code>；</li>\n<li>写入String表示的所有字符：<code>void write(String s)</code>。</li>\n</ul>\n<h3 id=\"FileWriter\"><a href=\"#FileWriter\" class=\"headerlink\" title=\"FileWriter\"></a>FileWriter</h3><p><code>FileWriter</code>就是向文件中写入字符流的<code>Writer</code>。它的使用方法和<code>FileReader</code>类似：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\"><span class=\"keyword\">try</span></span> (Writer writer = <span class=\"keyword\">new</span> <span class=\"built_in\">FileWriter</span>(<span class=\"string\">&quot;readme.txt&quot;</span>, StandardCharsets.UTF_8)) &#123;</span><br><span class=\"line\">    writer.<span class=\"built_in\">write</span>(<span class=\"string\">&#x27;H&#x27;</span>); <span class=\"comment\">// 写入单个字符</span></span><br><span class=\"line\">    writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;Hello&quot;</span>.<span class=\"built_in\">toCharArray</span>()); <span class=\"comment\">// 写入char[]</span></span><br><span class=\"line\">    writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// 写入String</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"CharArrayWriter\"><a href=\"#CharArrayWriter\" class=\"headerlink\" title=\"CharArrayWriter\"></a>CharArrayWriter</h3><p><code>CharArrayWriter</code>可以在内存中创建一个<code>Writer</code>，它的作用实际上是构造一个缓冲区，可以写入<code>char</code>，最后得到写入的<code>char[]</code>数组，这和<code>ByteArrayOutputStream</code>非常类似：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (CharArrayWriter writer = <span class=\"keyword\">new</span> CharArrayWriter()) &#123;</span><br><span class=\"line\">    writer.<span class=\"keyword\">write</span>(<span class=\"number\">65</span>);</span><br><span class=\"line\">    writer.<span class=\"keyword\">write</span>(<span class=\"number\">66</span>);</span><br><span class=\"line\">    writer.<span class=\"keyword\">write</span>(<span class=\"number\">67</span>);</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] data = writer.toCharArray(); <span class=\"comment\">// &#123; &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27; &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"StringWriter\"><a href=\"#StringWriter\" class=\"headerlink\" title=\"StringWriter\"></a>StringWriter</h3><p><code>StringWriter</code>也是一个基于内存的<code>Writer</code>，它和<code>CharArrayWriter</code>类似。实际上，<code>StringWriter</code>在内部维护了一个<code>StringBuffer</code>，并对外提供了<code>Writer</code>接口。</p>\n<h3 id=\"OutputStreamWriter\"><a href=\"#OutputStreamWriter\" class=\"headerlink\" title=\"OutputStreamWriter\"></a>OutputStreamWriter</h3><p>除了<code>CharArrayWriter</code>和<code>StringWriter</code>外，普通的Writer实际上是基于<code>OutputStream</code>构造的，它接收<code>char</code>，然后在内部自动转换成一个或多个<code>byte</code>，并写入<code>OutputStream</code>。因此，<code>OutputStreamWriter</code>就是一个将任意的<code>OutputStream</code>转换为<code>Writer</code>的转换器：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Writer writer = <span class=\"keyword\">new</span> <span class=\"type\">OutputStreamWriter</span>(<span class=\"keyword\">new</span> <span class=\"type\">FileOutputStream</span>(<span class=\"string\">&quot;readme.txt&quot;</span>), <span class=\"string\">&quot;UTF-8&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码实际上就是<code>FileWriter</code>的一种实现方式。这和上一节的<code>InputStreamReader</code>是一样的。</p>\n<h1 id=\"PrintStream和PrintWriter\"><a href=\"#PrintStream和PrintWriter\" class=\"headerlink\" title=\"PrintStream和PrintWriter\"></a>PrintStream和PrintWriter</h1><p><code>PrintStream</code>是一种<code>FilterOutputStream</code>，它在<code>OutputStream</code>的接口上，额外提供了一些写入各种数据类型的方法：</p>\n<ul>\n<li>写入<code>int</code>：<code>print(int)</code></li>\n<li>写入<code>boolean</code>：<code>print(boolean)</code></li>\n<li>写入<code>String</code>：<code>print(String)</code></li>\n<li>写入<code>Object</code>：<code>print(Object)</code>，实际上相当于<code>print(object.toString())</code></li>\n<li>…</li>\n</ul>\n<p>以及对应的一组<code>println()</code>方法，它会自动加上换行符。</p>\n<p>我们经常使用的<code>System.out.println()</code>实际上就是使用<code>PrintStream</code>打印各种数据。其中，<code>System.out</code>是系统默认提供的<code>PrintStream</code>，表示标准输出：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.print(<span class=\"number\">12345</span>); <span class=\"comment\">// 输出12345</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.print(<span class=\"keyword\">new</span> <span class=\"constructor\">Object()</span>); <span class=\"comment\">// 输出类似java.lang.Object@3c7a835a</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// 输出Hello并换行</span></span><br></pre></td></tr></table></figure>\n\n<p><code>System.err</code>是系统默认提供的标准错误输出。</p>\n<p><code>PrintStream</code>和<code>OutputStream</code>相比，除了添加了一组<code>print()</code>&#x2F;<code>println()</code>方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出<code>IOException</code>，这样我们在编写代码的时候，就不必捕获<code>IOException</code>。</p>\n<h3 id=\"PrintWriter\"><a href=\"#PrintWriter\" class=\"headerlink\" title=\"PrintWriter\"></a>PrintWriter</h3><p><code>PrintStream</code>最终输出的总是byte数据，而<code>PrintWriter</code>则是扩展了<code>Writer</code>接口，它的<code>print()</code>&#x2F;<code>println()</code>方法最终输出的是<code>char</code>数据。两者的使用方法几乎是一模一样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h1 id=\"使用Files\"><a href=\"#使用Files\" class=\"headerlink\" title=\"使用Files\"></a>使用Files</h1><p>从Java 7开始，提供了<code>Files</code>和<code>Paths</code>这两个工具类，能极大地方便我们读写文件。</p>\n<p>虽然<code>Files</code>和<code>Paths</code>是<code>java.nio</code>包里面的类，但他俩封装了很多读写文件的简单方法，例如，我们要把一个文件的全部内容读取为一个<code>byte[]</code>，可以这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">byte<span class=\"literal\">[]</span> data = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>read<span class=\"constructor\">AllBytes(Paths.<span class=\"params\">get</span>(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>如果是文本文件，可以把一个文件的全部内容读取为<code>String</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认使用UTF-8编码读取:</span></span><br><span class=\"line\">String content1 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>read<span class=\"constructor\">String(Paths.<span class=\"params\">get</span>(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>)</span>);</span><br><span class=\"line\"><span class=\"comment\">// 可指定编码:</span></span><br><span class=\"line\">String content2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>read<span class=\"constructor\">String(Paths.<span class=\"params\">get</span>(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>)</span>, StandardCharsets.ISO_8859_1);</span><br><span class=\"line\"><span class=\"comment\">// 按行读取并返回每行内容:</span></span><br><span class=\"line\">List&lt;String&gt; lines = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>read<span class=\"constructor\">AllLines(Paths.<span class=\"params\">get</span>(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>写入文件也非常方便：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写入二进制文件:</span></span><br><span class=\"line\">byte<span class=\"literal\">[]</span> data =<span class=\"operator\"> ...</span></span><br><span class=\"line\"><span class=\"operator\"></span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>write(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Paths</span>.</span></span>get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), data);</span><br><span class=\"line\"><span class=\"comment\">// 写入文本并指定编码:</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>write<span class=\"constructor\">String(Paths.<span class=\"params\">get</span>(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>)</span>, <span class=\"string\">&quot;文本内容...&quot;</span>, StandardCharsets.ISO_8859_1);</span><br><span class=\"line\"><span class=\"comment\">// 按行写入文本:</span></span><br><span class=\"line\">List&lt;String&gt; lines =<span class=\"operator\"> ...</span></span><br><span class=\"line\"><span class=\"operator\"></span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>write(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Paths</span>.</span></span>get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>), lines);</span><br></pre></td></tr></table></figure>\n\n<p>此外，<code>Files</code>工具类还有<code>copy()</code>、<code>delete()</code>、<code>exists()</code>、<code>move()</code>等快捷方法操作文件和目录。</p>\n<p>最后需要特别注意的是，<code>Files</code>提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容。</p>\n","categories":["Java","1.Java快速入门","08.IO"],"tags":["写作"]},{"title":"2.面向对象编程","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"面向对象基础\"><a href=\"#面向对象基础\" class=\"headerlink\" title=\"面向对象基础\"></a>面向对象基础</h1><h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>面向对象编程，是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p>\n<p>现实世界中，我们定义了“人”这种抽象概念，而具体的人则是“小明”、“小红”、“小军”等一个个具体的人。所以，“人”可以定义为一个类（class），而具体的人则是实例（instance）：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">现实世界</th>\n<th align=\"left\">计算机模型</th>\n<th align=\"left\">Java代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">人</td>\n<td align=\"left\">类 &#x2F; class</td>\n<td align=\"left\">class Person { }</td>\n</tr>\n<tr>\n<td align=\"left\">小明</td>\n<td align=\"left\">实例 &#x2F; ming</td>\n<td align=\"left\">Person ming &#x3D; new Person()</td>\n</tr>\n<tr>\n<td align=\"left\">小红</td>\n<td align=\"left\">实例 &#x2F; hong</td>\n<td align=\"left\">Person hong &#x3D; new Person()</td>\n</tr>\n<tr>\n<td align=\"left\">小军</td>\n<td align=\"left\">实例 &#x2F; jun</td>\n<td align=\"left\">Person jun &#x3D; new Person()</td>\n</tr>\n</tbody></table>\n<p>同样的，“书”也是一种抽象的概念，所以它是类，而《Java核心技术》、《Java编程思想》、《Java学习笔记》则是实例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">现实世界</th>\n<th align=\"left\">计算机模型</th>\n<th align=\"left\">Java代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">书</td>\n<td align=\"left\">类 &#x2F; class</td>\n<td align=\"left\">class Book { }</td>\n</tr>\n<tr>\n<td align=\"left\">Java核心技术</td>\n<td align=\"left\">实例 &#x2F; book1</td>\n<td align=\"left\">Book book1 &#x3D; new Book()</td>\n</tr>\n<tr>\n<td align=\"left\">Java编程思想</td>\n<td align=\"left\">实例 &#x2F; book2</td>\n<td align=\"left\">Book book2 &#x3D; new Book()</td>\n</tr>\n<tr>\n<td align=\"left\">Java学习笔记</td>\n<td align=\"left\">实例 &#x2F; book3</td>\n<td align=\"left\">Book book3 &#x3D; new Book()</td>\n</tr>\n</tbody></table>\n<h3 id=\"class和instance\"><a href=\"#class和instance\" class=\"headerlink\" title=\"class和instance\"></a>class和instance</h3><p>所以，只要理解了class和instance的概念，基本上就明白了什么是面向对象编程。</p>\n<p>class是一种对象模版，它定义了如何创建实例，因此，class本身就是一种数据类型：</p>\n<p><img src=\"/2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.assets/l.jpeg\" alt=\"class\"></p>\n<p>而instance是对象实例，instance是根据class创建的实例，可以创建多个instance，每个instance类型相同，但各自属性可能不相同：</p>\n<p><img src=\"/2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.assets/l-16416681439241.jpeg\" alt=\"instances\"></p>\n<h3 id=\"定义class\"><a href=\"#定义class\" class=\"headerlink\" title=\"定义class\"></a>定义class</h3><p>在Java中，创建一个类，例如，给这个类命名为<code>Person</code>，就是定义一个<code>class</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个<code>class</code>可以包含多个字段（<code>field</code>），字段用来描述一个类的特征。上面的<code>Person</code>类，我们定义了两个字段，一个是<code>String</code>类型的字段，命名为<code>name</code>，一个是<code>int</code>类型的字段，命名为<code>age</code>。因此，通过<code>class</code>，把一组数据汇集到一个对象上，实现了数据封装。</p>\n<p><code>public</code>是用来修饰字段的，它表示这个字段可以被外部访问。</p>\n<p>我们再看另一个<code>Book</code>类的定义：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> author;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> isbn;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">double</span> price;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>请指出<code>Book</code>类的各个字段。</p>\n<h3 id=\"创建实例\"><a href=\"#创建实例\" class=\"headerlink\" title=\"创建实例\"></a>创建实例</h3><p>定义了class，只是定义了对象模版，而要根据对象模版创建出真正的对象实例，必须用new操作符。</p>\n<p>new操作符可以创建一个实例，然后，我们需要定义一个引用类型的变量来指向这个实例：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Person ming</span> = new Person();</span><br></pre></td></tr></table></figure>\n\n<p>上述代码创建了一个Person类型的实例，并通过变量<code>ming</code>指向它。</p>\n<p>注意区分<code>Person ming</code>是定义<code>Person</code>类型的变量<code>ming</code>，而<code>new Person()</code>是创建<code>Person</code>实例。</p>\n<p>有了指向这个实例的变量，我们就可以通过这个变量来操作实例。访问实例变量可以用<code>变量.字段</code>，例如：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">ming.name = &quot;Xiao Ming&quot;; // 对字段<span class=\"type\">name</span>赋值</span><br><span class=\"line\">ming.age = <span class=\"number\">12</span>; // 对字段age赋值</span><br><span class=\"line\"><span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(ming.name); // 访问字段<span class=\"type\">name</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person hong = <span class=\"built_in\">new</span> Person();</span><br><span class=\"line\">hong.name = &quot;Xiao Hong&quot;;</span><br><span class=\"line\">hong.age = <span class=\"number\">15</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上述两个变量分别指向两个不同的实例，它们在内存中的结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">            ┌──────────────────┐</span><br><span class=\"line\">ming ──────&gt;│Person instance   │</span><br><span class=\"line\">            ├──────────────────┤</span><br><span class=\"line\">            │name = &quot;Xiao Ming&quot;│</span><br><span class=\"line\">            │age = 12          │</span><br><span class=\"line\">            └──────────────────┘</span><br><span class=\"line\">            ┌──────────────────┐</span><br><span class=\"line\">hong ──────&gt;│Person instance   │</span><br><span class=\"line\">            ├──────────────────┤</span><br><span class=\"line\">            │name = &quot;Xiao Hong&quot;│</span><br><span class=\"line\">            │age = 15          │</span><br><span class=\"line\">            └──────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>两个<code>instance</code>拥有<code>class</code>定义的<code>name</code>和<code>age</code>字段，且各自都有一份独立的数据，互不干扰。</p>\n<p> 一个Java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致。如果要定义多个public类，必须拆到多个Java源文件中。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>一个<code>class</code>可以包含多个<code>field</code>，例如，我们给<code>Person</code>类就定义了两个<code>field</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，直接把<code>field</code>用<code>public</code>暴露给外部可能会破坏封装性。比如，代码可以这样写：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person ming = new Person()<span class=\"comment\">;</span></span><br><span class=\"line\">ming.name = <span class=\"string\">&quot;Xiao Ming&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\">ming.age = -<span class=\"number\">99</span><span class=\"comment\">; // age设置为负数 </span></span><br></pre></td></tr></table></figure>\n\n<p>显然，直接操作<code>field</code>，容易造成逻辑混乱。为了避免外部代码直接去访问<code>field</code>，我们可以用<code>private</code>修饰<code>field</code>，拒绝外部访问：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>试试<code>private</code>修饰的<code>field</code>有什么效果：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> private field</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>是不是编译报错？把访问<code>field</code>的赋值语句去了就可以正常编译了。</p>\n<p><img src=\"/2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.assets/l-16416681981514.png\" alt=\"buduijin\"></p>\n<p>把<code>field</code>从<code>public</code>改成<code>private</code>，外部代码不能访问这些<code>field</code>，那我们定义这些<code>field</code>有什么用？怎么才能给它赋值？怎么才能读取它的值？</p>\n<p>所以我们需要使用方法（<code>method</code>）来让外部代码可以间接修改<code>field</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> private field</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>虽然外部代码不能直接修改<code>private</code>字段，但是，外部代码可以调用方法<code>setName()</code>和<code>setAge()</code>来间接修改<code>private</code>字段。在方法内部，我们就有机会检查参数对不对。比如，<code>setAge()</code>就会检查传入的参数，参数超出了范围，直接报错。这样，外部代码就没有任何机会把<code>age</code>设置成不合理的值。</p>\n<p>对<code>setName()</code>方法同样可以做检查，例如，不允许传入<code>null</code>和空字符串：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"type\">void</span> setName(String <span class=\"type\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"type\">name</span> == <span class=\"keyword\">null</span> || <span class=\"type\">name</span>.isBlank()) &#123;</span><br><span class=\"line\">        throw <span class=\"built_in\">new</span> IllegalArgumentException(&quot;invalid name&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.name = <span class=\"type\">name</span>.strip(); // 去掉首尾空格</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样，外部代码不能直接读取<code>private</code>字段，但可以通过<code>getName()</code>和<code>getAge()</code>间接获取<code>private</code>字段的值。</p>\n<p>所以，一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。</p>\n<p>调用方法的语法是<code>实例变量.方法名(参数);</code>。一个方法调用就是一个语句，所以不要忘了在末尾加<code>;</code>。例如：<code>ming.setName(&quot;Xiao Ming&quot;);</code>。</p>\n<h3 id=\"定义方法\"><a href=\"#定义方法\" class=\"headerlink\" title=\"定义方法\"></a>定义方法</h3><p>从上面的代码可以看出，定义方法的语法是：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">修饰符 方法返回类型 方法名(方法参数列表) &#123;</span><br><span class=\"line\">    若干方法语句<span class=\"comment\">;</span></span><br><span class=\"line\">    return 方法返回值<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>方法返回值通过<code>return</code>语句实现，如果没有返回值，返回类型设置为<code>void</code>，可以省略<code>return</code>。</p>\n<h3 id=\"private方法\"><a href=\"#private方法\" class=\"headerlink\" title=\"private方法\"></a>private方法</h3><p>有<code>public</code>方法，自然就有<code>private</code>方法。和<code>private</code>字段一样，<code>private</code>方法不允许外部调用，那我们定义<code>private</code>方法有什么用？</p>\n<p>定义<code>private</code>方法的理由是内部方法是可以调用<code>private</code>方法的。例如：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> private method</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>观察上述代码，<code>calcAge()</code>是一个<code>private</code>方法，外部代码无法调用，但是，内部方法<code>getAge()</code>可以调用它。</p>\n<p>此外，我们还注意到，这个<code>Person</code>类只定义了<code>birth</code>字段，没有定义<code>age</code>字段，获取<code>age</code>时，通过方法<code>getAge()</code>返回的是一个实时计算的值，并非存储在某个字段的值。这说明方法可以封装一个类的对外接口，调用方不需要知道也不关心<code>Person</code>实例在内部到底有没有<code>age</code>字段。</p>\n<h3 id=\"this变量\"><a href=\"#this变量\" class=\"headerlink\" title=\"this变量\"></a>this变量</h3><p>在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例。因此，通过<code>this.field</code>就可以访问当前实例的字段。</p>\n<p>如果没有命名冲突，可以省略<code>this</code>。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getName</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name; <span class=\"comment\">// 相当于this.name</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果有局部变量和字段重名，那么局部变量优先级更高，就必须加上<code>this</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setName</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name; <span class=\"comment\">// 前面的this不可少，少了就变成局部变量name了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"方法参数\"><a href=\"#方法参数\" class=\"headerlink\" title=\"方法参数\"></a>方法参数</h3><p>方法可以包含0个或任意个参数。方法参数用于接收传递给方法的变量值。调用方法时，必须严格按照参数的定义一一传递。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNameAndAge</span><span class=\"params\">(<span class=\"keyword\">String</span> name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用这个<code>setNameAndAge()</code>方法时，必须有两个参数，且第一个参数必须为<code>String</code>，第二个参数必须为<code>int</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person ming = <span class=\"keyword\">new</span> <span class=\"constructor\">Person()</span>;</span><br><span class=\"line\">ming.set<span class=\"constructor\">NameAndAge(<span class=\"string\">&quot;Xiao Ming&quot;</span>)</span>; <span class=\"comment\">// 编译错误：参数个数不对</span></span><br><span class=\"line\">ming.set<span class=\"constructor\">NameAndAge(12, <span class=\"string\">&quot;Xiao Ming&quot;</span>)</span>; <span class=\"comment\">// 编译错误：参数类型不对</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h3><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Group</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span>[] names;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setNames</span>(<span class=\"params\"><span class=\"built_in\">String</span>... names</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.names = names;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>setNames()</code>就定义了一个可变参数。调用时，可以这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Group g = <span class=\"keyword\">new</span> <span class=\"constructor\">Group()</span>;</span><br><span class=\"line\">g.set<span class=\"constructor\">Names(<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"string\">&quot;Xiao Hong&quot;</span>, <span class=\"string\">&quot;Xiao Jun&quot;</span>)</span>; <span class=\"comment\">// 传入3个String</span></span><br><span class=\"line\">g.set<span class=\"constructor\">Names(<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"string\">&quot;Xiao Hong&quot;</span>)</span>; <span class=\"comment\">// 传入2个String</span></span><br><span class=\"line\">g.set<span class=\"constructor\">Names(<span class=\"string\">&quot;Xiao Ming&quot;</span>)</span>; <span class=\"comment\">// 传入1个String</span></span><br><span class=\"line\">g.set<span class=\"constructor\">Names()</span>; <span class=\"comment\">// 传入0个String</span></span><br></pre></td></tr></table></figure>\n\n<p>完全可以把可变参数改写为<code>String[]</code>类型：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Group</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span>[] names;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setNames</span>(<span class=\"params\"><span class=\"built_in\">String</span>[] names</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.names = names;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，调用方需要自己先构造<code>String[]</code>，比较麻烦。例如：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Group</span> <span class=\"title\">g</span> = new Group();</span><br><span class=\"line\">g.setNames(new <span class=\"keyword\">String</span>[] &#123;<span class=\"string\">&quot;Xiao Ming&quot;</span>, <span class=\"string\">&quot;Xiao Hong&quot;</span>, <span class=\"string\">&quot;Xiao Jun&quot;</span>&#125;); // 传入<span class=\"number\">1</span>个<span class=\"keyword\">String</span>[]</span><br></pre></td></tr></table></figure>\n\n<p>另一个问题是，调用方可以传入<code>null</code>：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Group</span> g = <span class=\"keyword\">new</span> <span class=\"keyword\">Group</span>();</span><br><span class=\"line\">g.setNames(<span class=\"keyword\">null</span>);</span><br></pre></td></tr></table></figure>\n\n<p>而可变参数可以保证无法传入<code>null</code>，因为传入0个参数时，接收到的实际值是一个空数组而不是<code>null</code>。</p>\n<h3 id=\"参数绑定\"><a href=\"#参数绑定\" class=\"headerlink\" title=\"参数绑定\"></a>参数绑定</h3><p>调用方把参数传递给实例方法时，调用时传递的值会按参数位置一一绑定。</p>\n<p>那什么是参数绑定？</p>\n<p>我们先观察一个基本类型参数的传递：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 基本类型参数绑定</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行代码，从结果可知，修改外部的局部变量<code>n</code>，不影响实例<code>p</code>的<code>age</code>字段，原因是<code>setAge()</code>方法获得的参数，复制了<code>n</code>的值，因此，<code>p.age</code>和局部变量<code>n</code>互不影响。</p>\n<p>结论：基本类型参数的传递，是调用方值的复制。双方各自的后续修改，互不影响。</p>\n<p>我们再看一个传递引用参数的例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 引用类型参数绑定</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到<code>setName()</code>的参数现在是一个数组。一开始，把<code>fullname</code>数组传进去，然后，修改<code>fullname</code>数组的内容，结果发现，实例<code>p</code>的字段<code>p.name</code>也被修改了！</p>\n<p>结论：引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）。</p>\n<p>有了上面的结论，我们再看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 引用类型参数绑定</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>不要怀疑引用参数绑定的机制，试解释为什么上面的代码两次输出都是<code>&quot;Bob&quot;</code>。</p>\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><p>创建实例的时候，我们经常需要同时初始化这个实例的字段，例如：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person ming = <span class=\"keyword\">new</span> <span class=\"constructor\">Person()</span>;</span><br><span class=\"line\">ming.set<span class=\"constructor\">Name(<span class=\"string\">&quot;小明&quot;</span>)</span>;</span><br><span class=\"line\">ming.set<span class=\"constructor\">Age(12)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>初始化对象实例需要3行代码，而且，如果忘了调用<code>setName()</code>或者<code>setAge()</code>，这个实例内部的状态就是不正确的。</p>\n<p>能否在创建对象实例时就把内部字段全部初始化为合适的值？</p>\n<p>完全可以。</p>\n<p>这时，我们就需要构造方法。</p>\n<p>创建实例的时候，实际上是通过构造方法来初始化实例的。我们先来定义一个构造方法，能在创建<code>Person</code>实例的时候，一次性传入<code>name</code>和<code>age</code>，完成初始化：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 构造方法</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>由于构造方法是如此特殊，所以构造方法的名称就是类名。构造方法的参数没有限制，在方法内部，也可以编写任意语句。但是，和普通方法相比，构造方法没有返回值（也没有<code>void</code>），调用构造方法，必须用<code>new</code>操作符。</p>\n<h3 id=\"默认构造方法\"><a href=\"#默认构造方法\" class=\"headerlink\" title=\"默认构造方法\"></a>默认构造方法</h3><p>是不是任何<code>class</code>都有构造方法？是的。</p>\n<p>那前面我们并没有为<code>Person</code>类编写构造方法，为什么可以调用<code>new Person()</code>？</p>\n<p>原因是如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要特别注意的是，如果我们自定义了一个构造方法，那么，编译器就<em>不再</em>自动创建默认构造方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 构造方法</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 构造方法</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> name; <span class=\"comment\">// 默认初始化为null</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age; <span class=\"comment\">// 默认初始化为0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以对字段直接进行初始化：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> name = <span class=\"string\">&quot;Unamed&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么问题来了：既对字段进行初始化，又在构造方法中对字段进行初始化：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> name = <span class=\"string\">&quot;Unamed&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">String</span> name, <span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们创建对象的时候，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>得到的对象实例，字段的初始值是啥？</p>\n<p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p>\n<ol>\n<li>先初始化字段，例如，<code>int age = 10;</code>表示字段初始化为<code>10</code>，<code>double salary;</code>表示字段默认初始化为<code>0</code>，<code>String name;</code>表示引用类型字段默认初始化为<code>null</code>；</li>\n<li>执行构造方法的代码进行初始化。</li>\n</ol>\n<p>因此，构造方法的代码由于后运行，所以，<code>new Person(&quot;Xiao Ming&quot;, 12)</code>的字段值最终由构造方法的代码确定。</p>\n<h3 id=\"多构造方法\"><a href=\"#多构造方法\" class=\"headerlink\" title=\"多构造方法\"></a>多构造方法</h3><p>可以定义多个构造方法，在通过<code>new</code>操作符调用的时候，编译器通过构造方法的参数数量、位置和类型自动区分：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Person</span>(<span class=\"params\"><span class=\"built_in\">String</span> name, int age</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Person</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = <span class=\"number\">12</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Person</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果调用<code>new Person(&quot;Xiao Ming&quot;, 20);</code>，会自动匹配到构造方法<code>public Person(String, int)</code>。</p>\n<p>如果调用<code>new Person(&quot;Xiao Ming&quot;);</code>，会自动匹配到构造方法<code>public Person(String)</code>。</p>\n<p>如果调用<code>new Person();</code>，会自动匹配到构造方法<code>public Person()</code>。</p>\n<p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Person</span>(<span class=\"params\"><span class=\"built_in\">String</span> name, int age</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Person</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(name, <span class=\"number\">18</span>); <span class=\"comment\">// 调用另一个构造方法Person(String, int)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Person</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(<span class=\"string\">&quot;Unnamed&quot;</span>); <span class=\"comment\">// 调用另一个构造方法Person(String)</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"重载\"><a href=\"#重载\" class=\"headerlink\" title=\"重载\"></a>重载</h2><p>在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成<em>同名</em>方法。例如，在<code>Hello</code>类中，定义多个<code>hello()</code>方法：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> Hello &#123;</span><br><span class=\"line\">    <span class=\"built_in\">public</span> <span class=\"type\">void</span> hello() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Hello, world!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">public</span> <span class=\"type\">void</span> hello(String <span class=\"type\">name</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Hello, &quot; + <span class=\"type\">name</span> + &quot;!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">public</span> <span class=\"type\">void</span> hello(String <span class=\"type\">name</span>, <span class=\"type\">int</span> age) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (age &lt; <span class=\"number\">18</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Hi, &quot; + <span class=\"type\">name</span> + &quot;!&quot;);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;Hello, &quot; + <span class=\"type\">name</span> + &quot;!&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法名相同，但各自的参数不同，称为方法重载（<code>Overload</code>）。</p>\n<p>注意：方法重载的返回值类型通常都是相同的。</p>\n<p>方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p>\n<p>举个例子，<code>String</code>类提供了多个重载方法<code>indexOf()</code>，可以查找子串：</p>\n<ul>\n<li><code>int indexOf(int ch)</code>：根据字符的Unicode码查找；</li>\n<li><code>int indexOf(String str)</code>：根据字符串查找；</li>\n<li><code>int indexOf(int ch, int fromIndex)</code>：根据字符查找，但指定起始位置；</li>\n<li><code>int indexOf(String str, int fromIndex)</code>根据字符串查找，但指定起始位置。</li>\n</ul>\n<p>试一试：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> String.indexOf()</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h2 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h2><h3 id=\"Java-封装\"><a href=\"#Java-封装\" class=\"headerlink\" title=\"Java 封装\"></a>Java 封装</h3><hr>\n<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。</p>\n<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>\n<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>\n<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>\n<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>\n<h3 id=\"封装的优点\"><a href=\"#封装的优点\" class=\"headerlink\" title=\"封装的优点\"></a>封装的优点</h3><ul>\n<li>\\1. 良好的封装能够减少耦合。</li>\n<li>\\2. 类内部的结构可以自由修改。</li>\n<li>\\3. 可以对成员变量进行更精确的控制。</li>\n<li>\\4. 隐藏信息，实现细节。</li>\n</ul>\n<hr>\n<h3 id=\"实现Java封装的步骤\"><a href=\"#实现Java封装的步骤\" class=\"headerlink\" title=\"实现Java封装的步骤\"></a>实现Java封装的步骤</h3><p>\\1. 修改属性的可见性来限制对属性的访问（一般限制为private），例如：</p>\n<p>public class Person {    private String name;    private int age; }</p>\n<p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p>\n<p>\\2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p>\n<p>public class Person{    private String name;    private int age;     public int getAge(){      return age;    }     public String getName(){      return name;    }     public void setAge(int age){      this.age &#x3D; age;    }     public void setName(String name){      this.name &#x3D; name;    } }</p>\n<p>采用 <strong>this</strong> 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</p>\n<hr>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><p>让我们来看一个java封装类的例子：</p>\n<h3 id=\"EncapTest-java-文件代码：\"><a href=\"#EncapTest-java-文件代码：\" class=\"headerlink\" title=\"EncapTest.java 文件代码：\"></a>EncapTest.java 文件代码：</h3><p>&#x2F;* 文件名: EncapTest.java *&#x2F; public class EncapTest{    private String name;   private String idNum;   private int age;    public int getAge(){      return age;   }    public String getName(){      return name;   }    public String getIdNum(){      return idNum;   }    public void setAge( int newAge){      age &#x3D; newAge;   }    public void setName(String newName){      name &#x3D; newName;   }    public void setIdNum( String newId){      idNum &#x3D; newId;   } }</p>\n<p>以上实例中public方法是外部类访问该类成员变量的入口。</p>\n<p>通常情况下，这些方法被称为getter和setter方法。</p>\n<p>因此，任何要访问类中私有成员变量的类都要通过这些getter和setter方法。</p>\n<p>通过如下的例子说明EncapTest类的变量怎样被访问：</p>\n<h3 id=\"RunEncap-java-文件代码：\"><a href=\"#RunEncap-java-文件代码：\" class=\"headerlink\" title=\"RunEncap.java 文件代码：\"></a>RunEncap.java 文件代码：</h3><p>&#x2F;* F文件名 : RunEncap.java *&#x2F; public class RunEncap{   public static void main(String args[]){      EncapTest encap &#x3D; new EncapTest();      encap.setName(“James”);      encap.setAge(20);      encap.setIdNum(“12343ms”);       System.out.print(“Name : “ + encap.getName()+                              “ Age : “+ encap.getAge());    } }</p>\n<h2 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h2><p>在前面的章节中，我们已经定义了<code>Person</code>类：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"code\"><pre><span class=\"line\">class <span class=\"type\">Person</span> &#123;</span><br><span class=\"line\">    private <span class=\"type\">String</span> name;</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"type\">String</span> getName() <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setName(<span class=\"type\">String</span> name) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">int</span> getAge() <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setAge(<span class=\"built_in\">int</span> age) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，假设需要定义一个<code>Student</code>类，字段如下：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"code\"><pre><span class=\"line\">class <span class=\"type\">Student</span> &#123;</span><br><span class=\"line\">    private <span class=\"type\">String</span> name;</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"type\">String</span> getName() <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setName(<span class=\"type\">String</span> name) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">int</span> getAge() <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setAge(<span class=\"built_in\">int</span> age) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">int</span> getScore() &#123; … &#125;</span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setScore(<span class=\"built_in\">int</span> score) &#123; … &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>仔细观察，发现<code>Student</code>类包含了<code>Person</code>类已有的字段和方法，只是多出了一个<code>score</code>字段和相应的<code>getScore()</code>、<code>setScore()</code>方法。</p>\n<p>能不能在<code>Student</code>中不要写重复的代码？</p>\n<p>这个时候，继承就派上用场了。</p>\n<p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让<code>Student</code>从<code>Person</code>继承时，<code>Student</code>就获得了<code>Person</code>的所有功能，我们只需要为<code>Student</code>编写新增的功能。</p>\n<p>Java使用<code>extends</code>关键字来实现继承：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"code\"><pre><span class=\"line\">class <span class=\"type\">Person</span> &#123;</span><br><span class=\"line\">    private <span class=\"type\">String</span> name;</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"type\">String</span> getName() <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setName(<span class=\"type\">String</span> name) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">int</span> getAge() <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setAge(<span class=\"built_in\">int</span> age) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class <span class=\"type\">Student</span> extends <span class=\"type\">Person</span> &#123;</span><br><span class=\"line\">    // 不要重复name和age字段/方法,</span><br><span class=\"line\">    // 只需要定义新增score字段/方法:</span><br><span class=\"line\">    private <span class=\"built_in\">int</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"built_in\">int</span> getScore() &#123; … &#125;</span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setScore(<span class=\"built_in\">int</span> score) &#123; … &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，通过继承，<code>Student</code>只需要编写额外的功能，不再需要重复代码。</p>\n<p> 注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p>\n<p>在OOP的术语中，我们把<code>Person</code>称为超类（super class），父类（parent class），基类（base class），把<code>Student</code>称为子类（subclass），扩展类（extended class）。</p>\n<h3 id=\"继承树\"><a href=\"#继承树\" class=\"headerlink\" title=\"继承树\"></a>继承树</h3><p>注意到我们在定义<code>Person</code>的时候，没有写<code>extends</code>。在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。所以，任何类，除了<code>Object</code>，都会继承自某个类。下图是<code>Person</code>、<code>Student</code>的继承树：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────┐</span><br><span class=\"line\">│  Object   │</span><br><span class=\"line\">└───────────┘</span><br><span class=\"line\">      ▲</span><br><span class=\"line\">      │</span><br><span class=\"line\">┌───────────┐</span><br><span class=\"line\">│  Person   │</span><br><span class=\"line\">└───────────┘</span><br><span class=\"line\">      ▲</span><br><span class=\"line\">      │</span><br><span class=\"line\">┌───────────┐</span><br><span class=\"line\">│  Student  │</span><br><span class=\"line\">└───────────┘</span><br></pre></td></tr></table></figure>\n\n<p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。只有<code>Object</code>特殊，它没有父类。</p>\n<p>类似的，如果我们定义一个继承自<code>Person</code>的<code>Teacher</code>，它们的继承树关系如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">       ┌───────────┐</span><br><span class=\"line\">       │  Object   │</span><br><span class=\"line\">       └───────────┘</span><br><span class=\"line\">             ▲</span><br><span class=\"line\">             │</span><br><span class=\"line\">       ┌───────────┐</span><br><span class=\"line\">       │  Person   │</span><br><span class=\"line\">       └───────────┘</span><br><span class=\"line\">          ▲     ▲</span><br><span class=\"line\">          │     │</span><br><span class=\"line\">          │     │</span><br><span class=\"line\">┌───────────┐ ┌───────────┐</span><br><span class=\"line\">│  Student  │ │  Teacher  │</span><br><span class=\"line\">└───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a>protected</h3><p>继承有个特点，就是子类无法访问父类的<code>private</code>字段或者<code>private</code>方法。例如，<code>Student</code>类就无法访问<code>Person</code>类的<code>name</code>和<code>age</code>字段：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> int age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">String</span> hello() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + name; <span class=\"comment\">// 编译错误：无法访问name字段</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把<code>private</code>改为<code>protected</code>。用<code>protected</code>修饰的字段可以被子类访问：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> int age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">String</span> hello() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + name; <span class=\"comment\">// OK!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问，后面我们还会详细讲解。</p>\n<h3 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h3><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。例如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">String</span> hello() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"keyword\">super</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，这里使用<code>super.name</code>，或者<code>this.name</code>，或者<code>name</code>，效果都是一样的。编译器会自动定位到父类的<code>name</code>字段。</p>\n<p>但是，在某些时候，就必须使用<code>super</code>。我们来看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> super</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上面的代码，会得到一个编译错误，大意是在<code>Student</code>的构造方法中，无法调用<code>Person</code>的构造方法。</p>\n<p>这是因为在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> int score;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"type\">Student</span>(<span class=\"type\">String</span> name, int age, int score) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(); <span class=\"comment\">// 自动调用父类的构造方法</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p>\n<p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> int score;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"type\">Student</span>(<span class=\"type\">String</span> name, int age, int score) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(name, age); <span class=\"comment\">// 调用父类的构造方法Person(String, int)</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.score = score;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样就可以正常编译了！</p>\n<p>因此我们得出结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>\n<p>这里还顺带引出了另一个问题：即子类<em>不会继承</em>任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</p>\n<h3 id=\"阻止继承\"><a href=\"#阻止继承\" class=\"headerlink\" title=\"阻止继承\"></a>阻止继承</h3><p>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</p>\n<p>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</p>\n<p>例如，定义一个<code>Shape</code>类：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> sealed <span class=\"keyword\">class</span> <span class=\"symbol\">Shape</span> <span class=\"symbol\">permits</span> <span class=\"symbol\">Rect, <span class=\"symbol\">Circle</span>, <span class=\"symbol\">Triangle</span></span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述<code>Shape</code>类就是一个<code>sealed</code>类，它只允许指定的3个类继承它。如果写：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rect</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>是没问题的，因为<code>Rect</code>出现在<code>Shape</code>的<code>permits</code>列表中。但是，如果定义一个<code>Ellipse</code>就会报错：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ellipse</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;...&#125;</span><br><span class=\"line\"><span class=\"comment\">// Compile error: class is not allowed to extend sealed class: Shape</span></span><br></pre></td></tr></table></figure>\n\n<p>原因是<code>Ellipse</code>并未出现在<code>Shape</code>的<code>permits</code>列表中。这种<code>sealed</code>类主要用于一些框架，防止继承被滥用。</p>\n<p><code>sealed</code>类在Java 15中目前是预览状态，要启用它，必须使用参数<code>--enable-preview</code>和<code>--source 15</code>。</p>\n<h3 id=\"向上转型\"><a href=\"#向上转型\" class=\"headerlink\" title=\"向上转型\"></a>向上转型</h3><p>如果一个引用变量的类型是<code>Student</code>，那么它可以指向一个<code>Student</code>类型的实例：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Student s</span> = new Student();</span><br></pre></td></tr></table></figure>\n\n<p>如果一个引用类型的变量是<code>Person</code>，那么它可以指向一个<code>Person</code>类型的实例：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Person p</span> = new Person();</span><br></pre></td></tr></table></figure>\n\n<p>现在问题来了：如果<code>Student</code>是从<code>Person</code>继承下来的，那么，一个引用类型为<code>Person</code>的变量，能否指向<code>Student</code>类型的实例？</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> <span class=\"type\">Student</span>(); <span class=\"comment\">// ???</span></span><br></pre></td></tr></table></figure>\n\n<p>测试一下就可以发现，这种指向是允许的！</p>\n<p>这是因为<code>Student</code>继承自<code>Person</code>，因此，它拥有<code>Person</code>的全部功能。<code>Person</code>类型的变量，如果指向<code>Student</code>类型的实例，对它进行操作，是没有问题的！</p>\n<p>这种把一个子类类型安全地变为父类类型的赋值，被称为向上转型（upcasting）。</p>\n<p>向上转型实际上是把一个子类型安全地变为更加抽象的父类型：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">Student s = new Student();</span><br><span class=\"line\">Person p = s; <span class=\"regexp\">//</span> upcasting, ok</span><br><span class=\"line\">Object o1 = p; <span class=\"regexp\">//</span> upcasting, ok</span><br><span class=\"line\">Object o2 = s; <span class=\"regexp\">//</span> upcasting, ok</span><br></pre></td></tr></table></figure>\n\n<p>注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p>\n<h3 id=\"向下转型\"><a href=\"#向下转型\" class=\"headerlink\" title=\"向下转型\"></a>向下转型</h3><p>和向上转型相反，如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）。例如：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p1 = <span class=\"keyword\">new</span> <span class=\"type\">Student</span>(); <span class=\"comment\">// upcasting, ok</span></span><br><span class=\"line\">Person p2 = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>();</span><br><span class=\"line\">Student s1 = (Student) p1; <span class=\"comment\">// ok</span></span><br><span class=\"line\">Student s2 = (Student) p2; <span class=\"comment\">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure>\n\n<p>如果测试上面的代码，可以发现：</p>\n<p><code>Person</code>类型<code>p1</code>实际指向<code>Student</code>实例，<code>Person</code>类型变量<code>p2</code>实际指向<code>Person</code>实例。在向下转型的时候，把<code>p1</code>转型为<code>Student</code>会成功，因为<code>p1</code>确实指向<code>Student</code>实例，把<code>p2</code>转型为<code>Student</code>会失败，因为<code>p2</code>的实际类型是<code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p>\n<p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</p>\n<p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> <span class=\"constructor\">Person()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(p instanceof Person); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(p instanceof Student); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\">Student s = <span class=\"keyword\">new</span> <span class=\"constructor\">Student()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(s instanceof Person); <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(s instanceof Student); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">Student n = null;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(n instanceof Student); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p>\n<p>利用<code>instanceof</code>，在向下转型前可以先判断：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> Student) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 只有判断成功才会向下转型:</span></span><br><span class=\"line\">    Student s = (Student) p; <span class=\"comment\">// 一定会成功</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从Java 14开始，判断<code>instanceof</code>后，可以直接转型为指定变量，避免再次强制转型。例如，对于以下代码：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Object</span> obj = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (obj <span class=\"keyword\">instanceof</span> <span class=\"keyword\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> s = (<span class=\"keyword\">String</span>) obj;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(s.toUpperCase());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以改写如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> instanceof variable:</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这种使用<code>instanceof</code>的写法更加简洁。</p>\n<h3 id=\"区分继承和组合\"><a href=\"#区分继承和组合\" class=\"headerlink\" title=\"区分继承和组合\"></a>区分继承和组合</h3><p>在使用继承时，我们要注意逻辑一致性。</p>\n<p>考察下面的<code>Book</code>类：</p>\n<figure class=\"highlight nim\"><table><tr><td class=\"code\"><pre><span class=\"line\">class <span class=\"type\">Book</span> &#123;</span><br><span class=\"line\">    protected <span class=\"type\">String</span> name;</span><br><span class=\"line\">    public <span class=\"type\">String</span> getName() <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">    public <span class=\"built_in\">void</span> setName(<span class=\"type\">String</span> name) <span class=\"meta\">&#123;...&#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>Book</code>类也有<code>name</code>字段，那么，我们能不能让<code>Student</code>继承自<code>Book</code>呢？</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> int score;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>显然，从逻辑上讲，这是不合理的，<code>Student</code>不应该从<code>Book</code>继承，而应该从<code>Person</code>继承。</p>\n<p>究其原因，是因为<code>Student</code>是<code>Person</code>的一种，它们是is关系，而<code>Student</code>并不是<code>Book</code>。实际上<code>Student</code>和<code>Book</code>的关系是has关系。</p>\n<p>具有has关系不应该使用继承，而是使用组合，即<code>Student</code>可以持有一个<code>Book</code>实例：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"type\">Book</span> book;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> int score;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，继承是is关系，组合是has关系。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p>\n<p>例如，在<code>Person</code>类中，我们定义了<code>run()</code>方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Person.run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在子类<code>Student</code>中，覆写这个<code>run()</code>方法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public void run() &#123;</span><br><span class=\"line\">        <span class=\"type\">System</span>.out.println(<span class=\"string\">&quot;Student.run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Override和Overload不同的是，如果方法签名不同，就是Overload，Overload方法是一个新方法；如果方法签名相同，并且返回值也相同，就是<code>Override</code>。</p>\n<p> 注意：方法名相同，方法参数相同，但方法返回值不同，也是不同的方法。在Java程序中，出现这种情况，编译器会报错。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">run</span>(<span class=\"params\"></span>)</span> &#123; … &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不是Override，因为参数不同:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">run</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123; … &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 不是Override，因为返回值不同:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int <span class=\"function\"><span class=\"title\">run</span>(<span class=\"params\"></span>)</span> &#123; … &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> override</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>但是<code>@Override</code>不是必需的。</p>\n<p>在上一节中，我们已经知道，引用变量的声明类型可能与其实际类型不符，例如：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Person p</span> = new Student();</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们考虑一种情况，如果子类覆写了父类的方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> override</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>那么，一个实际类型为<code>Student</code>，引用类型为<code>Person</code>的变量，调用其<code>run()</code>方法，调用的是<code>Person</code>还是<code>Student</code>的<code>run()</code>方法？</p>\n<p>运行一下上面的代码就可以知道，实际上调用的方法是<code>Student</code>的<code>run()</code>方法。因此可得出结论：</p>\n<p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p>\n<p>这个非常重要的特性在面向对象编程中称之为多态。它的英文拼写非常复杂：Polymorphic。</p>\n<h3 id=\"多态-1\"><a href=\"#多态-1\" class=\"headerlink\" title=\"多态\"></a>多态</h3><p>多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> <span class=\"built_in\">Student</span>();</span><br><span class=\"line\">p.<span class=\"built_in\">run</span>(); <span class=\"comment\">// 无法确定运行时究竟调用哪个run()方法</span></span><br></pre></td></tr></table></figure>\n\n<p>有童鞋会问，从上面的代码一看就明白，肯定调用的是<code>Student</code>的<code>run()</code>方法啊。</p>\n<p>但是，假设我们编写这样一个方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runTwice</span><span class=\"params\">(Person p)</span> </span>&#123;</span><br><span class=\"line\">    p.<span class=\"built_in\">run</span>();</span><br><span class=\"line\">    p.<span class=\"built_in\">run</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它传入的参数类型是<code>Person</code>，我们是无法知道传入的参数实际类型究竟是<code>Person</code>，还是<code>Student</code>，还是<code>Person</code>的其他子类，因此，也无法确定调用的是不是<code>Person</code>类定义的<code>run()</code>方法。</p>\n<p>所以，多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</p>\n<p>我们还是来举栗子。</p>\n<p>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">double</span> income;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">getTax</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> income * <span class=\"number\">0.1</span>; <span class=\"comment\">// 税率10%</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>SalaryIncome</code>，并覆写<code>getTax()</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Salary</span> <span class=\"keyword\">extends</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public double getTax() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (income &lt;= <span class=\"number\">5000</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (income - <span class=\"number\">5000</span>) * <span class=\"number\">0.2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StateCouncilSpecialAllowance</span> <span class=\"keyword\">extends</span> <span class=\"title\">Income</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public double getTax() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">double</span> <span class=\"title\">totalTax</span><span class=\"params\">(Income... incomes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> total = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Income income: incomes) &#123;</span><br><span class=\"line\">        total = total + income.<span class=\"built_in\">getTax</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>来试一下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Polymorphic</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</p>\n<p>可见，多态具有一个非常强大的功能，就是允许添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。</p>\n<h3 id=\"覆写Object方法\"><a href=\"#覆写Object方法\" class=\"headerlink\" title=\"覆写Object方法\"></a>覆写Object方法</h3><p>因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p>\n<ul>\n<li><code>toString()</code>：把instance输出为<code>String</code>；</li>\n<li><code>equals()</code>：判断两个instance是否逻辑相等；</li>\n<li><code>hashCode()</code>：计算一个instance的哈希值。</li>\n</ul>\n<p>在必要的情况下，我们可以覆写<code>Object</code>的这几个方法。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"comment\">// 显示更有意义的字符串:</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">toString</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Person:name=&quot;</span> + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 比较是否相等:</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">equals</span>(<span class=\"params\"><span class=\"built_in\">Object</span> o</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 当且仅当o为Person类型:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Person) &#123;</span><br><span class=\"line\">            Person p = (Person) o;</span><br><span class=\"line\">            <span class=\"comment\">// 并且name字段相同时，返回true:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name.equals(p.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 计算hash:</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int <span class=\"function\"><span class=\"title\">hashCode</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name.hashCode();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"调用super\"><a href=\"#调用super\" class=\"headerlink\" title=\"调用super\"></a>调用super</h3><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">hello</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">hello</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用父类的hello()方法:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.hello() + <span class=\"string\">&quot;!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p>继承可以允许子类覆写父类的方法。如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> final <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">hello</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, &quot;</span> + name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">    <span class=\"comment\">// compile error: 不允许覆写</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">hello</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。用<code>final</code>修饰的类不能被继承：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// compile error: 不允许继承自Person</span></span><br><span class=\"line\">Student <span class=\"keyword\">extends</span> Person &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> name = <span class=\"string\">&quot;Unamed&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对<code>final</code>字段重新赋值会报错：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>();</span><br><span class=\"line\">p.name = <span class=\"string\">&quot;New Name&quot;</span>; <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>可以在构造方法中初始化final字段：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person</span><span class=\"params\">(<span class=\"keyword\">String</span> name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方法更为常用，因为可以保证实例一旦创建，其<code>final</code>字段就不可修改。</p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>由于多态的存在，每个子类都可以覆写父类的方法，例如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    public void run() &#123; … &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public void run() &#123; … &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Teacher</span> <span class=\"keyword\">extends</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public void run() &#123; … &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从<code>Person</code>类派生的<code>Student</code>和<code>Teacher</code>都可以覆写<code>run()</code>方法。</p>\n<p>如果父类<code>Person</code>的<code>run()</code>方法没有实际意义，能否去掉方法的执行语句？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>; <span class=\"comment\">// Compile Error!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>答案是不行，会导致编译错误，因为定义方法的时候，必须实现方法的语句。</p>\n<p>能不能去掉父类的<code>run()</code>方法？</p>\n<p>答案还是不行，因为去掉父类的<code>run()</code>方法，就失去了多态的特性。例如，<code>runTwice()</code>就无法编译：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runTwice</span><span class=\"params\">(Person p)</span> </span>&#123;</span><br><span class=\"line\">    p.<span class=\"built_in\">run</span>(); <span class=\"comment\">// Person没有run()方法，会导致编译错误</span></span><br><span class=\"line\">    p.<span class=\"built_in\">run</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，所以，<code>Person</code>类也无法被实例化。编译器会告诉我们，无法编译<code>Person</code>类，因为它包含抽象方法。</p>\n<p>必须把<code>Person</code>类本身也声明为<code>abstract</code>，才能正确编译它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抽象类-1\"><a href=\"#抽象类-1\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>如果一个<code>class</code>定义了方法，但没有具体执行代码，这个方法就是抽象方法，抽象方法用<code>abstract</code>修饰。</p>\n<p>因为无法执行抽象方法，因此这个类也必须申明为抽象类（abstract class）。</p>\n<p>使用<code>abstract</code>修饰的类就是抽象类。我们无法实例化一个抽象类：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(); <span class=\"comment\">// 编译错误</span></span><br></pre></td></tr></table></figure>\n\n<p>无法实例化的抽象类有什么用？</p>\n<p>因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法，否则编译会报错。因此，抽象方法实际上相当于定义了“规范”。</p>\n<p>例如，<code>Person</code>类定义了抽象方法<code>run()</code>，那么，在实现子类<code>Student</code>的时候，就必须覆写<code>run()</code>方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> abstract class</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"面向抽象编程\"><a href=\"#面向抽象编程\" class=\"headerlink\" title=\"面向抽象编程\"></a>面向抽象编程</h3><p>当我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Person s</span> = new Student();</span><br><span class=\"line\"><span class=\"attribute\">Person t</span> = new Teacher();</span><br></pre></td></tr></table></figure>\n\n<p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不关心Person变量的具体子类型:</span></span><br><span class=\"line\">s.<span class=\"built_in\">run</span>();</span><br><span class=\"line\">t.<span class=\"built_in\">run</span>();</span><br></pre></td></tr></table></figure>\n\n<p>同样的代码，如果引用的是一个新的子类，我们仍然不关心具体类型：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 同样不关心新的子类是如何实现run()方法的：</span></span><br><span class=\"line\">Person e = <span class=\"keyword\">new</span> <span class=\"built_in\">Employee</span>();</span><br><span class=\"line\">e.<span class=\"built_in\">run</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p>\n<p>面向抽象编程的本质就是：</p>\n<ul>\n<li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li>\n<li>不需要子类就可以实现业务逻辑（正常编译）；</li>\n<li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li>\n</ul>\n<h2 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h2><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>\n<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就可以把该抽象类改写为接口：<code>interface</code>。</p>\n<p>在Java中，使用<code>interface</code>可以声明一个接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>\n<p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"title\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Student</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">run</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"built_in\">this</span>.name + <span class=\"string\">&quot; run&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getName</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Student</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">Person, <span class=\"symbol\">Hello</span></span> &#123; <span class=\"comment\">// 实现了两个interface</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h3><p>注意区分术语：</p>\n<p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>\n<p>抽象类和接口的对比如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">abstract class</th>\n<th align=\"left\">interface</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">继承</td>\n<td align=\"left\">只能extends一个class</td>\n<td align=\"left\">可以implements多个interface</td>\n</tr>\n<tr>\n<td align=\"left\">字段</td>\n<td align=\"left\">可以定义实例字段</td>\n<td align=\"left\">不能定义实例字段</td>\n</tr>\n<tr>\n<td align=\"left\">抽象方法</td>\n<td align=\"left\">可以定义抽象方法</td>\n<td align=\"left\">可以定义抽象方法</td>\n</tr>\n<tr>\n<td align=\"left\">非抽象方法</td>\n<td align=\"left\">可以定义非抽象方法</td>\n<td align=\"left\">可以定义default方法</td>\n</tr>\n</tbody></table>\n<h3 id=\"接口继承\"><a href=\"#接口继承\" class=\"headerlink\" title=\"接口继承\"></a>接口继承</h3><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> <span class=\"keyword\">extends</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p>\n<h3 id=\"继承关系\"><a href=\"#继承关系\" class=\"headerlink\" title=\"继承关系\"></a>继承关系</h3><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────────┐</span><br><span class=\"line\">│   Iterable    │</span><br><span class=\"line\">└───────────────┘</span><br><span class=\"line\">        ▲                ┌───────────────────┐</span><br><span class=\"line\">        │                │      Object       │</span><br><span class=\"line\">┌───────────────┐        └───────────────────┘</span><br><span class=\"line\">│  Collection   │                  ▲</span><br><span class=\"line\">└───────────────┘                  │</span><br><span class=\"line\">        ▲     ▲          ┌───────────────────┐</span><br><span class=\"line\">        │     └──────────│AbstractCollection │</span><br><span class=\"line\">┌───────────────┐        └───────────────────┘</span><br><span class=\"line\">│     List      │                  ▲</span><br><span class=\"line\">└───────────────┘                  │</span><br><span class=\"line\">              ▲          ┌───────────────────┐</span><br><span class=\"line\">              └──────────│   AbstractList    │</span><br><span class=\"line\">                         └───────────────────┘</span><br><span class=\"line\">                                ▲     ▲</span><br><span class=\"line\">                                │     │</span><br><span class=\"line\">                                │     │</span><br><span class=\"line\">                     ┌────────────┐ ┌────────────┐</span><br><span class=\"line\">                     │ ArrayList  │ │ LinkedList │</span><br><span class=\"line\">                     └────────────┘ └────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">List list = new ArrayList(); <span class=\"regexp\">//</span> 用List接口引用具体子类的实例</span><br><span class=\"line\">Collection coll = list; <span class=\"regexp\">//</span> 向上转型为Collection接口</span><br><span class=\"line\">Iterable it = coll; <span class=\"regexp\">//</span> 向上转型为Iterable接口</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"default方法\"><a href=\"#default方法\" class=\"headerlink\" title=\"default方法\"></a>default方法</h3><p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> interface</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>\n<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。</p>\n<p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 <strong>,</strong> 来分割。</p>\n<p>例如定义一个颜色的枚举类。</p>\n<figure class=\"highlight capnproto\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Color</span> </span></span><br><span class=\"line\"><span class=\"class\"></span>&#123; </span><br><span class=\"line\">    RED, GREEN, BLUE; </span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n\n<p>以上枚举类 Color 颜色常量有 RED, GREEN, BLUE，分别表示红色，绿色，蓝色。</p>\n<p>使用实例：</p>\n<p><strong>enum</strong> Color<br>{<br>  RED, GREEN, BLUE;<br>}</p>\n<p><strong>public</strong> <strong>class</strong> Test<br>{<br>  <em>&#x2F;&#x2F; 执行输出结果</em><br>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args)<br>  {<br>    Color c1 &#x3D; Color.RED;<br>    System.out.println(c1);<br>  }<br>}</p>\n<p>执行以上代码输出结果为：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">RED</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内部类中使用枚举\"><a href=\"#内部类中使用枚举\" class=\"headerlink\" title=\"内部类中使用枚举\"></a>内部类中使用枚举</h3><p>枚举类也可以声明在内部类中：</p>\n<p><strong>public</strong> <strong>class</strong> Test<br>{<br>  <strong>enum</strong> Color<br>  {<br>    RED, GREEN, BLUE;<br>  }</p>\n<p>  <em>&#x2F;&#x2F; 执行输出结果</em><br>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args)<br>  {<br>    Color c1 &#x3D; Color.RED;<br>    System.out.println(c1);<br>  }<br>}</p>\n<p>执行以上代码输出结果为：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">RED</span></span><br></pre></td></tr></table></figure>\n\n<p>每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。</p>\n<p>以上的枚举类 Color 转化在内部类实现：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Color</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> final Color RED = <span class=\"keyword\">new</span> <span class=\"type\">Color</span>();</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> final Color BLUE = <span class=\"keyword\">new</span> <span class=\"type\">Color</span>();</span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> final Color GREEN = <span class=\"keyword\">new</span> <span class=\"type\">Color</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代枚举元素\"><a href=\"#迭代枚举元素\" class=\"headerlink\" title=\"迭代枚举元素\"></a>迭代枚举元素</h3><p>可以使用 for 语句来迭代枚举元素：</p>\n<p><strong>enum</strong> Color<br>{<br>  RED, GREEN, BLUE;<br>}<br><strong>public</strong> <strong>class</strong> MyClass {<br> <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {<br>  <strong>for</strong> (Color myVar : Color.values()) {<br>   System.out.println(myVar);<br>  }<br> }<br>}</p>\n<p>执行以上代码输出结果为：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">RED</span></span><br><span class=\"line\"><span class=\"attribute\">GREEN</span></span><br><span class=\"line\"><span class=\"attribute\">BLUE</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"在-switch-中使用枚举类\"><a href=\"#在-switch-中使用枚举类\" class=\"headerlink\" title=\"在 switch 中使用枚举类\"></a>在 switch 中使用枚举类</h3><p>枚举类常应用于 switch 语句中：</p>\n<p><strong>enum</strong> Color<br>{<br>  RED, GREEN, BLUE;<br>}<br><strong>public</strong> <strong>class</strong> MyClass {<br> <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {<br>  Color myVar &#x3D; Color.BLUE;</p>\n<p>  <strong>switch</strong>(myVar) {<br>   <strong>case</strong> RED:<br>    System.out.println(“红色”);<br>    <strong>break</strong>;<br>   <strong>case</strong> GREEN:<br>     System.out.println(“绿色”);<br>    <strong>break</strong>;<br>   <strong>case</strong> BLUE:<br>    System.out.println(“蓝色”);<br>    <strong>break</strong>;<br>  }<br> }<br>}</p>\n<p>执行以上代码输出结果为：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">蓝色</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"values-ordinal-和-valueOf-方法\"><a href=\"#values-ordinal-和-valueOf-方法\" class=\"headerlink\" title=\"values(), ordinal() 和 valueOf() 方法\"></a>values(), ordinal() 和 valueOf() 方法</h3><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>\n<p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>\n<ul>\n<li>values() 返回枚举类中所有的值。</li>\n<li>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</li>\n<li>valueOf()方法返回指定字符串值的枚举常量。</li>\n</ul>\n<p><strong>enum</strong> Color<br>{<br>  RED, GREEN, BLUE;<br>}</p>\n<p><strong>public</strong> <strong>class</strong> Test<br>{<br>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args)<br>  {<br>    <em>&#x2F;&#x2F; 调用 values()</em><br>    Color[] arr &#x3D; Color.values();</p>\n<pre><code>*// 迭代枚举*\n**for** (Color col : arr)\n&#123;\n  *// 查看索引*\n  System.out.println(col + &quot; at index &quot; + col.ordinal());\n&#125;\n \n*// 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException*\nSystem.out.println(Color.valueOf(&quot;RED&quot;));\n*// System.out.println(Color.valueOf(&quot;WHITE&quot;));*\n</code></pre>\n<p>  }<br>}</p>\n<p>执行以上代码输出结果为：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">RED <span class=\"built_in\">at</span> index <span class=\"number\">0</span></span><br><span class=\"line\">GREEN <span class=\"built_in\">at</span> index <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">BLUE </span><span class=\"built_in\">at</span> index <span class=\"number\">2</span></span><br><span class=\"line\">RED</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"枚举类成员\"><a href=\"#枚举类成员\" class=\"headerlink\" title=\"枚举类成员\"></a>枚举类成员</h3><p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。</p>\n<p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p>\n<p><strong>enum</strong> Color<br>{<br>  RED, GREEN, BLUE;</p>\n<p>  <em>&#x2F;&#x2F; 构造函数</em><br>  <strong>private</strong> Color()<br>  {<br>    System.out.println(“Constructor called for : “ + <strong>this</strong>.toString());<br>  }</p>\n<p>  <strong>public</strong> <strong>void</strong> colorInfo()<br>  {<br>    System.out.println(“Universal Color”);<br>  }<br>}</p>\n<p><strong>public</strong> <strong>class</strong> Test<br>{<br>  <em>&#x2F;&#x2F; 输出</em><br>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args)<br>  {<br>    Color c1 &#x3D; Color.RED;<br>    System.out.println(c1);<br>    c1.colorInfo();<br>  }<br>}</p>\n<p>执行以上代码输出结果为：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Constructor</span> <span class=\"title\">called</span> <span class=\"title\">for</span> :</span> RED</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Constructor</span> <span class=\"title\">called</span> <span class=\"title\">for</span> :</span> GREEN</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">Constructor</span> <span class=\"title\">called</span> <span class=\"title\">for</span> :</span> BLUE</span><br><span class=\"line\">RED</span><br><span class=\"line\">Universal Color</span><br></pre></td></tr></table></figure>\n\n<p> <a href=\"https://www.runoob.com/java/java-interfaces.html\">Java 接口</a></p>\n<p><a href=\"https://www.runoob.com/java/java-package.html\">Java 包(package)</a> </p>\n<h3 id=\"1-篇笔记-写笔记\"><a href=\"#1-篇笔记-写笔记\" class=\"headerlink\" title=\"1 篇笔记 写笔记\"></a>1 篇笔记 写笔记</h3><p>枚举类中的抽象方法实现，需要枚举类中的每个对象都对其进行实现。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">enum</span> Color&#123;</span><br><span class=\"line\">    RED&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getColor</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//枚举对象实现抽象方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;红色&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    GREEN&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getColor</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//枚举对象实现抽象方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;绿色&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    BLUE&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getColor</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"comment\">//枚举对象实现抽象方法</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;蓝色&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"built_in\">String</span> getColor();<span class=\"comment\">//定义抽象方法</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">main</span>(<span class=\"params\"><span class=\"built_in\">String</span>[] args</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Color c:Color.values())&#123;</span><br><span class=\"line\">            System.out.print(c.getColor() + <span class=\"string\">&quot;、&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>在前面的代码中，我们把类和接口命名为<code>Person</code>、<code>Student</code>、<code>Hello</code>等简单名字。</p>\n<p>在现实中，如果小明写了一个<code>Person</code>类，小红也写了一个<code>Person</code>类，现在，小白既想用小明的<code>Person</code>，也想用小红的<code>Person</code>，怎么办？</p>\n<p>如果小军写了一个<code>Arrays</code>类，恰好JDK也自带了一个<code>Arrays</code>类，如何解决类名冲突？</p>\n<p>在Java中，我们使用<code>package</code>来解决名字冲突。</p>\n<p>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>\n<p>例如：</p>\n<p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p>\n<p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p>\n<p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p>\n<p>JDK的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p>\n<p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p>\n<p>小明的<code>Person.java</code>文件：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> ming; <span class=\"comment\">// 申明包名ming</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>小军的<code>Arrays.java</code>文件：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> mr.jun; <span class=\"comment\">// 申明包名mr.jun</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Arrays</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在Java虚拟机执行的时候，JVM只看完整类名，因此，只要包名不同，类就不同。</p>\n<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p>\n<p> 要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p>\n<p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>\n<p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package_sample</span><br><span class=\"line\">└─ src</span><br><span class=\"line\">    ├─ hong</span><br><span class=\"line\">    │  └─ Person.java</span><br><span class=\"line\">    │  ming</span><br><span class=\"line\">    │  └─ Person.java</span><br><span class=\"line\">    └─ mr</span><br><span class=\"line\">       └─ jun</span><br><span class=\"line\">          └─ Arrays.java</span><br></pre></td></tr></table></figure>\n\n<p>即所有Java文件对应的目录层次要和包的层次一致。</p>\n<p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package_sample</span><br><span class=\"line\">└─ bin</span><br><span class=\"line\">   ├─ hong</span><br><span class=\"line\">   │  └─ Person.class</span><br><span class=\"line\">   │  ming</span><br><span class=\"line\">   │  └─ Person.class</span><br><span class=\"line\">   └─ mr</span><br><span class=\"line\">      └─ jun</span><br><span class=\"line\">         └─ Arrays.class</span><br></pre></td></tr></table></figure>\n\n<p>编译的命令相对比较复杂，我们需要在<code>src</code>目录下执行<code>javac</code>命令：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">javac -d ../bin ming/<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Person</span>.</span></span>java hong/<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Person</span>.</span></span>java mr/jun/<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span>java</span><br></pre></td></tr></table></figure>\n\n<p>在IDE中，会自动根据包结构编译所有Java源码，所以不必担心使用命令行编译的复杂命令。</p>\n<h3 id=\"包作用域\"><a href=\"#包作用域\" class=\"headerlink\" title=\"包作用域\"></a>包作用域</h3><p>位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 包作用域:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Hello!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Main</code>类也定义在<code>hello</code>包下面：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hello;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> void main(<span class=\"keyword\">String</span>[] args) &#123;</span><br><span class=\"line\">        Person p = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>();</span><br><span class=\"line\">        p.hello(); <span class=\"comment\">// 可以调用，因为Main和Person在同一个包</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p>\n<p>第一种，直接写出完整类名，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Person.java</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> ming;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mr.jun.Arrays arrays = <span class=\"keyword\">new</span> mr.jun.Arrays();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>很显然，每次写完整类名比较痛苦。</p>\n<p>因此，第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Person.java</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> ming;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入完整类名:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> mr.jun.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Arrays arrays = <span class=\"keyword\">new</span> Arrays();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Person.java</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> ming;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入mr.jun包的所有class:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> mr.jun.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Arrays arrays = <span class=\"keyword\">new</span> Arrays();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p>\n<p>还有一种<code>import static</code>的语法，它可以导入可以导入一个类的静态字段和静态方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">package main;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 导入System类的所有静态字段和静态方法:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"keyword\">static</span> java.lang.System.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 相当于调用System.out.println(…)</span></span><br><span class=\"line\">        out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Hello, world!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>import static</code>很少使用。</p>\n<p>Java编译器最终编译出的<code>.class</code>文件只使用<em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p>\n<ul>\n<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>\n<li>如果是简单类名，按下面的顺序依次查找：<ul>\n<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>\n<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>\n<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>\n</ul>\n</li>\n</ul>\n<p>如果按照上面的规则还无法确定类名，则编译报错。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Main.java</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.text.Format;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        java.util.List list; <span class=\"comment\">// ok，使用完整类名 -&gt; java.util.List</span></span><br><span class=\"line\">        Format format = <span class=\"keyword\">null</span>; <span class=\"comment\">// ok，使用import的类 -&gt; java.text.Format</span></span><br><span class=\"line\">        String s = <span class=\"string\">&quot;hi&quot;</span>; <span class=\"comment\">// ok，使用java.lang包的String -&gt; java.lang.String</span></span><br><span class=\"line\">        System.out.println(s); <span class=\"comment\">// ok，使用java.lang包的System -&gt; java.lang.System</span></span><br><span class=\"line\">        MessageFormat mf = <span class=\"keyword\">null</span>; <span class=\"comment\">// 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，编写class的时候，编译器会自动帮我们做两个import动作：</p>\n<ul>\n<li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li>\n<li>默认自动<code>import java.lang.*</code>。</li>\n</ul>\n<p> 注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p>\n<p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p>\n<h3 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>\n<ul>\n<li>org.apache</li>\n<li>org.apache.commons.log</li>\n<li>com.liaoxuefeng.sample</li>\n</ul>\n<p>子包就可以根据功能自行命名。</p>\n<p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p>\n<ul>\n<li>String</li>\n<li>System</li>\n<li>Runtime</li>\n<li>…</li>\n</ul>\n<p>要注意也不要和JDK常用类重名：</p>\n<ul>\n<li>java.util.List</li>\n<li>java.text.Format</li>\n<li>java.math.BigInteger</li>\n<li>…</li>\n</ul>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>在Java中，我们经常看到<code>public</code>、<code>protected</code>、<code>private</code>这些修饰符。在Java中，这些修饰符可以用来限定访问作用域。</p>\n<h3 id=\"public\"><a href=\"#public\" class=\"headerlink\" title=\"public\"></a>public</h3><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>Hello</code>是<code>public</code>，因此，可以被其他包的类访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Main可以访问Hello</span></span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>hi()</code>方法是<code>public</code>，可以被其他类调用，前提是首先要能访问<code>Hello</code>类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">        h.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"private\"><a href=\"#private\" class=\"headerlink\" title=\"private\"></a>private</h3><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不能被其他类调用:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，确切地说，<code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> private</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p>\n<h3 id=\"protected-1\"><a href=\"#protected-1\" class=\"headerlink\" title=\"protected\"></a>protected</h3><p><code>protected</code>作用于继承关系。定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// protected方法:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的<code>protected</code>方法可以被继承的类访问：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> xyz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> <span class=\"keyword\">extends</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    void foo() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以访问protected方法:</span></span><br><span class=\"line\">        hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"package\"><a href=\"#package\" class=\"headerlink\" title=\"package\"></a>package</h3><p>最后，包作用域是指一个类允许访问同一个<code>package</code>的没有<code>public</code>、<code>private</code>修饰的<code>class</code>，以及没有<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"><span class=\"comment\">// package权限的类:</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// package权限的方法:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以访问package权限的类:</span></span><br><span class=\"line\">        Hello h = <span class=\"keyword\">new</span> Hello();</span><br><span class=\"line\">        <span class=\"comment\">// 可以调用package权限的方法:</span></span><br><span class=\"line\">        h.hi();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意，包名必须完全一致，包没有父子关系，<code>com.apache</code>和<code>com.apache.abc</code>是不同的包。</p>\n<h3 id=\"局部变量\"><a href=\"#局部变量\" class=\"headerlink\" title=\"局部变量\"></a>局部变量</h3><p>在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">package abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">(<span class=\"keyword\">String</span> name)</span> </span>&#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">        <span class=\"keyword\">String</span> s = name.<span class=\"built_in\">toLowerCase</span>(); <span class=\"comment\">// ②</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = s.<span class=\"built_in\">length</span>(); <span class=\"comment\">// ③</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">10</span>) &#123; <span class=\"comment\">// ④</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> p = <span class=\"number\">10</span> - len; <span class=\"comment\">// ⑤</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>; i&lt;<span class=\"number\">10</span>; i++) &#123; <span class=\"comment\">// ⑥</span></span><br><span class=\"line\">                System.out.<span class=\"built_in\">println</span>(); <span class=\"comment\">// ⑦</span></span><br><span class=\"line\">            &#125; <span class=\"comment\">// ⑧</span></span><br><span class=\"line\">        &#125; <span class=\"comment\">// ⑨</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">// ⑩</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们观察上面的<code>hi()</code>方法代码：</p>\n<ul>\n<li>方法参数name是局部变量，它的作用域是整个方法，即①～⑩；</li>\n<li>变量s的作用域是定义处到方法结束，即②～⑩；</li>\n<li>变量len的作用域是定义处到方法结束，即③～⑩；</li>\n<li>变量p的作用域是定义处到if块结束，即⑤～⑨；</li>\n<li>变量i的作用域是for循环，即⑥～⑧。</li>\n</ul>\n<p>使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。</p>\n<h3 id=\"final-1\"><a href=\"#final-1\" class=\"headerlink\" title=\"final\"></a>final</h3><p>Java还提供了一个<code>final</code>修饰符。<code>final</code>与访问权限不冲突，它有很多作用。</p>\n<p>用<code>final</code>修饰<code>class</code>可以阻止被继承：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 无法被继承:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">(<span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> i = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 无法被覆写:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.n = <span class=\"number\">1</span>; <span class=\"comment\">// error!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>final</code>修饰局部变量可以阻止被重新赋值：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> abc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hello</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">hi</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">int</span> t)</span> </span>&#123;</span><br><span class=\"line\">        t = <span class=\"number\">1</span>; <span class=\"comment\">// error!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"最佳实践-1\"><a href=\"#最佳实践-1\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h3><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p>\n<p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p>\n<p>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</p>\n<h2 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h2><p>在Java程序中，通常情况下，我们把不同的类组织在不同的包下面，对于一个包下面的类来说，它们是在同一层次，没有父子关系：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">java.lang</span><br><span class=\"line\">├── Math</span><br><span class=\"line\">├── Runnable</span><br><span class=\"line\">├── String</span><br><span class=\"line\">└── ...</span><br></pre></td></tr></table></figure>\n\n<p>还有一种类，它被定义在另一个类的内部，所以称为内部类（Nested Class）。Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的。</p>\n<h3 id=\"Inner-Class\"><a href=\"#Inner-Class\" class=\"headerlink\" title=\"Inner Class\"></a>Inner Class</h3><p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"keyword\">Outer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"keyword\">Inner</span> &#123;</span><br><span class=\"line\">        // 定义了一个<span class=\"keyword\">Inner</span> <span class=\"keyword\">Class</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述定义的<code>Outer</code>是一个普通类，而<code>Inner</code>是一个Inner Class，它与普通类有个最大的不同，就是Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例。示例代码如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> inner class</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>观察上述代码，要实例化一个<code>Inner</code>，我们必须首先创建一个<code>Outer</code>的实例，然后，调用<code>Outer</code>实例的<code>new</code>来创建<code>Inner</code>实例：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Outer</span>.<span class=\"keyword\">Inner</span> <span class=\"keyword\">inner</span> = <span class=\"keyword\">outer</span>.<span class=\"built_in\">new</span> <span class=\"keyword\">Inner</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这是因为Inner Class除了有一个<code>this</code>指向它自己，还隐含地持有一个Outer Class实例，可以用<code>Outer.this</code>访问这个实例。所以，实例化一个Inner Class不能脱离Outer实例。</p>\n<p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，就是可以修改Outer Class的<code>private</code>字段，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的<code>private</code>字段和方法。</p>\n<p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。</p>\n<h3 id=\"Anonymous-Class\"><a href=\"#Anonymous-Class\" class=\"headerlink\" title=\"Anonymous Class\"></a>Anonymous Class</h3><p>还有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous Class）来定义。示例代码如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Anonymous Class</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Runnable r = <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">Runnable</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实现必要的抽象方法...</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p>\n<p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而匿名类被编译为<code>Outer$1.class</code>。如果有多个匿名类，Java编译器会将每个匿名类依次命名为<code>Outer$1</code>、<code>Outer$2</code>、<code>Outer$3</code>……</p>\n<p>除了接口外，匿名类也完全可以继承自普通类。观察以下代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Anonymous Class</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>map1</code>是一个普通的<code>HashMap</code>实例，但<code>map2</code>是一个匿名类实例，只是该匿名类继承自<code>HashMap</code>。<code>map3</code>也是一个继承自<code>HashMap</code>的匿名类实例，并且添加了<code>static</code>代码块来初始化数据。观察编译输出可发现<code>Main$1.class</code>和<code>Main$2.class</code>两个匿名类文件。</p>\n<h3 id=\"Static-Nested-Class\"><a href=\"#Static-Nested-Class\" class=\"headerlink\" title=\"Static Nested Class\"></a>Static Nested Class</h3><p>最后一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Static Nested Class</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p>\n<h2 id=\"classpath和jar\"><a href=\"#classpath和jar\" class=\"headerlink\" title=\"classpath和jar\"></a>classpath和jar</h2><p>在Java中，我们经常听到<code>classpath</code>这个东西。网上有很多关于“如何设置classpath”的文章，但大部分设置都不靠谱。</p>\n<p>到底什么是<code>classpath</code>？</p>\n<p><code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code>。</p>\n<p>因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p>\n<p>所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来，可能长这样：</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:<span class=\"symbol\">\\w</span>ork<span class=\"symbol\">\\p</span>roject1<span class=\"symbol\">\\b</span>in;C:<span class=\"symbol\">\\s</span>hared;&quot;D:<span class=\"symbol\">\\M</span>y Documents<span class=\"symbol\">\\p</span>roject1<span class=\"symbol\">\\b</span>in&quot;</span><br></pre></td></tr></table></figure>\n\n<p>在Linux系统上，用<code>:</code>分隔，可能长这样：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">/usr/</span>shared:<span class=\"regexp\">/usr/</span>local<span class=\"regexp\">/bin:/</span>home<span class=\"regexp\">/liaoxuefeng/</span>bin</span><br></pre></td></tr></table></figure>\n\n<p>现在我们假设<code>classpath</code>是<code>.;C:\\work\\project1\\bin;C:\\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p>\n<ul>\n<li>&lt;当前目录&gt;\\abc\\xyz\\Hello.class</li>\n<li>C:\\work\\project1\\bin\\abc\\xyz\\Hello.class</li>\n<li>C:\\shared\\abc\\xyz\\Hello.class</li>\n</ul>\n<p>注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p>\n<p><code>classpath</code>的设定方法有两种：</p>\n<p>在系统环境变量中设置<code>classpath</code>环境变量，不推荐；</p>\n<p>在启动JVM时设置<code>classpath</code>变量，推荐。</p>\n<p>我们强烈<em>不推荐</em>在系统环境变量中设置<code>classpath</code>，那样会污染整个系统环境。在启动JVM时设置<code>classpath</code>才是推荐的做法。实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -classpath .;C:<span class=\"symbol\">\\w</span>ork<span class=\"symbol\">\\p</span>roject1<span class=\"symbol\">\\b</span>in;C:<span class=\"symbol\">\\s</span>hared abc.xyz.Hello</span><br></pre></td></tr></table></figure>\n\n<p>或者使用<code>-cp</code>的简写：</p>\n<figure class=\"highlight taggerscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -cp .;C:<span class=\"symbol\">\\w</span>ork<span class=\"symbol\">\\p</span>roject1<span class=\"symbol\">\\b</span>in;C:<span class=\"symbol\">\\s</span>hared abc.xyz.Hello</span><br></pre></td></tr></table></figure>\n\n<p>没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">java </span>abc.xyz.Hello</span><br></pre></td></tr></table></figure>\n\n<p>上述命令告诉JVM只在当前目录搜索<code>Hello.class</code>。</p>\n<p>在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包。</p>\n<p>通常，我们在自己编写的<code>class</code>中，会引用Java核心库的<code>class</code>，例如，<code>String</code>、<code>ArrayList</code>等。这些<code>class</code>应该上哪去找？</p>\n<p>有很多“如何设置classpath”的文章会告诉你把JVM自带的<code>rt.jar</code>放入<code>classpath</code>，但事实上，根本不需要告诉JVM如何去Java核心库查找<code>class</code>，JVM怎么可能笨到连自己的核心库在哪都不知道？</p>\n<p> 不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</p>\n<p>更好的做法是，不要设置<code>classpath</code>！默认的当前目录<code>.</code>对于绝大多数情况都够用了。</p>\n<p>假设我们有一个编译后的<code>Hello.class</code>，它的包名是<code>com.example</code>，当前目录是<code>C:\\work</code>，那么，目录结构必须如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\work</span><br><span class=\"line\">└─ com</span><br><span class=\"line\">   └─ example</span><br><span class=\"line\">      └─ Hello.class</span><br></pre></td></tr></table></figure>\n\n<p>运行这个<code>Hello.class</code>必须在当前目录下使用如下命令：</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">C:</span>\\work&gt; java -<span class=\"keyword\">cp</span> . <span class=\"keyword\">com</span>.example.Hello</span><br></pre></td></tr></table></figure>\n\n<p>JVM根据classpath设置的<code>.</code>在当前目录下查找<code>com.example.Hello</code>，即实际搜索文件必须位于<code>com/example/Hello.class</code>。如果指定的<code>.class</code>文件不存在，或者目录结构和包名对不上，均会报错。</p>\n<h3 id=\"jar包\"><a href=\"#jar包\" class=\"headerlink\" title=\"jar包\"></a>jar包</h3><p>如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p>\n<p>jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p>\n<p>jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -cp ./hello<span class=\"selector-class\">.jar</span> abc<span class=\"selector-class\">.xyz</span>.Hello</span><br></pre></td></tr></table></figure>\n\n<p>这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p>\n<p>那么问题来了：如何创建jar包？</p>\n<p>因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p>\n<p>假设编译输出的目录结构是这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">package_sample</span><br><span class=\"line\">└─ bin</span><br><span class=\"line\">   ├─ hong</span><br><span class=\"line\">   │  └─ Person.class</span><br><span class=\"line\">   │  ming</span><br><span class=\"line\">   │  └─ Person.class</span><br><span class=\"line\">   └─ mr</span><br><span class=\"line\">      └─ jun</span><br><span class=\"line\">         └─ Arrays.class</span><br></pre></td></tr></table></figure>\n\n<p>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。如果在Windows的资源管理器中看，应该长这样：</p>\n<p><img src=\"/2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.assets/l-16416689542296.jpeg\" alt=\"hello.zip.ok\"></p>\n<p>如果长这样：</p>\n<p><img src=\"/2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.assets/l-16416689542317.jpeg\" alt=\"hello.zip.invalid\"></p>\n<p>说明打包打得有问题，JVM仍然无法从jar包中查找正确的<code>class</code>，原因是<code>hong.Person</code>必须按<code>hong/Person.class</code>存放，而不是<code>bin/hong/Person.class</code>。</p>\n<p>jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">java </span>-<span class=\"keyword\">jar </span>hello.<span class=\"keyword\">jar</span></span><br></pre></td></tr></table></figure>\n\n<p>jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p>\n<p>在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200\">Maven</a>，可以非常方便地创建jar包。</p>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><p>从Java 9开始，JDK又引入了模块（Module）。</p>\n<p>什么是模块？这要从Java 9之前的版本说起。</p>\n<p>我们知道，<code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器。</p>\n<p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。</p>\n<p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</span><br></pre></td></tr></table></figure>\n\n<p> 注意：JVM自带的标准库rt.jar不要写到classpath中，写了反而会干扰JVM的正常运行。</p>\n<p>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code>。</p>\n<p>所以，jar只是用于存放class的容器，它并不关心class之间的依赖。</p>\n<p>从Java 9开始引入的模块，主要是为了解决“依赖”这个问题。如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p>\n<p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p>\n<ul>\n<li>java.base.jmod</li>\n<li>java.compiler.jmod</li>\n<li>java.datatransfer.jmod</li>\n<li>java.desktop.jmod</li>\n<li>…</li>\n</ul>\n<p>这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p>\n<p>把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p>\n<h3 id=\"编写模块\"><a href=\"#编写模块\" class=\"headerlink\" title=\"编写模块\"></a>编写模块</h3><p>那么，我们应该如何编写模块呢？还是以具体的例子来说。首先，创建模块和原有的创建Java项目是完全一样的，以<code>oop-module</code>工程为例，它的目录结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">oop-module</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">├── build.sh</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── com</span><br><span class=\"line\">    │   └── itranswarp</span><br><span class=\"line\">    │       └── sample</span><br><span class=\"line\">    │           ├── Greeting.java</span><br><span class=\"line\">    │           └── Main.java</span><br><span class=\"line\">    └── module-info.java</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> hello.world &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">requires</span> java.base; <span class=\"comment\">// 可不写，任何模块都会自动引入java.base</span></span><br><span class=\"line\">\t<span class=\"keyword\">requires</span> java.xml;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p>\n<p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code>代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">package com.itranswarp.sample;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.xml.XMLConstants;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tGreeting g = <span class=\"keyword\">new</span> <span class=\"built_in\">Greeting</span>();</span><br><span class=\"line\">\t\tSystem.out.<span class=\"built_in\">println</span>(g.<span class=\"built_in\">hello</span>(XMLConstants.XML_NS_PREFIX));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p>\n<p>下面，我们用JDK提供的命令行工具来编译并创建模块。</p>\n<p>首先，我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure>\n\n<p>如果编译成功，现在项目结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">oop-module</span><br><span class=\"line\">├── bin</span><br><span class=\"line\">│   ├── com</span><br><span class=\"line\">│   │   └── itranswarp</span><br><span class=\"line\">│   │       └── sample</span><br><span class=\"line\">│   │           ├── Greeting.class</span><br><span class=\"line\">│   │           └── Main.class</span><br><span class=\"line\">│   └── module-info.class</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── com</span><br><span class=\"line\">    │   └── itranswarp</span><br><span class=\"line\">    │       └── sample</span><br><span class=\"line\">    │           ├── Greeting.java</span><br><span class=\"line\">    │           └── Main.java</span><br><span class=\"line\">    └── module-info.java</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>src</code>目录下的<code>module-info.java</code>被编译到<code>bin</code>目录下的<code>module-info.class</code>。</p>\n<p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure>\n\n<p>现在我们就在当前目录下得到了<code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure>\n\n<p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p>\n<h3 id=\"运行模块\"><a href=\"#运行模块\" class=\"headerlink\" title=\"运行模块\"></a>运行模块</h3><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java --module-path hello.jmod --module hello.world</span><br></pre></td></tr></table></figure>\n\n<p>结果是一个错误：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">Error occurred during initialization of boot layer</span><br><span class=\"line\">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure>\n\n<p>原因是<code>.jmod</code>不能被放入<code>--module-path</code>中。换成<code>.jar</code>就没问题了：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ java --module-path hello.jar --module hello.world</span><br><span class=\"line\">Hello, xml!</span><br></pre></td></tr></table></figure>\n\n<p>那我们辛辛苦苦创建的<code>hello.jmod</code>有什么用？答案是我们可以用它来打包JRE。</p>\n<h3 id=\"打包JRE\"><a href=\"#打包JRE\" class=\"headerlink\" title=\"打包JRE\"></a>打包JRE</h3><p>前面讲了，为了支持模块化，Java 9首先带头把自己的一个巨大无比的<code>rt.jar</code>拆成了几十个<code>.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p>\n<p>过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p>\n<p>现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code>jlink</code>命令来干这件事。命令如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure>\n\n<p>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p>\n<p>现在，在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ jre/bin/java --module hello.world</span><br><span class=\"line\">Hello, xml!</span><br></pre></td></tr></table></figure>\n\n<p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p>\n<h3 id=\"访问权限\"><a href=\"#访问权限\" class=\"headerlink\" title=\"访问权限\"></a>访问权限</h3><p>前面我们讲过，Java的class访问权限分为public、protected、private和默认的包访问权限。引入模块后，这些访问权限的规则就要稍微做些调整。</p>\n<p>确切地说，class的这些访问权限只在一个模块内有效，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p>\n<p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\">module java.<span class=\"built_in\">xml</span> &#123;</span><br><span class=\"line\">    exports java.<span class=\"built_in\">xml</span>;</span><br><span class=\"line\">    exports javax.<span class=\"built_in\">xml</span>.catalog;</span><br><span class=\"line\">    exports javax.<span class=\"built_in\">xml</span>.datatype;</span><br><span class=\"line\">    <span class=\"params\">...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> hello.world &#123;</span><br><span class=\"line\">    <span class=\"keyword\">exports</span> com.itranswarp.sample;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">requires</span> java.base;</span><br><span class=\"line\">\t<span class=\"keyword\">requires</span> java.xml;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，模块进一步隔离了代码的访问权限。</p>\n<h1 id=\"常用类\"><a href=\"#常用类\" class=\"headerlink\" title=\"常用类\"></a>常用类</h1><h2 id=\"字符串和编码\"><a href=\"#字符串和编码\" class=\"headerlink\" title=\"字符串和编码\"></a>字符串和编码</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>在Java中，<code>String</code>是一个引用类型，它本身也是一个<code>class</code>。但是，Java编译器对<code>String</code>有特殊处理，即可以直接用<code>&quot;...&quot;</code>来表示一个字符串：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"string\">&quot;Hello!&quot;</span><span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上字符串在<code>String</code>内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> s2 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">String</span></span>(<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[] &#123;<span class=\"string\">&#x27;H&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;!&#x27;</span>&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>String</code>太常用了，所以Java提供了<code>&quot;...&quot;</code>这种字符串字面量表示方法。</p>\n<p>Java字符串的一个重要特点就是字符串<em>不可变</em>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> String</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>根据上面代码的输出，试解释字符串内容是否改变。</p>\n<h3 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h3><p>当我们想要比较两个字符串是否相同时，要特别注意，我们实际上是想比较字符串的内容是否相同。必须使用<code>equals()</code>方法而不能用<code>==</code>。</p>\n<p>我们看下面的例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> String</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</p>\n<p>所以，这种<code>==</code>比较返回<code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> String</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>结论：两个字符串比较，必须总是使用<code>equals()</code>方法。</p>\n<p>要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p>\n<p><code>String</code>类还提供了多种方法来搜索子串、提取子串。常用的方法有：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 是否包含子串:</span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.contains(<span class=\"string\">&quot;ll&quot;</span>); <span class=\"regexp\">//</span> true</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>contains()</code>方法的参数是<code>CharSequence</code>而不是<code>String</code>，因为<code>CharSequence</code>是<code>String</code>的父类。</p>\n<p>搜索子串的更多的例子：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.indexOf(<span class=\"string\">&quot;l&quot;</span>); <span class=\"regexp\">//</span> <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.lastIndexOf(<span class=\"string\">&quot;l&quot;</span>); <span class=\"regexp\">//</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.startsWith(<span class=\"string\">&quot;He&quot;</span>); <span class=\"regexp\">//</span> true</span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span>.endsWith(<span class=\"string\">&quot;lo&quot;</span>); <span class=\"regexp\">//</span> true</span><br></pre></td></tr></table></figure>\n\n<p>提取子串的例子：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;Hello&quot;.<span class=\"built_in\">substring</span>(<span class=\"number\">2</span>); <span class=\"operator\">/</span><span class=\"operator\">/</span> &quot;llo&quot;</span><br><span class=\"line\">&quot;Hello&quot;.<span class=\"built_in\">substring</span>(<span class=\"number\">2</span>, <span class=\"number\">4</span>); &quot;ll&quot;</span><br></pre></td></tr></table></figure>\n\n<p>注意索引号是从<code>0</code>开始的。</p>\n<h3 id=\"去除首尾空白字符\"><a href=\"#去除首尾空白字符\" class=\"headerlink\" title=\"去除首尾空白字符\"></a>去除首尾空白字符</h3><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。空白字符包括空格，<code>\\t</code>，<code>\\r</code>，<code>\\n</code>：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;  <span class=\"subst\">\\t</span>Hello<span class=\"subst\">\\r</span><span class=\"subst\">\\n</span> &quot;</span>.trim(); <span class=\"comment\">// &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：<code>trim()</code>并没有改变字符串的内容，而是返回了一个新字符串。</p>\n<p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\\u3000</code>也会被移除：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;\\u3000Hello\\u3000&quot;</span>.strip(); <span class=\"regexp\">//</span> <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span>.stripLeading(); <span class=\"regexp\">//</span> <span class=\"string\">&quot;Hello &quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span>.stripTrailing(); <span class=\"regexp\">//</span> <span class=\"string\">&quot; Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空和空白字符串：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;&quot;</span><span class=\"string\">.isEmpty</span><span class=\"params\">()</span>; <span class=\"string\">//</span> <span class=\"literal\">true</span>，因为字符串长度为0</span><br><span class=\"line\"><span class=\"string\">&quot;  &quot;</span><span class=\"string\">.isEmpty</span><span class=\"params\">()</span>; <span class=\"string\">//</span> <span class=\"literal\">false</span>，因为字符串长度不为0</span><br><span class=\"line\"><span class=\"string\">&quot;  \\n&quot;</span><span class=\"string\">.isBlank</span><span class=\"params\">()</span>; <span class=\"string\">//</span> <span class=\"literal\">true</span>，因为只包含空白字符</span><br><span class=\"line\"><span class=\"string\">&quot; Hello &quot;</span><span class=\"string\">.isBlank</span><span class=\"params\">()</span>; <span class=\"string\">//</span> <span class=\"literal\">false</span>，因为包含非空白字符</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"替换子串\"><a href=\"#替换子串\" class=\"headerlink\" title=\"替换子串\"></a>替换子串</h3><p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\">s.replace(<span class=\"string\">&#x27;l&#x27;</span>, <span class=\"string\">&#x27;w&#x27;</span>); <span class=\"regexp\">//</span> <span class=\"string\">&quot;hewwo&quot;</span>，所有字符<span class=\"string\">&#x27;l&#x27;</span>被替换为<span class=\"string\">&#x27;w&#x27;</span></span><br><span class=\"line\">s.replace(<span class=\"string\">&quot;ll&quot;</span>, <span class=\"string\">&quot;~~&quot;</span>); <span class=\"regexp\">//</span> <span class=\"string\">&quot;he~~o&quot;</span>，所有子串<span class=\"string\">&quot;ll&quot;</span>被替换为<span class=\"string\">&quot;~~&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>另一种是通过正则表达式替换：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> s <span class=\"operator\">=</span> <span class=\"string\">&quot;A,,B;C ,D&quot;</span>;</span><br><span class=\"line\">s.replaceAll(<span class=\"string\">&quot;[<span class=\"subst\">\\\\</span>,<span class=\"subst\">\\\\</span>;<span class=\"subst\">\\\\</span>s]+&quot;</span>, <span class=\"string\">&quot;,&quot;</span>); <span class=\"comment\">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代码通过正则表达式，把匹配的子串统一替换为<code>&quot;,&quot;</code>。关于正则表达式的用法我们会在后面详细讲解。</p>\n<h3 id=\"分割字符串\"><a href=\"#分割字符串\" class=\"headerlink\" title=\"分割字符串\"></a>分割字符串</h3><p>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;A,B,C,D&quot;</span>;</span><br><span class=\"line\">String[] ss = s.split(<span class=\"string\">&quot;\\\\,&quot;</span>); <span class=\"regexp\">//</span> &#123;<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"拼接字符串\"><a href=\"#拼接字符串\" class=\"headerlink\" title=\"拼接字符串\"></a>拼接字符串</h3><p>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span>[] arr = &#123;<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">String</span> s = <span class=\"keyword\">String</span>.join(<span class=\"string\">&quot;***&quot;</span>, arr); <span class=\"comment\">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"格式化字符串\"><a href=\"#格式化字符串\" class=\"headerlink\" title=\"格式化字符串\"></a>格式化字符串</h3><p>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> String</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>有几个占位符，后面就传入几个参数。参数类型要和占位符一致。我们经常用这个方法来格式化信息。常用的占位符有：</p>\n<ul>\n<li><code>%s</code>：显示字符串；</li>\n<li><code>%d</code>：显示整数；</li>\n<li><code>%x</code>：显示十六进制整数；</li>\n<li><code>%f</code>：显示浮点数。</li>\n</ul>\n<p>占位符还可以带格式，例如<code>%.2f</code>表示显示两位小数。如果你不确定用啥占位符，那就始终用<code>%s</code>，因为<code>%s</code>可以显示任何数据类型。要查看完整的格式化语法，请参考<a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/Formatter.html#syntax\">JDK文档</a>。</p>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code>。这是一个重载方法，编译器会根据参数自动选择合适的方法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>value<span class=\"constructor\">Of(123)</span>; <span class=\"comment\">// &quot;123&quot;</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>value<span class=\"constructor\">Of(45.67)</span>; <span class=\"comment\">// &quot;45.67&quot;</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>value<span class=\"constructor\">Of(<span class=\"params\">true</span>)</span>; <span class=\"comment\">// &quot;true&quot;</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>value<span class=\"constructor\">Of(<span class=\"params\">new</span> Object()</span>); <span class=\"comment\">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure>\n\n<p>要把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> n1 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(<span class=\"string\">&quot;123&quot;</span>)</span>; <span class=\"comment\">// 123</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> n2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(<span class=\"string\">&quot;ff&quot;</span>, 16)</span>; <span class=\"comment\">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure>\n\n<p>把字符串转换为<code>boolean</code>类型：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">boolean b1 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Boolean</span>.</span></span>parse<span class=\"constructor\">Boolean(<span class=\"string\">&quot;true&quot;</span>)</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\">boolean b2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Boolean</span>.</span></span>parse<span class=\"constructor\">Boolean(<span class=\"string\">&quot;FALSE&quot;</span>)</span>; <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>get<span class=\"constructor\">Integer(<span class=\"string\">&quot;java.version&quot;</span>)</span>; <span class=\"comment\">// 版本号，11</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"转换为char\"><a href=\"#转换为char\" class=\"headerlink\" title=\"转换为char[]\"></a>转换为char[]</h3><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">char</span><span class=\"literal\">[]</span> cs = <span class=\"string\">&quot;Hello&quot;</span>.<span class=\"keyword\">to</span><span class=\"constructor\">CharArray()</span>; <span class=\"comment\">// String -&gt; char[]</span></span><br><span class=\"line\">String s = <span class=\"keyword\">new</span> <span class=\"constructor\">String(<span class=\"params\">cs</span>)</span>; <span class=\"comment\">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure>\n\n<p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> String &lt;-&gt; char[]</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p>\n<p>从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p>\n<p>例如，下面的代码设计了一个<code>Score</code>类保存一组学生的成绩：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// int[]</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>观察两次输出，由于<code>Score</code>内部直接引用了外部传入的<code>int[]</code>数组，这会造成外部代码对<code>int[]</code>数组的修改，影响到<code>Score</code>类的字段。如果外部代码不可信，这就会造成安全隐患。</p>\n<p>请修复<code>Score</code>的构造方法，使得外部代码对数组的修改不影响<code>Score</code>实例的<code>int[]</code>字段。</p>\n<h3 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h3><p>在早期的计算机系统中，为了给字符编码，美国国家标准学会（American National Standard Institute：ANSI）制定了一套英文字母、数字和常用符号的编码，它占用一个字节，编码范围从<code>0</code>到<code>127</code>，最高位始终为<code>0</code>，称为<code>ASCII</code>编码。例如，字符<code>&#39;A&#39;</code>的编码是<code>0x41</code>，字符<code>&#39;1&#39;</code>的编码是<code>0x31</code>。</p>\n<p>如果要把汉字也纳入计算机编码，很显然一个字节是不够的。<code>GB2312</code>标准使用两个字节表示一个汉字，其中第一个字节的最高位始终为<code>1</code>，以便和<code>ASCII</code>编码区分开。例如，汉字<code>&#39;中&#39;</code>的<code>GB2312</code>编码是<code>0xd6d0</code>。</p>\n<p>类似的，日文有<code>Shift_JIS</code>编码，韩文有<code>EUC-KR</code>编码，这些编码因为标准不统一，同时使用，就会产生冲突。</p>\n<p>为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码，它把世界上主要语言都纳入同一个编码，这样，中文、日文、韩文和其他语言就不会冲突。</p>\n<p><code>Unicode</code>编码需要两个或者更多字节表示，我们可以比较中英文字符在<code>ASCII</code>、<code>GB2312</code>和<code>Unicode</code>的编码：</p>\n<p>英文字符<code>&#39;A&#39;</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">         ┌────┐</span><br><span class=\"line\">ASCII:   │ 41 │</span><br><span class=\"line\">         └────┘</span><br><span class=\"line\">         ┌────┬────┐</span><br><span class=\"line\">Unicode: │ 00 │ 41 │</span><br><span class=\"line\">         └────┴────┘</span><br></pre></td></tr></table></figure>\n\n<p>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节。</p>\n<p>中文字符<code>&#39;中&#39;</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">         ┌────┬────┐</span><br><span class=\"line\">GB2312:  │ d6 │ d0 │</span><br><span class=\"line\">         └────┴────┘</span><br><span class=\"line\">         ┌────┬────┐</span><br><span class=\"line\">Unicode: │ 4e │ 2d │</span><br><span class=\"line\">         └────┴────┘</span><br></pre></td></tr></table></figure>\n\n<p>那我们经常使用的<code>UTF-8</code>又是什么编码呢？因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，它是一种变长编码，用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码。通过<code>UTF-8</code>编码，英文字符<code>&#39;A&#39;</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>&#39;中&#39;</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code>。</p>\n<p><code>UTF-8</code>编码的另一个好处是容错能力强。如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p>\n<p>在Java中，<code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码。如果我们要手动把字符串转换成其他编码，可以这样做：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte[] </span><span class=\"keyword\">b1 </span>= <span class=\"string\">&quot;Hello&quot;</span>.getBytes()<span class=\"comment\">; // 按系统默认编码转换，不推荐</span></span><br><span class=\"line\"><span class=\"keyword\">byte[] </span><span class=\"keyword\">b2 </span>= <span class=\"string\">&quot;Hello&quot;</span>.getBytes(<span class=\"string\">&quot;UTF-8&quot;</span>)<span class=\"comment\">; // 按UTF-8编码转换</span></span><br><span class=\"line\"><span class=\"keyword\">byte[] </span><span class=\"keyword\">b2 </span>= <span class=\"string\">&quot;Hello&quot;</span>.getBytes(<span class=\"string\">&quot;GBK&quot;</span>)<span class=\"comment\">; // 按GBK编码转换</span></span><br><span class=\"line\"><span class=\"keyword\">byte[] </span><span class=\"keyword\">b3 </span>= <span class=\"string\">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8)<span class=\"comment\">; // 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure>\n\n<p>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</p>\n<p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] b = ...</span><br><span class=\"line\"><span class=\"keyword\">String</span> s1 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">String</span></span>(b, <span class=\"string\">&quot;GBK&quot;</span>); <span class=\"comment\">// 按GBK转换</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> s2 = <span class=\"keyword\">new</span> <span class=\"built_in\"><span class=\"keyword\">String</span></span>(b, StandardCharsets.UTF_8); <span class=\"comment\">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure>\n\n<p>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</p>\n<h3 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h3><p>对于不同版本的JDK，<code>String</code>类在内存中有不同的优化方式。具体来说，早期JDK版本的<code>String</code>总是以<code>char[]</code>存储，它的定义如下：</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"built_in\">char</span>[] value;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> offset;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> <span class=\"keyword\">count</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而较新的JDK版本的<code>String</code>则以<code>byte[]</code>存储：如果<code>String</code>仅包含ASCII字符，则每个<code>byte</code>存储一个字符，否则，每两个<code>byte</code>存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的<code>String</code>通常仅包含ASCII字符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] value;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span> coder; <span class=\"comment\">// 0 = LATIN1, 1 = UTF16</span></span><br></pre></td></tr></table></figure>\n\n<p>对于使用者来说，<code>String</code>内部的优化不影响任何已有代码，因为它的<code>public</code>方法签名是不变的。</p>\n<h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><p>Java编译器对<code>String</code>做了特殊处理，使得我们可以直接用<code>+</code>拼接字符串。</p>\n<p>考察下面的循环代码：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">String <span class=\"attr\">s</span> = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">for (int <span class=\"attr\">i</span> = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"attr\">s</span> = s + <span class=\"string\">&quot;,&quot;</span> + i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然可以直接拼接字符串，但是，在循环中，每次循环都会创建新的字符串对象，然后扔掉旧的字符串。这样，绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率。</p>\n<p>为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    sb.<span class=\"built_in\">append</span>(<span class=\"string\">&#x27;,&#x27;</span>);</span><br><span class=\"line\">    sb.<span class=\"built_in\">append</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">String</span> s = sb.toString();</span><br></pre></td></tr></table></figure>\n\n<p><code>StringBuilder</code>还可以进行链式操作：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 链式操作</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果我们查看<code>StringBuilder</code>的源码，可以发现，进行链式操作的关键是，定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法。</p>\n<p>仿照<code>StringBuilder</code>，我们也可以设计支持链式操作的类。例如，一个可以不断增加的计数器：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 链式操作</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意：对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>\n<p>你可能还听说过<code>StringBuffer</code>，这是Java早期的一个<code>StringBuilder</code>的线程安全版本，它通过同步来保证多个线程操作<code>StringBuffer</code>也是安全的，但是同步会带来执行速度的下降。</p>\n<p><code>StringBuilder</code>和<code>StringBuffer</code>接口完全相同，现在完全没有必要使用<code>StringBuffer</code>。</p>\n<h2 id=\"StringJoiner\"><a href=\"#StringJoiner\" class=\"headerlink\" title=\"StringJoiner\"></a>StringJoiner</h2><p>要高效拼接字符串，应该使用<code>StringBuilder</code>。</p>\n<p>很多时候，我们拼接的字符串像这样：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Hello Bob, Alice, Grace!</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个<code>StringJoiner</code>来干这个事：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.StringJoiner;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>慢着！用<code>StringJoiner</code>的结果少了前面的<code>&quot;Hello &quot;</code>和结尾的<code>&quot;!&quot;</code>！遇到这种情况，需要给<code>StringJoiner</code>指定“开头”和“结尾”：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.StringJoiner;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"String-join\"><a href=\"#String-join\" class=\"headerlink\" title=\"String.join()\"></a>String.join()</h3><p><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>[] names = &#123;<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Grace&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"built_in\">String</span>.join(<span class=\"string\">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"包装类型\"><a href=\"#包装类型\" class=\"headerlink\" title=\"包装类型\"></a>包装类型</h2><p>我们已经知道，Java的数据类型分两种：</p>\n<ul>\n<li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li>\n<li>引用类型：所有<code>class</code>和<code>interface</code>类型</li>\n</ul>\n<p>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code>：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> s = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> n = <span class=\"keyword\">null</span>; <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>那么，如何把一个基本类型视为对象（引用类型）？</p>\n<p>比如，想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Integer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Integer</span><span class=\"params\">(<span class=\"keyword\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">intValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义好了<code>Integer</code>类，我们就可以把<code>int</code>和<code>Integer</code>互相转换：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Integer</span> n = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"type\">Integer</span> n2 = <span class=\"built_in\">new</span> <span class=\"type\">Integer</span>(<span class=\"number\">99</span>);</span><br><span class=\"line\"><span class=\"type\">int</span> n3 = n2.intValue();</span><br></pre></td></tr></table></figure>\n\n<p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">基本类型</th>\n<th align=\"left\">对应的引用类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">boolean</td>\n<td align=\"left\">java.lang.Boolean</td>\n</tr>\n<tr>\n<td align=\"left\">byte</td>\n<td align=\"left\">java.lang.Byte</td>\n</tr>\n<tr>\n<td align=\"left\">short</td>\n<td align=\"left\">java.lang.Short</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">java.lang.Integer</td>\n</tr>\n<tr>\n<td align=\"left\">long</td>\n<td align=\"left\">java.lang.Long</td>\n</tr>\n<tr>\n<td align=\"left\">float</td>\n<td align=\"left\">java.lang.Float</td>\n</tr>\n<tr>\n<td align=\"left\">double</td>\n<td align=\"left\">java.lang.Double</td>\n</tr>\n<tr>\n<td align=\"left\">char</td>\n<td align=\"left\">java.lang.Character</td>\n</tr>\n</tbody></table>\n<p>我们可以直接使用，并不需要自己去定义：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Integer:</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"Auto-Boxing\"><a href=\"#Auto-Boxing\" class=\"headerlink\" title=\"Auto Boxing\"></a>Auto Boxing</h3><p>因为<code>int</code>和<code>Integer</code>可以互相转换：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\">Integer n = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>value<span class=\"constructor\">Of(<span class=\"params\">i</span>)</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> x = n.<span class=\"built_in\">int</span><span class=\"constructor\">Value()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以，Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Integer</span> n = <span class=\"number\">100</span>; // 编译器自动使用<span class=\"keyword\">Integer</span>.valueOf(<span class=\"built_in\">int</span>)</span><br><span class=\"line\"><span class=\"built_in\">int</span> x = n; // 编译器自动使用<span class=\"keyword\">Integer</span>.intValue()</span><br></pre></td></tr></table></figure>\n\n<p>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</p>\n<p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p>\n<p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> NullPointerException</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"不变类\"><a href=\"#不变类\" class=\"headerlink\" title=\"不变类\"></a>不变类</h3><p>所有的包装类型都是不变类。我们查看<code>Integer</code>的源码可知，它的核心代码如下：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"symbol\">Integer</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"built_in\">int</span> value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，一旦创建了<code>Integer</code>对象，该对象就是不变的。</p>\n<p>对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> == or equals?</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>仔细观察结果的童鞋可以发现，<code>==</code>比较，较小的两个相同的<code>Integer</code>返回<code>true</code>，较大的两个相同的<code>Integer</code>返回<code>false</code>，这是因为<code>Integer</code>是不变类，编译器把<code>Integer x = 127;</code>自动变为<code>Integer x = Integer.valueOf(127);</code>，为了节省内存，<code>Integer.valueOf()</code>对于较小的数，始终返回相同的实例，因此，<code>==</code>比较“恰好”为<code>true</code>，但我们<em>绝不能</em>因为Java标准库的<code>Integer</code>内部有缓存优化就用<code>==</code>比较，必须用<code>equals()</code>方法比较两个<code>Integer</code>。</p>\n<p> 按照语义编程，而不是针对特定的底层实现去“优化”。</p>\n<p>因为<code>Integer.valueOf()</code>可能始终返回同一个<code>Integer</code>实例，因此，在我们自己创建<code>Integer</code>的时候，以下两种方法：</p>\n<ul>\n<li>方法1：<code>Integer n = new Integer(100);</code></li>\n<li>方法2：<code>Integer n = Integer.valueOf(100);</code></li>\n</ul>\n<p>方法2更好，因为方法1总是创建新的<code>Integer</code>实例，方法2把内部优化留给<code>Integer</code>的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p>\n<p>我们把能创建“新”对象的静态方法称为静态工厂方法。<code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p>\n<p> 创建新对象时，优先选用静态工厂方法而不是new操作符。</p>\n<p>如果我们考察<code>Byte.valueOf()</code>方法的源码，可以看到，标准库返回的<code>Byte</code>实例全部是缓存实例，但调用者并不关心静态工厂方法以何种方式创建新实例还是直接返回缓存的实例。</p>\n<h3 id=\"进制转换\"><a href=\"#进制转换\" class=\"headerlink\" title=\"进制转换\"></a>进制转换</h3><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> x1 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(<span class=\"string\">&quot;100&quot;</span>)</span>; <span class=\"comment\">// 100</span></span><br><span class=\"line\"><span class=\"built_in\">int</span> x2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>parse<span class=\"constructor\">Int(<span class=\"string\">&quot;100&quot;</span>, 16)</span>; <span class=\"comment\">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure>\n\n<p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Integer:</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意：上述方法的输出都是<code>String</code>，在计算机内存中，只用二进制表示，不存在十进制或十六进制的表示方法。<code>int n = 100</code>在内存中总是以4字节的二进制表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌────────┬────────┬────────┬────────┐</span><br><span class=\"line\">│00000000│00000000│00000000│01100100│</span><br><span class=\"line\">└────────┴────────┴────────┴────────┘</span><br></pre></td></tr></table></figure>\n\n<p>我们经常使用的<code>System.out.println(n);</code>是依靠核心库自动把整数格式化为10进制输出并显示在屏幕上，使用<code>Integer.toHexString(n)</code>则通过核心库自动把整数格式化为16进制。</p>\n<p>这里我们注意到程序设计的一个重要原则：数据的存储和显示要分离。</p>\n<p>Java的包装类型还定义了一些有用的静态变量</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// boolean只有两个值true/false，其包装类型只需要引用Boolean提供的静态字段:</span></span><br><span class=\"line\"><span class=\"keyword\">Boolean</span> t = <span class=\"keyword\">Boolean</span>.<span class=\"keyword\">TRUE</span>;</span><br><span class=\"line\"><span class=\"keyword\">Boolean</span> f = <span class=\"keyword\">Boolean</span>.<span class=\"keyword\">FALSE</span>;</span><br><span class=\"line\"><span class=\"comment\">// int可表示的最大/最小值:</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> max = Integer.MAX_VALUE; <span class=\"comment\">// 2147483647</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> min = Integer.MIN_VALUE; <span class=\"comment\">// -2147483648</span></span><br><span class=\"line\"><span class=\"comment\">// long类型占用的bit和byte数量:</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> sizeOfLong = <span class=\"keyword\">Long</span>.<span class=\"keyword\">SIZE</span>; <span class=\"comment\">// 64 (bits)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> bytesOfLong = <span class=\"keyword\">Long</span>.BYTES; <span class=\"comment\">// 8 (bytes)</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，所有的整数和浮点数的包装类型都继承自<code>Number</code>，因此，可以非常方便地直接通过包装类型获取各种基本类型：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 向上转型为Number:</span></span><br><span class=\"line\">Number num = <span class=\"keyword\">new</span> <span class=\"constructor\">Integer(999)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 获取byte, int, long, float, double:</span></span><br><span class=\"line\">byte b = num.byte<span class=\"constructor\">Value()</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> n = num.<span class=\"built_in\">int</span><span class=\"constructor\">Value()</span>;</span><br><span class=\"line\">long ln = num.long<span class=\"constructor\">Value()</span>;</span><br><span class=\"line\"><span class=\"built_in\">float</span> f = num.<span class=\"built_in\">float</span><span class=\"constructor\">Value()</span>;</span><br><span class=\"line\">double d = num.double<span class=\"constructor\">Value()</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"处理无符号整型\"><a href=\"#处理无符号整型\" class=\"headerlink\" title=\"处理无符号整型\"></a>处理无符号整型</h3><p>在Java中，并没有无符号整型（Unsigned）的基本数据类型。<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>都是带符号整型，最高位是符号位。而C语言则提供了CPU支持的全部数据类型，包括无符号整型。无符号整型和有符号整型的转换在Java中就需要借助包装类型的静态方法完成。</p>\n<p>例如，byte是有符号整型，范围是<code>-128</code><del><code>+127</code>，但如果把<code>byte</code>看作无符号整型，它的范围就是<code>0</code></del><code>255</code>。我们把一个负的<code>byte</code>按无符号整型转换为<code>int</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Byte</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为<code>byte</code>的<code>-1</code>的二进制表示是<code>11111111</code>，以无符号整型转换后的<code>int</code>就是<code>255</code>。</p>\n<p>类似的，可以把一个<code>short</code>按unsigned转换为<code>int</code>，把一个<code>int</code>按unsigned转换为<code>long</code>。</p>\n<h2 id=\"JavaBean\"><a href=\"#JavaBean\" class=\"headerlink\" title=\"JavaBean\"></a>JavaBean</h2><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p>\n<ul>\n<li>若干<code>private</code>实例字段；</li>\n<li>通过<code>public</code>方法来读写实例字段。</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getName</span>(<span class=\"params\"></span>)</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setName</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123; <span class=\"built_in\">this</span>.name = name; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int <span class=\"function\"><span class=\"title\">getAge</span>(<span class=\"params\"></span>)</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.age; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setAge</span>(<span class=\"params\">int age</span>)</span> &#123; <span class=\"built_in\">this</span>.age = age; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果读写方法符合以下这种命名规范：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读方法:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">Type</span> getXyz()</span><br><span class=\"line\"><span class=\"comment\">// 写方法:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"literal\">void</span> setXyz(<span class=\"keyword\">Type</span> value)</span><br></pre></td></tr></table></figure>\n\n<p>那么这种<code>class</code>被称为<code>JavaBean</code>：</p>\n<p><img src=\"/2.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.assets/l-164166958483810.jpeg\" alt=\"java-bean\"></p>\n<p>上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p>\n<p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 读方法:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">bool</span>ean isChild()</span><br><span class=\"line\"><span class=\"comment\">// 写方法:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">void</span> setChild(<span class=\"built_in\">bool</span>ean value)</span><br></pre></td></tr></table></figure>\n\n<p>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性：</p>\n<ul>\n<li>对应的读方法是<code>String getName()</code></li>\n<li>对应的写方法是<code>setName(String)</code></li>\n</ul>\n<p>只有<code>getter</code>的属性称为只读属性（read-only），例如，定义一个age只读属性：</p>\n<ul>\n<li>对应的读方法是<code>int getAge()</code></li>\n<li>无对应的写方法<code>setAge(int)</code></li>\n</ul>\n<p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p>\n<p>很明显，只读属性很常见，只写属性不常见。</p>\n<p>属性只需要定义<code>getter</code>和<code>setter</code>方法，不一定需要对应的字段。例如，<code>child</code>只读属性定义如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getName</span>(<span class=\"params\"></span>)</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setName</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123; <span class=\"built_in\">this</span>.name = name; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int <span class=\"function\"><span class=\"title\">getAge</span>(<span class=\"params\"></span>)</span> &#123; <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.age; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setAge</span>(<span class=\"params\">int age</span>)</span> &#123; <span class=\"built_in\">this</span>.age = age; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">isChild</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age &lt;= <span class=\"number\">6</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看出，<code>getter</code>和<code>setter</code>也是一种数据封装的方法。</p>\n<h3 id=\"JavaBean的作用\"><a href=\"#JavaBean的作用\" class=\"headerlink\" title=\"JavaBean的作用\"></a>JavaBean的作用</h3><p>JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p>\n<p>通过IDE，可以快速生成<code>getter</code>和<code>setter</code>。例如，在Eclipse中，先输入以下代码：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，点击右键，在弹出的菜单中选择“Source”，“Generate Getters and Setters”，在弹出的对话框中选中需要生成<code>getter</code>和<code>setter</code>方法的字段，点击确定即可由IDE自动完成所有方法代码。</p>\n<h3 id=\"枚举JavaBean属性\"><a href=\"#枚举JavaBean属性\" class=\"headerlink\" title=\"枚举JavaBean属性\"></a>枚举JavaBean属性</h3><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.beans.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>运行上述代码，可以列出所有的属性，以及对应的读写方法。注意<code>class</code>属性是从<code>Object</code>继承的<code>getClass()</code>方法带来的。</p>\n<h2 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h2><p>在Java中，我们可以通过<code>static final</code>来定义常量。例如，我们希望定义周一到周日这7个常量，可以用7个不同的<code>int</code>表示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Weekday</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SUN = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MON = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TUE = <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> WED = <span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> THU = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> FRI = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SAT = <span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用常量的时候，可以这么引用：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (day == <span class=\"built_in\">Weekday</span>.SAT || day == <span class=\"built_in\">Weekday</span>.SUN) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> work at home</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也可以把常量定义为字符串类型，例如，定义3种颜色的常量：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Color</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> RED = <span class=\"string\">&quot;r&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> GREEN = <span class=\"string\">&quot;g&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> BLUE = <span class=\"string\">&quot;b&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用常量的时候，可以这么引用：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span> color = <span class=\"params\">...</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (Color.RED.<span class=\"keyword\">equals</span>(color)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无论是<code>int</code>常量还是<code>String</code>常量，使用这些常量来表示一组枚举值的时候，有一个严重的问题就是，编译器无法检查每个值的合理性。例如：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"params\">(<span class=\"attr\">weekday</span> == 6 || <span class=\"attr\">weekday</span> == 7)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"params\">(<span class=\"attr\">tasks</span> == Weekday.MON)</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">//</span> TODO:</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码编译和运行均不会报错，但存在两个问题：</p>\n<ul>\n<li>注意到<code>Weekday</code>定义的常量范围是<code>0</code>~&#96;6<code>，并不包含</code>7<code>，编译器无法检查不在枚举中的</code>int&#96;值；</li>\n<li>定义的常量仍可与其他变量比较，但其用途并非是枚举星期值。</li>\n</ul>\n<h3 id=\"enum\"><a href=\"#enum\" class=\"headerlink\" title=\"enum\"></a>enum</h3><p>为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> enum</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到定义枚举类是通过关键字<code>enum</code>实现的，我们只需依次列出枚举的常量名。</p>\n<p>和<code>int</code>定义的常量相比，使用<code>enum</code>定义枚举有如下好处：</p>\n<p>首先，<code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。例如，下面的语句不可能编译通过：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> day = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (day == Weekday.SUN) &#123; // Compile error: bad operand <span class=\"keyword\">types</span> <span class=\"keyword\">for</span> binary <span class=\"keyword\">operator</span> <span class=\"string\">&#x27;==&#x27;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，不可能引用到非枚举的值，因为无法通过编译。</p>\n<p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个<code>Weekday</code>枚举类型的变量赋值为<code>Color</code>枚举类型的值：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Weekday</span> x = <span class=\"built_in\">Weekday</span>.SUN; <span class=\"comment\">// ok!</span></span><br><span class=\"line\"><span class=\"built_in\">Weekday</span> y = Color.RED; <span class=\"comment\">// Compile error: incompatible types</span></span><br></pre></td></tr></table></figure>\n\n<p>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</p>\n<h3 id=\"enum的比较\"><a href=\"#enum的比较\" class=\"headerlink\" title=\"enum的比较\"></a>enum的比较</h3><p>使用<code>enum</code>定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用<code>equals()</code>方法，如果使用<code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用<code>equals()</code>方法，但<code>enum</code>类型可以例外。</p>\n<p>这是因为<code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (day == <span class=\"built_in\">Weekday</span>.FRI) &#123; <span class=\"comment\">// ok!</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (day.equals(<span class=\"built_in\">Weekday</span>.SUN)) &#123; <span class=\"comment\">// ok, but more code!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"enum类型\"><a href=\"#enum类型\" class=\"headerlink\" title=\"enum类型\"></a>enum类型</h3><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？</p>\n<p>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>\n<ul>\n<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>\n<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>\n<li>定义的每个实例都是引用类型的唯一实例；</li>\n<li>可以将<code>enum</code>类型用于<code>switch</code>语句。</li>\n</ul>\n<p>例如，我们定义的<code>Color</code>枚举类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Color</span> </span>&#123;</span><br><span class=\"line\">    RED, GREEN, BLUE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译器编译出的<code>class</code>大概就像这样：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Color</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enum</span> </span>&#123; <span class=\"comment\">// 继承自Enum，标记为final class</span></span><br><span class=\"line\">    <span class=\"comment\">// 每个实例均为全局唯一:</span></span><br><span class=\"line\">    public static <span class=\"keyword\">final</span> <span class=\"type\">Color</span> <span class=\"type\">RED</span> = <span class=\"keyword\">new</span> <span class=\"type\">Color</span>();</span><br><span class=\"line\">    public static <span class=\"keyword\">final</span> <span class=\"type\">Color</span> <span class=\"type\">GREEN</span> = <span class=\"keyword\">new</span> <span class=\"type\">Color</span>();</span><br><span class=\"line\">    public static <span class=\"keyword\">final</span> <span class=\"type\">Color</span> <span class=\"type\">BLUE</span> = <span class=\"keyword\">new</span> <span class=\"type\">Color</span>();</span><br><span class=\"line\">    <span class=\"comment\">// private构造方法，确保外部无法调用new操作符:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Color</span>() &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p>\n<p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例，因此，这些实例有一些方法：</p>\n<h3 id=\"name\"><a href=\"#name\" class=\"headerlink\" title=\"name()\"></a>name()</h3><p>返回常量名，例如：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Weekday</span>.</span><span class=\"module\"><span class=\"identifier\">SUN</span>.</span></span>name<span class=\"literal\">()</span>; <span class=\"comment\">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ordinal\"><a href=\"#ordinal\" class=\"headerlink\" title=\"ordinal()\"></a>ordinal()</h3><p>返回定义的常量的顺序，从0开始计数，例如：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">int</span> n = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Weekday</span>.</span><span class=\"module\"><span class=\"identifier\">MON</span>.</span></span>ordinal<span class=\"literal\">()</span>; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>改变枚举常量定义的顺序就会导致<code>ordinal()</code>返回值发生变化。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Weekday</span> </span>&#123;</span><br><span class=\"line\">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Weekday</span> </span>&#123;</span><br><span class=\"line\">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>的<code>ordinal</code>就是不同的。如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。</p>\n<p>有些童鞋会想，<code>Weekday</code>的枚举常量如果要和<code>int</code>转换，使用<code>ordinal()</code>不是非常方便？比如这样写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String task = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Weekday</span>.</span><span class=\"module\"><span class=\"identifier\">MON</span>.</span></span>ordinal<span class=\"literal\">()</span> + <span class=\"string\">&quot;/ppt&quot;</span>;</span><br><span class=\"line\">save<span class=\"constructor\">ToFile(<span class=\"params\">task</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> enum</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code>int</code>值。</p>\n<p> 注意：枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做！</p>\n<p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> enum</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>覆写<code>toString()</code>的目的是在输出时更有可读性。</p>\n<p> 注意：判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()！</p>\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3><p>最后，枚举类可以应用在<code>switch</code>语句中。因为枚举类天生具有类型信息和有限个枚举常量，所以比<code>int</code>、<code>String</code>类型更适合用在<code>switch</code>语句中：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> switch</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>加上<code>default</code>语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误。</p>\n<h2 id=\"记录类\"><a href=\"#记录类\" class=\"headerlink\" title=\"记录类\"></a>记录类</h2><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p>\n<ol>\n<li>定义class时使用<code>final</code>，无法派生子类；</li>\n<li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li>\n</ol>\n<p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">x</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">y</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了保证不变类的比较，还需要正确覆写<code>equals()</code>和<code>hashCode()</code>方法，这样才能在集合类中正常使用。后续我们会详细讲解正确覆写<code>equals()</code>和<code>hashCode()</code>，这里演示<code>Point</code>不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</p>\n<h3 id=\"record\"><a href=\"#record\" class=\"headerlink\" title=\"record\"></a>record</h3><p>从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Record</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>仔细观察<code>Point</code>的定义：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">record</span> <span class=\"title\">Point</span>(<span class=\"params\"><span class=\"built_in\">int</span> x, <span class=\"built_in\">int</span> y</span>)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把上述定义改写为class，相当于以下代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"title\">extends</span> <span class=\"title\">Record</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Point</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">x</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">y</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">String</span> <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">String</span>.format(<span class=\"string\">&quot;Point[x=%s, y=%s]&quot;</span>, x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p>\n<p>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</p>\n<p>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</p>\n<h3 id=\"构造方法-1\"><a href=\"#构造方法-1\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><p>编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p>\n<p>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">record</span> <span class=\"title\">Point</span>(<span class=\"params\"><span class=\"built_in\">int</span> x, <span class=\"built_in\">int</span> y</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Point &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到方法<code>public Point &#123;...&#125;</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，编译器最终生成的构造方法如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span> <span class=\"keyword\">extends</span> <span class=\"title\">Record</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">Point</span>(int x, int y) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这是我们编写的Compact Constructor:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || y &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">IllegalArgumentException</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 这是编译器继续生成的赋值代码:</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">record</span> <span class=\"title\">Point</span>(<span class=\"params\"><span class=\"built_in\">int</span> x, <span class=\"built_in\">int</span> y</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Point <span class=\"title\">of</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Point(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Point <span class=\"title\">of</span>(<span class=\"params\"><span class=\"built_in\">int</span> x, <span class=\"built_in\">int</span> y</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Point(x, y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样我们可以写出更简洁的代码：</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> z = <span class=\"built_in\">Point</span>.of();</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"built_in\">Point</span>.of(<span class=\"number\">123</span>, <span class=\"number\">456</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BigInteger\"><a href=\"#BigInteger\" class=\"headerlink\" title=\"BigInteger\"></a>BigInteger</h2><h3 id=\"BigInteger-1\"><a href=\"#BigInteger-1\" class=\"headerlink\" title=\"BigInteger\"></a>BigInteger</h3><p>在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快。</p>\n<p>如果我们使用的整数范围超过了<code>long</code>型怎么办？这个时候，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigInteger bi = <span class=\"keyword\">new</span> <span class=\"constructor\">BigInteger(<span class=\"string\">&quot;1234567890&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(bi.pow(<span class=\"number\">5</span>)); <span class=\"comment\">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure>\n\n<p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p>\n<figure class=\"highlight llvm\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigInteger <span class=\"type\">i1</span> <span class=\"operator\">=</span> new BigInteger(<span class=\"string\">&quot;1234567890&quot;</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">BigInteger <span class=\"type\">i2</span> <span class=\"operator\">=</span> new BigInteger(<span class=\"string\">&quot;12345678901234567890&quot;</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">BigInteger sum <span class=\"operator\">=</span> <span class=\"type\">i1</span>.<span class=\"keyword\">add</span>(<span class=\"type\">i2</span>)<span class=\"comment\">; // 12345678902469135780</span></span><br></pre></td></tr></table></figure>\n\n<p>和<code>long</code>型整数运算比，<code>BigInteger</code>不会有范围限制，但缺点是速度比较慢。</p>\n<p>也可以把<code>BigInteger</code>转换成<code>long</code>型：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigInteger i = <span class=\"keyword\">new</span> <span class=\"constructor\">BigInteger(<span class=\"string\">&quot;123456789000&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(i.long<span class=\"constructor\">Value()</span>); <span class=\"comment\">// 123456789000</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(i.multiply(i).long<span class=\"constructor\">ValueExact()</span>); <span class=\"comment\">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p>\n<p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p>\n<ul>\n<li>转换为<code>byte</code>：<code>byteValue()</code></li>\n<li>转换为<code>short</code>：<code>shortValue()</code></li>\n<li>转换为<code>int</code>：<code>intValue()</code></li>\n<li>转换为<code>long</code>：<code>longValue()</code></li>\n<li>转换为<code>float</code>：<code>floatValue()</code></li>\n<li>转换为<code>double</code>：<code>doubleValue()</code></li>\n</ul>\n<p>因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p>\n<p>如果<code>BigInteger</code>的值甚至超过了<code>float</code>的最大范围（3.4x1038），那么返回的float是什么呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// BigInteger to float</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigInteger;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h2 id=\"BigDecimal\"><a href=\"#BigDecimal\" class=\"headerlink\" title=\"BigDecimal\"></a>BigDecimal</h2><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示一个任意大小且精度完全准确的浮点数。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigDecimal bd = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;123.4567&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(bd.multiply(bd)); <span class=\"comment\">// 15241.55677489</span></span><br></pre></td></tr></table></figure>\n\n<p><code>BigDecimal</code>用<code>scale()</code>表示小数位数，例如：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;123.45&quot;</span>)</span>;</span><br><span class=\"line\">BigDecimal d2 = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;123.4500&quot;</span>)</span>;</span><br><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;1234500&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d1.scale<span class=\"literal\">()</span>); <span class=\"comment\">// 2,两位小数</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d2.scale<span class=\"literal\">()</span>); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d3.scale<span class=\"literal\">()</span>); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;123.4500&quot;</span>)</span>;</span><br><span class=\"line\">BigDecimal d2 = d1.strip<span class=\"constructor\">TrailingZeros()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d1.scale<span class=\"literal\">()</span>); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d2.scale<span class=\"literal\">()</span>); <span class=\"comment\">// 2,因为去掉了00</span></span><br><span class=\"line\"></span><br><span class=\"line\">BigDecimal d3 = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;1234500&quot;</span>)</span>;</span><br><span class=\"line\">BigDecimal d4 = d3.strip<span class=\"constructor\">TrailingZeros()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d3.scale<span class=\"literal\">()</span>); <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d4.scale<span class=\"literal\">()</span>); <span class=\"comment\">// -2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p>\n<p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigDecimal;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.math.RoundingMode;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">BigDecimal</span> d<span class=\"number\">1</span> = new BigDecimal(<span class=\"string\">&quot;123.456&quot;</span>);</span><br><span class=\"line\"><span class=\"attribute\">BigDecimal</span> d<span class=\"number\">2</span> = new BigDecimal(<span class=\"string\">&quot;23.456789&quot;</span>);</span><br><span class=\"line\"><span class=\"attribute\">BigDecimal</span> d<span class=\"number\">3</span> = d<span class=\"number\">1</span>.divide(d<span class=\"number\">2</span>, <span class=\"number\">10</span>, RoundingMode.HALF_UP); // 保留<span class=\"number\">10</span>位小数并四舍五入</span><br><span class=\"line\"><span class=\"attribute\">BigDecimal</span> d<span class=\"number\">4</span> = d<span class=\"number\">1</span>.divide(d<span class=\"number\">2</span>); // 报错：ArithmeticException，因为除不尽</span><br></pre></td></tr></table></figure>\n\n<p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.math.BigDecimal;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigDecimal n = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;12.75&quot;</span>)</span>;</span><br><span class=\"line\">BigDecimal m = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;0.15&quot;</span>)</span>;</span><br><span class=\"line\">BigDecimal<span class=\"literal\">[]</span> dr = n.divide<span class=\"constructor\">AndRemainder(<span class=\"params\">m</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (dr<span class=\"literal\">[<span class=\"number\">1</span>]</span>.signum<span class=\"literal\">()</span><span class=\"operator\"> == </span><span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// n是m的整数倍</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"比较BigDecimal\"><a href=\"#比较BigDecimal\" class=\"headerlink\" title=\"比较BigDecimal\"></a>比较BigDecimal</h3><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">BigDecimal d1 = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;123.456&quot;</span>)</span>;</span><br><span class=\"line\">BigDecimal d2 = <span class=\"keyword\">new</span> <span class=\"constructor\">BigDecimal(<span class=\"string\">&quot;123.45600&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d1.equals(d2)); <span class=\"comment\">// false,因为scale不同</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d1.equals(d2.strip<span class=\"constructor\">TrailingZeros()</span>)); <span class=\"comment\">// true,因为d2去除尾部0后scale变为2</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(d1.compare<span class=\"constructor\">To(<span class=\"params\">d2</span>)</span>); <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure>\n\n<p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p>\n<p> 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p>\n<p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BigDecimal</span> <span class=\"keyword\">extends</span> <span class=\"title\">Number</span> <span class=\"title\">implements</span> <span class=\"title\">Comparable&lt;BigDecimal&gt;</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"type\">BigInteger</span> intVal;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> int scale;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p>\n<h2 id=\"常用工具类\"><a href=\"#常用工具类\" class=\"headerlink\" title=\"常用工具类\"></a>常用工具类</h2><p>Java的核心库提供了大量的现成的类供我们使用。本节我们介绍几个常用的工具类。</p>\n<h3 id=\"Math\"><a href=\"#Math\" class=\"headerlink\" title=\"Math\"></a>Math</h3><p>顾名思义，<code>Math</code>类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算：</p>\n<p>求绝对值：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Math</span>.abs(-<span class=\"number\">100</span>); // <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"attribute\">Math</span>.abs(-<span class=\"number\">7</span>.<span class=\"number\">8</span>); // <span class=\"number\">7</span>.<span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n\n<p>取最大或最小值：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Math</span>.max(<span class=\"number\">100</span>, <span class=\"number\">99</span>); // <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"attribute\">Math</span>.min(<span class=\"number\">1</span>.<span class=\"number\">2</span>, <span class=\"number\">2</span>.<span class=\"number\">3</span>); // <span class=\"number\">1</span>.<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>计算xy次方：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">10</span>); // <span class=\"number\">2</span>的<span class=\"number\">10</span>次方=<span class=\"number\">1024</span></span><br></pre></td></tr></table></figure>\n\n<p>计算√x：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Math</span>.sqrt(<span class=\"number\">2</span>); // <span class=\"number\">1</span>.<span class=\"number\">414</span>...</span><br></pre></td></tr></table></figure>\n\n<p>计算ex次方：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Math</span>.exp(<span class=\"number\">2</span>); // <span class=\"number\">7</span>.<span class=\"number\">389</span>...</span><br></pre></td></tr></table></figure>\n\n<p>计算以e为底的对数：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Math</span>.log(<span class=\"number\">4</span>); // <span class=\"number\">1</span>.<span class=\"number\">386</span>...</span><br></pre></td></tr></table></figure>\n\n<p>计算以10为底的对数：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Math</span>.log<span class=\"number\">10</span>(<span class=\"number\">100</span>); // <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>三角函数：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Math</span>.sin(<span class=\"number\">3</span>.<span class=\"number\">14</span>); // <span class=\"number\">0</span>.<span class=\"number\">00159</span>...</span><br><span class=\"line\"><span class=\"attribute\">Math</span>.cos(<span class=\"number\">3</span>.<span class=\"number\">14</span>); // -<span class=\"number\">0</span>.<span class=\"number\">9999</span>...</span><br><span class=\"line\"><span class=\"attribute\">Math</span>.tan(<span class=\"number\">3</span>.<span class=\"number\">14</span>); // -<span class=\"number\">0</span>.<span class=\"number\">0015</span>...</span><br><span class=\"line\"><span class=\"attribute\">Math</span>.asin(<span class=\"number\">1</span>.<span class=\"number\">0</span>); // <span class=\"number\">1</span>.<span class=\"number\">57079</span>...</span><br><span class=\"line\"><span class=\"attribute\">Math</span>.acos(<span class=\"number\">1</span>.<span class=\"number\">0</span>); // <span class=\"number\">0</span>.<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>Math还提供了几个数学常量：</p>\n<figure class=\"highlight qml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">double</span> pi = <span class=\"built_in\">Math</span>.PI; <span class=\"comment\">// 3.14159...</span></span><br><span class=\"line\"><span class=\"built_in\">double</span> e = <span class=\"built_in\">Math</span>.E; <span class=\"comment\">// 2.7182818...</span></span><br><span class=\"line\"><span class=\"built_in\">Math</span>.sin(<span class=\"built_in\">Math</span>.PI / <span class=\"number\">6</span>); <span class=\"comment\">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure>\n\n<p>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Math</span>.</span></span>random<span class=\"literal\">()</span>; <span class=\"comment\">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们要生成一个区间在<code>[MIN, MAX)</code>的随机数，可以借助<code>Math.random()</code>实现，计算如下：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>有些童鞋可能注意到Java标准库还提供了一个<code>StrictMath</code>，它提供了和<code>Math</code>几乎一模一样的方法。这两个类的区别在于，由于浮点数计算存在误差，不同的平台（例如x86和ARM）计算的结果可能不一致（指误差不同），因此，<code>StrictMath</code>保证所有平台计算结果都是完全相同的，而<code>Math</code>会尽量针对平台优化计算速度，所以，绝大多数情况下，使用<code>Math</code>就足够了。</p>\n<h3 id=\"Random\"><a href=\"#Random\" class=\"headerlink\" title=\"Random\"></a>Random</h3><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p>\n<p>要生成一个随机数，可以使用<code>nextInt()</code>、<code>nextLong()</code>、<code>nextFloat()</code>、<code>nextDouble()</code>：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Random</span> r = new Random();</span><br><span class=\"line\"><span class=\"attribute\">r</span>.nextInt(); // <span class=\"number\">2071575453</span>,每次都不一样</span><br><span class=\"line\"><span class=\"attribute\">r</span>.nextInt(<span class=\"number\">10</span>); // <span class=\"number\">5</span>,生成一个[<span class=\"number\">0</span>,<span class=\"number\">10</span>)之间的int</span><br><span class=\"line\"><span class=\"attribute\">r</span>.nextLong(); // <span class=\"number\">8811649292570369305</span>,每次都不一样</span><br><span class=\"line\"><span class=\"attribute\">r</span>.nextFloat(); // <span class=\"number\">0</span>.<span class=\"number\">54335</span>...生成一个[<span class=\"number\">0</span>,<span class=\"number\">1</span>)之间的float</span><br><span class=\"line\"><span class=\"attribute\">r</span>.nextDouble(); // <span class=\"number\">0</span>.<span class=\"number\">3716</span>...生成一个[<span class=\"number\">0</span>,<span class=\"number\">1</span>)之间的double</span><br></pre></td></tr></table></figure>\n\n<p>有童鞋问，每次运行程序，生成的随机数都是不同的，没看出<em>伪随机数</em>的特性来。</p>\n<p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p>\n<p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Random;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>前面我们使用的<code>Math.random()</code>实际上内部调用了<code>Random</code>类，所以它也是伪随机数，只是我们无法指定种子。</p>\n<h3 id=\"SecureRandom\"><a href=\"#SecureRandom\" class=\"headerlink\" title=\"SecureRandom\"></a>SecureRandom</h3><p>有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">SecureRandom sr = <span class=\"keyword\">new</span> <span class=\"constructor\">SecureRandom()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(sr.next<span class=\"constructor\">Int(100)</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>SecureRandom</code>无法指定种子，它使用RNG（random number generator）算法。JDK的<code>SecureRandom</code>实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.SecureRandom;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.security.NoSuchAlgorithmException;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>\n<p>在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用<code>SecureRandom</code>来产生安全的随机数。</p>\n<p> 需要使用安全随机数的时候，必须使用SecureRandom，绝不能使用Random！</p>\n","categories":["Java","1.Java快速入门","02.面向对象编程"],"tags":["写作"]},{"title":"1.数据结构","url":"/2022/02/04/4-Java_2.%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80_1.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","content":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><h1 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h1><h1 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h1><h1 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h1><h1 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h1>","categories":["Java","2.理论基础","1.数据结构"],"tags":["写作"]},{"title":"2.算法","url":"/2022/02/04/4-Java_2.%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80_2.%E7%AE%97%E6%B3%95/","content":"<h1 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h1><h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><h1 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h1><h1 id=\"分治\"><a href=\"#分治\" class=\"headerlink\" title=\"分治\"></a>分治</h1><h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><h1 id=\"回溯\"><a href=\"#回溯\" class=\"headerlink\" title=\"回溯\"></a>回溯</h1><h1 id=\"贪心\"><a href=\"#贪心\" class=\"headerlink\" title=\"贪心\"></a>贪心</h1><h1 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h1><h1 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h1><h1 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h1><h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1>","categories":["Java","2.理论基础","2.算法"],"tags":["写作"]},{"title":"9.日期和时间","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_9.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4/","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>在计算机中，我们经常需要处理日期和时间。</p>\n<p>这是日期：</p>\n<ul>\n<li>2019-11-20</li>\n<li>2020-1-1</li>\n</ul>\n<p>这是时间：</p>\n<ul>\n<li>12:30:59</li>\n<li>2020-1-1 20:21:59</li>\n</ul>\n<p>日期是指某一天，它不是连续变化的，而是应该被看成离散的。</p>\n<p>而时间有两种概念，一种是不带日期的时间，例如，12:30:59。另一种是带日期的时间，例如，2020-1-1 20:21:59，只有这种带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。</p>\n<h3 id=\"本地时间\"><a href=\"#本地时间\" class=\"headerlink\" title=\"本地时间\"></a>本地时间</h3><p>当我们说当前时刻是2019年11月20日早上8:15的时候，我们说的实际上是本地时间。在国内就是北京时间。在这个时刻，如果地球上不同地方的人们同时看一眼手表，他们各自的本地时间是不同的：</p>\n<p><img src=\"/9.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.assets/l.jpeg\" alt=\"localtime\"></p>\n<p>所以，不同的时区，在同一时刻，本地时间是不同的。全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</p>\n<h3 id=\"时区\"><a href=\"#时区\" class=\"headerlink\" title=\"时区\"></a>时区</h3><p>因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。时区有好几种表示方式。</p>\n<p>一种是以<code>GMT</code>或者<code>UTC</code>加时区偏移表示，例如：<code>GMT+08:00</code>或者<code>UTC+08:00</code>表示东八区。</p>\n<p><code>GMT</code>和<code>UTC</code>可以认为基本是等价的，只是<code>UTC</code>使用更精确的原子钟计时，每隔几年会有一个闰秒，我们在开发程序的时候可以忽略两者的误差，因为计算机的时钟在联网的时候会自动与时间服务器同步时间。</p>\n<p>另一种是缩写，例如，<code>CST</code>表示<code>China Standard Time</code>，也就是中国标准时间。但是<code>CST</code>也可以表示美国中部时间<code>Central Standard Time USA</code>，因此，缩写容易产生混淆，我们尽量不要使用缩写。</p>\n<p>最后一种是以洲／城市表示，例如，<code>Asia/Shanghai</code>，表示上海所在地的时区。特别注意城市名称不是任意的城市，而是由国际标准组织规定的城市。</p>\n<p>因为时区的存在，东八区的2019年11月20日早上8:15，和西五区的2019年11月19日晚上19:15，他们的时刻是相同的：</p>\n<p><img src=\"/9.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.assets/l-16418939865886.jpeg\" alt=\"timezone\"></p>\n<p>时刻相同的意思就是，分别在两个时区的两个人，如果在这一刻通电话，他们各自报出自己手表上的时间，虽然本地时间是不同的，但是这两个时间表示的时刻是相同的。</p>\n<h3 id=\"夏令时\"><a href=\"#夏令时\" class=\"headerlink\" title=\"夏令时\"></a>夏令时</h3><p>时区还不是最复杂的，更复杂的是夏令时。所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。我们国家实行过一段时间夏令时，1992年就废除了，但是矫情的美国人到现在还在使用，所以时间换算更加复杂。</p>\n<p><img src=\"/9.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.assets/l-16418939865887.jpeg\" alt=\"daynight-saving\"></p>\n<p>因为涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。我们举个栗子：</p>\n<p>对于2019-11-20和2019-6-20两个日期来说，假设北京人在纽约：</p>\n<ul>\n<li>如果以<code>GMT</code>或者<code>UTC</code>作为时区，无论日期是多少，时间都是<code>19:00</code>；</li>\n<li>如果以国家／城市表示，例如<code>America／NewYork</code>，虽然纽约也在西五区，但是，因为夏令时的存在，在不同的日期，<code>GMT</code>时间和纽约时间可能是不一样的：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">时区</th>\n<th align=\"left\">2019-11-20</th>\n<th align=\"left\">2019-6-20</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">GMT-05:00</td>\n<td align=\"left\">19:00</td>\n<td align=\"left\">19:00</td>\n</tr>\n<tr>\n<td align=\"left\">UTC-05:00</td>\n<td align=\"left\">19:00</td>\n<td align=\"left\">19:00</td>\n</tr>\n<tr>\n<td align=\"left\">America&#x2F;New_York</td>\n<td align=\"left\">19:00</td>\n<td align=\"left\">20:00</td>\n</tr>\n</tbody></table>\n<p>实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p>\n<p> 计算夏令时请使用标准库提供的相关类，不要试图自己计算夏令时。</p>\n<h3 id=\"本地化\"><a href=\"#本地化\" class=\"headerlink\" title=\"本地化\"></a>本地化</h3><p>在计算机中，通常使用<code>Locale</code>表示一个国家或地区的日期、时间、数字、货币等格式。<code>Locale</code>由<code>语言_国家</code>的字母缩写构成，例如，<code>zh_CN</code>表示中文+中国，<code>en_US</code>表示英文+美国。语言使用小写，国家使用大写。</p>\n<p>对于日期来说，不同的Locale，例如，中国和美国的表示方式如下：</p>\n<ul>\n<li>zh_CN：2016-11-30</li>\n<li>en_US：11&#x2F;30&#x2F;2016</li>\n</ul>\n<p>计算机用<code>Locale</code>在日期、时间、货币和字符串之间进行转换。一个电商网站会根据用户所在的<code>Locale</code>对用户显示如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">中国用户</th>\n<th align=\"left\">美国用户</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">购买价格</td>\n<td align=\"left\">12000.00</td>\n<td align=\"left\">12,000.00</td>\n</tr>\n<tr>\n<td align=\"left\">购买日期</td>\n<td align=\"left\">2016-11-30</td>\n<td align=\"left\">11&#x2F;30&#x2F;2016</td>\n</tr>\n</tbody></table>\n<h1 id=\"Date和Calendar\"><a href=\"#Date和Calendar\" class=\"headerlink\" title=\"Date和Calendar\"></a>Date和Calendar</h1><p>在计算机中，应该如何表示日期和时间呢？</p>\n<p>我们经常看到的日期和时间表示方式如下：</p>\n<ul>\n<li>2019-11-20 0:15:00 GMT+00:00</li>\n<li>2019年11月20日8:15:00</li>\n<li>11&#x2F;19&#x2F;2019 19:15:00 America&#x2F;New_York</li>\n</ul>\n<p>如果直接以字符串的形式存储，那么不同的格式，不同的语言会让表示方式非常繁琐。</p>\n<p>在理解日期和时间的表示方式之前，我们先要理解数据的存储和展示。</p>\n<p>当我们定义一个整型变量并赋值时：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int n</span> = 123400;</span><br></pre></td></tr></table></figure>\n\n<p>编译器会把上述字符串（程序源码就是一个字符串）编译成字节码。在程序的运行期，变量<code>n</code>指向的内存实际上是一个4字节区域：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌──┬──┬──┬──┐</span><br><span class=\"line\">│00│01│e2│08│</span><br><span class=\"line\">└──┴──┴──┴──┘</span><br></pre></td></tr></table></figure>\n\n<p>注意到计算机内存除了二进制的<code>0</code>&#x2F;<code>1</code>外没有其他任何格式。上述十六机制是为了简化表示。</p>\n<p>当我们用<code>System.out.println(n)</code>打印这个整数的时候，实际上<code>println()</code>这个方法在内部把<code>int</code>类型转换成<code>String</code>类型，然后打印出字符串<code>123400</code>。</p>\n<p>类似的，我们也可以以十六进制的形式打印这个整数，或者，如果<code>n</code>表示一个价格，我们就以<code>$123,400.00</code>的形式来打印它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>可见，整数<code>123400</code>是数据的存储格式，它的存储格式非常简单。而我们打印的各种各样的字符串，则是数据的展示格式。展示格式有多种形式，但本质上它就是一个转换方法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String <span class=\"keyword\">to</span><span class=\"constructor\">Display(<span class=\"params\">int</span> <span class=\"params\">n</span>)</span> &#123;<span class=\"operator\"> ... </span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>理解了数据的存储和展示，我们回头看看以下几种日期和时间：</p>\n<ul>\n<li>2019-11-20 0:15:01 GMT+00:00</li>\n<li>2019年11月20日8:15:01</li>\n<li>11&#x2F;19&#x2F;2019 19:15:01 America&#x2F;New_York</li>\n</ul>\n<p>它们实际上是数据的展示格式，分别按英国时区、中国时区、纽约时区对同一个时刻进行展示。而这个“同一个时刻”在计算机中存储的本质上只是一个整数，我们称它为<code>Epoch Time</code>。</p>\n<p><code>Epoch Time</code>是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数，例如：</p>\n<p><code>1574208900</code>表示从从1970年1月1日零点GMT时区到该时刻一共经历了1574208900秒，换算成伦敦、北京和纽约时间分别是：</p>\n<figure class=\"highlight subunit\"><table><tr><td class=\"code\"><pre><span class=\"line\">1574208900 = 北京时间2019<span class=\"string\">-11</span><span class=\"string\">-20</span> 8:15:00</span><br><span class=\"line\">           = 伦敦时间2019<span class=\"string\">-11</span><span class=\"string\">-20</span> 0:15:00</span><br><span class=\"line\">           = 纽约时间2019<span class=\"string\">-11</span><span class=\"string\">-19</span> 19:15:00</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/9.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.assets/l.jpeg\" alt=\"localtime\"></p>\n<p>因此，在计算机中，只需要存储一个整数<code>1574208900</code>表示某一时刻。当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">String</span> <span class=\"title\">displayDateTime</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">String</span> timezone)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Epoch Time</code>又称为时间戳，在不同的编程语言中，会有几种存储方式：</p>\n<ul>\n<li>以秒为单位的整数：1574208900，缺点是精度只能到秒；</li>\n<li>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</li>\n<li>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</li>\n</ul>\n<p>它们之间转换非常简单。而在Java程序中，时间戳通常是用<code>long</code>表示的毫秒数，即：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">long t</span> = 1574208900123L;</span><br></pre></td></tr></table></figure>\n\n<p>转换成北京时间就是<code>2019-11-20T8:15:00.123</code>。要获取当前时间戳，可以使用<code>System.currentTimeMillis()</code>，这是Java程序获取时间戳最常用的方法。</p>\n<h3 id=\"标准库API\"><a href=\"#标准库API\" class=\"headerlink\" title=\"标准库API\"></a>标准库API</h3><p>我们再来看一下Java标准库提供的API。Java标准库有两套处理日期和时间的API：</p>\n<ul>\n<li>一套定义在<code>java.util</code>这个包里面，主要包括<code>Date</code>、<code>Calendar</code>和<code>TimeZone</code>这几个类；</li>\n<li>一套新的API是在Java 8引入的，定义在<code>java.time</code>这个包里面，主要包括<code>LocalDateTime</code>、<code>ZonedDateTime</code>、<code>ZoneId</code>等。</li>\n</ul>\n<p>为什么会有新旧两套API呢？因为历史遗留原因，旧的API存在很多问题，所以引入了新的API。</p>\n<p>那么我们能不能跳过旧的API直接用新的API呢？如果涉及到遗留代码就不行，因为很多遗留代码仍然使用旧的API，所以目前仍然需要对旧的API有一定了解，很多时候还需要在新旧两种对象之间进行转换。</p>\n<p>本节我们快速讲解旧API的常用类型和方法。</p>\n<h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date\"></a>Date</h3><p><code>java.util.Date</code>是用于表示一个日期和时间的对象，注意与<code>java.sql.Date</code>区分，后者用在数据库中。如果观察Date的源码，可以发现它实际上存储了一个long类型的以毫秒表示的时间戳：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">Date</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">Serializable, <span class=\"symbol\">Cloneable</span>, <span class=\"symbol\">Comparable</span></span>&lt;<span class=\"symbol\">Date</span>&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> transient long fastTime;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看Date的基本用法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意<code>getYear()</code>返回的年份必须加上<code>1900</code>，<code>getMonth()</code>返回的月份是<code>0</code><del><code>11</code>分别表示1</del>12月，所以要加1，而<code>getDate()</code>返回的日期范围是<code>1</code>~&#96;31&#96;，又不能加1。</p>\n<p>打印本地时区表示的日期和时间时，不同的计算机可能会有不同的结果。如果我们想要针对用户的偏好精确地控制日期和时间的格式，就可以使用<code>SimpleDateFormat</code>对一个<code>Date</code>进行转换。它用预定义的字符串表示格式化：</p>\n<ul>\n<li>yyyy：年</li>\n<li>MM：月</li>\n<li>dd: 日</li>\n<li>HH: 小时</li>\n<li>mm: 分钟</li>\n<li>ss: 秒</li>\n</ul>\n<p>我们来看如何以自定义的格式输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>Java的格式化预定义了许多不同的格式，我们以<code>MMM</code>和<code>E</code>为例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码在不同的语言环境会打印出类似<code>Sun Sep 15, 2019</code>这样的日期。可以从<a href=\"https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/text/SimpleDateFormat.html\">JDK文档</a>查看详细的格式说明。一般来说，字母越长，输出越长。以<code>M</code>为例，假设当前月份是9月：</p>\n<ul>\n<li><code>M</code>：输出<code>9</code></li>\n<li><code>MM</code>：输出<code>09</code></li>\n<li><code>MMM</code>：输出<code>Sep</code></li>\n<li><code>MMMM</code>：输出<code>September</code></li>\n</ul>\n<p><code>Date</code>对象有几个严重的问题：它不能转换时区，除了<code>toGMTString()</code>可以按<code>GMT+0:00</code>输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</p>\n<h3 id=\"Calendar\"><a href=\"#Calendar\" class=\"headerlink\" title=\"Calendar\"></a>Calendar</h3><p><code>Calendar</code>可以用于获取并设置年、月、日、时、分、秒，它和<code>Date</code>比，主要多了一个可以做简单的日期和时间运算的功能。</p>\n<p>我们来看<code>Calendar</code>的基本用法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到<code>Calendar</code>获取年月日这些信息变成了<code>get(int field)</code>，返回的年份不必转换，返回的月份仍然要加1，返回的星期要特别注意，<code>1</code>~&#96;7&#96;分别表示周日，周一，……，周六。</p>\n<p><code>Calendar</code>只有一种方式获取，即<code>Calendar.getInstance()</code>，而且一获取到就是当前时间。如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>利用<code>Calendar.getTime()</code>可以将一个<code>Calendar</code>对象转换成<code>Date</code>对象，然后就可以用<code>SimpleDateFormat</code>进行格式化了。</p>\n<h3 id=\"TimeZone\"><a href=\"#TimeZone\" class=\"headerlink\" title=\"TimeZone\"></a>TimeZone</h3><p><code>Calendar</code>和<code>Date</code>相比，它提供了时区转换的功能。时区用<code>TimeZone</code>对象表示：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>时区的唯一标识是以字符串表示的ID，我们获取指定<code>TimeZone</code>对象也是以这个ID为参数获取，<code>GMT+09:00</code>、<code>Asia/Shanghai</code>都是有效的时区ID。要列出系统支持的所有ID，请使用<code>TimeZone.getAvailableIDs()</code>。</p>\n<p>有了时区，我们就可以对指定时间进行转换。例如，下面的例子演示了如何将北京时间<code>2019-11-20 8:15:00</code>转换为纽约时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>可见，利用<code>Calendar</code>进行时区转换的步骤是：</p>\n<ol>\n<li>清除所有字段；</li>\n<li>设定指定时区；</li>\n<li>设定日期和时间；</li>\n<li>创建<code>SimpleDateFormat</code>并设定目标时区；</li>\n<li>格式化获取的<code>Date</code>对象（注意<code>Date</code>对象无时区信息，时区信息存储在<code>SimpleDateFormat</code>中）。</li>\n</ol>\n<p>因此，本质上时区转换只能通过<code>SimpleDateFormat</code>在显示的时候完成。</p>\n<p><code>Calendar</code>也可以对日期和时间进行简单的加减：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.text.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h1 id=\"LocalDateTime\"><a href=\"#LocalDateTime\" class=\"headerlink\" title=\"LocalDateTime\"></a>LocalDateTime</h1><p>从Java 8开始，<code>java.time</code>包提供了新的日期和时间API，主要涉及的类型有：</p>\n<ul>\n<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code>；</li>\n<li>带时区的日期和时间：<code>ZonedDateTime</code>；</li>\n<li>时刻：<code>Instant</code>；</li>\n<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code>；</li>\n<li>时间间隔：<code>Duration</code>。</li>\n</ul>\n<p>以及一套新的用于取代<code>SimpleDateFormat</code>的格式化类型<code>DateTimeFormatter</code>。</p>\n<p>和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。</p>\n<p>此外，新API修正了旧API不合理的常量设计：</p>\n<ul>\n<li>Month的范围用1~12表示1月到12月；</li>\n<li>Week的范围用1~7表示周一到周日。</li>\n</ul>\n<p>最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p>\n<h3 id=\"LocalDateTime-1\"><a href=\"#LocalDateTime-1\" class=\"headerlink\" title=\"LocalDateTime\"></a>LocalDateTime</h3><p>我们首先来看最常用的<code>LocalDateTime</code>，它表示一个本地日期和时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，<code>LocalDateTime</code>、<code>LocalDate</code>和<code>LocalTime</code>默认严格按照<a href=\"https://www.iso.org/iso-8601-date-and-time-format.html\">ISO 8601</a>规定的日期和时间格式进行打印。</p>\n<p>上述代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">LocalDateTime dt = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalDateTime</span>.</span></span>now<span class=\"literal\">()</span>; <span class=\"comment\">// 当前日期和时间</span></span><br><span class=\"line\">LocalDate d = dt.<span class=\"keyword\">to</span><span class=\"constructor\">LocalDate()</span>; <span class=\"comment\">// 转换到当前日期</span></span><br><span class=\"line\">LocalTime t = dt.<span class=\"keyword\">to</span><span class=\"constructor\">LocalTime()</span>; <span class=\"comment\">// 转换到当前时间</span></span><br></pre></td></tr></table></figure>\n\n<p>反过来，通过指定的日期和时间创建<code>LocalDateTime</code>可以通过<code>of()</code>方法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定日期和时间:</span></span><br><span class=\"line\">LocalDate d2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalDate</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 2019-11-30, 注意11=11月</span></span><br><span class=\"line\">LocalTime t2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalTime</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>); <span class=\"comment\">// 15:16:17</span></span><br><span class=\"line\">LocalDateTime dt2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalDateTime</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"number\">2019</span>, <span class=\"number\">11</span>, <span class=\"number\">30</span>, <span class=\"number\">15</span>, <span class=\"number\">16</span>, <span class=\"number\">17</span>);</span><br><span class=\"line\">LocalDateTime dt3 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalDateTime</span>.</span></span><span class=\"keyword\">of</span>(d2, t2);</span><br></pre></td></tr></table></figure>\n\n<p>因为严格按照ISO 8601的格式，因此，将字符串转换为<code>LocalDateTime</code>就可以传入标准格式：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">LocalDateTime dt = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalDateTime</span>.</span></span>parse(<span class=\"string\">&quot;2019-11-19T15:16:17&quot;</span>);</span><br><span class=\"line\">LocalDate d = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalDate</span>.</span></span>parse(<span class=\"string\">&quot;2019-11-19&quot;</span>);</span><br><span class=\"line\">LocalTime t = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalTime</span>.</span></span>parse(<span class=\"string\">&quot;15:16:17&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意ISO 8601规定的日期和时间分隔符是<code>T</code>。标准格式如下：</p>\n<ul>\n<li>日期：yyyy-MM-dd</li>\n<li>时间：HH:mm:ss</li>\n<li>带毫秒的时间：HH:mm:ss.SSS</li>\n<li>日期和时间：yyyy-MM-dd’T’HH:mm:ss</li>\n<li>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</li>\n</ul>\n<h3 id=\"DateTimeFormatter\"><a href=\"#DateTimeFormatter\" class=\"headerlink\" title=\"DateTimeFormatter\"></a>DateTimeFormatter</h3><p>如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成<code>LocalDateTime</code>，可以使用新的<code>DateTimeFormatter</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.format.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>LocalDateTime</code>提供了对日期和时间进行加减的非常简单的链式调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到月份加减会自动调整日期，例如从<code>2019-10-31</code>减去1个月得到的结果是<code>2019-09-30</code>，因为9月没有31日。</p>\n<p>对日期和时间进行调整则使用<code>withXxx()</code>方法，例如：<code>withHour(15)</code>会把<code>10:11:12</code>变为<code>15:11:12</code>：</p>\n<ul>\n<li>调整年：withYear()</li>\n<li>调整月：withMonth()</li>\n<li>调整日：withDayOfMonth()</li>\n<li>调整时：withHour()</li>\n<li>调整分：withMinute()</li>\n<li>调整秒：withSecond()</li>\n</ul>\n<p>示例代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>同样注意到调整月份时，会相应地调整日期，即把<code>2019-10-31</code>的月份调整为<code>9</code>时，日期也自动变为<code>30</code>。</p>\n<p>实际上，<code>LocalDateTime</code>还有一个通用的<code>with()</code>方法允许我们做更复杂的运算。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.temporal.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>对于计算某个月第1个周日这样的问题，新的API可以轻松完成。</p>\n<p>要判断两个<code>LocalDateTime</code>的先后，可以使用<code>isBefore()</code>、<code>isAfter()</code>方法，对于<code>LocalDate</code>和<code>LocalTime</code>类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到<code>LocalDateTime</code>无法与时间戳进行转换，因为<code>LocalDateTime</code>没有时区，无法确定某一时刻。后面我们要介绍的<code>ZonedDateTime</code>相当于<code>LocalDateTime</code>加时区的组合，它具有时区，可以与<code>long</code>表示的时间戳进行转换。</p>\n<h3 id=\"Duration和Period\"><a href=\"#Duration和Period\" class=\"headerlink\" title=\"Duration和Period\"></a>Duration和Period</h3><p><code>Duration</code>表示两个时刻之间的时间间隔。另一个类似的<code>Period</code>表示两个日期之间的天数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到两个<code>LocalDateTime</code>之间的差值使用<code>Duration</code>表示，类似<code>PT1235H10M30S</code>，表示1235小时10分钟30秒。而两个<code>LocalDate</code>之间的差值用<code>Period</code>表示，类似<code>P1M21D</code>，表示1个月21天。</p>\n<p><code>Duration</code>和<code>Period</code>的表示方法也符合ISO 8601的格式，它以<code>P...T...</code>的形式表示，<code>P...T</code>之间表示日期间隔，<code>T</code>后面表示时间间隔。如果是<code>PT...</code>的格式表示仅有时间间隔。利用<code>ofXxx()</code>或者<code>parse()</code>方法也可以直接创建<code>Duration</code>：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Duration</span> d<span class=\"number\">1</span> = Duration.ofHours(<span class=\"number\">10</span>); // <span class=\"number\">10</span> hours</span><br><span class=\"line\"><span class=\"attribute\">Duration</span> d<span class=\"number\">2</span> = Duration.parse(<span class=\"string\">&quot;P1DT2H3M&quot;</span>); // <span class=\"number\">1</span> day, <span class=\"number\">2</span> hours, <span class=\"number\">3</span> minutes</span><br></pre></td></tr></table></figure>\n\n<p>有的童鞋可能发现Java 8引入的<code>java.time</code>API。怎么和一个开源的<a href=\"https://www.joda.org/\">Joda Time</a>很像？难道JDK也开始抄袭开源了？其实正是因为开源的Joda Time设计很好，应用广泛，所以JDK团队邀请Joda Time的作者Stephen Colebourne共同设计了<code>java.time</code>API。</p>\n<h1 id=\"ZonedDateTime\"><a href=\"#ZonedDateTime\" class=\"headerlink\" title=\"ZonedDateTime\"></a>ZonedDateTime</h1><p><code>LocalDateTime</code>总是表示本地日期和时间，要表示一个带时区的日期和时间，我们就需要<code>ZonedDateTime</code>。</p>\n<p>可以简单地把<code>ZonedDateTime</code>理解成<code>LocalDateTime</code>加<code>ZoneId</code>。<code>ZoneId</code>是<code>java.time</code>引入的新的时区类，注意和旧的<code>java.util.TimeZone</code>区别。</p>\n<p>要创建一个<code>ZonedDateTime</code>对象，有以下几种方法，一种是通过<code>now()</code>方法返回当前时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>观察打印的两个<code>ZonedDateTime</code>，发现它们时区不同，但表示的时间都是同一时刻（毫秒数不同是执行语句时的时间差）：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span>T<span class=\"number\">20</span>:<span class=\"number\">58</span>:<span class=\"number\">18</span>.<span class=\"number\">786182</span>+<span class=\"number\">08</span>:<span class=\"number\">00</span>[Asia/Shanghai]</span><br><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span>T<span class=\"number\">08</span>:<span class=\"number\">58</span>:<span class=\"number\">18</span>.<span class=\"number\">788860</span>-<span class=\"number\">04</span>:<span class=\"number\">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>\n\n<p>另一种方式是通过给一个<code>LocalDateTime</code>附加一个<code>ZoneId</code>，就可以变成<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>以这种方式创建的<code>ZonedDateTime</code>，它的日期和时间与<code>LocalDateTime</code>相同，但附加的时区不同，因此是两个不同的时刻：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span>T<span class=\"number\">15</span>:<span class=\"number\">16</span>:<span class=\"number\">17</span>+<span class=\"number\">08</span>:<span class=\"number\">00</span>[Asia/Shanghai]</span><br><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span>T<span class=\"number\">15</span>:<span class=\"number\">16</span>:<span class=\"number\">17</span>-<span class=\"number\">04</span>:<span class=\"number\">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"时区转换\"><a href=\"#时区转换\" class=\"headerlink\" title=\"时区转换\"></a>时区转换</h3><p>要转换时区，首先我们需要有一个<code>ZonedDateTime</code>对象，然后，通过<code>withZoneSameInstant()</code>将关联时区转换到另一个时区，转换后日期和时间都会相应调整。</p>\n<p>下面的代码演示了如何将北京时间转换为纽约时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>要特别注意，时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。这是北京时间9月15日的转换结果：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span>T<span class=\"number\">21</span>:<span class=\"number\">05</span>:<span class=\"number\">50</span>.<span class=\"number\">187697</span>+<span class=\"number\">08</span>:<span class=\"number\">00</span>[Asia/Shanghai]</span><br><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span>T<span class=\"number\">09</span>:<span class=\"number\">05</span>:<span class=\"number\">50</span>.<span class=\"number\">187697</span>-<span class=\"number\">04</span>:<span class=\"number\">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>\n\n<p>这是北京时间11月15日的转换结果：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">11</span>-<span class=\"number\">15</span>T<span class=\"number\">21</span>:<span class=\"number\">05</span>:<span class=\"number\">50</span>.<span class=\"number\">187697</span>+<span class=\"number\">08</span>:<span class=\"number\">00</span>[Asia/Shanghai]</span><br><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">11</span>-<span class=\"number\">15</span>T<span class=\"number\">08</span>:<span class=\"number\">05</span>:<span class=\"number\">50</span>.<span class=\"number\">187697</span>-<span class=\"number\">05</span>:<span class=\"number\">00</span>[America/New_York]</span><br></pre></td></tr></table></figure>\n\n<p>两次转换后的纽约时间有1小时的夏令时时差。</p>\n<p> 涉及到时区时，千万不要自己计算时差，否则难以正确处理夏令时。</p>\n<p>有了<code>ZonedDateTime</code>，将其转换为本地时间就非常简单：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">ZonedDateTime <span class=\"attr\">zdt</span> = ...</span><br><span class=\"line\">LocalDateTime <span class=\"attr\">ldt</span> = zdt.toLocalDateTime();</span><br></pre></td></tr></table></figure>\n\n<p>转换为<code>LocalDateTime</code>时，直接丢弃了时区信息。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>某航线从北京飞到纽约需要13小时20分钟，请根据北京起飞日期和时间计算到达纽约的当地日期和时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>提示：<code>ZonedDateTime</code>仍然提供了<code>plusDays()</code>等加减操作。</p>\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/90.%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4.1255943660631584/40.ZonedDateTime.1303904694304801/datetime-flight.zip?utm_source=blog_lxf\">flight-time练习</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<h1 id=\"DateTimeFormatter-1\"><a href=\"#DateTimeFormatter-1\" class=\"headerlink\" title=\"DateTimeFormatter\"></a>DateTimeFormatter</h1><p>使用旧的<code>Date</code>对象时，我们用<code>SimpleDateFormat</code>进行格式化显示。使用新的<code>LocalDateTime</code>或<code>ZonedLocalDateTime</code>时，我们要进行格式化显示，就要使用<code>DateTimeFormatter</code>。</p>\n<p>和<code>SimpleDateFormat</code>不同的是，<code>DateTimeFormatter</code>不但是不变对象，它还是线程安全的。线程的概念我们会在后面涉及到。现在我们只需要记住：因为<code>SimpleDateFormat</code>不是线程安全的，使用的时候，只能在方法内部创建新的局部变量。而<code>DateTimeFormatter</code>可以只创建一个实例，到处引用。</p>\n<p>创建<code>DateTimeFormatter</code>时，我们仍然通过传入格式化字符串实现：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DateTimeFormatter formatter = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DateTimeFormatter</span>.</span></span><span class=\"keyword\">of</span><span class=\"constructor\">Pattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>格式化字符串的使用方式与<code>SimpleDateFormat</code>完全一致。</p>\n<p>另一种创建<code>DateTimeFormatter</code>的方法是，传入格式化字符串时，同时指定<code>Locale</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DateTimeFormatter formatter = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DateTimeFormatter</span>.</span></span><span class=\"keyword\">of</span><span class=\"constructor\">Pattern(<span class=\"string\">&quot;E, yyyy-MMMM-dd HH:mm&quot;</span>, Locale.US)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式可以按照<code>Locale</code>默认习惯格式化。我们来看实际效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.format.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Locale;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>在格式化字符串中，如果需要输出固定字符，可以用<code>&#39;xxx&#39;</code>表示。</p>\n<p>运行上述代码，分别以默认方式、中国地区和美国地区对当前时间进行显示，结果如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span>T<span class=\"number\">23</span>:<span class=\"number\">16</span> GMT+<span class=\"number\">08</span>:<span class=\"number\">00</span></span><br><span class=\"line\"><span class=\"attribute\">2019</span> <span class=\"number\">9</span>月 <span class=\"number\">15</span> 周日 <span class=\"number\">23</span>:<span class=\"number\">16</span></span><br><span class=\"line\"><span class=\"attribute\">Sun</span>, September/<span class=\"number\">15</span>/<span class=\"number\">2019</span> <span class=\"number\">23</span>:<span class=\"number\">16</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们直接调用<code>System.out.println()</code>对一个<code>ZonedDateTime</code>或者<code>LocalDateTime</code>实例进行打印的时候，实际上，调用的是它们的<code>toString()</code>方法，默认的<code>toString()</code>方法显示的字符串就是按照<code>ISO 8601</code>格式显示的，我们可以通过<code>DateTimeFormatter</code>预定义的几个静态变量来引用：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">var ldt = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalDateTime</span>.</span></span>now<span class=\"literal\">()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DateTimeFormatter</span>.</span><span class=\"module\"><span class=\"identifier\">ISO_DATE</span>.</span></span>format(ldt));</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DateTimeFormatter</span>.</span><span class=\"module\"><span class=\"identifier\">ISO_DATE_TIME</span>.</span></span>format(ldt));</span><br></pre></td></tr></table></figure>\n\n<p>得到的输出和<code>toString()</code>类似：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"attribute\">2019</span>-<span class=\"number\">09</span>-<span class=\"number\">15</span>T<span class=\"number\">23</span>:<span class=\"number\">16</span>:<span class=\"number\">51</span>.<span class=\"number\">56217</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Instant\"><a href=\"#Instant\" class=\"headerlink\" title=\"Instant\"></a>Instant</h1><p>我们已经讲过，计算机存储的当前时间，本质上只是一个不断递增的整数。Java提供的<code>System.currentTimeMillis()</code>返回的就是以毫秒表示的当前时间戳。</p>\n<p>这个当前时间戳在<code>java.time</code>中以<code>Instant</code>类型表示，我们用<code>Instant.now()</code>获取当前时间戳，效果和<code>System.currentTimeMillis()</code>类似：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>打印的结果类似：</p>\n<figure class=\"highlight dns\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1568568760</span></span><br><span class=\"line\"><span class=\"number\">1568568760316</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，<code>Instant</code>内部只有两个核心字段：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Instant</span> <span class=\"keyword\">implements</span> ... </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> seconds;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> nanos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个是以秒为单位的时间戳，一个是更精确的纳秒精度。它和<code>System.currentTimeMillis()</code>返回的<code>long</code>相比，只是多了更高精度的纳秒。</p>\n<p>既然<code>Instant</code>就是时间戳，那么，给它附加上一个时区，就可以创建出<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 以指定时间戳创建Instant:</span></span><br><span class=\"line\">Instant ins = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Instant</span>.</span></span><span class=\"keyword\">of</span><span class=\"constructor\">EpochSecond(1568568760)</span>;</span><br><span class=\"line\">ZonedDateTime zdt = ins.at<span class=\"constructor\">Zone(ZoneId.<span class=\"params\">systemDefault</span>()</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(zdt); <span class=\"comment\">// 2019-09-16T01:32:40+08:00[Asia/Shanghai]</span></span><br></pre></td></tr></table></figure>\n\n<p>可见，对于某一个时间戳，给它关联上指定的<code>ZoneId</code>，就得到了<code>ZonedDateTime</code>，继而可以获得了对应时区的<code>LocalDateTime</code>。</p>\n<p>所以，<code>LocalDateTime</code>，<code>ZoneId</code>，<code>Instant</code>，<code>ZonedDateTime</code>和<code>long</code>都可以互相转换：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────┐</span><br><span class=\"line\">│LocalDateTime│────┐</span><br><span class=\"line\">└─────────────┘    │    ┌─────────────┐</span><br><span class=\"line\">                   ├───&gt;│ZonedDateTime│</span><br><span class=\"line\">┌─────────────┐    │    └─────────────┘</span><br><span class=\"line\">│   ZoneId    │────┘           ▲</span><br><span class=\"line\">└─────────────┘      ┌─────────┴─────────┐</span><br><span class=\"line\">                     │                   │</span><br><span class=\"line\">                     ▼                   ▼</span><br><span class=\"line\">              ┌─────────────┐     ┌─────────────┐</span><br><span class=\"line\">              │   Instant   │&lt;───&gt;│    long     │</span><br><span class=\"line\">              └─────────────┘     └─────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>转换的时候，只需要留意<code>long</code>类型以毫秒还是秒为单位即可。</p>\n<h1 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h1><p>由于Java提供了新旧两套日期和时间的API，除非涉及到遗留代码，否则我们应该坚持使用新的API。</p>\n<p>如果需要与遗留代码打交道，如何在新旧API之间互相转换呢？</p>\n<h3 id=\"旧API转新API\"><a href=\"#旧API转新API\" class=\"headerlink\" title=\"旧API转新API\"></a>旧API转新API</h3><p>如果要把旧式的<code>Date</code>或<code>Calendar</code>转换为新API对象，可以通过<code>toInstant()</code>方法转换为<code>Instant</code>对象，再继续转换为<code>ZonedDateTime</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Date -&gt; Instant:</span></span><br><span class=\"line\">Instant ins1 = <span class=\"keyword\">new</span> <span class=\"constructor\">Date()</span>.<span class=\"keyword\">to</span><span class=\"constructor\">Instant()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Calendar -&gt; Instant -&gt; ZonedDateTime:</span></span><br><span class=\"line\">Calendar calendar = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Calendar</span>.</span></span>get<span class=\"constructor\">Instance()</span>;</span><br><span class=\"line\">Instant ins2 = calendar.<span class=\"keyword\">to</span><span class=\"constructor\">Instant()</span>;</span><br><span class=\"line\">ZonedDateTime zdt = ins2.at<span class=\"constructor\">Zone(<span class=\"params\">calendar</span>.<span class=\"params\">getTimeZone</span>()</span>.<span class=\"keyword\">to</span><span class=\"constructor\">ZoneId()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>从上面的代码还可以看到，旧的<code>TimeZone</code>提供了一个<code>toZoneId()</code>，可以把自己变成新的<code>ZoneId</code>。</p>\n<h3 id=\"新API转旧API\"><a href=\"#新API转旧API\" class=\"headerlink\" title=\"新API转旧API\"></a>新API转旧API</h3><p>如果要把新的<code>ZonedDateTime</code>转换为旧的API对象，只能借助<code>long</code>型时间戳做一个“中转”：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ZonedDateTime -&gt; long:</span></span><br><span class=\"line\">ZonedDateTime zdt = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ZonedDateTime</span>.</span></span>now<span class=\"literal\">()</span>;</span><br><span class=\"line\">long ts = zdt.<span class=\"keyword\">to</span><span class=\"constructor\">EpochSecond()</span><span class=\"operator\"> * </span><span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// long -&gt; Date:</span></span><br><span class=\"line\">Date date = <span class=\"keyword\">new</span> <span class=\"constructor\">Date(<span class=\"params\">ts</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// long -&gt; Calendar:</span></span><br><span class=\"line\">Calendar calendar = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Calendar</span>.</span></span>get<span class=\"constructor\">Instance()</span>;</span><br><span class=\"line\">calendar.clear<span class=\"literal\">()</span>;</span><br><span class=\"line\">calendar.set<span class=\"constructor\">TimeZone(TimeZone.<span class=\"params\">getTimeZone</span>(<span class=\"params\">zdt</span>.<span class=\"params\">getZone</span>()</span>.get<span class=\"constructor\">Id()</span>));</span><br><span class=\"line\">calendar.set<span class=\"constructor\">TimeInMillis(<span class=\"params\">zdt</span>.<span class=\"params\">toEpochSecond</span>()</span><span class=\"operator\"> * </span><span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>从上面的代码还可以看到，新的<code>ZoneId</code>转换为旧的<code>TimeZone</code>，需要借助<code>ZoneId.getId()</code>返回的<code>String</code>完成。</p>\n<h3 id=\"在数据库中存储日期和时间\"><a href=\"#在数据库中存储日期和时间\" class=\"headerlink\" title=\"在数据库中存储日期和时间\"></a>在数据库中存储日期和时间</h3><p>除了旧式的<code>java.util.Date</code>，我们还可以找到另一个<code>java.sql.Date</code>，它继承自<code>java.util.Date</code>，但会自动忽略所有时间相关信息。这个奇葩的设计原因要追溯到数据库的日期与时间类型。</p>\n<p>在数据库中，也存在几种日期和时间类型：</p>\n<ul>\n<li><code>DATETIME</code>：表示日期和时间；</li>\n<li><code>DATE</code>：仅表示日期；</li>\n<li><code>TIME</code>：仅表示时间；</li>\n<li><code>TIMESTAMP</code>：和<code>DATETIME</code>类似，但是数据库会在创建或者更新记录的时候同时修改<code>TIMESTAMP</code>。</li>\n</ul>\n<p>在使用Java程序操作数据库时，我们需要把数据库类型与Java类型映射起来。下表是数据库类型与Java新旧API的映射关系：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">数据库</th>\n<th align=\"left\">对应Java类（旧）</th>\n<th align=\"left\">对应Java类（新）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DATETIME</td>\n<td align=\"left\">java.util.Date</td>\n<td align=\"left\">LocalDateTime</td>\n</tr>\n<tr>\n<td align=\"left\">DATE</td>\n<td align=\"left\">java.sql.Date</td>\n<td align=\"left\">LocalDate</td>\n</tr>\n<tr>\n<td align=\"left\">TIME</td>\n<td align=\"left\">java.sql.Time</td>\n<td align=\"left\">LocalTime</td>\n</tr>\n<tr>\n<td align=\"left\">TIMESTAMP</td>\n<td align=\"left\">java.sql.Timestamp</td>\n<td align=\"left\">LocalDateTime</td>\n</tr>\n</tbody></table>\n<p>实际上，在数据库中，我们需要存储的最常用的是时刻（<code>Instant</code>），因为有了时刻信息，就可以根据用户自己选择的时区，显示出正确的本地时间。所以，最好的方法是直接用长整数<code>long</code>表示，在数据库中存储为<code>BIGINT</code>类型。</p>\n<p>通过存储一个<code>long</code>型时间戳，我们可以编写一个<code>timestampToString()</code>的方法，非常简单地为不同用户以不同的偏好来显示不同的本地时间：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.format.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Locale;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>对上述方法进行调用，结果如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">2019</span>年<span class=\"number\">11</span>月<span class=\"number\">20</span>日 上午<span class=\"number\">8</span>:<span class=\"number\">15</span></span><br><span class=\"line\"><span class=\"attribute\">Nov</span> <span class=\"number\">19</span>, <span class=\"number\">2019</span>, <span class=\"number\">7</span>:<span class=\"number\">15</span> PM</span><br></pre></td></tr></table></figure>\n","categories":["Java","1.Java快速入门","09.日期和时间"],"tags":["写作"]},{"title":"3.计算机网络","url":"/2022/02/04/4-Java_2.%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80_3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"<h1 id=\"HTTP-x2F-HTTPS-协议\"><a href=\"#HTTP-x2F-HTTPS-协议\" class=\"headerlink\" title=\"HTTP&#x2F;HTTPS. 协议\"></a>HTTP&#x2F;HTTPS. 协议</h1><h1 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h1><h1 id=\"UDP-x2F-TCP协议\"><a href=\"#UDP-x2F-TCP协议\" class=\"headerlink\" title=\"UDP&#x2F;TCP协议\"></a>UDP&#x2F;TCP协议</h1><h1 id=\"网络安全\"><a href=\"#网络安全\" class=\"headerlink\" title=\"网络安全\"></a>网络安全</h1><h1 id=\"域名解析\"><a href=\"#域名解析\" class=\"headerlink\" title=\"域名解析\"></a>域名解析</h1>","categories":["Java","2.理论基础","3.计算机网络"],"tags":["写作"]},{"title":"7.集合","url":"/2022/02/04/4-Java_1.Java%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8_7.%E9%9B%86%E5%90%88/","content":"<h1 id=\"Java集合简介\"><a href=\"#Java集合简介\" class=\"headerlink\" title=\"Java集合简介\"></a>Java集合简介</h1><p>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。例如，5只小兔构成的集合：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\"></span><br><span class=\"line\">│   (\\_(\\     (\\_/)     (\\_/)     (\\_/)      (\\(\\   │</span><br><span class=\"line\">    ( -.-)    (•.•)     (&gt;.&lt;)     (^.^)     (=&#x27;.&#x27;)</span><br><span class=\"line\">│  C(&quot;)_(&quot;)  (&quot;)_(&quot;)   (&quot;)_(&quot;)   (&quot;)_(&quot;)   O(_&quot;)&quot;)  │</span><br><span class=\"line\"></span><br><span class=\"line\">└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>在数学中，我们经常遇到集合的概念。例如：</p>\n<ul>\n<li>有限集合：<ul>\n<li>一个班所有的同学构成的集合；</li>\n<li>一个网站所有的商品构成的集合；</li>\n<li>…</li>\n</ul>\n</li>\n<li>无限集合：<ul>\n<li>全体自然数集合：1，2，3，……</li>\n<li>有理数集合；</li>\n<li>实数集合；</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<p>为什么要在计算机中引入集合呢？这是为了便于处理一组类似的数据，例如：</p>\n<ul>\n<li>计算所有同学的总成绩和平均成绩；</li>\n<li>列举所有的商品名称和价格；</li>\n<li>……</li>\n</ul>\n<p>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。很显然，Java的数组可以看作是一种集合：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span>[] ss = <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>[<span class=\"number\">10</span>]; <span class=\"comment\">// 可以持有10个String对象</span></span><br><span class=\"line\">ss[<span class=\"number\">0</span>] = <span class=\"string\">&quot;Hello&quot;</span>; <span class=\"comment\">// 可以放入String对象</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> first = ss[<span class=\"number\">0</span>]; <span class=\"comment\">// 可以获取String对象</span></span><br></pre></td></tr></table></figure>\n\n<p>既然Java提供了数组这种数据类型，可以充当集合，那么，我们为什么还需要其他集合类？这是因为数组有如下限制：</p>\n<ul>\n<li>数组初始化后大小不可变；</li>\n<li>数组只能按索引顺序存取。</li>\n</ul>\n<p>因此，我们需要各种不同类型的集合类来处理不同的数据，例如：</p>\n<ul>\n<li>可变大小的顺序链表；</li>\n<li>保证无重复元素的集合；</li>\n<li>…</li>\n</ul>\n<h3 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h3><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。Java的<code>java.util</code>包主要提供了以下三种类型的集合：</p>\n<ul>\n<li><code>List</code>：一种有序列表的集合，例如，按索引排列的<code>Student</code>的<code>List</code>；</li>\n<li><code>Set</code>：一种保证没有重复元素的集合，例如，所有无重复名称的<code>Student</code>的<code>Set</code>；</li>\n<li><code>Map</code>：一种通过键值（key-value）查找的映射表集合，例如，根据<code>Student</code>的<code>name</code>查找对应<code>Student</code>的<code>Map</code>。</li>\n</ul>\n<p>Java集合的设计有几个特点：一是实现了接口和实现类相分离，例如，有序表的接口是<code>List</code>，具体的实现类有<code>ArrayList</code>，<code>LinkedList</code>等，二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;<span class=\"keyword\">String</span>&gt; list = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>&lt;&gt;(); <span class=\"comment\">// 只能放入String类型</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>\n<p>由于Java的集合设计非常久远，中间经历过大规模改进，我们要注意到有一小部分集合类是遗留类，不应该继续使用：</p>\n<ul>\n<li><code>Hashtable</code>：一种线程安全的<code>Map</code>实现；</li>\n<li><code>Vector</code>：一种线程安全的<code>List</code>实现；</li>\n<li><code>Stack</code>：基于<code>Vector</code>实现的<code>LIFO</code>的栈。</li>\n</ul>\n<p>还有一小部分接口是遗留接口，也不应该继续使用：</p>\n<ul>\n<li><code>Enumeration&lt;E&gt;</code>：已被<code>Iterator&lt;E&gt;</code>取代。</li>\n</ul>\n<h1 id=\"使用List\"><a href=\"#使用List\" class=\"headerlink\" title=\"使用List\"></a>使用List</h1><p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p>\n<p><code>List</code>的行为和数组几乎完全相同：<code>List</code>内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从<code>0</code>开始。</p>\n<p>数组和<code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组<code>&#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;&#125;</code>中删除索引为<code>2</code>的元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│ A │ B │ C │ D │ E │   │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┘</span><br><span class=\"line\">              │   │</span><br><span class=\"line\">          ┌───┘   │</span><br><span class=\"line\">          │   ┌───┘</span><br><span class=\"line\">          │   │</span><br><span class=\"line\">          ▼   ▼</span><br><span class=\"line\">┌───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│ A │ B │ D │ E │   │   │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>这个“删除”操作实际上是把<code>&#39;C&#39;</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</p>\n<p>因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是<code>ArrayList</code>。实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如，一个<code>ArrayList</code>拥有5个元素，实际数组大小为<code>6</code>（即有一个空位）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">size=5</span><br><span class=\"line\">┌───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│ A │ B │ C │ D │ E │   │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">size=5</span><br><span class=\"line\">┌───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│ A │ B │   │ C │ D │ E │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加<code>1</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">size=6</span><br><span class=\"line\">┌───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│ A │ B │ F │ C │ D │ E │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">size=6</span><br><span class=\"line\">┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│ A │ B │ F │ C │ D │ E │   │   │   │   │   │   │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加<code>1</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">size=7</span><br><span class=\"line\">┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">│ A │ B │ F │ C │ D │ E │ G │   │   │   │   │   │</span><br><span class=\"line\">└───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p>\n<p>我们考察<code>List&lt;E&gt;</code>接口，可以看到几个主要的接口方法：</p>\n<ul>\n<li>在末尾添加一个元素：<code>boolean add(E e)</code></li>\n<li>在指定索引添加一个元素：<code>boolean add(int index, E e)</code></li>\n<li>删除指定索引的元素：<code>E remove(int index)</code></li>\n<li>删除某个元素：<code>boolean remove(Object e)</code></li>\n<li>获取指定索引的元素：<code>E get(int index)</code></li>\n<li>获取链表大小（包含元素的个数）：<code>int size()</code></li>\n</ul>\n<p>但是，实现<code>List</code>接口并非只能通过数组（即<code>ArrayList</code>的实现方式）来实现，另一种<code>LinkedList</code>通过“链表”也实现了List接口。在<code>LinkedList</code>中，它的内部每个元素都指向下一个元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">        ┌───┬───┐   ┌───┬───┐   ┌───┬───┐   ┌───┬───┐</span><br><span class=\"line\">HEAD ──&gt;│ A │ ●─┼──&gt;│ B │ ●─┼──&gt;│ C │ ●─┼──&gt;│ D │   │</span><br><span class=\"line\">        └───┴───┘   └───┴───┘   └───┴───┘   └───┴───┘</span><br></pre></td></tr></table></figure>\n\n<p>我们来比较一下<code>ArrayList</code>和<code>LinkedList</code>：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">ArrayList</th>\n<th align=\"left\">LinkedList</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">获取指定元素</td>\n<td align=\"left\">速度很快</td>\n<td align=\"left\">需要从头开始查找元素</td>\n</tr>\n<tr>\n<td align=\"left\">添加元素到末尾</td>\n<td align=\"left\">速度很快</td>\n<td align=\"left\">速度很快</td>\n</tr>\n<tr>\n<td align=\"left\">在指定位置添加&#x2F;删除</td>\n<td align=\"left\">需要移动元素</td>\n<td align=\"left\">不需要移动元素</td>\n</tr>\n<tr>\n<td align=\"left\">内存占用</td>\n<td align=\"left\">少</td>\n<td align=\"left\">较大</td>\n</tr>\n</tbody></table>\n<p>通常情况下，我们总是优先使用<code>ArrayList</code>。</p>\n<h3 id=\"List的特点\"><a href=\"#List的特点\" class=\"headerlink\" title=\"List的特点\"></a>List的特点</h3><p>使用<code>List</code>时，我们要关注<code>List</code>接口的规范。<code>List</code>接口允许我们添加重复的元素，即<code>List</code>内部的元素可以重复：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>List</code>还允许添加<code>null</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"创建List\"><a href=\"#创建List\" class=\"headerlink\" title=\"创建List\"></a>创建List</h3><p>除了使用<code>ArrayList</code>和<code>LinkedList</code>，我们还可以通过<code>List</code>接口提供的<code>of()</code>方法，根据给定元素快速创建<code>List</code>：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">List</span>&lt;Integer&gt; list = List.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure>\n\n<p>但是<code>List.of()</code>方法不接受<code>null</code>值，如果传入<code>null</code>，会抛出<code>NullPointerException</code>异常。</p>\n<h3 id=\"遍历List\"><a href=\"#遍历List\" class=\"headerlink\" title=\"遍历List\"></a>遍历List</h3><p>和数组类型，我们要遍历一个<code>List</code>，完全可以用<code>for</code>循环根据索引配合<code>get(int)</code>方法遍历：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>但这种方式并不推荐，一是代码复杂，二是因为<code>get(int)</code>方法只有<code>ArrayList</code>的实现是高效的，换成<code>LinkedList</code>后，索引越大，访问速度越慢。</p>\n<p>所以我们要始终坚持使用迭代器<code>Iterator</code>来访问<code>List</code>。<code>Iterator</code>本身也是一个对象，但它是由<code>List</code>的实例调用<code>iterator()</code>方法的时候创建的。<code>Iterator</code>对象知道如何遍历一个<code>List</code>，并且不同的<code>List</code>类型，返回的<code>Iterator</code>对象实现也是不同的，但总是具有最高的访问效率。</p>\n<p><code>Iterator</code>对象有两个方法：<code>boolean hasNext()</code>判断是否有下一个元素，<code>E next()</code>返回下一个元素。因此，使用<code>Iterator</code>遍历<code>List</code>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Iterator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>有童鞋可能觉得使用<code>Iterator</code>访问<code>List</code>的代码比使用索引更复杂。但是，要记住，通过<code>Iterator</code>遍历<code>List</code>永远是最高效的方式。并且，由于<code>Iterator</code>遍历是如此常用，所以，Java的<code>for each</code>循环本身就可以帮我们使用<code>Iterator</code>遍历。把上面的代码再改写如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码就是我们编写遍历<code>List</code>的常见代码。</p>\n<p>实际上，只要实现了<code>Iterable</code>接口的集合类都可以直接用<code>for each</code>循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把<code>for each</code>循环变成<code>Iterator</code>的调用，原因就在于<code>Iterable</code>接口定义了一个<code>Iterator&lt;E&gt; iterator()</code>方法，强迫集合类必须返回一个<code>Iterator</code>实例。</p>\n<h3 id=\"List和Array转换\"><a href=\"#List和Array转换\" class=\"headerlink\" title=\"List和Array转换\"></a>List和Array转换</h3><p>把<code>List</code>变为<code>Array</code>有三种方法，第一种是调用<code>toArray()</code>方法直接返回一个<code>Object[]</code>数组：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这种方法会丢失类型信息，所以实际应用很少。</p>\n<p>第二种方式是给<code>toArray(T[])</code>传入一个类型相同的<code>Array</code>，<code>List</code>内部自动把元素复制到传入的<code>Array</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到这个<code>toArray(T[])</code>方法的泛型参数<code>&lt;T&gt;</code>并不是<code>List</code>接口定义的泛型参数<code>&lt;E&gt;</code>，所以，我们实际上可以传入其他类型的数组，例如我们传入<code>Number</code>类型的数组，返回的仍然是<code>Number</code>类型：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>但是，如果我们传入类型不匹配的数组，例如，<code>String[]</code>类型的数组，由于<code>List</code>的元素是<code>Integer</code>，所以无法放入<code>String</code>数组，这个方法会抛出<code>ArrayStoreException</code>。</p>\n<p>如果我们传入的数组大小和<code>List</code>实际的元素个数不一致怎么办？根据<a href=\"https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/util/List.html#toArray(T[])\">List接口</a>的文档，我们可以知道：</p>\n<p>如果传入的数组不够大，那么<code>List</code>内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比<code>List</code>元素还要多，那么填充完元素后，剩下的数组元素一律填充<code>null</code>。</p>\n<p>实际上，最常用的是传入一个“恰好”大小的数组：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer[]<span class=\"built_in\"> array </span>= list.toArray(new Integer[list.size()]);</span><br></pre></td></tr></table></figure>\n\n<p>最后一种更简洁的写法是通过<code>List</code>接口定义的<code>T[] toArray(IntFunction&lt;T[]&gt; generator)</code>方法：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer[]<span class=\"built_in\"> array </span>= list.toArray(Integer[]::new);</span><br></pre></td></tr></table></figure>\n\n<p>这种函数式写法我们会在后续讲到。</p>\n<p>反过来，把<code>Array</code>变为<code>List</code>就简单多了，通过<code>List.of(T...)</code>方法最简单：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer[]<span class=\"built_in\"> array </span>= &#123; 1, 2, 3 &#125;;</span><br><span class=\"line\">List&lt;Integer&gt; list = List.of(array);</span><br></pre></td></tr></table></figure>\n\n<p>对于JDK 11之前的版本，可以使用<code>Arrays.asList(T...)</code>方法把数组转换成<code>List</code>。</p>\n<p>要注意的是，返回的<code>List</code>不一定就是<code>ArrayList</code>或者<code>LinkedList</code>，因为<code>List</code>只是一个接口，如果我们调用<code>List.of()</code>，它返回的是一个只读<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>对只读<code>List</code>调用<code>add()</code>、<code>remove()</code>方法会抛出<code>UnsupportedOperationException</code>。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>给定一组连续的整数，例如：10，11，12，……，20，但其中缺失一个数字，试找出缺失的数字：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    <span class=\"built_in\">public</span> static <span class=\"type\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">        // 构造从<span class=\"keyword\">start</span>到<span class=\"keyword\">end</span>的序列：</span><br><span class=\"line\">        final <span class=\"type\">int</span> start = <span class=\"number\">10</span>;</span><br><span class=\"line\">        final <span class=\"type\">int</span> end = <span class=\"number\">20</span>;</span><br><span class=\"line\">        List&lt;<span class=\"type\">Integer</span>&gt; list = <span class=\"built_in\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"keyword\">start</span>; i &lt;= <span class=\"keyword\">end</span>; i++) &#123;</span><br><span class=\"line\">            list.<span class=\"keyword\">add</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 随机删除List中的一个元素:</span><br><span class=\"line\">        <span class=\"type\">int</span> removed = list.remove((<span class=\"type\">int</span>) (Math.random() * list.size()));</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"built_in\">found</span> = findMissingNumber(<span class=\"keyword\">start</span>, <span class=\"keyword\">end</span>, list);</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(list.toString());</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;missing number: &quot; + <span class=\"built_in\">found</span>);</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(removed == <span class=\"built_in\">found</span> ? &quot;测试成功&quot; : &quot;测试失败&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>增强版：和上述题目一样，但整数不再有序，试找出缺失的数字：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    <span class=\"built_in\">public</span> static <span class=\"type\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">        // 构造从<span class=\"keyword\">start</span>到<span class=\"keyword\">end</span>的序列：</span><br><span class=\"line\">        final <span class=\"type\">int</span> start = <span class=\"number\">10</span>;</span><br><span class=\"line\">        final <span class=\"type\">int</span> end = <span class=\"number\">20</span>;</span><br><span class=\"line\">        List&lt;<span class=\"type\">Integer</span>&gt; list = <span class=\"built_in\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"keyword\">start</span>; i &lt;= <span class=\"keyword\">end</span>; i++) &#123;</span><br><span class=\"line\">            list.<span class=\"keyword\">add</span>(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        // 洗牌算法shuffle可以随机交换List中的元素位置:</span><br><span class=\"line\">        Collections.shuffle(list);</span><br><span class=\"line\">        // 随机删除List中的一个元素:</span><br><span class=\"line\">        <span class=\"type\">int</span> removed = list.remove((<span class=\"type\">int</span>) (Math.random() * list.size()));</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"built_in\">found</span> = findMissingNumber(<span class=\"keyword\">start</span>, <span class=\"keyword\">end</span>, list);</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(list.toString());</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(&quot;missing number: &quot; + <span class=\"built_in\">found</span>);</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(removed == <span class=\"built_in\">found</span> ? &quot;测试成功&quot; : &quot;测试失败&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/70.%E9%9B%86%E5%90%88.1255943629175808/20.%E4%BD%BF%E7%94%A8List.1265112034799552/coll-list.zip?utm_source=blog_lxf\">找出缺失的数字</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<h1 id=\"编写equals方法\"><a href=\"#编写equals方法\" class=\"headerlink\" title=\"编写equals方法\"></a>编写equals方法</h1><p>我们知道<code>List</code>是一种有序链表：<code>List</code>内部按照放入元素的先后顺序存放，并且每个元素都可以通过索引确定自己的位置。</p>\n<p><code>List</code>还提供了<code>boolean contains(Object o)</code>方法来判断<code>List</code>是否包含某个指定元素。此外，<code>int indexOf(Object o)</code>方法可以返回某个元素的索引，如果元素不存在，就返回<code>-1</code>。</p>\n<p>我们来看一个例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>这里我们注意一个问题，我们往<code>List</code>中添加的<code>&quot;C&quot;</code>和调用<code>contains(&quot;C&quot;)</code>传入的<code>&quot;C&quot;</code>是不是同一个实例？</p>\n<p>如果这两个<code>&quot;C&quot;</code>不是同一个实例，这段代码是否还能得到正确的结果？我们可以改写一下代码测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为我们传入的是<code>new String(&quot;C&quot;)</code>，所以一定是不同的实例。结果仍然符合预期，这是为什么呢？</p>\n<p>因为<code>List</code>内部并不是通过<code>==</code>判断两个元素是否相等，而是使用<code>equals()</code>方法判断两个元素是否相等，例如<code>contains()</code>方法可以实现如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ArrayList</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>[] elementData;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">contains</span>(<span class=\"params\"><span class=\"built_in\">Object</span> o</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (int i = <span class=\"number\">0</span>; i &lt; elementData.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(elementData[i])) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，要正确使用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，放入的实例必须正确覆写<code>equals()</code>方法，否则，放进去的实例，查找不到。我们之所以能正常放入<code>String</code>、<code>Integer</code>这些对象，是因为Java标准库定义的这些类已经正确实现了<code>equals()</code>方法。</p>\n<p>我们以<code>Person</code>对象为例，测试一下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>不出意外，虽然放入了<code>new Person(&quot;Bob&quot;)</code>，但是用另一个<code>new Person(&quot;Bob&quot;)</code>查询不到，原因就是<code>Person</code>类没有覆写<code>equals()</code>方法。</p>\n<h3 id=\"编写equals\"><a href=\"#编写equals\" class=\"headerlink\" title=\"编写equals\"></a>编写equals</h3><p>如何正确编写<code>equals()</code>方法？<code>equals()</code>方法要求我们必须满足以下条件：</p>\n<ul>\n<li>自反性（Reflexive）：对于非<code>null</code>的<code>x</code>来说，<code>x.equals(x)</code>必须返回<code>true</code>；</li>\n<li>对称性（Symmetric）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，则<code>y.equals(x)</code>也必须为<code>true</code>；</li>\n<li>传递性（Transitive）：对于非<code>null</code>的<code>x</code>、<code>y</code>和<code>z</code>来说，如果<code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>也必须为<code>true</code>；</li>\n<li>一致性（Consistent）：对于非<code>null</code>的<code>x</code>和<code>y</code>来说，只要<code>x</code>和<code>y</code>状态不变，则<code>x.equals(y)</code>总是一致地返回<code>true</code>或者<code>false</code>；</li>\n<li>对<code>null</code>的比较：即<code>x.equals(null)</code>永远返回<code>false</code>。</li>\n</ul>\n<p>上述规则看上去似乎非常复杂，但其实代码实现<code>equals()</code>方法是很简单的，我们以<code>Person</code>类为例：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">Person</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们要定义“相等”的逻辑含义。对于<code>Person</code>类，如果<code>name</code>相等，并且<code>age</code>相等，我们就认为两个<code>Person</code>实例相等。</p>\n<p>因此，编写<code>equals()</code>方法如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">equals</span>(<span class=\"params\"><span class=\"built_in\">Object</span> o</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Person) &#123;</span><br><span class=\"line\">        Person p = (Person) o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name.equals(p.name) &amp;&amp; <span class=\"built_in\">this</span>.age == p.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于引用字段比较，我们使用<code>equals()</code>，对于基本类型字段的比较，我们使用<code>==</code>。</p>\n<p>如果<code>this.name</code>为<code>null</code>，那么<code>equals()</code>方法会报错，因此，需要继续改写如下：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> boolean equals(Object o) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o instanceof Person) &#123;</span><br><span class=\"line\">        Person p = (Person) o;</span><br><span class=\"line\">        boolean nameEquals = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.name == <span class=\"literal\">null</span> &amp;&amp; p.name == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            nameEquals = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.name != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            nameEquals = <span class=\"keyword\">this</span>.name.equals(p.name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nameEquals &amp;&amp; <span class=\"keyword\">this</span>.age == p.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>Person</code>有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用<code>Objects.equals()</code>静态方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">equals</span>(<span class=\"params\"><span class=\"built_in\">Object</span> o</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o <span class=\"keyword\">instanceof</span> Person) &#123;</span><br><span class=\"line\">        Person p = (Person) o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.equals(<span class=\"built_in\">this</span>.name, p.name) &amp;&amp; <span class=\"built_in\">this</span>.age == p.age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们总结一下<code>equals()</code>方法的正确编写方法：</p>\n<ol>\n<li>先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；</li>\n<li>用<code>instanceof</code>判断传入的待比较的<code>Object</code>是不是当前类型，如果是，继续比较，否则，返回<code>false</code>；</li>\n<li>对引用类型用<code>Objects.equals()</code>比较，对基本类型直接用<code>==</code>比较。</li>\n</ol>\n<p>使用<code>Objects.equals()</code>比较两个引用类型是否相等的目的是省去了判断<code>null</code>的麻烦。两个引用类型都是<code>null</code>时它们也是相等的。</p>\n<p>如果不调用<code>List</code>的<code>contains()</code>、<code>indexOf()</code>这些方法，那么放入的元素就不需要实现<code>equals()</code>方法。</p>\n<h3 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>给Person类增加equals方法，使得调用indexOf()方法返回正常：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Objects;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/70.%E9%9B%86%E5%90%88.1255943629175808/30.%E7%BC%96%E5%86%99equals%E6%96%B9%E6%B3%95.1265116446975264/coll-equals.zip?utm_source=blog_lxf\">覆写equals方法</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<h1 id=\"使用Map\"><a href=\"#使用Map\" class=\"headerlink\" title=\"使用Map\"></a>使用Map</h1><p>我们知道，<code>List</code>是一种顺序列表，如果有一个存储学生<code>Student</code>实例的<code>List</code>，要在<code>List</code>中根据<code>name</code>查找某个指定的<code>Student</code>的分数，应该怎么办？</p>\n<p>最简单的方法是遍历<code>List</code>并判断<code>name</code>是否相等，然后返回指定元素：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Student&gt; list = ...</span><br><span class=\"line\">Student <span class=\"keyword\">target</span> = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Student s : list) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;Xiao Ming&quot;</span>.equals(s.name)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">target</span> = s;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">System.out.println(<span class=\"keyword\">target</span>.score);</span><br></pre></td></tr></table></figure>\n\n<p>这种需求其实非常常见，即通过一个键去查询对应的值。使用<code>List</code>来实现存在效率非常低的问题，因为平均需要扫描一半的元素才能确定，而<code>Map</code>这种键值（key-value）映射表的数据结构，作用就是能高效通过<code>key</code>快速查找<code>value</code>（元素）。</p>\n<p>用<code>Map</code>来实现根据<code>name</code>查询某个<code>Student</code>的代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>通过上述代码可知：<code>Map&lt;K, V&gt;</code>是一种键-值映射表，当我们调用<code>put(K key, V value)</code>方法时，就把<code>key</code>和<code>value</code>做了映射并放入<code>Map</code>。当我们调用<code>V get(K key)</code>时，就可以通过<code>key</code>获取到对应的<code>value</code>。如果<code>key</code>不存在，则返回<code>null</code>。和<code>List</code>类似，<code>Map</code>也是一个接口，最常用的实现类是<code>HashMap</code>。</p>\n<p>如果只是想查询某个<code>key</code>是否存在，可以调用<code>boolean containsKey(K key)</code>方法。</p>\n<p>如果我们在存储<code>Map</code>映射关系的时候，对同一个key调用两次<code>put()</code>方法，分别放入不同的<code>value</code>，会有什么问题呢？例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>重复放入<code>key-value</code>并不会有任何问题，但是一个<code>key</code>只能关联一个<code>value</code>。在上面的代码中，一开始我们把<code>key</code>对象<code>&quot;apple&quot;</code>映射到<code>Integer</code>对象<code>123</code>，然后再次调用<code>put()</code>方法把<code>&quot;apple&quot;</code>映射到<code>789</code>，这时，原来关联的<code>value</code>对象<code>123</code>就被“冲掉”了。实际上，<code>put()</code>方法的签名是<code>V put(K key, V value)</code>，如果放入的<code>key</code>已经存在，<code>put()</code>方法会返回被删除的旧的<code>value</code>，否则，返回<code>null</code>。</p>\n<p> 始终牢记：Map中不存在重复的key，因为放入相同的key，只会把原有的key-value对应的value给替换掉。</p>\n<p>此外，在一个<code>Map</code>中，虽然<code>key</code>不能重复，但<code>value</code>是可以重复的：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;<span class=\"keyword\">String</span>, Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;apple&quot;</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;pear&quot;</span>, <span class=\"number\">123</span>); <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遍历Map\"><a href=\"#遍历Map\" class=\"headerlink\" title=\"遍历Map\"></a>遍历Map</h3><p>对<code>Map</code>来说，要遍历<code>key</code>可以使用<code>for each</code>循环遍历<code>Map</code>实例的<code>keySet()</code>方法返回的<code>Set</code>集合，它包含不重复的<code>key</code>的集合：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>同时遍历<code>key</code>和<code>value</code>可以使用<code>for each</code>循环遍历<code>Map</code>对象的<code>entrySet()</code>集合，它包含每一个<code>key-value</code>映射：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>Map</code>和<code>List</code>不同的是，<code>Map</code>存储的是<code>key-value</code>的映射关系，并且，它<em>不保证顺序</em>。在遍历的时候，遍历的顺序既不一定是<code>put()</code>时放入的<code>key</code>的顺序，也不一定是<code>key</code>的排序顺序。使用<code>Map</code>时，任何依赖顺序的逻辑都是不可靠的。以<code>HashMap</code>为例，假设我们放入<code>&quot;A&quot;</code>，<code>&quot;B&quot;</code>，<code>&quot;C&quot;</code>这3个<code>key</code>，遍历的时候，每个<code>key</code>会保证被遍历一次且仅遍历一次，但顺序完全没有保证，甚至对于不同的JDK版本，相同的代码遍历的输出顺序都是不同的！</p>\n<p> 遍历Map时，不可假设输出的key是有序的！</p>\n<h3 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>请编写一个根据<code>name</code>查找<code>score</code>的程序，并利用<code>Map</code>充当缓存，以提高查找效率：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/70.%E9%9B%86%E5%90%88.1255943629175808/40.%E4%BD%BF%E7%94%A8Map.1265118019954528/coll-map.zip?utm_source=blog_lxf\">find-student-score</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<h1 id=\"编写equals和hashCode\"><a href=\"#编写equals和hashCode\" class=\"headerlink\" title=\"编写equals和hashCode\"></a>编写equals和hashCode</h1><p>我们知道Map是一种键-值（key-value）映射表，可以通过key快速查找对应的value。</p>\n<p>以HashMap为例，观察下面的代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;<span class=\"keyword\">String</span>, Person&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Person</span>(<span class=\"string\">&quot;Xiao Ming&quot;</span>));</span><br><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;b&quot;</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Person</span>(<span class=\"string\">&quot;Xiao Hong&quot;</span>));</span><br><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;c&quot;</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Person</span>(<span class=\"string\">&quot;Xiao Jun&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">map.<span class=\"built_in\">get</span>(<span class=\"string\">&quot;a&quot;</span>); <span class=\"comment\">// Person(&quot;Xiao Ming&quot;)</span></span><br><span class=\"line\">map.<span class=\"built_in\">get</span>(<span class=\"string\">&quot;x&quot;</span>); <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n\n<p><code>HashMap</code>之所以能根据<code>key</code>直接拿到<code>value</code>，原因是它内部通过空间换时间的方法，用一个大数组存储所有<code>value</code>，并根据key直接计算出<code>value</code>应该存储在哪个索引：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  ┌───┐</span><br><span class=\"line\">0 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">1 │ ●─┼───&gt; Person(&quot;Xiao Ming&quot;)</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">2 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">3 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">4 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">5 │ ●─┼───&gt; Person(&quot;Xiao Hong&quot;)</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">6 │ ●─┼───&gt; Person(&quot;Xiao Jun&quot;)</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">7 │   │</span><br><span class=\"line\">  └───┘</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>key</code>的值为<code>&quot;a&quot;</code>，计算得到的索引总是<code>1</code>，因此返回<code>value</code>为<code>Person(&quot;Xiao Ming&quot;)</code>，如果<code>key</code>的值为<code>&quot;b&quot;</code>，计算得到的索引总是<code>5</code>，因此返回<code>value</code>为<code>Person(&quot;Xiao Hong&quot;)</code>，这样，就不必遍历整个数组，即可直接读取<code>key</code>对应的<code>value</code>。</p>\n<p>当我们使用<code>key</code>存取<code>value</code>的时候，就会引出一个问题：</p>\n<p>我们放入<code>Map</code>的<code>key</code>是字符串<code>&quot;a&quot;</code>，但是，当我们获取<code>Map</code>的<code>value</code>时，传入的变量不一定就是放入的那个<code>key</code>对象。</p>\n<p>换句话讲，两个<code>key</code>应该是内容相同，但不一定是同一个对象。测试代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为在<code>Map</code>的内部，对<code>key</code>做比较是通过<code>equals()</code>实现的，这一点和<code>List</code>查找元素需要正确覆写<code>equals()</code>是一样的，即正确使用<code>Map</code>必须保证：作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法。</p>\n<p>我们经常使用<code>String</code>作为<code>key</code>，因为<code>String</code>已经正确覆写了<code>equals()</code>方法。但如果我们放入的<code>key</code>是一个自己写的类，就必须保证正确覆写了<code>equals()</code>方法。</p>\n<p>我们再思考一下<code>HashMap</code>为什么能通过<code>key</code>直接计算出<code>value</code>存储的索引。相同的<code>key</code>对象（使用<code>equals()</code>判断时返回<code>true</code>）必须要计算出相同的索引，否则，相同的<code>key</code>每次取出的<code>value</code>就不一定对。</p>\n<p>通过<code>key</code>计算索引的方式就是调用<code>key</code>对象的<code>hashCode()</code>方法，它返回一个<code>int</code>整数。<code>HashMap</code>正是通过这个方法直接定位<code>key</code>对应的<code>value</code>的索引，继而直接返回<code>value</code>。</p>\n<p>因此，正确使用<code>Map</code>必须保证：</p>\n<ol>\n<li>作为<code>key</code>的对象必须正确覆写<code>equals()</code>方法，相等的两个<code>key</code>实例调用<code>equals()</code>必须返回<code>true</code>；</li>\n<li>作为<code>key</code>的对象还必须正确覆写<code>hashCode()</code>方法，且<code>hashCode()</code>方法要严格遵循以下规范：</li>\n</ol>\n<ul>\n<li>如果两个对象相等，则两个对象的<code>hashCode()</code>必须相等；</li>\n<li>如果两个对象不相等，则两个对象的<code>hashCode()</code>尽量不要相等。</li>\n</ul>\n<p>即对应两个实例<code>a</code>和<code>b</code>：</p>\n<ul>\n<li>如果<code>a</code>和<code>b</code>相等，那么<code>a.equals(b)</code>一定为<code>true</code>，则<code>a.hashCode()</code>必须等于<code>b.hashCode()</code>；</li>\n<li>如果<code>a</code>和<code>b</code>不相等，那么<code>a.equals(b)</code>一定为<code>false</code>，则<code>a.hashCode()</code>和<code>b.hashCode()</code>尽量不要相等。</li>\n</ul>\n<p>上述第一条规范是正确性，必须保证实现，否则<code>HashMap</code>不能正常工作。</p>\n<p>而第二条如果尽量满足，则可以保证查询效率，因为不同的对象，如果返回相同的<code>hashCode()</code>，会造成<code>Map</code>内部存储冲突，使存取的效率下降。</p>\n<p>正确编写<code>equals()</code>的方法我们已经在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1265116446975264\">编写equals方法</a>一节中讲过了，以<code>Person</code>类为例：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">String</span> firstName;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> lastName;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> age;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把需要比较的字段找出来：</p>\n<ul>\n<li>firstName</li>\n<li>lastName</li>\n<li>age</li>\n</ul>\n<p>然后，引用类型使用<code>Objects.equals()</code>比较，基本类型使用<code>==</code>比较。</p>\n<p>在正确实现<code>equals()</code>的基础上，我们还需要正确实现<code>hashCode()</code>，即上述3个字段分别相同的实例，<code>hashCode()</code>返回的<code>int</code>必须相同：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span> &#123;</span><br><span class=\"line\">    String firstName;</span><br><span class=\"line\">    String lastName;</span><br><span class=\"line\">    int age;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    int hashCode() &#123;</span><br><span class=\"line\">        int <span class=\"built_in\">h</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">h</span> = <span class=\"number\">31</span> * <span class=\"built_in\">h</span> + firstName.hashCode();</span><br><span class=\"line\">        <span class=\"built_in\">h</span> = <span class=\"number\">31</span> * <span class=\"built_in\">h</span> + lastName.hashCode();</span><br><span class=\"line\">        <span class=\"built_in\">h</span> = <span class=\"number\">31</span> * <span class=\"built_in\">h</span> + age;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">h</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>String</code>类已经正确实现了<code>hashCode()</code>方法，我们在计算<code>Person</code>的<code>hashCode()</code>时，反复使用<code>31*h</code>，这样做的目的是为了尽量把不同的<code>Person</code>实例的<code>hashCode()</code>均匀分布到整个<code>int</code>范围。</p>\n<p>和实现<code>equals()</code>方法遇到的问题类似，如果<code>firstName</code>或<code>lastName</code>为<code>null</code>，上述代码工作起来就会抛<code>NullPointerException</code>。为了解决这个问题，我们在计算<code>hashCode()</code>的时候，经常借助<code>Objects.hash()</code>来计算：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">return</span> Objects.<span class=\"title\">hash</span><span class=\"params\">(firstName, lastName, age)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，编写<code>equals()</code>和<code>hashCode()</code>遵循的原则是：</p>\n<p><code>equals()</code>用到的用于比较的每一个字段，都必须在<code>hashCode()</code>中用于计算；<code>equals()</code>中没有使用到的字段，绝不可放在<code>hashCode()</code>中计算。</p>\n<p>另外注意，对于放入<code>HashMap</code>的<code>value</code>对象，没有任何要求。</p>\n<h3 id=\"延伸阅读\"><a href=\"#延伸阅读\" class=\"headerlink\" title=\"延伸阅读\"></a>延伸阅读</h3><p>既然<code>HashMap</code>内部使用了数组，通过计算<code>key</code>的<code>hashCode()</code>直接定位<code>value</code>所在的索引，那么第一个问题来了：hashCode()返回的<code>int</code>范围高达±21亿，先不考虑负数，<code>HashMap</code>内部使用的数组得有多大？</p>\n<p>实际上<code>HashMap</code>初始化时默认的数组大小只有16，任何<code>key</code>，无论它的<code>hashCode()</code>有多大，都可以简单地通过：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int</span> index = key.hashCode() &amp; <span class=\"number\">0</span>xf; // <span class=\"number\">0</span>xf = <span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n\n<p>把索引确定在0～15，即永远不会超出数组范围，上述算法只是一种最简单的实现。</p>\n<p>第二个问题：如果添加超过16个<code>key-value</code>到<code>HashMap</code>，数组不够用了怎么办？</p>\n<p>添加超过一定数量的<code>key-value</code>时，<code>HashMap</code>会在内部自动扩容，每次扩容一倍，即长度为16的数组扩展为长度32，相应地，需要重新确定<code>hashCode()</code>计算的索引位置。例如，对长度为32的数组计算<code>hashCode()</code>对应的索引，计算方式要改为：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">int</span> index = key.hashCode() &amp; <span class=\"number\">0</span>x<span class=\"number\">1</span>f; // <span class=\"number\">0</span>x<span class=\"number\">1</span>f = <span class=\"number\">31</span></span><br></pre></td></tr></table></figure>\n\n<p>由于扩容会导致重新分布已有的<code>key-value</code>，所以，频繁扩容对<code>HashMap</code>的性能影响很大。如果我们确定要使用一个容量为<code>10000</code>个<code>key-value</code>的<code>HashMap</code>，更好的方式是创建<code>HashMap</code>时就指定容量：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Integer</span>&gt; <span class=\"built_in\">map</span> = <span class=\"literal\">new</span> HashMap&lt;&gt;(<span class=\"number\">10000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>虽然指定容量是<code>10000</code>，但<code>HashMap</code>内部的数组长度总是2n，因此，实际数组长度被初始化为比<code>10000</code>大的<code>16384</code>（214）。</p>\n<p>最后一个问题：如果不同的两个<code>key</code>，例如<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>，它们的<code>hashCode()</code>恰好是相同的（这种情况是完全可能的，因为不相等的两个实例，只要求<code>hashCode()</code>尽量不相等），那么，当我们放入：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Person</span>(<span class=\"string\">&quot;Xiao Ming&quot;</span>));</span><br><span class=\"line\">map.<span class=\"built_in\">put</span>(<span class=\"string\">&quot;b&quot;</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Person</span>(<span class=\"string\">&quot;Xiao Hong&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>时，由于计算出的数组索引相同，后面放入的<code>&quot;Xiao Hong&quot;</code>会不会把<code>&quot;Xiao Ming&quot;</code>覆盖了？</p>\n<p>当然不会！使用<code>Map</code>的时候，只要<code>key</code>不相同，它们映射的<code>value</code>就互不干扰。但是，在<code>HashMap</code>内部，确实可能存在不同的<code>key</code>，映射到相同的<code>hashCode()</code>，即相同的数组索引上，肿么办？</p>\n<p>我们就假设<code>&quot;a&quot;</code>和<code>&quot;b&quot;</code>这两个<code>key</code>最终计算出的索引都是5，那么，在<code>HashMap</code>的数组中，实际存储的不是一个<code>Person</code>实例，而是一个<code>List</code>，它包含两个<code>Entry</code>，一个是<code>&quot;a&quot;</code>的映射，一个是<code>&quot;b&quot;</code>的映射：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  ┌───┐</span><br><span class=\"line\">0 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">1 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">2 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">3 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">4 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">5 │ ●─┼───&gt; List&lt;Entry&lt;String, Person&gt;&gt;</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">6 │   │</span><br><span class=\"line\">  ├───┤</span><br><span class=\"line\">7 │   │</span><br><span class=\"line\">  └───┘</span><br></pre></td></tr></table></figure>\n\n<p>在查找的时候，例如：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">Person p = map.<span class=\"built_in\">get</span>(<span class=\"string\">&quot;a&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>HashMap内部通过<code>&quot;a&quot;</code>找到的实际上是<code>List&lt;Entry&lt;String, Person&gt;&gt;</code>，它还需要遍历这个<code>List</code>，并找到一个<code>Entry</code>，它的<code>key</code>字段是<code>&quot;a&quot;</code>，才能返回对应的<code>Person</code>实例。</p>\n<p>我们把不同的<code>key</code>具有相同的<code>hashCode()</code>的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用<code>List</code>存储<code>hashCode()</code>相同的<code>key-value</code>。显然，如果冲突的概率越大，这个<code>List</code>就越长，<code>Map</code>的<code>get()</code>方法效率就越低，这就是为什么要尽量满足条件二：</p>\n<p> 如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</p>\n<p><code>hashCode()</code>方法编写得越好，<code>HashMap</code>工作的效率就越高。</p>\n<h1 id=\"使用EnumMap\"><a href=\"#使用EnumMap\" class=\"headerlink\" title=\"使用EnumMap\"></a>使用EnumMap</h1><p>因为<code>HashMap</code>是一种通过对key计算<code>hashCode()</code>，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。</p>\n<p>如果作为key的对象是<code>enum</code>类型，那么，还可以使用Java集合库提供的一种<code>EnumMap</code>，它在内部以一个非常紧凑的数组存储value，并且根据<code>enum</code>类型的key直接定位到内部数组的索引，并不需要计算<code>hashCode()</code>，不但效率最高，而且没有额外的空间浪费。</p>\n<p>我们以<code>DayOfWeek</code>这个枚举类型为例，为它做一个“翻译”功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.DayOfWeek;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>使用<code>EnumMap</code>的时候，我们总是用<code>Map</code>接口来引用它，因此，实际上把<code>HashMap</code>和<code>EnumMap</code>互换，在客户端看来没有任何区别。</p>\n<h1 id=\"使用TreeMap\"><a href=\"#使用TreeMap\" class=\"headerlink\" title=\"使用TreeMap\"></a>使用TreeMap</h1><p>我们已经知道，<code>HashMap</code>是一种以空间换时间的映射表，它的实现原理决定了内部的Key是无序的，即遍历<code>HashMap</code>的Key时，其顺序是不可预测的（但每个Key都会遍历一次且仅遍历一次）。</p>\n<p>还有一种<code>Map</code>，它在内部会对Key进行排序，这种<code>Map</code>就是<code>SortedMap</code>。注意到<code>SortedMap</code>是接口，它的实现类是<code>TreeMap</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">       ┌───┐</span><br><span class=\"line\">       │Map│</span><br><span class=\"line\">       └───┘</span><br><span class=\"line\">         ▲</span><br><span class=\"line\">    ┌────┴─────┐</span><br><span class=\"line\">    │          │</span><br><span class=\"line\">┌───────┐ ┌─────────┐</span><br><span class=\"line\">│HashMap│ │SortedMap│</span><br><span class=\"line\">└───────┘ └─────────┘</span><br><span class=\"line\">               ▲</span><br><span class=\"line\">               │</span><br><span class=\"line\">          ┌─────────┐</span><br><span class=\"line\">          │ TreeMap │</span><br><span class=\"line\">          └─────────┘</span><br></pre></td></tr></table></figure>\n\n<p><code>SortedMap</code>保证遍历时以Key的顺序来进行排序。例如，放入的Key是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;orange&quot;</code>，遍历的顺序一定是<code>&quot;apple&quot;</code>、<code>&quot;orange&quot;</code>、<code>&quot;pear&quot;</code>，因为<code>String</code>默认按字母排序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>使用<code>TreeMap</code>时，放入的Key必须实现<code>Comparable</code>接口。<code>String</code>、<code>Integer</code>这些类已经实现了<code>Comparable</code>接口，因此可以直接作为Key使用。作为Value的对象则没有任何要求。</p>\n<p>如果作为Key的class没有实现<code>Comparable</code>接口，那么，必须在创建<code>TreeMap</code>时同时指定一个自定义排序算法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意到<code>Comparator</code>接口要求实现一个比较方法，它负责比较传入的两个元素<code>a</code>和<code>b</code>，如果<code>a&lt;b</code>，则返回负数，通常是<code>-1</code>，如果<code>a==b</code>，则返回<code>0</code>，如果<code>a&gt;b</code>，则返回正数，通常是<code>1</code>。<code>TreeMap</code>内部根据比较结果对Key进行排序。</p>\n<p>从上述代码执行结果可知，打印的Key确实是按照<code>Comparator</code>定义的顺序排序的。如果要根据Key查找Value，我们可以传入一个<code>new Person(&quot;Bob&quot;)</code>作为Key，它会返回对应的<code>Integer</code>值<code>2</code>。</p>\n<p>另外，注意到<code>Person</code>类并未覆写<code>equals()</code>和<code>hashCode()</code>，因为<code>TreeMap</code>不使用<code>equals()</code>和<code>hashCode()</code>。</p>\n<p>我们来看一个稍微复杂的例子：这次我们定义了<code>Student</code>类，并用分数<code>score</code>进行排序，高分在前：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>在<code>for</code>循环中，我们确实得到了正确的顺序。但是，且慢！根据相同的Key：<code>new Student(&quot;Bob&quot;, 66)</code>进行查找时，结果为<code>null</code>！</p>\n<p>这是怎么肥四？难道<code>TreeMap</code>有问题？遇到<code>TreeMap</code>工作不正常时，我们首先回顾Java编程基本规则：出现问题，不要怀疑Java标准库，要从自身代码找原因。</p>\n<p>在这个例子中，<code>TreeMap</code>出现问题，原因其实出在这个<code>Comparator</code>上：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">public<span class=\"built_in\"> int </span>compare(Student p1, Student p2) &#123;</span><br><span class=\"line\">   <span class=\"built_in\"> return </span>p1.score &gt; p2.score ? -1<span class=\"keyword\"> :</span> 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>p1.score</code>和<code>p2.score</code>不相等的时候，它的返回值是正确的，但是，在<code>p1.score</code>和<code>p2.score</code>相等的时候，它并没有返回<code>0</code>！这就是为什么<code>TreeMap</code>工作不正常的原因：<code>TreeMap</code>在比较两个Key是否相等时，依赖Key的<code>compareTo()</code>方法或者<code>Comparator.compare()</code>方法。在两个Key相等时，必须返回<code>0</code>。因此，修改代码如下：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">public<span class=\"built_in\"> int </span>compare(Student p1, Student p2) &#123;</span><br><span class=\"line\">   <span class=\"built_in\"> if </span>(p1.score == p2.score) &#123;</span><br><span class=\"line\">       <span class=\"built_in\"> return </span>0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   <span class=\"built_in\"> return </span>p1.score &gt; p2.score ? -1<span class=\"keyword\"> :</span> 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者直接借助<code>Integer.compare(int, int)</code>也可以返回正确的比较结果。</p>\n<h1 id=\"使用Properties\"><a href=\"#使用Properties\" class=\"headerlink\" title=\"使用Properties\"></a>使用Properties</h1><p>在编写应用程序的时候，经常需要读写配置文件。例如，用户的设置：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 上次最后打开的文件:</span></span><br><span class=\"line\"><span class=\"attr\">last_open_file</span>=/data/hello.txt</span><br><span class=\"line\"><span class=\"comment\"># 自动保存文件的时间间隔:</span></span><br><span class=\"line\"><span class=\"attr\">auto_save_interval</span>=<span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>配置文件的特点是，它的Key-Value一般都是<code>String</code>-<code>String</code>类型的，因此我们完全可以用<code>Map&lt;String, String&gt;</code>来表示它。</p>\n<p>因为配置文件非常常用，所以Java集合库提供了一个<code>Properties</code>来表示一组“配置”。由于历史遗留原因，<code>Properties</code>内部本质上是一个<code>Hashtable</code>，但我们只需要用到<code>Properties</code>自身关于读写配置的接口。</p>\n<h3 id=\"读取配置文件\"><a href=\"#读取配置文件\" class=\"headerlink\" title=\"读取配置文件\"></a>读取配置文件</h3><p>用<code>Properties</code>读取配置文件非常简单。Java默认配置文件以<code>.properties</code>为扩展名，每行以<code>key=value</code>表示，以<code>#</code>课开头的是注释。以下是一个典型的配置文件：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># setting.properties</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">last_open_file</span>=/data/hello.txt</span><br><span class=\"line\"><span class=\"attr\">auto_save_interval</span>=<span class=\"number\">60</span></span><br></pre></td></tr></table></figure>\n\n<p>可以从文件系统读取这个<code>.properties</code>文件：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String</span> f = <span class=\"string\">&quot;setting.properties&quot;</span>;</span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> <span class=\"type\">Properties</span>();</span><br><span class=\"line\">props.load(<span class=\"keyword\">new</span> <span class=\"type\">java</span>.io.FileInputStream(f));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">String</span> filepath = props.getProperty(<span class=\"string\">&quot;last_open_file&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">String</span> interval = props.getProperty(<span class=\"string\">&quot;auto_save_interval&quot;</span>, <span class=\"string\">&quot;120&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可见，用<code>Properties</code>读取配置文件，一共有三步：</p>\n<ol>\n<li>创建<code>Properties</code>实例；</li>\n<li>调用<code>load()</code>读取文件；</li>\n<li>调用<code>getProperty()</code>获取配置。</li>\n</ol>\n<p>调用<code>getProperty()</code>获取配置时，如果key不存在，将返回<code>null</code>。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</p>\n<p>也可以从classpath读取<code>.properties</code>文件，因为<code>load(InputStream)</code>方法接收一个<code>InputStream</code>实例，表示一个字节流，它不一定是文件流，也可以是从jar包中读取的资源流：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties <span class=\"built_in\">props</span> = <span class=\"built_in\">new</span> Properties();</span><br><span class=\"line\"><span class=\"built_in\">props</span>.<span class=\"built_in\">load</span>(getClass().getResourceAsStream(<span class=\"string\">&quot;/common/setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>试试从内存读取一个字节流：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> properties</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果有多个<code>.properties</code>文件，可以反复调用<code>load()</code>读取，后读取的key-value会覆盖已读取的key-value：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties <span class=\"built_in\">props</span> = <span class=\"built_in\">new</span> Properties();</span><br><span class=\"line\"><span class=\"built_in\">props</span>.<span class=\"built_in\">load</span>(getClass().getResourceAsStream(<span class=\"string\">&quot;/common/setting.properties&quot;</span>));</span><br><span class=\"line\"><span class=\"built_in\">props</span>.<span class=\"built_in\">load</span>(<span class=\"built_in\">new</span> FileInputStream(<span class=\"string\">&quot;C:\\\\conf\\\\setting.properties&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>上面的代码演示了<code>Properties</code>的一个常用用法：可以把默认配置文件放到classpath中，然后，根据机器的环境编写另一个配置文件，覆盖某些默认的配置。</p>\n<p><code>Properties</code>设计的目的是存储<code>String</code>类型的key－value，但<code>Properties</code>实际上是从<code>Hashtable</code>派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了<code>getProperty()</code>和<code>setProperty()</code>方法外，还有从<code>Hashtable</code>继承下来的<code>get()</code>和<code>put()</code>方法，这些方法的参数签名是<code>Object</code>，我们在使用<code>Properties</code>的时候，不要去调用这些从<code>Hashtable</code>继承下来的方法。</p>\n<h3 id=\"写入配置文件\"><a href=\"#写入配置文件\" class=\"headerlink\" title=\"写入配置文件\"></a>写入配置文件</h3><p>如果通过<code>setProperty()</code>修改了<code>Properties</code>实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用<code>store()</code>方法：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties <span class=\"built_in\">props</span> = <span class=\"built_in\">new</span> Properties();</span><br><span class=\"line\"><span class=\"built_in\">props</span>.setProperty(<span class=\"string\">&quot;url&quot;</span>, <span class=\"string\">&quot;http://www.liaoxuefeng.com&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">props</span>.setProperty(<span class=\"string\">&quot;language&quot;</span>, <span class=\"string\">&quot;Java&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">props</span>.store(<span class=\"built_in\">new</span> FileOutputStream(<span class=\"string\">&quot;C:\\\\conf\\\\setting.properties&quot;</span>), <span class=\"string\">&quot;这是写入的properties注释&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h3><p>早期版本的Java规定<code>.properties</code>文件编码是ASCII编码（ISO8859-1），如果涉及到中文就必须用<code>name=\\u4e2d\\u6587</code>来表示，非常别扭。从JDK9开始，Java的<code>.properties</code>文件可以使用UTF-8编码了。</p>\n<p>不过，需要注意的是，由于<code>load(InputStream)</code>默认总是以ASCII编码读取字节流，所以会导致读到乱码。我们需要用另一个重载方法<code>load(Reader)</code>读取：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">Properties <span class=\"built_in\">props</span> = <span class=\"built_in\">new</span> Properties();</span><br><span class=\"line\"><span class=\"built_in\">props</span>.<span class=\"built_in\">load</span>(<span class=\"built_in\">new</span> FileReader(<span class=\"string\">&quot;settings.properties&quot;</span>, StandardCharsets.UTF_8));</span><br></pre></td></tr></table></figure>\n\n<p>就可以正常读取中文。<code>InputStream</code>和<code>Reader</code>的区别是一个是字节流，一个是字符流。字符流在内存中已经以<code>char</code>类型表示了，不涉及编码问题。</p>\n<h1 id=\"使用Set\"><a href=\"#使用Set\" class=\"headerlink\" title=\"使用Set\"></a>使用Set</h1><p>我们知道，<code>Map</code>用于存储key-value的映射，对于充当key的对象，是不能重复的，并且，不但需要正确覆写<code>equals()</code>方法，还要正确覆写<code>hashCode()</code>方法。</p>\n<p>如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用<code>Set</code>。</p>\n<p><code>Set</code>用于存储不重复的元素集合，它主要提供以下几个方法：</p>\n<ul>\n<li>将元素添加进<code>Set&lt;E&gt;</code>：<code>boolean add(E e)</code></li>\n<li>将元素从<code>Set&lt;E&gt;</code>删除：<code>boolean remove(Object e)</code></li>\n<li>判断是否包含元素：<code>boolean contains(Object e)</code></li>\n</ul>\n<p>我们来看几个简单的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>Set</code>实际上相当于只存储key、不存储value的<code>Map</code>。我们经常用<code>Set</code>用于去除重复元素。</p>\n<p>因为放入<code>Set</code>的元素和<code>Map</code>的key类似，都要正确实现<code>equals()</code>和<code>hashCode()</code>方法，否则该元素无法正确地放入<code>Set</code>。</p>\n<p>最常用的<code>Set</code>实现类是<code>HashSet</code>，实际上，<code>HashSet</code>仅仅是对<code>HashMap</code>的一个简单封装，它的核心代码如下：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class HashSet&lt;E&gt; implements Set&lt;E&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 持有一个HashMap:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">HashMap</span>&lt;E, <span class=\"keyword\">Object</span>&gt; <span class=\"built_in\">map</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 放入HashMap的value:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">Object</span> PRESENT = <span class=\"keyword\">new</span> <span class=\"keyword\">Object</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"built_in\">add</span>(E e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">map</span>.put(e, PRESENT) == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> contains(<span class=\"keyword\">Object</span> o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">map</span>.containsKey(o);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> remove(<span class=\"keyword\">Object</span> o) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">map</span>.remove(o) == PRESENT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Set</code>接口并不保证有序，而<code>SortedSet</code>接口则保证元素是有序的：</p>\n<ul>\n<li><code>HashSet</code>是无序的，因为它实现了<code>Set</code>接口，并没有实现<code>SortedSet</code>接口；</li>\n<li><code>TreeSet</code>是有序的，因为它实现了<code>SortedSet</code>接口。</li>\n</ul>\n<p>用一张图表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">       ┌───┐</span><br><span class=\"line\">       │Set│</span><br><span class=\"line\">       └───┘</span><br><span class=\"line\">         ▲</span><br><span class=\"line\">    ┌────┴─────┐</span><br><span class=\"line\">    │          │</span><br><span class=\"line\">┌───────┐ ┌─────────┐</span><br><span class=\"line\">│HashSet│ │SortedSet│</span><br><span class=\"line\">└───────┘ └─────────┘</span><br><span class=\"line\">               ▲</span><br><span class=\"line\">               │</span><br><span class=\"line\">          ┌─────────┐</span><br><span class=\"line\">          │ TreeSet │</span><br><span class=\"line\">          └─────────┘</span><br></pre></td></tr></table></figure>\n\n<p>我们来看<code>HashSet</code>的输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意输出的顺序既不是添加的顺序，也不是<code>String</code>排序的顺序，在不同版本的JDK中，这个顺序也可能是不同的。</p>\n<p>把<code>HashSet</code>换成<code>TreeSet</code>，在遍历<code>TreeSet</code>时，输出就是有序的，这个顺序是元素的排序顺序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>使用<code>TreeSet</code>和使用<code>TreeMap</code>的要求一样，添加的元素必须正确实现<code>Comparable</code>接口，如果没有实现<code>Comparable</code>接口，那么创建<code>TreeSet</code>时必须传入一个<code>Comparator</code>对象。</p>\n<h3 id=\"练习-3\"><a href=\"#练习-3\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>在聊天软件中，发送方发送消息时，遇到网络超时后就会自动重发，因此，接收方可能会收到重复的消息，在显示给用户看的时候，需要首先去重。请练习使用<code>Set</code>去除重复的消息：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h1 id=\"使用Queue\"><a href=\"#使用Queue\" class=\"headerlink\" title=\"使用Queue\"></a>使用Queue</h1><p>队列（<code>Queue</code>）是一种经常使用的集合。<code>Queue</code>实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和<code>List</code>的区别在于，<code>List</code>可以在任意位置添加和删除元素，而<code>Queue</code>只有两个操作：</p>\n<ul>\n<li>把元素添加到队列末尾；</li>\n<li>从队列头部取出元素。</li>\n</ul>\n<p>超市的收银台就是一个队列：</p>\n<p><img src=\"/7.%E9%9B%86%E5%90%88.assets/l.jpeg\" alt=\"queue\"></p>\n<p>在Java的标准库中，队列接口<code>Queue</code>定义了以下几个方法：</p>\n<ul>\n<li><code>int size()</code>：获取队列长度；</li>\n<li><code>boolean add(E)</code>&#x2F;<code>boolean offer(E)</code>：添加元素到队尾；</li>\n<li><code>E remove()</code>&#x2F;<code>E poll()</code>：获取队首元素并从队列中删除；</li>\n<li><code>E element()</code>&#x2F;<code>E peek()</code>：获取队首元素但并不从队列中删除。</li>\n</ul>\n<p>对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">throw Exception</th>\n<th align=\"left\">返回false或null</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">添加元素到队尾</td>\n<td align=\"left\">add(E e)</td>\n<td align=\"left\">boolean offer(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素并删除</td>\n<td align=\"left\">E remove()</td>\n<td align=\"left\">E poll()</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素但不删除</td>\n<td align=\"left\">E element()</td>\n<td align=\"left\">E peek()</td>\n</tr>\n</tbody></table>\n<p>举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用<code>add()</code>方法，当添加失败时（可能超过了队列的容量），它会抛出异常：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">Queue&lt;<span class=\"keyword\">String</span>&gt; q = ...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    q.<span class=\"built_in\">add</span>(<span class=\"string\">&quot;Apple&quot;</span>);</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;添加成功&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(IllegalStateException e) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;添加失败&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们调用<code>offer()</code>方法来添加元素，当添加失败时，它不会抛异常，而是返回<code>false</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Queue&lt;String&gt; q =<span class=\"operator\"> ...</span></span><br><span class=\"line\"><span class=\"operator\"></span><span class=\"keyword\">if</span> (q.offer(<span class=\"string\">&quot;Apple&quot;</span>)) &#123;</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;添加成功&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;添加失败&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们需要从<code>Queue</code>中取出队首元素时，如果当前<code>Queue</code>是一个空队列，调用<code>remove()</code>方法，它会抛出异常：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">Queue&lt;<span class=\"keyword\">String</span>&gt; q = ...</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> s = q.<span class=\"built_in\">remove</span>();</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;获取成功&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span>(IllegalStateException e) &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;获取失败&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们调用<code>poll()</code>方法来取出队首元素，当获取失败时，它不会抛异常，而是返回<code>null</code>：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Queue</span>&lt;<span class=\"built_in\">String</span>&gt; q = <span class=\"params\">...</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> s = q.poll();</span><br><span class=\"line\"><span class=\"keyword\">if</span> (s != <span class=\"built_in\">null</span>) &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;获取成功&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;获取失败&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，两套方法可以根据需要来选择使用。</p>\n<p>注意：不要把<code>null</code>添加到队列中，否则<code>poll()</code>方法返回<code>null</code>时，很难确定是取到了<code>null</code>元素还是队列为空。</p>\n<p>接下来我们以<code>poll()</code>和<code>peek()</code>为例来说说“获取并删除”与“获取但不删除”的区别。对于<code>Queue</code>来说，每次调用<code>poll()</code>，都会获取队首元素，并且获取到的元素已经从队列中被删除了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果用<code>peek()</code>，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>从上面的代码中，我们还可以发现，<code>LinkedList</code>即实现了<code>List</code>接口，又实现了<code>Queue</code>接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是一个List:</span></span><br><span class=\"line\">List&lt;<span class=\"keyword\">String</span>&gt; list = <span class=\"keyword\">new</span> <span class=\"type\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 这是一个Queue:</span></span><br><span class=\"line\">Queue&lt;<span class=\"keyword\">String</span>&gt; queue = <span class=\"keyword\">new</span> <span class=\"type\">LinkedList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。</p>\n<h1 id=\"使用PriorityQueue\"><a href=\"#使用PriorityQueue\" class=\"headerlink\" title=\"使用PriorityQueue\"></a>使用PriorityQueue</h1><p>我们知道，<code>Queue</code>是一个先进先出（FIFO）的队列。</p>\n<p>在银行柜台办业务时，我们假设只有一个柜台在办理业务，但是办理业务的人很多，怎么办？</p>\n<p>可以每个人先取一个号，例如：<code>A1</code>、<code>A2</code>、<code>A3</code>……然后，按照号码顺序依次办理，实际上这就是一个<code>Queue</code>。</p>\n<p>如果这时来了一个VIP客户，他的号码是<code>V1</code>，虽然当前排队的是<code>A10</code>、<code>A11</code>、<code>A12</code>……但是柜台下一个呼叫的客户号码却是<code>V1</code>。</p>\n<p>这个时候，我们发现，要实现“VIP插队”的业务，用<code>Queue</code>就不行了，因为<code>Queue</code>会严格按FIFO的原则取出队首元素。我们需要的是优先队列：<code>PriorityQueue</code>。</p>\n<p><code>PriorityQueue</code>和<code>Queue</code>的区别在于，它的出队顺序与元素的优先级有关，对<code>PriorityQueue</code>调用<code>remove()</code>或<code>poll()</code>方法，返回的总是优先级最高的元素。</p>\n<p>要使用<code>PriorityQueue</code>，我们就必须给每个元素定义“优先级”。我们以实际代码为例，先看看<code>PriorityQueue</code>的行为：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.PriorityQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>我们放入的顺序是<code>&quot;apple&quot;</code>、<code>&quot;pear&quot;</code>、<code>&quot;banana&quot;</code>，但是取出的顺序却是<code>&quot;apple&quot;</code>、<code>&quot;banana&quot;</code>、<code>&quot;pear&quot;</code>，这是因为从字符串的排序看，<code>&quot;apple&quot;</code>排在最前面，<code>&quot;pear&quot;</code>排在最后面。</p>\n<p>因此，放入<code>PriorityQueue</code>的元素，必须实现<code>Comparable</code>接口，<code>PriorityQueue</code>会根据元素的排序顺序决定出队的优先级。</p>\n<p>如果我们要放入的元素并没有实现<code>Comparable</code>接口怎么办？<code>PriorityQueue</code>允许我们提供一个<code>Comparator</code>对象来判断两个元素的顺序。我们以银行排队业务为例，实现一个<code>PriorityQueue</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.PriorityQueue;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Queue;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>实现<code>PriorityQueue</code>的关键在于提供的<code>UserComparator</code>对象，它负责比较两个元素的大小（较小的在前）。<code>UserComparator</code>总是把<code>V</code>开头的号码优先返回，只有在开头相同的时候，才比较号码大小。</p>\n<p>上面的<code>UserComparator</code>的比较逻辑其实还是有问题的，它会把<code>A10</code>排在<code>A2</code>的前面，请尝试修复该错误。</p>\n<h1 id=\"使用Deque\"><a href=\"#使用Deque\" class=\"headerlink\" title=\"使用Deque\"></a>使用Deque</h1><p>我们知道，<code>Queue</code>是队列，只能一头进，另一头出。</p>\n<p>如果把条件放松一下，允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue），学名<code>Deque</code>。</p>\n<p>Java集合提供了接口<code>Deque</code>来实现一个双端队列，它的功能是：</p>\n<ul>\n<li>既可以添加到队尾，也可以添加到队首；</li>\n<li>既可以从队首获取，又可以从队尾获取。</li>\n</ul>\n<p>我们来比较一下<code>Queue</code>和<code>Deque</code>出队和入队的方法：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">Queue</th>\n<th align=\"left\">Deque</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">添加元素到队尾</td>\n<td align=\"left\">add(E e) &#x2F; offer(E e)</td>\n<td align=\"left\">addLast(E e) &#x2F; offerLast(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素并删除</td>\n<td align=\"left\">E remove() &#x2F; E poll()</td>\n<td align=\"left\">E removeFirst() &#x2F; E pollFirst()</td>\n</tr>\n<tr>\n<td align=\"left\">取队首元素但不删除</td>\n<td align=\"left\">E element() &#x2F; E peek()</td>\n<td align=\"left\">E getFirst() &#x2F; E peekFirst()</td>\n</tr>\n<tr>\n<td align=\"left\">添加元素到队首</td>\n<td align=\"left\">无</td>\n<td align=\"left\">addFirst(E e) &#x2F; offerFirst(E e)</td>\n</tr>\n<tr>\n<td align=\"left\">取队尾元素并删除</td>\n<td align=\"left\">无</td>\n<td align=\"left\">E removeLast() &#x2F; E pollLast()</td>\n</tr>\n<tr>\n<td align=\"left\">取队尾元素但不删除</td>\n<td align=\"left\">无</td>\n<td align=\"left\">E getLast() &#x2F; E peekLast()</td>\n</tr>\n</tbody></table>\n<p>对于添加元素到队尾的操作，<code>Queue</code>提供了<code>add()</code>&#x2F;<code>offer()</code>方法，而<code>Deque</code>提供了<code>addLast()</code>&#x2F;<code>offerLast()</code>方法。添加元素到对首、取队尾元素的操作在<code>Queue</code>中不存在，在<code>Deque</code>中由<code>addFirst()</code>&#x2F;<code>removeLast()</code>等方法提供。</p>\n<p>注意到<code>Deque</code>接口实际上扩展自<code>Queue</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"symbol\">Deque</span>&lt;<span class=\"symbol\">E</span>&gt; <span class=\"symbol\">extends</span> <span class=\"symbol\">Queue</span>&lt;<span class=\"symbol\">E</span>&gt; &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>Queue</code>提供的<code>add()</code>&#x2F;<code>offer()</code>方法在<code>Deque</code>中也可以使用，但是，使用<code>Deque</code>，最好不要调用<code>offer()</code>，而是调用<code>offerLast()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Deque;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果直接写<code>deque.offer()</code>，我们就需要思考，<code>offer()</code>实际上是<code>offerLast()</code>，我们明确地写上<code>offerLast()</code>，不需要思考就能一眼看出这是添加到队尾。</p>\n<p>因此，使用<code>Deque</code>，推荐总是明确调用<code>offerLast()</code>&#x2F;<code>offerFirst()</code>或者<code>pollFirst()</code>&#x2F;<code>pollLast()</code>方法。</p>\n<p><code>Deque</code>是一个接口，它的实现类有<code>ArrayDeque</code>和<code>LinkedList</code>。</p>\n<p>我们发现<code>LinkedList</code>真是一个全能选手，它即是<code>List</code>，又是<code>Queue</code>，还是<code>Deque</code>。但是我们在使用的时候，总是用特定的接口来引用它，这是因为持有接口说明代码的抽象层次更高，而且接口本身定义的方法代表了特定的用途。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不推荐的写法:</span></span><br><span class=\"line\">LinkedList&lt;<span class=\"keyword\">String</span>&gt; d1 = <span class=\"keyword\">new</span> <span class=\"type\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">d1.offerLast(<span class=\"string\">&quot;z&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 推荐的写法：</span></span><br><span class=\"line\">Deque&lt;<span class=\"keyword\">String</span>&gt; d2 = <span class=\"keyword\">new</span> <span class=\"type\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">d2.offerLast(<span class=\"string\">&quot;z&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可见面向抽象编程的一个原则就是：尽量持有接口，而不是具体的实现类。</p>\n<h1 id=\"使用Stack\"><a href=\"#使用Stack\" class=\"headerlink\" title=\"使用Stack\"></a>使用Stack</h1><p>栈（Stack）是一种后进先出（LIFO：Last In First Out）的数据结构。</p>\n<p>什么是LIFO呢？我们先回顾一下<code>Queue</code>的特点FIFO：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">          ────────────────────────</span><br><span class=\"line\">  (\\(\\      (\\(\\    (\\(\\    (\\(\\      (\\(\\</span><br><span class=\"line\"> (=&#x27;.&#x27;) ─&gt; (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;) ─&gt; (=&#x27;.&#x27;)</span><br><span class=\"line\">O(_&quot;)&quot;)   O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;)   O(_&quot;)&quot;)</span><br><span class=\"line\">          ────────────────────────</span><br></pre></td></tr></table></figure>\n\n<p>所谓FIFO，是最先进队列的元素一定最早出队列，而LIFO是最后进<code>Stack</code>的元素一定最早出<code>Stack</code>。如何做到这一点呢？只需要把队列的一端封死：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">           ───────────────────────────────┐</span><br><span class=\"line\">  (\\(\\       (\\(\\    (\\(\\    (\\(\\    (\\(\\ │</span><br><span class=\"line\"> (=&#x27;.&#x27;) &lt;─&gt; (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;)  (=&#x27;.&#x27;)│</span><br><span class=\"line\">O(_&quot;)&quot;)    O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;) O(_&quot;)&quot;)│</span><br><span class=\"line\">           ───────────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>Stack</code>是这样一种数据结构：只能不断地往<code>Stack</code>中压入（push）元素，最后进去的必须最早弹出（pop）来：</p>\n<p><img src=\"/7.%E9%9B%86%E5%90%88.assets/l-16418936951923.jpeg\" alt=\"donuts-stack\"></p>\n<p><code>Stack</code>只有入栈和出栈的操作：</p>\n<ul>\n<li>把元素压栈：<code>push(E)</code>；</li>\n<li>把栈顶的元素“弹出”：<code>pop()</code>；</li>\n<li>取栈顶元素但不弹出：<code>peek()</code>。</li>\n</ul>\n<p>在Java中，我们用<code>Deque</code>可以实现<code>Stack</code>的功能：</p>\n<ul>\n<li>把元素压栈：<code>push(E)</code>&#x2F;<code>addFirst(E)</code>；</li>\n<li>把栈顶的元素“弹出”：<code>pop()</code>&#x2F;<code>removeFirst()</code>；</li>\n<li>取栈顶元素但不弹出：<code>peek()</code>&#x2F;<code>peekFirst()</code>。</li>\n</ul>\n<p>为什么Java的集合类没有单独的<code>Stack</code>接口呢？因为有个遗留类名字就叫<code>Stack</code>，出于兼容性考虑，所以没办法创建<code>Stack</code>接口，只能用<code>Deque</code>接口来“模拟”一个<code>Stack</code>了。</p>\n<p>当我们把<code>Deque</code>作为<code>Stack</code>使用时，注意只调用<code>push()</code>&#x2F;<code>pop()</code>&#x2F;<code>peek()</code>方法，不要调用<code>addFirst()</code>&#x2F;<code>removeFirst()</code>&#x2F;<code>peekFirst()</code>方法，这样代码更加清晰。</p>\n<h3 id=\"Stack的作用\"><a href=\"#Stack的作用\" class=\"headerlink\" title=\"Stack的作用\"></a>Stack的作用</h3><p>Stack在计算机中使用非常广泛，JVM在处理Java方法调用的时候就会通过栈这种数据结构维护方法调用的层次。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"function\"><span class=\"title\">main</span>(<span class=\"params\"><span class=\"built_in\">String</span>[] args</span>)</span> &#123;</span><br><span class=\"line\">    foo(<span class=\"number\">123</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">foo</span>(<span class=\"params\">x</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;F-&quot;</span> + bar(x + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> int <span class=\"function\"><span class=\"title\">bar</span>(<span class=\"params\">int x</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x &lt;&lt; <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JVM会创建方法调用栈，每调用一个方法时，先将参数压栈，然后执行对应的方法；当方法返回时，返回值压栈，调用方法通过出栈操作获得方法返回值。</p>\n<p>因为方法调用栈有容量限制，嵌套调用过多会造成栈溢出，即引发<code>StackOverflowError</code>：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 测试无限递归调用</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>我们再来看一个<code>Stack</code>的用途：对整数进行进制的转换就可以利用栈。</p>\n<p>例如，我们要把一个<code>int</code>整数<code>12500</code>转换为十六进制表示的字符串，如何实现这个功能？</p>\n<p>首先我们准备一个空栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>然后计算12500÷16&#x3D;781…4，余数是<code>4</code>，把余数<code>4</code>压栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 4 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>然后计算781÷16&#x3D;48…13，余数是<code>13</code>，<code>13</code>的十六进制用字母<code>D</code>表示，把余数<code>D</code>压栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ D │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 4 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>然后计算48÷16&#x3D;3…0，余数是<code>0</code>，把余数<code>0</code>压栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 0 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ D │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 4 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>最后计算3÷16&#x3D;0…3，余数是<code>3</code>，把余数<code>3</code>压栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│ 3 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 0 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ D │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 4 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>当商是<code>0</code>的时候，计算结束，我们把栈的所有元素依次弹出，组成字符串<code>30D4</code>，这就是十进制整数<code>12500</code>的十六进制表示的字符串。</p>\n<h3 id=\"计算中缀表达式\"><a href=\"#计算中缀表达式\" class=\"headerlink\" title=\"计算中缀表达式\"></a>计算中缀表达式</h3><p>在编写程序的时候，我们使用的带括号的数学表达式实际上是中缀表达式，即运算符在中间，例如：<code>1 + 2 * (9 - 5)</code>。</p>\n<p>但是计算机执行表达式的时候，它并不能直接计算中缀表达式，而是通过编译器把中缀表达式转换为后缀表达式，例如：<code>1 2 9 5 - * +</code>。</p>\n<p>这个编译过程就会用到栈。我们先跳过编译这一步（涉及运算优先级，代码比较复杂），看看如何通过栈计算后缀表达式。</p>\n<p>计算后缀表达式不考虑优先级，直接从左到右依次计算，因此计算起来简单。首先准备一个空的栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>然后我们依次扫描后缀表达式<code>1 2 9 5 - * +</code>，遇到数字<code>1</code>，就直接扔到栈里：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 1 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>紧接着，遇到数字<code>2</code>，<code>9</code>，<code>5</code>，也扔到栈里：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│ 5 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 9 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 2 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 1 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>接下来遇到减号时，弹出栈顶的两个元素，并计算<code>9-5=4</code>，把结果<code>4</code>压栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 4 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 2 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 1 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>接下来遇到<code>*</code>号时，弹出栈顶的两个元素，并计算<code>2*4=8</code>，把结果<code>8</code>压栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 8 │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 1 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>接下来遇到<code>+</code>号时，弹出栈顶的两个元素，并计算<code>1+8=9</code>，把结果<code>9</code>压栈：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│   │</span><br><span class=\"line\">│ 9 │</span><br><span class=\"line\">└───┘</span><br></pre></td></tr></table></figure>\n\n<p>扫描结束后，没有更多的计算了，弹出栈的唯一一个元素，得到计算结果<code>9</code>。</p>\n<h3 id=\"练习-4\"><a href=\"#练习-4\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>请利用Stack把一个给定的整数转换为十六进制：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 转十六进制</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>进阶练习：</p>\n<p>请利用Stack把字符串中缀表达式编译为后缀表达式，然后再利用栈执行后缀表达式获得计算结果：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 高难度练习，慎重选择！</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>进阶练习2：</p>\n<p>请把带变量的中缀表达式编译为后缀表达式，执行后缀表达式时，传入变量的值并获得计算结果：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 超高难度练习，慎重选择！</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>从<a href=\"https://gitee.com/\"><img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE4AAAAYCAMAAABjozvFAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAMAUExURf////zz8//9/f34+PXMzPbV1Pba2f////TJyPPFxf38+////wAAAMcdI7sAAMMADQEBAbgAALwAALoAALkAAL8AAMopLskgJsgiJ8cfJfbS0vzy8ckoLLMAAM87Pd3d3cgbInt7e8YPGnBwcMcXH4CAgL0AALcAAOB7et1tboWFhUNDQwcHB8MAD1ZWVsEAAdXV1cYMGb4AABQUFLUAAMQBEwMDA+Hh4aysrJ2dnTIyMh4eHvT09Ombmvn5+cDAwKGhofv7+7YAADQ0NN9yc/ro6aWlpcIACsAAABcXF5KSknd3d0dHRw0NDWxsbMMAC/G8vO+0syUlJcUUHBwcHEVFRVBQUPX19cQAEf7+/kBAQM7OzlNTU8AABsIABrQAAP329scRG8ssL91ubvPz86ioqOqfn8rKykJCQsXFxdvb25+fn6Kior29vQkJCZWVldtlZeKCgampqSYmJhEREQ8PD7e3tycnJ7S0tNFCROuhoP3y8pubm4yMjGZmZsjIyE1NTfLAwPrj5ImJicMHFe/v73FxcdHR0QwMDNra2uJ/fuypqNA/QJaWln5+fnR0dPnf3mNjY1lZWUtLS+qjopiYmCoqKsgjKNZUVeaQkDY2NiIiIs01OOrq6swvMsUKF8EABN92djw8POB7e8nJycojKM45PP3z8s87PvfX1u+0tMQEFOTk5IKCgu7u7tlhYeulpNhdXTg4OPfZ2PTNzPnf4BoaGqSkpPTKyuyoqMHBweyrrNfX1/Dw8E9PT8/Pz42Nja6uroiIiGFhYf37+ttkZHp6eufn5+SLi0FBQYaGhnNzc5mZmdpgYOB4d8IAEVhYWFJSUsklKcvLy8QPGvXR0OiYmbKyso+Pj7GxsdLS0nx8fMcXHhYWFv79/eB3d8EADOeUlPXT0uF6eV1dXeSKihISEsTExIODg9JHST4+Pvvv7/rn5/zx8NxpatJFRt1wcfvq6q4AAPjc2990dasAAMYbIddYWfXOze2ur++3t////uF+ff3399hbXMkeJnevGJYAAAALdFJOU/Ly8vLy8vLl8vLy6tdKuQAAA5RJREFUOMullWd4FFUUhhdRg55vNtsLapLVZXdJ7zFogBTSe4f0Qu8dlA4CAULvvXcQ7KiAXYqCgmLHCtbYu1ju3JnZzY/wrIHvx73n3Oebd55zq8pH5VaHmzrdcuPNquuQj4oUdd5iCQlLrzq78UQvalsHG8mbVArvjFFb/UbR+0UR6dqQhDato4aN7eGVJuFa1ifNMgtcVnNV0otteWOB0azbH+cV90K91rwqxKGWpEtzjmjD+1xwTk+i/rGagd5wrzpXmdU7fuva0JWpoWFBTE3C1b4YDNztBTfdabfoVntWoJ82JP1RJZk6O3vKM5Mzm2hD86QyGjgAmBboz8b7Twla+hZ3xGUFHRviwfVeoDMbN7Ls4l8S4ZLekjRSpi2EpHtoETCYpGQA0UweLGKOCbFilO3GPWwsEgzL6e8r/+70Y9rtt8MupFnu57RwoLi5BFjZTLlAIAXNBTLGD6ehQFToSqAH+QPDXgsC+iq4+/RCXfUe+rPG6LyDy2gSAnT5HPcS8A6RBq8Q3QW8R1QJsAWhEkSxthhZtAQaVvtaJCu4FL01onwP/aHb988Vl8u1bdvEciFAfYjjhgOTqUmDUxzXhSgUSCU6qkHUksrPLmMZnYRmaWVoBtBdxh3WCXf6dqa9hhh5vi5oGa4fD7snA6U5QJyCe12cQbFCSbmULEfrFNyDagmnj/m9tnYXY6zRu3E0SrSOFveGhFvGN8q9wRi7vWJ7eEUi9QEmzJka/m6jUuw8g1XEFTjqzPX1v5p+EHGCej6nPRCFz8su8tBdbC5LSqFJlf53mg+32ncF6gARd+RHvTM6+pd9LfSxQbA7HlFWNvuLhba35xA9D8wmyhQ3TTwdZ90Hhcgoo4NjgLnjAX8F1ytvlohb/P0Wl+vnlJ+IPtVbIyfKP5wmT80kCgTiiRofYkk3onHFfDeyEgd1E6Pgp92nYoShzneG56h88tEmS/RyKd6wNbikz1drNRhDNPRJPtTXdqCJdYmpWTb5hhlnsz2b6DlkMxyb8/Jv+7pF1K5vCjZFmnSmWsm5FetY2zsHj9H/kHwFJNREWE23c5mskdWmNMMTsoGtW2nmzEJgSDtwlBIdFuPLlVduP2fUHlEML/OJQeHj1B4cjVSr7dL9aYnQGp9qZTm/IjC+gqh9OJq+U2eI3FwV5tCGrV5M1yiV5+mh/G+/81u/+8sP36Rrl8qn9cN2a8cbVNf1MP4HCWMMeoGMWdIAAAAASUVORK5CYII=\" alt=\"img\"></a>下载练习：<a href=\"https://gitee.com/liaoxuefeng/learn-java/blob/master/practices/Java%E6%95%99%E7%A8%8B/70.%E9%9B%86%E5%90%88.1255943629175808/120.%E4%BD%BF%E7%94%A8Stack.1265121668997888/coll-stack.zip?utm_source=blog_lxf\">Stack练习</a> （推荐使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266092093733664\">IDE练习插件</a>快速下载）</p>\n<h1 id=\"使用Iterator\"><a href=\"#使用Iterator\" class=\"headerlink\" title=\"使用Iterator\"></a>使用Iterator</h1><p>Java的集合类都可以使用<code>for each</code>循环，<code>List</code>、<code>Set</code>和<code>Queue</code>会迭代每个元素，<code>Map</code>会迭代每个key。以<code>List</code>为例：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"built_in\">List</span><span class=\"operator\">.</span><span class=\"variable\">of</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;Apple&quot;</span><span class=\"operator\">,</span> <span class=\"string\">&quot;Orange&quot;</span><span class=\"operator\">,</span> <span class=\"string\">&quot;Pear&quot;</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br><span class=\"line\"><span class=\"variable\">for</span> <span class=\"punctuation\">(</span><span class=\"built_in\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">:</span> <span class=\"variable\">list</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"variable\">System</span><span class=\"operator\">.</span><span class=\"variable\">out</span><span class=\"operator\">.</span><span class=\"variable\">println</span><span class=\"punctuation\">(</span><span class=\"variable\">s</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，Java编译器并不知道如何遍历<code>List</code>。上述代码能够编译通过，只是因为编译器把<code>for each</code>循环通过<code>Iterator</code>改写为了普通的<code>for</code>循环：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (Iterator&lt;<span class=\"built_in\">String</span>&gt; <span class=\"literal\">it</span> = <span class=\"keyword\">list</span>.iterator(); <span class=\"literal\">it</span>.hasNext(); ) &#123;</span><br><span class=\"line\">     <span class=\"built_in\">String</span> s = <span class=\"literal\">it</span>.next();</span><br><span class=\"line\">     System.out.println(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们把这种通过<code>Iterator</code>对象遍历集合的模式称为迭代器。</p>\n<p>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。</p>\n<p>例如，我们虽然知道<code>ArrayList</code>在内部是以数组形式存储元素，并且，它还提供了<code>get(int)</code>方法。虽然我们可以用<code>for</code>循环遍历：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i=<span class=\"number\">0</span>; i&lt;list.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">Object</span> value = list.<span class=\"built_in\">get</span>(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这样一来，调用方就必须知道集合的内部存储结构。并且，如果把<code>ArrayList</code>换成<code>LinkedList</code>，<code>get(int)</code>方法耗时会随着index的增加而增加。如果把<code>ArrayList</code>换成<code>Set</code>，上述代码就无法编译，因为<code>Set</code>内部没有索引。</p>\n<p>用<code>Iterator</code>遍历就没有上述问题，因为<code>Iterator</code>对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方则获得了统一的代码，编译器才能把标准的<code>for each</code>循环自动转换为<code>Iterator</code>遍历。</p>\n<p>如果我们自己编写了一个集合类，想要使用<code>for each</code>循环，只需满足以下条件：</p>\n<ul>\n<li>集合类实现<code>Iterable</code>接口，该接口要求返回一个<code>Iterator</code>对象；</li>\n<li>用<code>Iterator</code>对象迭代集合内部数据。</li>\n</ul>\n<p>这里的关键在于，集合类通过调用<code>iterator()</code>方法，返回一个<code>Iterator</code>对象，这个对象必须自己知道如何遍历该集合。</p>\n<p>一个简单的<code>Iterator</code>示例如下，它总是以倒序遍历集合：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> Iterator</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>虽然<code>ReverseList</code>和<code>ReverseIterator</code>的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按<code>for each</code>循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</p>\n<p>在编写<code>Iterator</code>的时候，我们通常可以用一个内部类来实现<code>Iterator</code>接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类<code>ReverseIterator</code>可以用<code>ReverseList.this</code>获得当前外部类的<code>this</code>引用，然后，通过这个<code>this</code>引用就可以访问<code>ReverseList</code>的所有字段和方法。</p>\n<h1 id=\"使用Collections\"><a href=\"#使用Collections\" class=\"headerlink\" title=\"使用Collections\"></a>使用Collections</h1><p><code>Collections</code>是JDK提供的工具类，同样位于<code>java.util</code>包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>\n<p> 注意Collections结尾多了一个s，不是Collection！</p>\n<p>我们一般看方法名和参数就可以确认<code>Collections</code>提供的该方法的功能。例如，对于以下静态方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">addAll</span>(<span class=\"params\">Collection&lt;? <span class=\"built_in\">super</span> T&gt; c, T... elements</span>)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>addAll()</code>方法可以给一个<code>Collection</code>类型的集合添加若干元素。因为方法签名是<code>Collection</code>，所以我们可以传入<code>List</code>，<code>Set</code>等各种集合类型。</p>\n<h3 id=\"创建空集合\"><a href=\"#创建空集合\" class=\"headerlink\" title=\"创建空集合\"></a>创建空集合</h3><p><code>Collections</code>提供了一系列方法来创建空集合：</p>\n<ul>\n<li>创建空List：<code>List&lt;T&gt; emptyList()</code></li>\n<li>创建空Map：<code>Map&lt;K, V&gt; emptyMap()</code></li>\n<li>创建空Set：<code>Set&lt;T&gt; emptySet()</code></li>\n</ul>\n<p>要注意到返回的空集合是不可变集合，无法向其中添加或删除元素。</p>\n<p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建空集合。例如，以下创建空<code>List</code>的两个方法是等价的：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list1</span> <span class=\"operator\">=</span> <span class=\"built_in\">List</span><span class=\"operator\">.</span><span class=\"variable\">of</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"variable\">Collections</span><span class=\"operator\">.</span><span class=\"variable\">emptyList</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建单元素集合\"><a href=\"#创建单元素集合\" class=\"headerlink\" title=\"创建单元素集合\"></a>创建单元素集合</h3><p><code>Collections</code>提供了一系列方法来创建一个单元素集合：</p>\n<ul>\n<li>创建一个元素的List：<code>List&lt;T&gt; singletonList(T o)</code></li>\n<li>创建一个元素的Map：<code>Map&lt;K, V&gt; singletonMap(K key, V value)</code></li>\n<li>创建一个元素的Set：<code>Set&lt;T&gt; singleton(T o)</code></li>\n</ul>\n<p>要注意到返回的单元素集合也是不可变集合，无法向其中添加或删除元素。</p>\n<p>此外，也可以用各个集合接口提供的<code>of(T...)</code>方法创建单元素集合。例如，以下创建单元素<code>List</code>的两个方法是等价的：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list1</span> <span class=\"operator\">=</span> <span class=\"built_in\">List</span><span class=\"operator\">.</span><span class=\"variable\">of</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;apple&quot;</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"variable\">Collections</span><span class=\"operator\">.</span><span class=\"variable\">singletonList</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;apple&quot;</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，使用<code>List.of(T...)</code>更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list1</span> <span class=\"operator\">=</span> <span class=\"built_in\">List</span><span class=\"operator\">.</span><span class=\"variable\">of</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span> <span class=\"operator\">//</span> <span class=\"variable\">empty</span> <span class=\"variable\">list</span></span><br><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list2</span> <span class=\"operator\">=</span> <span class=\"built_in\">List</span><span class=\"operator\">.</span><span class=\"variable\">of</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;apple&quot;</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span> <span class=\"operator\">//</span> <span class=\"number\">1</span> <span class=\"variable\">element</span></span><br><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list3</span> <span class=\"operator\">=</span> <span class=\"built_in\">List</span><span class=\"operator\">.</span><span class=\"variable\">of</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;apple&quot;</span><span class=\"operator\">,</span> <span class=\"string\">&quot;pear&quot;</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span> <span class=\"operator\">//</span> <span class=\"number\">2</span> <span class=\"variable\">elements</span></span><br><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list4</span> <span class=\"operator\">=</span> <span class=\"built_in\">List</span><span class=\"operator\">.</span><span class=\"variable\">of</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;apple&quot;</span><span class=\"operator\">,</span> <span class=\"string\">&quot;pear&quot;</span><span class=\"operator\">,</span> <span class=\"string\">&quot;orange&quot;</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span> <span class=\"operator\">//</span> <span class=\"number\">3</span> <span class=\"variable\">elements</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p><code>Collections</code>可以对<code>List</code>进行排序。因为排序会直接修改<code>List</code>元素的位置，因此必须传入可变<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"洗牌\"><a href=\"#洗牌\" class=\"headerlink\" title=\"洗牌\"></a>洗牌</h3><p><code>Collections</code>提供了洗牌算法，即传入一个有序的<code>List</code>，可以随机打乱<code>List</code>内部元素的顺序，效果相当于让计算机洗牌：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"不可变集合\"><a href=\"#不可变集合\" class=\"headerlink\" title=\"不可变集合\"></a>不可变集合</h3><p><code>Collections</code>还提供了一组方法把可变集合封装成不可变集合：</p>\n<ul>\n<li>封装成不可变List：<code>List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list)</code></li>\n<li>封装成不可变Set：<code>Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; set)</code></li>\n<li>封装成不可变Map：<code>Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</code></li>\n</ul>\n<p>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。我们来看看效果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>然而，继续对原始的可变<code>List</code>进行增删是可以的，并且，会直接影响到封装后的“不可变”<code>List</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因此，如果我们希望把一个可变<code>List</code>封装成不可变<code>List</code>，那么，返回不可变<code>List</code>后，最好立刻扔掉可变<code>List</code>的引用，这样可以保证后续操作不会意外改变原始对象，从而造成“不可变”<code>List</code>变化了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"线程安全集合\"><a href=\"#线程安全集合\" class=\"headerlink\" title=\"线程安全集合\"></a>线程安全集合</h3><p><code>Collections</code>还提供了一组方法，可以把线程不安全的集合变为线程安全的集合：</p>\n<ul>\n<li>变为线程安全的List：<code>List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code></li>\n<li>变为线程安全的Set：<code>Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s)</code></li>\n<li>变为线程安全的Map：<code>Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m)</code></li>\n</ul>\n<p>多线程的概念我们会在后面讲。因为从Java 5开始，引入了更高效的并发集合类，所以上述这几个同步方法已经没有什么用了。</p>\n","categories":["Java","1.Java快速入门","07.集合"],"tags":["写作"]},{"title":"4.操作系统","url":"/2022/02/04/4-Java_2.%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80_4.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"<h1 id=\"进程、线程\"><a href=\"#进程、线程\" class=\"headerlink\" title=\"进程、线程\"></a>进程、线程</h1><h1 id=\"进程-x2F-线程间通讯方式\"><a href=\"#进程-x2F-线程间通讯方式\" class=\"headerlink\" title=\"进程&#x2F;线程间通讯方式\"></a>进程&#x2F;线程间通讯方式</h1><h1 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h1><h1 id=\"进程-x2F-线程状态\"><a href=\"#进程-x2F-线程状态\" class=\"headerlink\" title=\"进程&#x2F;线程状态\"></a>进程&#x2F;线程状态</h1><h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><h1 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h1>","categories":["Java","2.理论基础","4.操作系统"],"tags":["写作"]},{"title":"6.编译原理","url":"/2022/02/04/4-Java_2.%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80_6.%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/","content":"","categories":["Java","2.理论基础","6.编译原理"],"tags":["写作"]},{"title":"5.深入理解计算机系统","url":"/2022/02/04/4-Java_2.%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80_5.%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/","content":"","categories":["Java","2.理论基础","5.深入理解计算机系统"],"tags":["写作"]},{"title":"7.计算机程序的构造和解释","url":"/2022/02/04/4-Java_2.%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80_7.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A/","content":"","categories":["Java","2.理论基础","7.计算机程序的构造和解释"],"tags":["写作"]},{"title":"8.数据库系统概念","url":"/2022/02/04/4-Java_2.%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80_8.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/","content":"","categories":["Java","2.理论基础","8.数据库系统概念"],"tags":["写作"]},{"title":"1.MySQL","url":"/2022/02/04/4-Java_3.JavaEE%E5%9F%BA%E7%A1%80_1.MySQL/","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><h1 id=\"MySQL-搭建\"><a href=\"#MySQL-搭建\" class=\"headerlink\" title=\"MySQL. 搭建\"></a>MySQL. 搭建</h1><h1 id=\"SQL-语句编写\"><a href=\"#SQL-语句编写\" class=\"headerlink\" title=\"SQL. 语句编写\"></a>SQL. 语句编写</h1><h1 id=\"约束\"><a href=\"#约束\" class=\"headerlink\" title=\"约束\"></a>约束</h1><h1 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h1><h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><h1 id=\"设计数据库表\"><a href=\"#设计数据库表\" class=\"headerlink\" title=\"设计数据库表\"></a>设计数据库表</h1><h1 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h1>","categories":["Java","3.JavaEE基础","1.MySQL"],"tags":["写作"]},{"title":"2.开发规范","url":"/2022/02/04/4-Java_3.JavaEE%E5%9F%BA%E7%A1%80_2.%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","content":"<h1 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h1><h1 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h1><h2 id=\"命名\"><a href=\"#命名\" class=\"headerlink\" title=\"命名\"></a>命名</h2><h2 id=\"其他规则\"><a href=\"#其他规则\" class=\"headerlink\" title=\"其他规则\"></a>其他规则</h2><h1 id=\"提交规范\"><a href=\"#提交规范\" class=\"headerlink\" title=\"提交规范\"></a>提交规范</h1>","categories":["Java","3.JavaEE基础","2.开发规范"],"tags":["写作"]},{"title":"3.Git","url":"/2022/02/04/4-Java_3.JavaEE%E5%9F%BA%E7%A1%80_3.Git/","content":"<h1 id=\"工作区\"><a href=\"#工作区\" class=\"headerlink\" title=\"工作区\"></a>工作区</h1><h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><h1 id=\"代码提交、推送、拉取、回退、重置\"><a href=\"#代码提交、推送、拉取、回退、重置\" class=\"headerlink\" title=\"代码提交、推送、拉取、回退、重置\"></a>代码提交、推送、拉取、回退、重置</h1><h1 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h1><h1 id=\"代码合并、解决冲突\"><a href=\"#代码合并、解决冲突\" class=\"headerlink\" title=\"代码合并、解决冲突\"></a>代码合并、解决冲突</h1><h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><h1 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h1>","categories":["Java","3.JavaEE基础","3.Git"],"tags":["写作"]},{"title":"4.Linux","url":"/2022/02/04/4-Java_3.JavaEE%E5%9F%BA%E7%A1%80_4.Linux/","content":"<h1 id=\"Linux系统安装\"><a href=\"#Linux系统安装\" class=\"headerlink\" title=\"Linux系统安装\"></a>Linux系统安装</h1><h1 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h1><h1 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h1><h1 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h1><h1 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h1><h1 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h1><h1 id=\"进程管理\"><a href=\"#进程管理\" class=\"headerlink\" title=\"进程管理\"></a>进程管理</h1><h1 id=\"网络管理\"><a href=\"#网络管理\" class=\"headerlink\" title=\"网络管理\"></a>网络管理</h1><h1 id=\"软件包管理\"><a href=\"#软件包管理\" class=\"headerlink\" title=\"软件包管理\"></a>软件包管理</h1><h1 id=\"服务管理\"><a href=\"#服务管理\" class=\"headerlink\" title=\"服务管理\"></a>服务管理</h1><h1 id=\"日志管理\"><a href=\"#日志管理\" class=\"headerlink\" title=\"日志管理\"></a>日志管理</h1><h1 id=\"Linux内核\"><a href=\"#Linux内核\" class=\"headerlink\" title=\"Linux内核\"></a>Linux内核</h1><h1 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h1><h1 id=\"常用环境搭建\"><a href=\"#常用环境搭建\" class=\"headerlink\" title=\"常用环境搭建\"></a>常用环境搭建</h1><h1 id=\"Shell脚本编程\"><a href=\"#Shell脚本编程\" class=\"headerlink\" title=\"Shell脚本编程\"></a>Shell脚本编程</h1><h1 id=\"VIM的使用\"><a href=\"#VIM的使用\" class=\"headerlink\" title=\"VIM的使用\"></a>VIM的使用</h1>","categories":["Java","3.JavaEE基础","4.Linux"],"tags":["写作"]},{"title":"5.前端基础","url":"/2022/02/04/4-Java_3.JavaEE%E5%9F%BA%E7%A1%80_5.%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/","content":"<h1 id=\"HTML\"><a href=\"#HTML\" class=\"headerlink\" title=\"HTML\"></a>HTML</h1><h1 id=\"CSS\"><a href=\"#CSS\" class=\"headerlink\" title=\"CSS\"></a>CSS</h1><h1 id=\"JavaScript\"><a href=\"#JavaScript\" class=\"headerlink\" title=\"JavaScript\"></a>JavaScript</h1><h2 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a>Ajax</h2><h1 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h1>","categories":["Java","3.JavaEE基础","5.前端基础"],"tags":["写作"]},{"title":"4.MyBatis","url":"/2022/02/04/4-Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_4.MyBatis/","content":"<h2 id=\"描述：数据访问框架，操作数据库进行增删改查等操作\"><a href=\"#描述：数据访问框架，操作数据库进行增删改查等操作\" class=\"headerlink\" title=\"描述：数据访问框架，操作数据库进行增删改查等操作\"></a>描述：数据访问框架，操作数据库进行增删改查等操作</h2><h2 id=\"增删改查\"><a href=\"#增删改查\" class=\"headerlink\" title=\"增删改查\"></a>增删改查</h2><h2 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h2><h2 id=\"动态-SQL\"><a href=\"#动态-SQL\" class=\"headerlink\" title=\"动态. SQL\"></a>动态. SQL</h2><h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><h2 id=\"和其他框架的整合\"><a href=\"#和其他框架的整合\" class=\"headerlink\" title=\"和其他框架的整合\"></a>和其他框架的整合</h2><h2 id=\"逆向工程\"><a href=\"#逆向工程\" class=\"headerlink\" title=\"逆向工程\"></a>逆向工程</h2>","categories":["Java","4.开发框架","4.MyBatis"],"tags":["写作"]},{"title":"1.Java Web","url":"/2022/02/04/4-Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_1.Java%20Web/","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>从本章开始，我们就正式进入到JavaEE的领域。</p>\n<p>什么是JavaEE？JavaEE是Java Platform Enterprise Edition的缩写，即Java企业平台。我们前面介绍的所有基于标准JDK的开发都是JavaSE，即Java Platform Standard Edition。此外，还有一个小众不太常用的JavaME：Java Platform Micro Edition，是Java移动开发平台（非Android），它们三者关系如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌────────────────┐</span><br><span class=\"line\">│     JavaEE     │</span><br><span class=\"line\">│┌──────────────┐│</span><br><span class=\"line\">││    JavaSE    ││</span><br><span class=\"line\">││┌────────────┐││</span><br><span class=\"line\">│││   JavaME   │││</span><br><span class=\"line\">││└────────────┘││</span><br><span class=\"line\">│└──────────────┘│</span><br><span class=\"line\">└────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>JavaME是一个裁剪后的“微型版”JDK，现在使用很少，我们不用管它。JavaEE也不是凭空冒出来的，它实际上是完全基于JavaSE，只是多了一大堆服务器相关的库以及API接口。所有的JavaEE程序，仍然是运行在标准的JavaSE的虚拟机上的。</p>\n<p>最早的JavaEE的名称是J2EE：Java 2 Platform Enterprise Edition，后来改名为JavaEE。由于Oracle将JavaEE移交给<a href=\"https://www.eclipse.org/\">Eclipse</a>开源组织时，不允许他们继续使用Java商标，所以JavaEE再次改名为<a href=\"https://jakarta.ee/\">Jakarta EE</a>。因为这个拼写比较复杂而且难记，所以我们后面还是用JavaEE这个缩写。</p>\n<p>JavaEE并不是一个软件产品，它更多的是一种软件架构和设计思想。我们可以把JavaEE看作是在JavaSE的基础上，开发的一系列基于服务器的组件、API标准和通用架构。</p>\n<p>JavaEE最核心的组件就是基于Servlet标准的Web服务器，开发者编写的应用程序是基于Servlet API并运行在Web服务器内部的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────┐</span><br><span class=\"line\">│┌───────────┐│</span><br><span class=\"line\">││ User App  ││</span><br><span class=\"line\">│├───────────┤│</span><br><span class=\"line\">││Servlet API││</span><br><span class=\"line\">│└───────────┘│</span><br><span class=\"line\">│ Web Server  │</span><br><span class=\"line\">├─────────────┤</span><br><span class=\"line\">│   JavaSE    │</span><br><span class=\"line\">└─────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>此外，JavaEE还有一系列技术标准：</p>\n<ul>\n<li>EJB：Enterprise JavaBean，企业级JavaBean，早期经常用于实现应用程序的业务逻辑，现在基本被轻量级框架如Spring所取代；</li>\n<li>JAAS：Java Authentication and Authorization Service，一个标准的认证和授权服务，常用于企业内部，Web程序通常使用更轻量级的自定义认证；</li>\n<li>JCA：JavaEE Connector Architecture，用于连接企业内部的EIS系统等；</li>\n<li>JMS：Java Message Service，用于消息服务；</li>\n<li>JTA：Java Transaction API，用于分布式事务；</li>\n<li>JAX-WS：Java API for XML Web Services，用于构建基于XML的Web服务；</li>\n<li>…</li>\n</ul>\n<p>目前流行的基于Spring的轻量级JavaEE开发架构，使用最广泛的是Servlet和JMS，以及一系列开源组件。本章我们将详细介绍基于Servlet的Web开发。</p>\n<h1 id=\"Web开发基础\"><a href=\"#Web开发基础\" class=\"headerlink\" title=\"Web开发基础\"></a>Web开发基础</h1><p>今天我们访问网站，使用App时，都是基于Web这种Browser&#x2F;Server模式，简称BS架构，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web页面，并把Web页面展示给用户即可。</p>\n<p>Web页面具有极强的交互性。由于Web页面是用HTML编写的，而HTML具备超强的表现力，并且，服务器端升级后，客户端无需任何部署就可以使用到新的版本，因此，BS架构升级非常容易。</p>\n<h3 id=\"HTTP协议\"><a href=\"#HTTP协议\" class=\"headerlink\" title=\"HTTP协议\"></a>HTTP协议</h3><p>在Web应用中，浏览器请求一个URL，服务器就把生成的HTML网页发送给浏览器，而浏览器和服务器之间的传输协议是HTTP，所以：</p>\n<ul>\n<li>HTML是一种用来定义网页的文本，会HTML，就可以编写网页；</li>\n<li>HTTP是在网络上传输HTML的协议，用于浏览器和服务器的通信。</li>\n</ul>\n<p>HTTP协议是一个基于TCP协议之上的请求-响应协议，它非常简单，我们先使用Chrome浏览器查看新浪首页，然后选择View - Developer - Inspect Elements就可以看到HTML：</p>\n<p>![html](1.Java Web.assets&#x2F;l.jpeg)</p>\n<p>切换到Network，重新加载页面，可以看到浏览器发出的每一个请求和响应：</p>\n<p>![http](1.Java Web.assets&#x2F;l-16418968566141.jpeg)</p>\n<p> 使用Chrome浏览器可以方便地调试Web应用程序。</p>\n<p>对于Browser来说，请求页面的流程如下：</p>\n<ol>\n<li>与服务器建立TCP连接；</li>\n<li>发送HTTP请求；</li>\n<li>收取HTTP响应，然后把网页在浏览器中显示出来。</li>\n</ol>\n<p>浏览器发送的HTTP请求如下：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>www.sina.com.cn</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span><span class=\"punctuation\">: </span>Mozilla/5.0 xxx</span><br><span class=\"line\"><span class=\"attribute\">Accept</span><span class=\"punctuation\">: </span>*/*</span><br><span class=\"line\"><span class=\"attribute\">Accept-Language</span><span class=\"punctuation\">: </span>zh-CN,zh;q=0.9,en-US;q=0.8</span><br></pre></td></tr></table></figure>\n\n<p>其中，第一行表示使用<code>GET</code>请求获取路径为<code>/</code>的资源，并使用<code>HTTP/1.1</code>协议，从第二行开始，每行都是以<code>Header: Value</code>形式表示的HTTP头，比较常用的HTTP Header包括：</p>\n<ul>\n<li>Host: 表示请求的主机名，因为一个服务器上可能运行着多个网站，因此，Host表示浏览器正在请求的域名；</li>\n<li>User-Agent: 标识客户端本身，例如Chrome浏览器的标识类似<code>Mozilla/5.0 ... Chrome/79</code>，IE浏览器的标识类似<code>Mozilla/5.0 (Windows NT ...) like Gecko</code>；</li>\n<li>Accept：表示浏览器能接收的资源类型，如<code>text/*</code>，<code>image/*</code>或者<code>*/*</code>表示所有；</li>\n<li>Accept-Language：表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；</li>\n<li>Accept-Encoding：表示浏览器可以支持的压缩类型，例如<code>gzip, deflate, br</code>。</li>\n</ul>\n<p>服务器的响应如下：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/html</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>21932</span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding</span><span class=\"punctuation\">: </span>gzip</span><br><span class=\"line\"><span class=\"attribute\">Cache-Control</span><span class=\"punctuation\">: </span>max-age=300</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"jboss-cli\">&lt;html&gt;<span class=\"string\">...</span>网页数据<span class=\"string\">...</span></span></span><br></pre></td></tr></table></figure>\n\n<p>服务器响应的第一行总是版本号+空格+数字+空格+文本，数字表示响应代码，其中<code>2xx</code>表示成功，<code>3xx</code>表示重定向，<code>4xx</code>表示客户端引发的错误，<code>5xx</code>表示服务器端引发的错误。数字是给程序识别，文本则是给开发者调试使用的。常见的响应代码有：</p>\n<ul>\n<li>200 OK：表示成功；</li>\n<li>301 Moved Permanently：表示该URL已经永久重定向；</li>\n<li>302 Found：表示该URL需要临时重定向；</li>\n<li>304 Not Modified：表示该资源没有修改，客户端可以使用本地缓存的版本；</li>\n<li>400 Bad Request：表示客户端发送了一个错误的请求，例如参数无效；</li>\n<li>401 Unauthorized：表示客户端因为身份未验证而不允许访问该URL；</li>\n<li>403 Forbidden：表示服务器因为权限问题拒绝了客户端的请求；</li>\n<li>404 Not Found：表示客户端请求了一个不存在的资源；</li>\n<li>500 Internal Server Error：表示服务器处理时内部出错，例如因为无法连接数据库；</li>\n<li>503 Service Unavailable：表示服务器此刻暂时无法处理请求。</li>\n</ul>\n<p>从第二行开始，服务器每一行均返回一个HTTP头。服务器经常返回的HTTP Header包括：</p>\n<ul>\n<li>Content-Type：表示该响应内容的类型，例如<code>text/html</code>，<code>image/jpeg</code>；</li>\n<li>Content-Length：表示该响应内容的长度（字节数）；</li>\n<li>Content-Encoding：表示该响应压缩算法，例如<code>gzip</code>；</li>\n<li>Cache-Control：指示客户端应如何缓存，例如<code>max-age=300</code>表示可以最多缓存300秒。</li>\n</ul>\n<p>HTTP请求和响应都由HTTP Header和HTTP Body构成，其中HTTP Header每行都以<code>\\r\\n</code>结束。如果遇到两个连续的<code>\\r\\n</code>，那么后面就是HTTP Body。浏览器读取HTTP Body，并根据Header信息中指示的<code>Content-Type</code>、<code>Content-Encoding</code>等解压后显示网页、图像或其他内容。</p>\n<p>通常浏览器获取的第一个资源是HTML网页，在网页中，如果嵌入了JavaScript、CSS、图片、视频等其他资源，浏览器会根据资源的URL再次向服务器请求对应的资源。</p>\n<p>关于HTTP协议的详细内容，请参考<a href=\"https://www.amazon.cn/dp/B00M2DKYRC/\">HTTP权威指南</a>一书，或者<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP\">Mozilla开发者网站</a>。</p>\n<p>我们在前面介绍的<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1319099982413858\">HTTP编程</a>是以客户端的身份去请求服务器资源。现在，我们需要以服务器的身份响应客户端请求，编写服务器程序来处理客户端请求通常就称之为Web开发。</p>\n<h3 id=\"编写HTTP-Server\"><a href=\"#编写HTTP-Server\" class=\"headerlink\" title=\"编写HTTP Server\"></a>编写HTTP Server</h3><p>我们来看一下如何编写HTTP Server。一个HTTP Server本质上是一个TCP服务器，我们先用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1305207629676577\">TCP编程</a>的多线程实现的服务器端框架：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket ss = <span class=\"keyword\">new</span> ServerSocket(<span class=\"number\">8080</span>); <span class=\"comment\">// 监听指定端口</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;server is running...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            Socket sock = ss.accept();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;connected from &quot;</span> + sock.getRemoteSocketAddress());</span><br><span class=\"line\">            Thread t = <span class=\"keyword\">new</span> Handler(sock);</span><br><span class=\"line\">            t.start();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    Socket sock;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Socket sock)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sock = sock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">this</span>.sock.getInputStream()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (OutputStream output = <span class=\"keyword\">this</span>.sock.getOutputStream()) &#123;</span><br><span class=\"line\">                handle(input, output);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.sock.close();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (IOException ioe) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;client disconnected.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(InputStream input, OutputStream output)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(input, StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"keyword\">var</span> writer = <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> OutputStreamWriter(output, StandardCharsets.UTF_8));</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 处理HTTP请求</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只需要在<code>handle()</code>方法中，用Reader读取HTTP请求，用Writer发送HTTP响应，即可实现一个最简单的HTTP服务器。编写代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(InputStream input, OutputStream output)</span> throws IOException </span>&#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Process new http request...&quot;</span>);</span><br><span class=\"line\">    var reader = <span class=\"keyword\">new</span> <span class=\"built_in\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class=\"line\">    var writer = <span class=\"keyword\">new</span> <span class=\"built_in\">BufferedWriter</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class=\"line\">    <span class=\"comment\">// 读取HTTP请求:</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> requestOk = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">String</span> first = reader.<span class=\"built_in\">readLine</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first.<span class=\"built_in\">startsWith</span>(<span class=\"string\">&quot;GET / HTTP/1.&quot;</span>)) &#123;</span><br><span class=\"line\">        requestOk = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> header = reader.<span class=\"built_in\">readLine</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (header.<span class=\"built_in\">isEmpty</span>()) &#123; <span class=\"comment\">// 读取到空行时, HTTP Header读取完毕</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(header);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(requestOk ? <span class=\"string\">&quot;Response OK&quot;</span> : <span class=\"string\">&quot;Response Error&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!requestOk) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发送错误响应:</span></span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;HTTP/1.0 404 Not Found\\r\\n&quot;</span>);</span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;Content-Length: 0\\r\\n&quot;</span>);</span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;\\r\\n&quot;</span>);</span><br><span class=\"line\">        writer.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 发送成功响应:</span></span><br><span class=\"line\">        <span class=\"keyword\">String</span> data = <span class=\"string\">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> length = data.<span class=\"built_in\">getBytes</span>(StandardCharsets.UTF_8).length;</span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;HTTP/1.0 200 OK\\r\\n&quot;</span>);</span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;Connection: close\\r\\n&quot;</span>);</span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;Content-Type: text/html\\r\\n&quot;</span>);</span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;Content-Length: &quot;</span> + length + <span class=\"string\">&quot;\\r\\n&quot;</span>);</span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;\\r\\n&quot;</span>); <span class=\"comment\">// 空行标识Header和Body的分隔</span></span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(data);</span><br><span class=\"line\">        writer.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里的核心代码是，先读取HTTP请求，这里我们只处理<code>GET /</code>的请求。当读取到空行时，表示已读到连续两个<code>\\r\\n</code>，说明请求结束，可以发送响应。发送响应的时候，首先发送响应代码<code>HTTP/1.0 200 OK</code>表示一个成功的200响应，使用<code>HTTP/1.0</code>协议，然后，依次发送Header，发送完Header后，再发送一个空行标识Header结束，紧接着发送HTTP Body，在浏览器输入<code>http://local.liaoxuefeng.com:8080/</code>就可以看到响应页面：</p>\n<p>![httpserver](1.Java Web.assets&#x2F;l-16418968566152.jpeg)</p>\n<p>HTTP目前有多个版本，<code>1.0</code>是早期版本，浏览器每次建立TCP连接后，只发送一个HTTP请求并接收一个HTTP响应，然后就关闭TCP连接。由于创建TCP连接本身就需要消耗一定的时间，因此，HTTP 1.1允许浏览器和服务器在同一个TCP连接上反复发送、接收多个HTTP请求和响应，这样就大大提高了传输效率。</p>\n<p>我们注意到HTTP协议是一个请求-响应协议，它总是发送一个请求，然后接收一个响应。能不能一次性发送多个请求，然后再接收多个响应呢？HTTP 2.0可以支持浏览器同时发出多个请求，但每个请求需要唯一标识，服务器可以不按请求的顺序返回多个响应，由浏览器自己把收到的响应和请求对应起来。可见，HTTP 2.0进一步提高了传输效率，因为浏览器发出一个请求后，不必等待响应，就可以继续发下一个请求。</p>\n<p>HTTP 3.0为了进一步提高速度，将抛弃TCP协议，改为使用无需创建连接的UDP协议，目前HTTP 3.0仍然处于实验阶段。</p>\n<h1 id=\"前端基础\"><a href=\"#前端基础\" class=\"headerlink\" title=\"前端基础\"></a>前端基础</h1><h1 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h1><h2 id=\"XML简介\"><a href=\"#XML简介\" class=\"headerlink\" title=\"XML简介\"></a>XML简介</h2><p>XML和JSON是两种经常在网络使用的数据表示格式，本章我们介绍如何使用Java读写XML和JSON。</p>\n<p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p>\n<p>例如，一个描述书籍的XML文档可能如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">note</span> <span class=\"meta-keyword\">SYSTEM</span> <span class=\"meta-string\">&quot;book.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Java核心技术<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">author</span>&gt;</span>Cay S. Horstmann<span class=\"tag\">&lt;/<span class=\"name\">author</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">isbn</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;CN&quot;</span>&gt;</span>1234567<span class=\"tag\">&lt;/<span class=\"name\">isbn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tags</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span>Java<span class=\"tag\">&lt;/<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span>Network<span class=\"tag\">&lt;/<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tags</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">pubDate</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>XML有几个特点：一是纯文本，默认使用UTF-8编码，二是可嵌套，适合表示结构化数据。如果把XML内容存为文件，那么它就是一个XML文件，例如<code>book.xml</code>。此外，XML内容经常通过网络作为消息传输。</p>\n<h3 id=\"XML的结构\"><a href=\"#XML的结构\" class=\"headerlink\" title=\"XML的结构\"></a>XML的结构</h3><p>XML有固定的结构，首行必定是<code>&lt;?xml version=&quot;1.0&quot;?&gt;</code>，可以加上可选的编码。紧接着，如果以类似<code>&lt;!DOCTYPE note SYSTEM &quot;book.dtd&quot;&gt;</code>声明的是文档定义类型（DTD：Document Type Definition），DTD是可选的。接下来是XML的文档内容，一个XML文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性，例如，<code>&lt;isbn lang=&quot;CN&quot;&gt;1234567&lt;/isbn&gt;</code>包含一个属性<code>lang=&quot;CN&quot;</code>，且元素必须正确嵌套。如果是空元素，可以用<code>&lt;tag/&gt;</code>表示。</p>\n<p>由于使用了<code>&lt;</code>、<code>&gt;</code>以及引号等标识符，如果内容出现了特殊符号，需要使用<code>&amp;???;</code>表示转义。例如，<code>Java&lt;tm&gt;</code>必须写成：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Java<span class=\"symbol\">&amp;lt;</span>tm<span class=\"symbol\">&amp;gt;</span><span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>常见的特殊字符如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字符</th>\n<th align=\"left\">表示</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">&lt;</td>\n<td align=\"left\">&lt;</td>\n</tr>\n<tr>\n<td align=\"left\">&gt;</td>\n<td align=\"left\">&gt;</td>\n</tr>\n<tr>\n<td align=\"left\">&amp;</td>\n<td align=\"left\">&amp;</td>\n</tr>\n<tr>\n<td align=\"left\">“</td>\n<td align=\"left\">&quot;</td>\n</tr>\n<tr>\n<td align=\"left\">‘</td>\n<td align=\"left\">&amp;apos;</td>\n</tr>\n</tbody></table>\n<p>格式正确的XML（Well Formed）是指XML的格式是正确的，可以被解析器正常读取。而合法的XML是指，不但XML格式正确，而且它的数据结构可以被DTD或者XSD验证。</p>\n<p>DTD文档可以指定一系列规则，例如：</p>\n<ul>\n<li>根元素必须是<code>book</code></li>\n<li><code>book</code>元素必须包含<code>name</code>，<code>author</code>等指定元素</li>\n<li><code>isbn</code>元素必须包含属性<code>lang</code></li>\n<li>…</li>\n</ul>\n<p>如何验证XML文件的正确性呢？最简单的方式是通过浏览器验证。可以直接把XML文件拖拽到浏览器窗口，如果格式错误，浏览器会报错。</p>\n<p>和结构类似的HTML不同，浏览器对HTML有一定的“容错性”，缺少关闭标签也可以被解析，但XML要求严格的格式，任何没有正确嵌套的标签都会导致错误。</p>\n<p>XML是一个技术体系，除了我们经常用到的XML文档本身外，XML还支持：</p>\n<ul>\n<li>DTD和XSD：验证XML结构和数据是否有效；</li>\n<li>Namespace：XML节点和属性的名字空间；</li>\n<li>XSLT：把XML转化为另一种文本；</li>\n<li>XPath：一种XML节点查询语言；</li>\n<li>…</li>\n</ul>\n<p>实际上，XML的这些相关技术实现起来非常复杂，在实际应用中很少用到，通常了解一下就可以了。</p>\n<h2 id=\"使用DOM\"><a href=\"#使用DOM\" class=\"headerlink\" title=\"使用DOM\"></a>使用DOM</h2><p>因为XML是一种树形结构的文档，它有两种标准的解析API：</p>\n<ul>\n<li>DOM：一次性读取XML，并在内存中表示为树形结构；</li>\n<li>SAX：以流的形式读取XML，使用事件回调。</li>\n</ul>\n<p>我们先来看如何使用DOM来读取XML。</p>\n<p>DOM是Document Object Model的缩写，DOM模型就是把XML结构作为一个树形结构处理，从根节点开始，每个节点都可以包含任意个子节点。</p>\n<p>我们以下面的XML为例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Java核心技术<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">author</span>&gt;</span>Cay S. Horstmann<span class=\"tag\">&lt;/<span class=\"name\">author</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">isbn</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;CN&quot;</span>&gt;</span>1234567<span class=\"tag\">&lt;/<span class=\"name\">isbn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tags</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span>Java<span class=\"tag\">&lt;/<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span>Network<span class=\"tag\">&lt;/<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tags</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">pubDate</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>如果解析为DOM结构，它大概长这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                      ┌─────────┐</span><br><span class=\"line\">                      │document │</span><br><span class=\"line\">                      └─────────┘</span><br><span class=\"line\">                           │</span><br><span class=\"line\">                           ▼</span><br><span class=\"line\">                      ┌─────────┐</span><br><span class=\"line\">                      │  book   │</span><br><span class=\"line\">                      └─────────┘</span><br><span class=\"line\">                           │</span><br><span class=\"line\">     ┌──────────┬──────────┼──────────┬──────────┐</span><br><span class=\"line\">     ▼          ▼          ▼          ▼          ▼</span><br><span class=\"line\">┌─────────┐┌─────────┐┌─────────┐┌─────────┐┌─────────┐</span><br><span class=\"line\">│  name   ││ author  ││  isbn   ││  tags   ││ pubDate │</span><br><span class=\"line\">└─────────┘└─────────┘└─────────┘└─────────┘└─────────┘</span><br><span class=\"line\">                                      │</span><br><span class=\"line\">                                 ┌────┴────┐</span><br><span class=\"line\">                                 ▼         ▼</span><br><span class=\"line\">                             ┌───────┐ ┌───────┐</span><br><span class=\"line\">                             │  tag  │ │  tag  │</span><br><span class=\"line\">                             └───────┘ └───────┘</span><br></pre></td></tr></table></figure>\n\n<p>注意到最顶层的document代表XML文档，它是真正的“根”，而<code>&lt;book&gt;</code>虽然是根元素，但它是<code>document</code>的一个子节点。</p>\n<p>Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：</p>\n<ul>\n<li>Document：代表整个XML文档；</li>\n<li>Element：代表一个XML元素；</li>\n<li>Attribute：代表一个元素的某个属性。</li>\n</ul>\n<p>使用DOM API解析一个XML文档的代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputStream input = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span><span class=\"keyword\">class</span>.get<span class=\"constructor\">ResourceAsStream(<span class=\"string\">&quot;/book.xml&quot;</span>)</span>;</span><br><span class=\"line\">DocumentBuilderFactory dbf = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DocumentBuilderFactory</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">Instance()</span>;</span><br><span class=\"line\">DocumentBuilder db = dbf.<span class=\"keyword\">new</span><span class=\"constructor\">DocumentBuilder()</span>;</span><br><span class=\"line\">Document doc = db.parse(input);</span><br></pre></td></tr></table></figure>\n\n<p><code>DocumentBuilder.parse()</code>用于解析一个XML，它可以接收InputStream，File或者URL，如果解析无误，我们将获得一个Document对象，这个对象代表了整个XML文档的树形结构，需要遍历以便读取指定元素的值：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">void print<span class=\"constructor\">Node(Node <span class=\"params\">n</span>, <span class=\"params\">int</span> <span class=\"params\">indent</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; indent; i++) &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.print(<span class=\"character\">&#x27; &#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    switch (n.get<span class=\"constructor\">NodeType()</span>) &#123;</span><br><span class=\"line\">    case Node.DOCUMENT_NODE: <span class=\"comment\">// Document节点</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Document: &quot;</span> + n.get<span class=\"constructor\">NodeName()</span>);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case Node.ELEMENT_NODE: <span class=\"comment\">// 元素节点</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Element: &quot;</span> + n.get<span class=\"constructor\">NodeName()</span>);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case Node.TEXT_NODE: <span class=\"comment\">// 文本</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Text: &quot;</span> + n.get<span class=\"constructor\">NodeName()</span> + <span class=\"string\">&quot; = &quot;</span> + n.get<span class=\"constructor\">NodeValue()</span>);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    case Node.ATTRIBUTE_NODE: <span class=\"comment\">// 属性</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Attr: &quot;</span> + n.get<span class=\"constructor\">NodeName()</span> + <span class=\"string\">&quot; = &quot;</span> + n.get<span class=\"constructor\">NodeValue()</span>);</span><br><span class=\"line\">        break;</span><br><span class=\"line\">    default: <span class=\"comment\">// 其他</span></span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;NodeType: &quot;</span> + n.get<span class=\"constructor\">NodeType()</span> + <span class=\"string\">&quot;, NodeName: &quot;</span> + n.get<span class=\"constructor\">NodeName()</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Node child = n.get<span class=\"constructor\">FirstChild()</span>; child != null; child = child.get<span class=\"constructor\">NextSibling()</span>) &#123;</span><br><span class=\"line\">        print<span class=\"constructor\">Node(<span class=\"params\">child</span>, <span class=\"params\">indent</span> + 1)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>解析结构如下：</p>\n<figure class=\"highlight dts\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">Document:</span> <span class=\"meta\">#document</span></span><br><span class=\"line\"><span class=\"symbol\"> Element:</span> book</span><br><span class=\"line\"><span class=\"symbol\">  Text:</span> <span class=\"meta\">#text = </span></span><br><span class=\"line\"><span class=\"symbol\">    </span></span><br><span class=\"line\"><span class=\"symbol\">  Element:</span> name</span><br><span class=\"line\"><span class=\"symbol\">   Text:</span> <span class=\"meta\">#text = Java核心技术</span></span><br><span class=\"line\"><span class=\"symbol\">  Text:</span> <span class=\"meta\">#text = </span></span><br><span class=\"line\"><span class=\"symbol\">    </span></span><br><span class=\"line\"><span class=\"symbol\">  Element:</span> author</span><br><span class=\"line\"><span class=\"symbol\">   Text:</span> <span class=\"meta\">#text = Cay S. Horstmann</span></span><br><span class=\"line\"><span class=\"symbol\">  Text:</span> <span class=\"meta\">#text = </span></span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n<p>对于DOM API解析出来的结构，我们从根节点Document出发，可以遍历所有子节点，获取所有元素、属性、文本数据，还可以包括注释，这些节点被统称为Node，每个Node都有自己的Type，根据Type来区分一个Node到底是元素，还是属性，还是文本，等等。</p>\n<p>使用DOM API时，如果要读取某个元素的文本，需要访问它的Text类型的子节点，所以使用起来还是比较繁琐的。</p>\n<h2 id=\"使用SAX\"><a href=\"#使用SAX\" class=\"headerlink\" title=\"使用SAX\"></a>使用SAX</h2><p>使用DOM解析XML的优点是用起来省事，但它的主要缺点是内存占用太大。</p>\n<p>另一种解析XML的方式是SAX。SAX是Simple API for XML的缩写，它是一种基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。</p>\n<p>SAX解析会触发一系列事件：</p>\n<ul>\n<li>startDocument：开始读取XML文档；</li>\n<li>startElement：读取到了一个元素，例如<code>&lt;book&gt;</code>；</li>\n<li>characters：读取到了字符；</li>\n<li>endElement：读取到了一个结束的元素，例如<code>&lt;/book&gt;</code>；</li>\n<li>endDocument：读取XML文档结束。</li>\n</ul>\n<p>如果我们用SAX API解析XML，Java代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputStream input = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span><span class=\"keyword\">class</span>.get<span class=\"constructor\">ResourceAsStream(<span class=\"string\">&quot;/book.xml&quot;</span>)</span>;</span><br><span class=\"line\">SAXParserFactory spf = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">SAXParserFactory</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">Instance()</span>;</span><br><span class=\"line\">SAXParser saxParser = spf.<span class=\"keyword\">new</span><span class=\"constructor\">SAXParser()</span>;</span><br><span class=\"line\">saxParser.parse(input, <span class=\"keyword\">new</span> <span class=\"constructor\">MyHandler()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>关键代码<code>SAXParser.parse()</code>除了需要传入一个<code>InputStream</code>外，还需要传入一个回调对象，这个对象要继承自<code>DefaultHandler</code>：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">class MyHandler extends DefaultHandler &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> startDocument() <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;start document&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> endDocument() <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;end document&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> startElement(<span class=\"keyword\">String</span> uri, <span class=\"keyword\">String</span> localName, <span class=\"keyword\">String</span> qName, Attributes attributes) <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;start element:&quot;</span>, localName, qName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> endElement(<span class=\"keyword\">String</span> uri, <span class=\"keyword\">String</span> localName, <span class=\"keyword\">String</span> qName) <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;end element:&quot;</span>, localName, qName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> characters(<span class=\"built_in\">char</span>[] ch, <span class=\"built_in\">int</span> start, <span class=\"built_in\">int</span> length) <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;characters:&quot;</span>, <span class=\"keyword\">new</span> <span class=\"keyword\">String</span>(ch, start, length));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> error(SAXParseException e) <span class=\"keyword\">throws</span> SAXException &#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;error:&quot;</span>, e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"built_in\">print</span>(<span class=\"keyword\">Object</span>... objs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">Object</span> obj : objs) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">print</span>(obj);</span><br><span class=\"line\">            System.out.<span class=\"built_in\">print</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行SAX解析代码，可以打印出下面的结果：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">start</span> document</span><br><span class=\"line\"><span class=\"built_in\">start</span> <span class=\"keyword\">element</span>:  book</span><br><span class=\"line\"><span class=\"keyword\">characters</span>:</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"built_in\">start</span> <span class=\"keyword\">element</span>:  name</span><br><span class=\"line\"><span class=\"keyword\">characters</span>: Java核心技术</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">end</span> <span class=\"title\">element</span>:  <span class=\"title\">name</span></span></span><br><span class=\"line\"><span class=\"keyword\">characters</span>:</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"built_in\">start</span> <span class=\"keyword\">element</span>:  author</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>如果要读取<code>&lt;name&gt;</code>节点的文本，我们就必须在解析过程中根据<code>startElement()</code>和<code>endElement()</code>定位当前正在读取的节点，可以使用栈结构保存，每遇到一个<code>startElement()</code>入栈，每遇到一个<code>endElement()</code>出栈，这样，读到<code>characters()</code>时我们才知道当前读取的文本是哪个节点的。可见，使用SAX API仍然比较麻烦。</p>\n<h2 id=\"使用Jackson\"><a href=\"#使用Jackson\" class=\"headerlink\" title=\"使用Jackson\"></a>使用Jackson</h2><p>前面我们介绍了DOM和SAX两种解析XML的标准接口。但是，无论是DOM还是SAX，使用起来都不直观。</p>\n<p>观察XML文档的结构：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">book</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;1&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Java核心技术<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">author</span>&gt;</span>Cay S. Horstmann<span class=\"tag\">&lt;/<span class=\"name\">author</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">isbn</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;CN&quot;</span>&gt;</span>1234567<span class=\"tag\">&lt;/<span class=\"name\">isbn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tags</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span>Java<span class=\"tag\">&lt;/<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">tag</span>&gt;</span>Network<span class=\"tag\">&lt;/<span class=\"name\">tag</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">tags</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">pubDate</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们发现，它完全可以对应到一个定义好的JavaBean中：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> author;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> isbn;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">String</span>&gt; tags;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> pubDate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果能直接从XML文档解析成一个JavaBean，那比DOM或者SAX不知道容易到哪里去了。</p>\n<p>幸运的是，一个名叫Jackson的开源的第三方库可以轻松做到XML到JavaBean的转换。我们要使用Jackson，先添加两个Maven的依赖：</p>\n<ul>\n<li>com.fasterxml.jackson.dataformat:jackson-dataformat-xml:2.10.1</li>\n<li>org.codehaus.woodstox:woodstox-core-asl:4.4.1</li>\n</ul>\n<p>然后，定义好JavaBean，就可以用下面几行代码解析：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputStream input = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span><span class=\"keyword\">class</span>.get<span class=\"constructor\">ResourceAsStream(<span class=\"string\">&quot;/book.xml&quot;</span>)</span>;</span><br><span class=\"line\">JacksonXmlModule <span class=\"keyword\">module</span> = <span class=\"keyword\">new</span> <span class=\"constructor\">JacksonXmlModule()</span>;</span><br><span class=\"line\">XmlMapper mapper = <span class=\"keyword\">new</span> <span class=\"constructor\">XmlMapper(<span class=\"params\">module</span>)</span>;</span><br><span class=\"line\">Book book = mapper.read<span class=\"constructor\">Value(<span class=\"params\">input</span>, Book.<span class=\"params\">class</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(book.id);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(book.name);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(book.author);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(book.isbn);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(book.tags);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(book.pubDate);</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>XmlMapper</code>就是我们需要创建的核心对象，可以用<code>readValue(InputStream, Class)</code>直接读取XML并返回一个JavaBean。运行上述代码，就可以直接从Book对象中拿到数据：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\">Java核心技术</span><br><span class=\"line\">Cay S. Horstmann</span><br><span class=\"line\"><span class=\"number\">1234567</span></span><br><span class=\"line\"><span class=\"string\">[Java, Network]</span></span><br><span class=\"line\"><span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n\n<p>如果要解析的数据格式不是Jackson内置的标准格式，那么需要编写一点额外的扩展来告诉Jackson如何自定义解析。这里我们不做深入讨论，可以参考Jackson的<a href=\"https://github.com/FasterXML/jackson\">官方文档</a>。</p>\n<h1 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h1><p>前面我们讨论了XML这种数据格式。XML的特点是功能全面，但标签繁琐，格式复杂。在Web上使用XML现在越来越少，取而代之的是JSON这种数据结构。</p>\n<p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。一个典型的JSON如下：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;id&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Java核心技术&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;author&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;firstName&quot;</span>: <span class=\"string\">&quot;Abc&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;lastName&quot;</span>: <span class=\"string\">&quot;Xyz&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"attr\">&quot;isbn&quot;</span>: <span class=\"string\">&quot;1234567&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;tags&quot;</span>: [<span class=\"string\">&quot;Java&quot;</span>, <span class=\"string\">&quot;Network&quot;</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JSON作为数据传输的格式，有几个显著的优点：</p>\n<ul>\n<li>JSON只允许使用UTF-8编码，不存在编码问题；</li>\n<li>JSON只允许使用双引号作为key，特殊字符用<code>\\</code>转义，格式简单；</li>\n<li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li>\n</ul>\n<p>因此，JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p>\n<ul>\n<li>键值对：<code>&#123;&quot;key&quot;: value&#125;</code></li>\n<li>数组：<code>[1, 2, 3]</code></li>\n<li>字符串：<code>&quot;abc&quot;</code></li>\n<li>数值（整数和浮点数）：<code>12.34</code></li>\n<li>布尔值：<code>true</code>或<code>false</code></li>\n<li>空值：<code>null</code></li>\n</ul>\n<p>浏览器直接支持使用JavaScript对JSON进行读写：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">// JSON string <span class=\"selector-tag\">to</span> JavaScript <span class=\"selector-tag\">object</span>:</span><br><span class=\"line\">jsObj = JSON.<span class=\"built_in\">parse</span>(jsonStr);</span><br><span class=\"line\"></span><br><span class=\"line\">// JavaScript <span class=\"selector-tag\">object</span> <span class=\"selector-tag\">to</span> JSON string:</span><br><span class=\"line\">jsonStr = JSON.<span class=\"built_in\">stringify</span>(jsObj);</span><br></pre></td></tr></table></figure>\n\n<p>所以，开发Web应用的时候，使用JSON作为数据传输，在浏览器端非常方便。因为JSON天生适合JavaScript处理，所以，绝大多数REST API都选择JSON作为数据传输格式。</p>\n<p>现在问题来了：使用Java如何对JSON进行读写？</p>\n<p>在Java中，针对JSON也有标准的JSR 353 API，但是我们在前面讲XML的时候发现，如果能直接在XML和JavaBean之间互相转换是最好的。类似的，如果能直接在JSON和JavaBean之间转换，那么用起来就简单多了。</p>\n<p>常用的用于解析JSON的第三方库有：</p>\n<ul>\n<li>Jackson</li>\n<li>Gson</li>\n<li>Fastjson</li>\n<li>…</li>\n</ul>\n<p>注意到上一节提到的那个可以解析XML的浓眉大眼的Jackson也可以解析JSON！因此我们只需要引入以下Maven依赖：</p>\n<ul>\n<li>com.fasterxml.jackson.core:jackson-databind:2.12.0</li>\n</ul>\n<p>就可以使用下面的代码解析一个JSON文件：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputStream input = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Main</span>.</span></span><span class=\"keyword\">class</span>.get<span class=\"constructor\">ResourceAsStream(<span class=\"string\">&quot;/book.json&quot;</span>)</span>;</span><br><span class=\"line\">ObjectMapper mapper = <span class=\"keyword\">new</span> <span class=\"constructor\">ObjectMapper()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 反序列化时忽略不存在的JavaBean属性:</span></span><br><span class=\"line\">mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class=\"literal\">false</span>);</span><br><span class=\"line\">Book book = mapper.read<span class=\"constructor\">Value(<span class=\"params\">input</span>, Book.<span class=\"params\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>核心代码是创建一个<code>ObjectMapper</code>对象。关闭<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>功能使得解析时如果JavaBean不存在该属性时解析不会报错。</p>\n<p>把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String json = mapper.write<span class=\"constructor\">ValueAsString(<span class=\"params\">book</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>要把JSON的某些值解析为特定的Java对象，例如<code>LocalDate</code>，也是完全可以的。例如：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Java核心技术&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;pubDate&quot;</span>: <span class=\"string\">&quot;2016-09-01&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要解析为：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> LocalDate pubDate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只需要引入标准的JSR 310关于JavaTime的数据格式定义至Maven：</p>\n<ul>\n<li>com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.12.0</li>\n</ul>\n<p>然后，在创建<code>ObjectMapper</code>时，注册一个新的<code>JavaTimeModule</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">ObjectMapper mapper = <span class=\"keyword\">new</span> <span class=\"type\">ObjectMapper</span>().registerModule(<span class=\"keyword\">new</span> <span class=\"type\">JavaTimeModule</span>());</span><br></pre></td></tr></table></figure>\n\n<p>有些时候，内置的解析规则和扩展的解析规则如果都不满足我们的需求，还可以自定义解析。</p>\n<p>举个例子，假设<code>Book</code>类的<code>isbn</code>是一个<code>BigInteger</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> BigInteger isbn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但JSON数据并不是标准的整形格式：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Java核心技术&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;isbn&quot;</span>: <span class=\"string\">&quot;978-7-111-54742-6&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接解析，肯定报错。这时，我们需要自定义一个<code>IsbnDeserializer</code>，用于解析含有非数字的字符串：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IsbnDeserializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">JsonDeserializer&lt;BigInteger&gt;</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">BigInteger</span> deserialize(<span class=\"type\">JsonParser</span> p, <span class=\"type\">DeserializationContext</span> ctxt) <span class=\"keyword\">throws</span> <span class=\"type\">IOException</span>, <span class=\"type\">JsonProcessingException</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取原始的JSON字符串内容:</span></span><br><span class=\"line\">        <span class=\"type\">String</span> s = p.getValueAsString();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">BigInteger</span>(s.replace(<span class=\"string\">&quot;-&quot;</span>, <span class=\"string\">&quot;&quot;</span>));</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (<span class=\"type\">NumberFormatException</span> e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">JsonParseException</span>(p, s, e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，在<code>Book</code>类中使用注解标注：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Book</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"comment\">// 表示反序列化isbn时使用自定义的IsbnDeserializer:</span></span><br><span class=\"line\">    @JsonDeserialize(<span class=\"keyword\">using</span> = IsbnDeserializer.class)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BigInteger isbn;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似的，自定义序列化时我们需要自定义一个<code>IsbnSerializer</code>，然后在<code>Book</code>类中标注<code>@JsonSerialize(using = ...)</code>即可。</p>\n<h3 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h3><p>在反序列化时，Jackson要求Java类需要一个默认的无参数构造方法，否则，无法直接实例化此类。存在带参数构造方法的类，如果要反序列化，注意再提供一个无参数构造方法。</p>\n<p>对于<code>enum</code>字段，Jackson按String类型处理，即：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Book</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> DayOfWeek start = MONDAY;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>序列化为：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;start&quot;</span>: <span class=\"string\">&quot;MONDAY&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>record</code>类型，Jackson会自动找出它的带参数构造方法，并根据JSON的key进行匹配，可直接反序列化。对<code>record</code>类型的支持需要版本<code>2.12.0</code>以上。</p>\n<h1 id=\"Servlet\"><a href=\"#Servlet\" class=\"headerlink\" title=\"Servlet\"></a>Servlet</h1><h2 id=\"Servlet入门\"><a href=\"#Servlet入门\" class=\"headerlink\" title=\"Servlet入门\"></a>Servlet入门</h2><p>在上一节中，我们看到，编写HTTP服务器其实是非常简单的，只需要先编写基于多线程的TCP服务，然后在一个TCP连接中读取HTTP请求，发送HTTP响应即可。</p>\n<p>但是，要编写一个完善的HTTP服务器，以HTTP&#x2F;1.1为例，需要考虑的包括：</p>\n<ul>\n<li>识别正确和错误的HTTP请求；</li>\n<li>识别正确和错误的HTTP头；</li>\n<li>复用TCP连接；</li>\n<li>复用线程；</li>\n<li>IO异常处理；</li>\n<li>…</li>\n</ul>\n<p>这些基础工作需要耗费大量的时间，并且经过长期测试才能稳定运行。如果我们只需要输出一个简单的HTML页面，就不得不编写上千行底层代码，那就根本无法做到高效而可靠地开发。</p>\n<p>因此，在JavaEE平台上，处理TCP连接，解析HTTP协议这些底层工作统统扔给现成的Web服务器去做，我们只需要把自己的应用程序跑在Web服务器上。为了实现这一目的，JavaEE提供了Servlet API，我们使用Servlet API编写自己的Servlet来处理HTTP请求，Web服务器实现Servlet API接口，实现底层功能：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                 ┌───────────┐</span><br><span class=\"line\">                 │My Servlet │</span><br><span class=\"line\">                 ├───────────┤</span><br><span class=\"line\">                 │Servlet API│</span><br><span class=\"line\">┌───────┐  HTTP  ├───────────┤</span><br><span class=\"line\">│Browser│&lt;──────&gt;│Web Server │</span><br><span class=\"line\">└───────┘        └───────────┘</span><br></pre></td></tr></table></figure>\n\n<p>我们来实现一个最简单的Servlet：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// WebServlet注解表示这是一个Servlet，并映射到地址/:</span></span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp)</span><br><span class=\"line\">            <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 设置响应类型:</span></span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取输出流:</span></span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> pw = resp.getWriter();</span><br><span class=\"line\">        <span class=\"comment\">// 写入响应:</span></span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 最后不要忘记flush强制输出:</span></span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个Servlet总是继承自<code>HttpServlet</code>，然后覆写<code>doGet()</code>或<code>doPost()</code>方法。注意到<code>doGet()</code>方法传入了<code>HttpServletRequest</code>和<code>HttpServletResponse</code>两个对象，分别代表HTTP请求和响应。我们使用Servlet API时，并不直接与底层TCP交互，也不需要解析HTTP协议，因为<code>HttpServletRequest</code>和<code>HttpServletResponse</code>就已经封装好了请求和响应。以发送响应为例，我们只需要设置正确的响应类型，然后获取<code>PrintWriter</code>，写入响应即可。</p>\n<p>现在问题来了：Servlet API是谁提供？</p>\n<p>Servlet API是一个jar包，我们需要通过Maven来引入它，才能正常编译。编写<code>pom.xml</code>文件如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>web-servlet-hello<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>war<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.servlet-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">finalName</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">finalName</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意到这个<code>pom.xml</code>与前面我们讲到的普通Java程序有个区别，打包类型不是<code>jar</code>，而是<code>war</code>，表示Java Web Application Archive：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>war<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>引入的Servlet API如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.servlet-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>&lt;scope&gt;</code>指定为<code>provided</code>，表示编译时使用，但不会打包到<code>.war</code>文件中，因为运行期Web服务器本身已经提供了Servlet API相关的jar包。</p>\n<p>我们还需要在工程目录下创建一个<code>web.xml</code>描述文件，放到<code>src/main/webapp/WEB-INF</code>目录下（固定目录结构，不要修改路径，注意大小写）。文件内容可以固定如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">web-app</span> <span class=\"meta-keyword\">PUBLIC</span></span></span><br><span class=\"line\"><span class=\"meta\"> <span class=\"meta-string\">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\"> <span class=\"meta-string\">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">display-name</span>&gt;</span>Archetype Created Web Application<span class=\"tag\">&lt;/<span class=\"name\">display-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>整个工程结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">web-servlet-hello</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │   └── com</span><br><span class=\"line\">        │       └── itranswarp</span><br><span class=\"line\">        │           └── learnjava</span><br><span class=\"line\">        │               └── servlet</span><br><span class=\"line\">        │                   └── HelloServlet.java</span><br><span class=\"line\">        ├── resources</span><br><span class=\"line\">        └── webapp</span><br><span class=\"line\">            └── WEB-INF</span><br><span class=\"line\">                └── web.xml</span><br></pre></td></tr></table></figure>\n\n<p>运行Maven命令<code>mvn clean package</code>，在<code>target</code>目录下得到一个<code>hello.war</code>文件，这个文件就是我们编译打包后的Web应用程序。</p>\n<p>现在问题又来了：我们应该如何运行这个<code>war</code>文件？</p>\n<p>普通的Java程序是通过启动JVM，然后执行<code>main()</code>方法开始运行。但是Web应用程序有所不同，我们无法直接运行<code>war</code>文件，必须先启动Web服务器，再由Web服务器加载我们编写的<code>HelloServlet</code>，这样就可以让<code>HelloServlet</code>处理浏览器发送的请求。</p>\n<p>因此，我们首先要找一个支持Servlet API的Web服务器。常用的服务器有：</p>\n<ul>\n<li><a href=\"https://tomcat.apache.org/\">Tomcat</a>：由Apache开发的开源免费服务器；</li>\n<li><a href=\"https://www.eclipse.org/jetty/\">Jetty</a>：由Eclipse开发的开源免费服务器；</li>\n<li><a href=\"https://javaee.github.io/glassfish/\">GlassFish</a>：一个开源的全功能JavaEE服务器。</li>\n</ul>\n<p>还有一些收费的商用服务器，如Oracle的<a href=\"https://www.oracle.com/middleware/weblogic/\">WebLogic</a>，IBM的<a href=\"https://www.ibm.com/cloud/websphere-application-platform/\">WebSphere</a>。</p>\n<p>无论使用哪个服务器，只要它支持Servlet API 4.0（因为我们引入的Servlet版本是4.0），我们的war包都可以在上面运行。这里我们选择使用最广泛的开源免费的Tomcat服务器。</p>\n<p>要运行我们的<code>hello.war</code>，首先要<a href=\"https://tomcat.apache.org/download-90.cgi\">下载Tomcat服务器</a>，解压后，把<code>hello.war</code>复制到Tomcat的<code>webapps</code>目录下，然后切换到<code>bin</code>目录，执行<code>startup.sh</code>或<code>startup.bat</code>启动Tomcat服务器：</p>\n<figure class=\"highlight powershell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$</span> ./startup.sh </span><br><span class=\"line\"><span class=\"keyword\">Using</span> CATALINA_BASE:   .../apache-tomcat-9.0.30</span><br><span class=\"line\"><span class=\"keyword\">Using</span> CATALINA_HOME:   .../apache-tomcat-9.0.30</span><br><span class=\"line\"><span class=\"keyword\">Using</span> CATALINA_TMPDIR: .../apache-tomcat-9.0.30/temp</span><br><span class=\"line\"><span class=\"keyword\">Using</span> JRE_HOME:        .../jdk-11.jdk/Contents/Home</span><br><span class=\"line\"><span class=\"keyword\">Using</span> CLASSPATH:       .../apache-tomcat-9.0.30/bin/bootstrap.jar:...</span><br><span class=\"line\">Tomcat started.</span><br></pre></td></tr></table></figure>\n\n<p>在浏览器输入<code>http://localhost:8080/hello/</code>即可看到<code>HelloServlet</code>的输出：</p>\n<p>![hello-servlet](1.Java Web.assets&#x2F;l-16418970471826.jpeg)</p>\n<p>细心的童鞋可能会问，为啥路径是<code>/hello/</code>而不是<code>/</code>？因为一个Web服务器允许同时运行多个Web App，而我们的Web App叫<code>hello</code>，因此，第一级目录<code>/hello</code>表示Web App的名字，后面的<code>/</code>才是我们在<code>HelloServlet</code>中映射的路径。</p>\n<p>那能不能直接使用<code>/</code>而不是<code>/hello/</code>？毕竟<code>/</code>比较简洁。</p>\n<p>答案是肯定的。先关闭Tomcat（执行<code>shutdown.sh</code>或<code>shutdown.bat</code>），然后删除Tomcat的webapps目录下的所有文件夹和文件，最后把我们的<code>hello.war</code>复制过来，改名为<code>ROOT.war</code>，文件名为<code>ROOT</code>的应用程序将作为默认应用，启动后直接访问<code>http://localhost:8080/</code>即可。</p>\n<p>实际上，类似Tomcat这样的服务器也是Java编写的，启动Tomcat服务器实际上是启动Java虚拟机，执行Tomcat的<code>main()</code>方法，然后由Tomcat负责加载我们的<code>.war</code>文件，并创建一个<code>HelloServlet</code>实例，最后以多线程的模式来处理HTTP请求。如果Tomcat服务器收到的请求路径是<code>/</code>（假定部署文件为ROOT.war），就转发到<code>HelloServlet</code>并传入<code>HttpServletRequest</code>和<code>HttpServletResponse</code>两个对象。</p>\n<p>因为我们编写的Servlet并不是直接运行，而是由Web服务器加载后创建实例运行，所以，类似Tomcat这样的Web服务器也称为Servlet容器。</p>\n<p>在Servlet容器中运行的Servlet具有如下特点：</p>\n<ul>\n<li>无法在代码中直接通过new创建Servlet实例，必须由Servlet容器自动创建Servlet实例；</li>\n<li>Servlet容器只会给每个Servlet类创建唯一实例；</li>\n<li>Servlet容器会使用多线程执行<code>doGet()</code>或<code>doPost()</code>方法。</li>\n</ul>\n<p>复习一下Java<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255943750561472\">多线程</a>的内容，我们可以得出结论：</p>\n<ul>\n<li>在Servlet中定义的实例变量会被多个线程同时访问，要注意线程安全；</li>\n<li><code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例是由Servlet容器传入的局部变量，它们只能被当前线程访问，不存在多个线程访问的问题；</li>\n<li>在<code>doGet()</code>或<code>doPost()</code>方法中，如果使用了<code>ThreadLocal</code>，但没有清理，那么它的状态很可能会影响到下次的某个请求，因为Servlet容器很可能用线程池实现线程复用。</li>\n</ul>\n<p>因此，正确编写Servlet，要清晰理解Java的多线程模型，需要同步访问的必须同步。</p>\n<h2 id=\"Servlet开发\"><a href=\"#Servlet开发\" class=\"headerlink\" title=\"Servlet开发\"></a>Servlet开发</h2><p>在上一节中，我们看到，一个完整的Web应用程序的开发流程如下：</p>\n<ol>\n<li>编写Servlet；</li>\n<li>打包为war文件；</li>\n<li>复制到Tomcat的webapps目录下；</li>\n<li>启动Tomcat。</li>\n</ol>\n<p>这个过程是不是很繁琐？如果我们想在IDE中断点调试，还需要打开Tomcat的远程调试端口并且连接上去。</p>\n<p>![javaee-expert](1.Java Web.assets&#x2F;l-16418970592428.png)</p>\n<p>![javaee-newbee](1.Java Web.assets&#x2F;l-16418970592429.png)</p>\n<p>许多初学者经常卡在如何在IDE中启动Tomcat并加载webapp，更不要说断点调试了。</p>\n<p>我们需要一种简单可靠，能直接在IDE中启动并调试webapp的方法。</p>\n<p>因为Tomcat实际上也是一个Java程序，我们看看Tomcat的启动流程：</p>\n<ol>\n<li>启动JVM并执行Tomcat的<code>main()</code>方法；</li>\n<li>加载war并初始化Servlet；</li>\n<li>正常服务。</li>\n</ol>\n<p>启动Tomcat无非就是设置好classpath并执行Tomcat某个jar包的<code>main()</code>方法，我们完全可以把Tomcat的jar包全部引入进来，然后自己编写一个<code>main()</code>方法，先启动Tomcat，然后让它加载我们的webapp就行。</p>\n<p>我们新建一个<code>web-servlet-embedded</code>工程，编写<code>pom.xml</code>如下：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>web-servlet-embedded<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>war<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">tomcat.version</span>&gt;</span>9.0.26<span class=\"tag\">&lt;/<span class=\"name\">tomcat.version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.tomcat.embed<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>tomcat-embed-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$</span><span class=\"template-variable\">&#123;tomcat.version&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.tomcat.embed<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>tomcat-embed-jasper<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$</span><span class=\"template-variable\">&#123;tomcat.version&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>&lt;packaging&gt;</code>类型仍然为<code>war</code>，引入依赖<code>tomcat-embed-core</code>和<code>tomcat-embed-jasper</code>，引入的Tomcat版本<code>&lt;tomcat.version&gt;</code>为<code>9.0.26</code>。</p>\n<p>不必引入Servlet API，因为引入Tomcat依赖后自动引入了Servlet API。因此，我们可以正常编写Servlet如下：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> name = req.getParameter(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            name = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> pw = resp.getWriter();</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;h1&gt;Hello, &quot;</span> + name + <span class=\"string\">&quot;!&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们编写一个<code>main()</code>方法，启动Tomcat服务器：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> void main(<span class=\"keyword\">String</span>[] args) throws Exception &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 启动Tomcat:</span></span><br><span class=\"line\">        Tomcat tomcat = <span class=\"keyword\">new</span> <span class=\"type\">Tomcat</span>();</span><br><span class=\"line\">        tomcat.setPort(Integer.getInteger(<span class=\"string\">&quot;port&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\">        tomcat.getConnector();</span><br><span class=\"line\">        <span class=\"comment\">// 创建webapp:</span></span><br><span class=\"line\">        Context ctx = tomcat.addWebapp(<span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">&quot;src/main/webapp&quot;</span>).getAbsolutePath());</span><br><span class=\"line\">        WebResourceRoot resources = <span class=\"keyword\">new</span> <span class=\"type\">StandardRoot</span>(ctx);</span><br><span class=\"line\">        resources.addPreResources(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"type\">DirResourceSet</span>(resources, <span class=\"string\">&quot;/WEB-INF/classes&quot;</span>, <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">&quot;target/classes&quot;</span>).getAbsolutePath(), <span class=\"string\">&quot;/&quot;</span>));</span><br><span class=\"line\">        ctx.setResources(resources);</span><br><span class=\"line\">        tomcat.start();</span><br><span class=\"line\">        tomcat.getServer().await();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们直接运行<code>main()</code>方法，即可启动嵌入式Tomcat服务器，然后，通过预设的<code>tomcat.addWebapp(&quot;&quot;, new File(&quot;src/main/webapp&quot;)</code>，Tomcat会自动加载当前工程作为根webapp，可直接在浏览器访问<code>http://localhost:8080/</code>：</p>\n<p>![embedded-tomcat](1.Java Web.assets&#x2F;l-164189705924210.png)</p>\n<p>通过<code>main()</code>方法启动Tomcat服务器并加载我们自己的webapp有如下好处：</p>\n<ol>\n<li>启动简单，无需下载Tomcat或安装任何IDE插件；</li>\n<li>调试方便，可在IDE中使用断点调试；</li>\n<li>使用Maven创建war包后，也可以正常部署到独立的Tomcat服务器中。</li>\n</ol>\n<p>对SpringBoot有所了解的童鞋可能知道，SpringBoot也支持在<code>main()</code>方法中一行代码直接启动Tomcat，并且还能方便地更换成Jetty等其他服务器。它的启动方式和我们介绍的是基本一样的，后续涉及到SpringBoot的部分我们还会详细讲解。</p>\n<h2 id=\"Servlet进阶\"><a href=\"#Servlet进阶\" class=\"headerlink\" title=\"Servlet进阶\"></a>Servlet进阶</h2><h3 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>一个Web App就是由一个或多个Servlet组成的，每个Servlet通过注解说明自己能处理的路径。例如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/hello&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述<code>HelloServlet</code>能处理<code>/hello</code>这个路径的请求。</p>\n<p> 早期的Servlet需要在web.xml中配置映射路径，但最新Servlet版本只需要通过注解就可以完成映射。</p>\n<p>因为浏览器发送请求的时候，还会有请求方法（HTTP Method）：即GET、POST、PUT等不同类型的请求。因此，要处理GET请求，我们要覆写<code>doGet()</code>方法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/hello&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似的，要处理POST请求，就需要覆写<code>doPost()</code>方法。</p>\n<p>如果没有覆写<code>doPost()</code>方法，那么<code>HelloServlet</code>能不能处理<code>POST /hello</code>请求呢？</p>\n<p>我们查看一下<code>HttpServlet</code>的<code>doPost()</code>方法就一目了然了：它会直接返回405或400错误。因此，一个Servlet如果映射到<code>/hello</code>，那么所有请求方法都会由这个Servlet处理，至于能不能返回200成功响应，要看有没有覆写对应的请求方法。</p>\n<p>一个Webapp完全可以有多个Servlet，分别映射不同的路径。例如：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/hello&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/signin&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SignInServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>浏览器发出的HTTP请求总是由Web Server先接收，然后，根据Servlet配置的映射，不同的路径转发到不同的Servlet：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">               ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\"></span><br><span class=\"line\">               │            /hello    ┌───────────────┐│</span><br><span class=\"line\">                          ┌──────────&gt;│ HelloServlet  │</span><br><span class=\"line\">               │          │           └───────────────┘│</span><br><span class=\"line\">┌───────┐    ┌──────────┐ │ /signin   ┌───────────────┐</span><br><span class=\"line\">│Browser│───&gt;│Dispatcher│─┼──────────&gt;│ SignInServlet ││</span><br><span class=\"line\">└───────┘    └──────────┘ │           └───────────────┘</span><br><span class=\"line\">               │          │ /         ┌───────────────┐│</span><br><span class=\"line\">                          └──────────&gt;│ IndexServlet  │</span><br><span class=\"line\">               │                      └───────────────┘│</span><br><span class=\"line\">                              Web Server</span><br><span class=\"line\">               └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>这种根据路径转发的功能我们一般称为Dispatch。映射到<code>/</code>的<code>IndexServlet</code>比较特殊，它实际上会接收所有未匹配的路径，相当于<code>/*</code>，因为Dispatcher的逻辑可以用伪代码实现如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String path =<span class=\"operator\"> ...</span></span><br><span class=\"line\"><span class=\"operator\"></span><span class=\"keyword\">if</span> (path.equals(<span class=\"string\">&quot;/hello&quot;</span>)) &#123;</span><br><span class=\"line\">    dispatch<span class=\"constructor\">To(<span class=\"params\">helloServlet</span>)</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (path.equals(<span class=\"string\">&quot;/signin&quot;</span>)) &#123;</span><br><span class=\"line\">    dispatch<span class=\"constructor\">To(<span class=\"params\">signinServlet</span>)</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 所有未匹配的路径均转发到&quot;/&quot;</span></span><br><span class=\"line\">    dispatch<span class=\"constructor\">To(<span class=\"params\">indexServlet</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以我们在浏览器输入一个<code>http://localhost:8080/abc</code>也会看到<code>IndexServlet</code>生成的页面。</p>\n<h4 id=\"HttpServletRequest\"><a href=\"#HttpServletRequest\" class=\"headerlink\" title=\"HttpServletRequest\"></a>HttpServletRequest</h4><p><code>HttpServletRequest</code>封装了一个HTTP请求，它实际上是从<code>ServletRequest</code>继承而来。最早设计Servlet时，设计者希望Servlet不仅能处理HTTP，也能处理类似SMTP等其他协议，因此，单独抽出了<code>ServletRequest</code>接口，但实际上除了HTTP外，并没有其他协议会用Servlet处理，所以这是一个过度设计。</p>\n<p>我们通过<code>HttpServletRequest</code>提供的接口方法可以拿到HTTP请求的几乎全部信息，常用的方法有：</p>\n<ul>\n<li>getMethod()：返回请求方法，例如，<code>&quot;GET&quot;</code>，<code>&quot;POST&quot;</code>；</li>\n<li>getRequestURI()：返回请求路径，但不包括请求参数，例如，<code>&quot;/hello&quot;</code>；</li>\n<li>getQueryString()：返回请求参数，例如，<code>&quot;name=Bob&amp;a=1&amp;b=2&quot;</code>；</li>\n<li>getParameter(name)：返回请求参数，GET请求从URL读取参数，POST请求从Body中读取参数；</li>\n<li>getContentType()：获取请求Body的类型，例如，<code>&quot;application/x-www-form-urlencoded&quot;</code>；</li>\n<li>getContextPath()：获取当前Webapp挂载的路径，对于ROOT来说，总是返回空字符串<code>&quot;&quot;</code>；</li>\n<li>getCookies()：返回请求携带的所有Cookie；</li>\n<li>getHeader(name)：获取指定的Header，对Header名称不区分大小写；</li>\n<li>getHeaderNames()：返回所有Header名称；</li>\n<li>getInputStream()：如果该请求带有HTTP Body，该方法将打开一个输入流用于读取Body；</li>\n<li>getReader()：和getInputStream()类似，但打开的是Reader；</li>\n<li>getRemoteAddr()：返回客户端的IP地址；</li>\n<li>getScheme()：返回协议类型，例如，<code>&quot;http&quot;</code>，<code>&quot;https&quot;</code>；</li>\n</ul>\n<p>此外，<code>HttpServletRequest</code>还有两个方法：<code>setAttribute()</code>和<code>getAttribute()</code>，可以给当前<code>HttpServletRequest</code>对象附加多个Key-Value，相当于把<code>HttpServletRequest</code>当作一个<code>Map&lt;String, Object&gt;</code>使用。</p>\n<p>调用<code>HttpServletRequest</code>的方法时，注意务必阅读接口方法的文档说明，因为有的方法会返回<code>null</code>，例如<code>getQueryString()</code>的文档就写了：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"code\"><pre><span class=\"line\">... This <span class=\"function\"><span class=\"keyword\">method</span> <span class=\"title\">returns</span> <span class=\"title\">null</span> <span class=\"title\">if</span> <span class=\"title\">the</span> <span class=\"title\">URL</span> <span class=\"title\">does</span> <span class=\"title\">not</span> <span class=\"title\">have</span> <span class=\"title\">a</span> <span class=\"title\">query</span> <span class=\"title\">string</span>...</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"HttpServletResponse\"><a href=\"#HttpServletResponse\" class=\"headerlink\" title=\"HttpServletResponse\"></a>HttpServletResponse</h4><p><code>HttpServletResponse</code>封装了一个HTTP响应。由于HTTP响应必须先发送Header，再发送Body，所以，操作<code>HttpServletResponse</code>对象时，必须先调用设置Header的方法，最后调用发送Body的方法。</p>\n<p>常用的设置Header的方法有：</p>\n<ul>\n<li>setStatus(sc)：设置响应代码，默认是<code>200</code>；</li>\n<li>setContentType(type)：设置Body的类型，例如，<code>&quot;text/html&quot;</code>；</li>\n<li>setCharacterEncoding(charset)：设置字符编码，例如，<code>&quot;UTF-8&quot;</code>；</li>\n<li>setHeader(name, value)：设置一个Header的值；</li>\n<li>addCookie(cookie)：给响应添加一个Cookie；</li>\n<li>addHeader(name, value)：给响应添加一个Header，因为HTTP协议允许有多个相同的Header；</li>\n</ul>\n<p>写入响应时，需要通过<code>getOutputStream()</code>获取写入流，或者通过<code>getWriter()</code>获取字符流，二者只能获取其中一个。</p>\n<p>写入响应前，无需设置<code>setContentLength()</code>，因为底层服务器会根据写入的字节数自动设置，如果写入的数据量很小，实际上会先写入缓冲区，如果写入的数据量很大，服务器会自动采用Chunked编码让浏览器能识别数据结束符而不需要设置Content-Length头。</p>\n<p>但是，写入完毕后调用<code>flush()</code>却是必须的，因为大部分Web服务器都基于HTTP&#x2F;1.1协议，会复用TCP连接。如果没有调用<code>flush()</code>，将导致缓冲区的内容无法及时发送到客户端。此外，写入完毕后千万不要调用<code>close()</code>，原因同样是因为会复用TCP连接，如果关闭写入流，将关闭TCP连接，使得Web服务器无法复用此TCP连接。</p>\n<p> 写入完毕后对输出流调用flush()而不是close()方法！</p>\n<p>有了<code>HttpServletRequest</code>和<code>HttpServletResponse</code>这两个高级接口，我们就不需要直接处理HTTP协议。注意到具体的实现类是由各服务器提供的，而我们编写的Web应用程序只关心接口方法，并不需要关心具体实现的子类。</p>\n<h4 id=\"Servlet多线程模型\"><a href=\"#Servlet多线程模型\" class=\"headerlink\" title=\"Servlet多线程模型\"></a>Servlet多线程模型</h4><p>一个Servlet类在服务器中只有一个实例，但对于每个HTTP请求，Web服务器会使用多线程执行请求。因此，一个Servlet的<code>doGet()</code>、<code>doPost()</code>等处理请求的方法是多线程并发执行的。如果Servlet中定义了字段，要注意多线程并发访问的问题：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">String</span>&gt; map = <span class=\"keyword\">new</span> <span class=\"type\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 注意读写map字段是多线程并发的:</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.map.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于每个请求，Web服务器会创建唯一的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例，因此，<code>HttpServletRequest</code>和<code>HttpServletResponse</code>实例只有在当前处理线程中有效，它们总是局部变量，不存在多线程共享的问题。</p>\n<h3 id=\"重定向与转发\"><a href=\"#重定向与转发\" class=\"headerlink\" title=\"重定向与转发\"></a>重定向与转发</h3><h4 id=\"Redirect\"><a href=\"#Redirect\" class=\"headerlink\" title=\"Redirect\"></a>Redirect</h4><p>重定向是指当浏览器请求一个URL时，服务器返回一个重定向指令，告诉浏览器地址已经变了，麻烦使用新的URL再重新发送新请求。</p>\n<p>例如，我们已经编写了一个能处理<code>/hello</code>的<code>HelloServlet</code>，如果收到的路径为<code>/hi</code>，希望能重定向到<code>/hello</code>，可以再编写一个<code>RedirectServlet</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/hi&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedirectServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 构造重定向的路径:</span></span><br><span class=\"line\">        <span class=\"type\">String</span> name = req.getParameter(<span class=\"string\">&quot;name&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> redirectToUrl = <span class=\"string\">&quot;/hello&quot;</span> + (name == <span class=\"literal\">null</span> ? <span class=\"string\">&quot;&quot;</span> : <span class=\"string\">&quot;?name=&quot;</span> + name);</span><br><span class=\"line\">        <span class=\"comment\">// 发送重定向响应:</span></span><br><span class=\"line\">        resp.sendRedirect(redirectToUrl);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果浏览器发送<code>GET /hi</code>请求，<code>RedirectServlet</code>将处理此请求。由于<code>RedirectServlet</code>在内部又发送了重定向响应，因此，浏览器会收到如下响应：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">302</span> Found</span><br><span class=\"line\"><span class=\"attribute\">Location</span><span class=\"punctuation\">: </span>/hello</span><br></pre></td></tr></table></figure>\n\n<p>当浏览器收到302响应后，它会立刻根据<code>Location</code>的指示发送一个新的<code>GET /hello</code>请求，这个过程就是重定向：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────┐   GET /hi     ┌───────────────┐</span><br><span class=\"line\">│Browser│ ────────────&gt; │RedirectServlet│</span><br><span class=\"line\">│       │ &lt;──────────── │               │</span><br><span class=\"line\">└───────┘   302         └───────────────┘</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">┌───────┐  GET /hello   ┌───────────────┐</span><br><span class=\"line\">│Browser│ ────────────&gt; │ HelloServlet  │</span><br><span class=\"line\">│       │ &lt;──────────── │               │</span><br><span class=\"line\">└───────┘   200 &lt;html&gt;  └───────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>观察Chrome浏览器的网络请求，可以看到两次HTTP请求：</p>\n<p>![redirect](1.Java Web.assets&#x2F;l-164189709784914.jpeg)</p>\n<p>并且浏览器的地址栏路径自动更新为<code>/hello</code>。</p>\n<p>重定向有两种：一种是302响应，称为临时重定向，一种是301响应，称为永久重定向。两者的区别是，如果服务器发送301永久重定向响应，浏览器会缓存<code>/hi</code>到<code>/hello</code>这个重定向的关联，下次请求<code>/hi</code>的时候，浏览器就直接发送<code>/hello</code>请求了。</p>\n<p>重定向有什么作用？重定向的目的是当Web应用升级后，如果请求路径发生了变化，可以将原来的路径重定向到新路径，从而避免浏览器请求原路径找不到资源。</p>\n<p><code>HttpServletResponse</code>提供了快捷的<code>redirect()</code>方法实现302重定向。如果要实现301永久重定向，可以这么写：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">resp</span><span class=\"selector-class\">.setStatus</span>(HttpServletResponse.SC_MOVED_PERMANENTLY); <span class=\"comment\">// 301</span></span><br><span class=\"line\"><span class=\"selector-tag\">resp</span><span class=\"selector-class\">.setHeader</span>(<span class=\"string\">&quot;Location&quot;</span>, <span class=\"string\">&quot;/hello&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Forward\"><a href=\"#Forward\" class=\"headerlink\" title=\"Forward\"></a>Forward</h4><p>Forward是指内部转发。当一个Servlet处理请求的时候，它可以决定自己不继续处理，而是转发给另一个Servlet处理。</p>\n<p>例如，我们已经编写了一个能处理<code>/hello</code>的<code>HelloServlet</code>，继续编写一个能处理<code>/morning</code>的<code>ForwardServlet</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/morning&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForwardServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        req.getRequestDispatcher(<span class=\"string\">&quot;/hello&quot;</span>).forward(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ForwardServlet</code>在收到请求后，它并不自己发送响应，而是把请求和响应都转发给路径为<code>/hello</code>的Servlet，即下面的代码：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">req</span><span class=\"selector-class\">.getRequestDispatcher</span>(<span class=\"string\">&quot;/hello&quot;</span>)<span class=\"selector-class\">.forward</span>(req, resp);</span><br></pre></td></tr></table></figure>\n\n<p>后续请求的处理实际上是由<code>HelloServlet</code>完成的。这种处理方式称为转发（Forward），我们用流程图画出来如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                          ┌────────────────────────┐</span><br><span class=\"line\">                          │      ┌───────────────┐ │</span><br><span class=\"line\">                          │ ────&gt;│ForwardServlet │ │</span><br><span class=\"line\">┌───────┐  GET /morning   │      └───────────────┘ │</span><br><span class=\"line\">│Browser│ ──────────────&gt; │              │         │</span><br><span class=\"line\">│       │ &lt;────────────── │              ▼         │</span><br><span class=\"line\">└───────┘    200 &lt;html&gt;   │      ┌───────────────┐ │</span><br><span class=\"line\">                          │ &lt;────│ HelloServlet  │ │</span><br><span class=\"line\">                          │      └───────────────┘ │</span><br><span class=\"line\">                          │       Web Server       │</span><br><span class=\"line\">                          └────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>转发和重定向的区别在于，转发是在Web服务器内部完成的，对浏览器来说，它只发出了一个HTTP请求：</p>\n<p>![forward](1.Java Web.assets&#x2F;l-164189709784915.jpeg)</p>\n<p>注意到使用转发的时候，浏览器的地址栏路径仍然是<code>/morning</code>，浏览器并不知道该请求在Web服务器内部实际上做了一次转发。</p>\n<h3 id=\"使用Session和Cookie\"><a href=\"#使用Session和Cookie\" class=\"headerlink\" title=\"使用Session和Cookie\"></a>使用Session和Cookie</h3><p>在Web应用程序中，我们经常要跟踪用户身份。当一个用户登录成功后，如果他继续访问其他页面，Web程序如何才能识别出该用户身份？</p>\n<p>因为HTTP协议是一个无状态协议，即Web应用程序无法区分收到的两个HTTP请求是否是同一个浏览器发出的。为了跟踪用户状态，服务器可以向浏览器分配一个唯一ID，并以Cookie的形式发送到浏览器，浏览器在后续访问时总是附带此Cookie，这样，服务器就可以识别用户身份。</p>\n<h4 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h4><p>我们把这种基于唯一ID识别用户身份的机制称为Session。每个用户第一次访问服务器后，会自动获得一个Session ID。如果用户在一段时间内没有访问服务器，那么Session会自动失效，下次即使带着上次分配的Session ID访问，服务器也认为这是一个新用户，会分配新的Session ID。</p>\n<p>JavaEE的Servlet机制内建了对Session的支持。我们以登录为例，当一个用户登录成功后，我们就可以把这个用户的名字放入一个<code>HttpSession</code>对象，以便后续访问其他页面的时候，能直接从<code>HttpSession</code>取出用户名：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebServlet(<span class=\"params\">urlPatterns</span> = <span class=\"string\">&quot;/signin&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> SignInServlet extends HttpServlet &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 模拟一个数据库:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, String&gt; users = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Map</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"string\">&quot;bob&quot;</span>, <span class=\"string\">&quot;bob123&quot;</span>, <span class=\"string\">&quot;alice&quot;</span>, <span class=\"string\">&quot;alice123&quot;</span>, <span class=\"string\">&quot;tom&quot;</span>, <span class=\"string\">&quot;tomcat&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// GET请求时显示登录页:</span></span><br><span class=\"line\">    protected void <span class=\"keyword\">do</span><span class=\"constructor\">Get(HttpServletRequest <span class=\"params\">req</span>, HttpServletResponse <span class=\"params\">resp</span>)</span> throws ServletException, IOException &#123;</span><br><span class=\"line\">        resp.set<span class=\"constructor\">ContentType(<span class=\"string\">&quot;text/html&quot;</span>)</span>;</span><br><span class=\"line\">        PrintWriter pw = resp.get<span class=\"constructor\">Writer()</span>;</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;h1&gt;Sign In&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;form action=\\&quot;/signin\\&quot; method=\\&quot;post\\&quot;&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;p&gt;Username: &lt;input name=\\&quot;username\\&quot;&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;p&gt;Password: &lt;input name=\\&quot;password\\&quot; type=\\&quot;password\\&quot;&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;p&gt;&lt;button type=\\&quot;submit\\&quot;&gt;Sign In&lt;/button&gt; &lt;a href=\\&quot;/\\&quot;&gt;Cancel&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;/form&gt;&quot;</span>);</span><br><span class=\"line\">        pw.flush<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// POST请求时处理用户登录:</span></span><br><span class=\"line\">    protected void <span class=\"keyword\">do</span><span class=\"constructor\">Post(HttpServletRequest <span class=\"params\">req</span>, HttpServletResponse <span class=\"params\">resp</span>)</span> throws ServletException, IOException &#123;</span><br><span class=\"line\">        String name = req.get<span class=\"constructor\">Parameter(<span class=\"string\">&quot;username&quot;</span>)</span>;</span><br><span class=\"line\">        String password = req.get<span class=\"constructor\">Parameter(<span class=\"string\">&quot;password&quot;</span>)</span>;</span><br><span class=\"line\">        String expectedPassword = users.get(name.<span class=\"keyword\">to</span><span class=\"constructor\">LowerCase()</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (expectedPassword != null<span class=\"operator\"> &amp;&amp; </span>expectedPassword.equals(password)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 登录成功:</span></span><br><span class=\"line\">            req.get<span class=\"constructor\">Session()</span>.set<span class=\"constructor\">Attribute(<span class=\"string\">&quot;user&quot;</span>, <span class=\"params\">name</span>)</span>;</span><br><span class=\"line\">            resp.send<span class=\"constructor\">Redirect(<span class=\"string\">&quot;/&quot;</span>)</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            resp.send<span class=\"constructor\">Error(HttpServletResponse.SC_FORBIDDEN)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述<code>SignInServlet</code>在判断用户登录成功后，立刻将用户名放入当前<code>HttpSession</code>中：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">HttpSession <span class=\"keyword\">session</span> = req.getSession();</span><br><span class=\"line\"><span class=\"keyword\">session</span>.setAttribute(&quot;user&quot;, <span class=\"type\">name</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在<code>IndexServlet</code>中，可以从<code>HttpSession</code>取出用户名：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从HttpSession获取当前用户名:</span></span><br><span class=\"line\">        <span class=\"type\">String</span> user = (<span class=\"type\">String</span>) req.getSession().getAttribute(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        resp.setCharacterEncoding(<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">        resp.setHeader(<span class=\"string\">&quot;X-Powered-By&quot;</span>, <span class=\"string\">&quot;JavaEE Servlet&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> pw = resp.getWriter();</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;h1&gt;Welcome, &quot;</span> + (user != <span class=\"literal\">null</span> ? user : <span class=\"string\">&quot;Guest&quot;</span>) + <span class=\"string\">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 未登录，显示登录链接:</span></span><br><span class=\"line\">            pw.write(<span class=\"string\">&quot;&lt;p&gt;&lt;a href=\\&quot;/signin\\&quot;&gt;Sign In&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 已登录，显示登出链接:</span></span><br><span class=\"line\">            pw.write(<span class=\"string\">&quot;&lt;p&gt;&lt;a href=\\&quot;/signout\\&quot;&gt;Sign Out&lt;/a&gt;&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果用户已登录，可以通过访问<code>/signout</code>登出。登出逻辑就是从<code>HttpSession</code>中移除用户相关信息：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/signout&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SignOutServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 从HttpSession移除用户名:</span></span><br><span class=\"line\">        req.getSession().removeAttribute(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">        resp.sendRedirect(<span class=\"string\">&quot;/&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于Web应用程序来说，我们总是通过<code>HttpSession</code>这个高级接口访问当前Session。如果要深入理解Session原理，可以认为Web服务器在内存中自动维护了一个ID到<code>HttpSession</code>的映射表，我们可以用下图表示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">           ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\"></span><br><span class=\"line\">           │      ┌───────────────┐                │</span><br><span class=\"line\">             ┌───&gt;│ IndexServlet  │&lt;──────────┐</span><br><span class=\"line\">           │ │    └───────────────┘           ▼    │</span><br><span class=\"line\">┌───────┐    │    ┌───────────────┐      ┌────────┐</span><br><span class=\"line\">│Browser│──┼─┼───&gt;│ SignInServlet │&lt;────&gt;│Sessions││</span><br><span class=\"line\">└───────┘    │    └───────────────┘      └────────┘</span><br><span class=\"line\">           │ │    ┌───────────────┐           ▲    │</span><br><span class=\"line\">             └───&gt;│SignOutServlet │&lt;──────────┘</span><br><span class=\"line\">           │      └───────────────┘                │</span><br><span class=\"line\"></span><br><span class=\"line\">           └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>而服务器识别Session的关键就是依靠一个名为<code>JSESSIONID</code>的Cookie。在Servlet中第一次调用<code>req.getSession()</code>时，Servlet容器自动创建一个Session ID，然后通过一个名为<code>JSESSIONID</code>的Cookie发送给浏览器：</p>\n<p>![session](1.Java Web.assets&#x2F;l-164189710880418.jpeg)</p>\n<p>这里要注意的几点是：</p>\n<ul>\n<li><code>JSESSIONID</code>是由Servlet容器自动创建的，目的是维护一个浏览器会话，它和我们的登录逻辑没有关系；</li>\n<li>登录和登出的业务逻辑是我们自己根据<code>HttpSession</code>是否存在一个<code>&quot;user&quot;</code>的Key判断的，登出后，Session ID并不会改变；</li>\n<li>即使没有登录功能，仍然可以使用<code>HttpSession</code>追踪用户，例如，放入一些用户配置信息等。</li>\n</ul>\n<p>除了使用Cookie机制可以实现Session外，还可以通过隐藏表单、URL末尾附加ID来追踪Session。这些机制很少使用，最常用的Session机制仍然是Cookie。</p>\n<p>使用Session时，由于服务器把所有用户的Session都存储在内存中，如果遇到内存不足的情况，就需要把部分不活动的Session序列化到磁盘上，这会大大降低服务器的运行效率，因此，放入Session的对象要小，通常我们放入一个简单的<code>User</code>对象就足够了：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">long</span> id; <span class=\"comment\">// 唯一标识</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> email;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在使用多台服务器构成集群时，使用Session会遇到一些额外的问题。通常，多台服务器集群使用反向代理作为网站入口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                                     ┌────────────┐</span><br><span class=\"line\">                                ┌───&gt;│Web Server 1│</span><br><span class=\"line\">                                │    └────────────┘</span><br><span class=\"line\">┌───────┐     ┌─────────────┐   │    ┌────────────┐</span><br><span class=\"line\">│Browser│────&gt;│Reverse Proxy│───┼───&gt;│Web Server 2│</span><br><span class=\"line\">└───────┘     └─────────────┘   │    └────────────┘</span><br><span class=\"line\">                                │    ┌────────────┐</span><br><span class=\"line\">                                └───&gt;│Web Server 3│</span><br><span class=\"line\">                                     └────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>如果多台Web Server采用无状态集群，那么反向代理总是以轮询方式将请求依次转发给每台Web Server，这会造成一个用户在Web Server 1存储的Session信息，在Web Server 2和3上并不存在，即从Web Server 1登录后，如果后续请求被转发到Web Server 2或3，那么用户看到的仍然是未登录状态。</p>\n<p>要解决这个问题，方案一是在所有Web Server之间进行Session复制，但这样会严重消耗网络带宽，并且，每个Web Server的内存均存储所有用户的Session，内存使用率很低。</p>\n<p>另一个方案是采用粘滞会话（Sticky Session）机制，即反向代理在转发请求的时候，总是根据JSESSIONID的值判断，相同的JSESSIONID总是转发到固定的Web Server，但这需要反向代理的支持。</p>\n<p>无论采用何种方案，使用Session机制，会使得Web Server的集群很难扩展，因此，Session适用于中小型Web应用程序。对于大型Web应用程序来说，通常需要避免使用Session机制。</p>\n<h4 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h4><p>实际上，Servlet提供的<code>HttpSession</code>本质上就是通过一个名为<code>JSESSIONID</code>的Cookie来跟踪用户会话的。除了这个名称外，其他名称的Cookie我们可以任意使用。</p>\n<p>如果我们想要设置一个Cookie，例如，记录用户选择的语言，可以编写一个<code>LanguageServlet</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebServlet(<span class=\"params\">urlPatterns</span> = <span class=\"string\">&quot;/pref&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> LanguageServlet extends HttpServlet &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> static final Set&lt;String&gt; LANGUAGES = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Set</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"string\">&quot;en&quot;</span>, <span class=\"string\">&quot;zh&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void <span class=\"keyword\">do</span><span class=\"constructor\">Get(HttpServletRequest <span class=\"params\">req</span>, HttpServletResponse <span class=\"params\">resp</span>)</span> throws ServletException, IOException &#123;</span><br><span class=\"line\">        String lang = req.get<span class=\"constructor\">Parameter(<span class=\"string\">&quot;lang&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LANGUAGES</span>.</span></span>contains(lang)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建一个新的Cookie:</span></span><br><span class=\"line\">            Cookie cookie = <span class=\"keyword\">new</span> <span class=\"constructor\">Cookie(<span class=\"string\">&quot;lang&quot;</span>, <span class=\"params\">lang</span>)</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 该Cookie生效的路径范围:</span></span><br><span class=\"line\">            cookie.set<span class=\"constructor\">Path(<span class=\"string\">&quot;/&quot;</span>)</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 该Cookie有效期:</span></span><br><span class=\"line\">            cookie.set<span class=\"constructor\">MaxAge(8640000)</span>; <span class=\"comment\">// 8640000秒=100天</span></span><br><span class=\"line\">            <span class=\"comment\">// 将该Cookie添加到响应:</span></span><br><span class=\"line\">            resp.add<span class=\"constructor\">Cookie(<span class=\"params\">cookie</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resp.send<span class=\"constructor\">Redirect(<span class=\"string\">&quot;/&quot;</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>创建一个新Cookie时，除了指定名称和值以外，通常需要设置<code>setPath(&quot;/&quot;)</code>，浏览器根据此前缀决定是否发送Cookie。如果一个Cookie调用了<code>setPath(&quot;/user/&quot;)</code>，那么浏览器只有在请求以<code>/user/</code>开头的路径时才会附加此Cookie。通过<code>setMaxAge()</code>设置Cookie的有效期，单位为秒，最后通过<code>resp.addCookie()</code>把它添加到响应。</p>\n<p>如果访问的是https网页，还需要调用<code>setSecure(true)</code>，否则浏览器不会发送该Cookie。</p>\n<p>因此，务必注意：浏览器在请求某个URL时，是否携带指定的Cookie，取决于Cookie是否满足以下所有要求：</p>\n<ul>\n<li>URL前缀是设置Cookie时的Path；</li>\n<li>Cookie在有效期内；</li>\n<li>Cookie设置了secure时必须以https访问。</li>\n</ul>\n<p>我们可以在浏览器看到服务器发送的Cookie：</p>\n<p>![cookie](1.Java Web.assets&#x2F;l-164189710880419.jpeg)</p>\n<p>如果我们要读取Cookie，例如，在<code>IndexServlet</code>中，读取名为<code>lang</code>的Cookie以获取用户设置的语言，可以写一个方法如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">parseLanguageFromCookie</span>(<span class=\"params\">HttpServletRequest req</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取请求附带的所有Cookie:</span></span><br><span class=\"line\">    Cookie[] cookies = req.getCookies();</span><br><span class=\"line\">    <span class=\"comment\">// 如果获取到Cookie:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cookies != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 循环每个Cookie:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Cookie cookie : cookies) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果Cookie名称为lang:</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cookie.getName().equals(<span class=\"string\">&quot;lang&quot;</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 返回Cookie的值:</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> cookie.getValue();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 返回默认值:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;en&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，读取Cookie主要依靠遍历<code>HttpServletRequest</code>附带的所有Cookie。</p>\n<h1 id=\"JSP\"><a href=\"#JSP\" class=\"headerlink\" title=\"JSP\"></a>JSP</h1><p>我们从前面的章节可以看到，Servlet就是一个能处理HTTP请求，发送HTTP响应的小程序，而发送响应无非就是获取<code>PrintWriter</code>，然后输出HTML：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">PrintWriter pw = resp.getWriter();</span><br><span class=\"line\">pw.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;&lt;html&gt;&quot;</span>);</span><br><span class=\"line\">pw.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;&lt;body&gt;&quot;</span>);</span><br><span class=\"line\">pw.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;&lt;h1&gt;Welcome, &quot;</span> + <span class=\"built_in\">name</span> + <span class=\"string\">&quot;!&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">pw.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class=\"line\">pw.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class=\"line\">pw.flush();</span><br></pre></td></tr></table></figure>\n\n<p>只不过，用PrintWriter输出HTML比较痛苦，因为不但要正确编写HTML，还需要插入各种变量。如果想在Servlet中输出一个类似新浪首页的HTML，写对HTML基本上不太可能。</p>\n<p>那有没有更简单的输出HTML的办法？</p>\n<h3 id=\"有！\"><a href=\"#有！\" class=\"headerlink\" title=\"有！\"></a>有！</h3><p>我们可以使用JSP。</p>\n<p>JSP是Java Server Pages的缩写，它的文件必须放到<code>/src/main/webapp</code>下，文件名必须以<code>.jsp</code>结尾，整个文件与HTML并无太大区别，但需要插入变量，或者动态输出的地方，使用特殊指令<code>&lt;% ... %&gt;</code>。</p>\n<p>我们来编写一个<code>hello.jsp</code>，内容如下：</p>\n<figure class=\"highlight bnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">&lt;html&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;head&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;title&gt;</span>Hello World - JSP<span class=\"attribute\">&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;body&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;%-- JSP Comment --%&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;h1&gt;</span>Hello World!<span class=\"attribute\">&lt;/h1&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;p&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;%</span></span><br><span class=\"line\"><span class=\"attribute\">         out.println(&quot;Your IP address is &quot;);</span></span><br><span class=\"line\"><span class=\"attribute\">    %&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;span style=&quot;color:red&quot;&gt;</span></span><br><span class=\"line\">        <span class=\"attribute\">&lt;%= request.getRemoteAddr() %&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;/span&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>整个JSP的内容实际上是一个HTML，但是稍有不同：</p>\n<ul>\n<li>包含在<code>&lt;%--</code>和<code>--%&gt;</code>之间的是JSP的注释，它们会被完全忽略；</li>\n<li>包含在<code>&lt;%</code>和<code>%&gt;</code>之间的是Java代码，可以编写任意Java代码；</li>\n<li>如果使用<code>&lt;%= xxx %&gt;</code>则可以快捷输出一个变量的值。</li>\n</ul>\n<p>JSP页面内置了几个变量：</p>\n<ul>\n<li>out：表示HttpServletResponse的PrintWriter；</li>\n<li>session：表示当前HttpSession对象；</li>\n<li>request：表示HttpServletRequest对象。</li>\n</ul>\n<p>这几个变量可以直接使用。</p>\n<p>访问JSP页面时，直接指定完整路径。例如，<code>http://localhost:8080/hello.jsp</code>，浏览器显示如下：</p>\n<p>![jsp](1.Java Web.assets&#x2F;l-164189720817222.jpeg)</p>\n<p>JSP和Servlet有什么区别？其实它们没有任何区别，因为JSP在执行前首先被编译成一个Servlet。在Tomcat的临时目录下，可以找到一个<code>hello_jsp.java</code>的源文件，这个文件就是Tomcat把JSP自动转换成的Servlet源码：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.apache.jsp;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> hello_jsp <span class=\"keyword\">extends</span> org.apache.jasper.<span class=\"keyword\">runtime</span>.HttpJspBase</span><br><span class=\"line\">    <span class=\"keyword\">implements</span> org.apache.jasper.<span class=\"keyword\">runtime</span>.JspSourceDependent,</span><br><span class=\"line\">               org.apache.jasper.<span class=\"keyword\">runtime</span>.JspSourceImports &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> _jspService(<span class=\"keyword\">final</span> javax.servlet.http.HttpServletRequest request, <span class=\"keyword\">final</span> javax.servlet.http.HttpServletResponse response)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> java.io.IOException, javax.servlet.ServletException &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">        out.<span class=\"keyword\">write</span>(<span class=\"string\">&quot;&lt;html&gt;\\n&quot;</span>);</span><br><span class=\"line\">        out.<span class=\"keyword\">write</span>(<span class=\"string\">&quot;&lt;head&gt;\\n&quot;</span>);</span><br><span class=\"line\">        out.<span class=\"keyword\">write</span>(<span class=\"string\">&quot;    &lt;title&gt;Hello World - JSP&lt;/title&gt;\\n&quot;</span>);</span><br><span class=\"line\">        out.<span class=\"keyword\">write</span>(<span class=\"string\">&quot;&lt;/head&gt;\\n&quot;</span>);</span><br><span class=\"line\">        out.<span class=\"keyword\">write</span>(<span class=\"string\">&quot;&lt;body&gt;\\n&quot;</span>);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见JSP本质上就是一个Servlet，只不过无需配置映射路径，Web Server会根据路径查找对应的<code>.jsp</code>文件，如果找到了，就自动编译成Servlet再执行。在服务器运行过程中，如果修改了JSP的内容，那么服务器会自动重新编译。</p>\n<h3 id=\"JSP高级功能\"><a href=\"#JSP高级功能\" class=\"headerlink\" title=\"JSP高级功能\"></a>JSP高级功能</h3><p>JSP的指令非常复杂，除了<code>&lt;% ... %&gt;</code>外，JSP页面本身可以通过<code>page</code>指令引入Java类：</p>\n<figure class=\"highlight gcode\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"meta\">%</span>@ page import=<span class=\"string\">&quot;java.io.*&quot;</span> <span class=\"meta\">%</span>&gt;</span><br><span class=\"line\">&lt;<span class=\"meta\">%</span>@ page import=<span class=\"string\">&quot;java.util.*&quot;</span> <span class=\"meta\">%</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>这样后续的Java代码才能引用简单类名而不是完整类名。</p>\n<p>使用<code>include</code>指令可以引入另一个JSP文件：</p>\n<figure class=\"highlight erb\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &lt;%</span><span class=\"ruby\">@ <span class=\"keyword\">include</span> file=<span class=\"string\">&quot;header.jsp&quot;</span></span><span class=\"xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Index Page<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    &lt;%</span><span class=\"ruby\">@ <span class=\"keyword\">include</span> file=<span class=\"string\">&quot;footer.jsp&quot;</span></span><span class=\"xml\">%&gt;</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JSP-Tag\"><a href=\"#JSP-Tag\" class=\"headerlink\" title=\"JSP Tag\"></a>JSP Tag</h3><p>JSP还允许自定义输出的tag，例如：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">c:out</span> <span class=\"attr\">value</span> = <span class=\"string\">&quot;$</span></span></span><span class=\"template-variable\">&#123;sessionScope.user.name&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>JSP Tag需要正确引入taglib的jar包，并且还需要正确声明，使用起来非常复杂，对于页面开发来说，<em>不推荐</em>使用JSP Tag，因为我们后续会介绍更简单的模板引擎，这里我们不再介绍如何使用taglib。</p>\n<h1 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h1><h2 id=\"MVC开发\"><a href=\"#MVC开发\" class=\"headerlink\" title=\"MVC开发\"></a>MVC开发</h2><p>我们通过前面的章节可以看到：</p>\n<ul>\n<li>Servlet适合编写Java代码，实现各种复杂的业务逻辑，但不适合输出复杂的HTML；</li>\n<li>JSP适合编写HTML，并在其中插入动态内容，但不适合编写复杂的Java代码。</li>\n</ul>\n<p>能否将两者结合起来，发挥各自的优点，避免各自的缺点？</p>\n<p>答案是肯定的。我们来看一个具体的例子。</p>\n<p>假设我们已经编写了几个JavaBean：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> long id;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> School school;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">School</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> address;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>UserServlet</code>中，我们可以从数据库读取<code>User</code>、<code>School</code>等信息，然后，把读取到的JavaBean先放到HttpServletRequest中，再通过<code>forward()</code>传给<code>user.jsp</code>处理：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/user&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 假装从数据库读取:</span></span><br><span class=\"line\">        <span class=\"type\">School</span> school = <span class=\"keyword\">new</span> <span class=\"type\">School</span>(<span class=\"string\">&quot;No.1 Middle School&quot;</span>, <span class=\"string\">&quot;101 South Street&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">User</span> user = <span class=\"keyword\">new</span> <span class=\"type\">User</span>(<span class=\"number\">123</span>, <span class=\"string\">&quot;Bob&quot;</span>, school);</span><br><span class=\"line\">        <span class=\"comment\">// 放入Request中:</span></span><br><span class=\"line\">        req.setAttribute(<span class=\"string\">&quot;user&quot;</span>, user);</span><br><span class=\"line\">        <span class=\"comment\">// forward给user.jsp:</span></span><br><span class=\"line\">        req.getRequestDispatcher(<span class=\"string\">&quot;/WEB-INF/user.jsp&quot;</span>).forward(req, resp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>user.jsp</code>中，我们只负责展示相关JavaBean的信息，不需要编写访问数据库等复杂逻辑：</p>\n<figure class=\"highlight bnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">&lt;%@ page import=&quot;com.itranswarp.learnjava.bean.*&quot;%&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;%</span></span><br><span class=\"line\"><span class=\"attribute\">    User user = (User) request.getAttribute(&quot;user&quot;);</span></span><br><span class=\"line\"><span class=\"attribute\">%&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;html&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;head&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;title&gt;</span>Hello World - JSP<span class=\"attribute\">&lt;/title&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;/head&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;body&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;h1&gt;</span>Hello <span class=\"attribute\">&lt;%= user.name %&gt;</span>!<span class=\"attribute\">&lt;/h1&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;p&gt;</span>School Name:</span><br><span class=\"line\">    <span class=\"attribute\">&lt;span style=&quot;color:red&quot;&gt;</span></span><br><span class=\"line\">        <span class=\"attribute\">&lt;%= user.school.name %&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;/span&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;/p&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;p&gt;</span>School Address:</span><br><span class=\"line\">    <span class=\"attribute\">&lt;span style=&quot;color:red&quot;&gt;</span></span><br><span class=\"line\">        <span class=\"attribute\">&lt;%= user.school.address %&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;/span&gt;</span></span><br><span class=\"line\">    <span class=\"attribute\">&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;/body&gt;</span></span><br><span class=\"line\"><span class=\"attribute\">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>请注意几点：</p>\n<ul>\n<li>需要展示的<code>User</code>被放入<code>HttpServletRequest</code>中以便传递给JSP，因为一个请求对应一个<code>HttpServletRequest</code>，我们也无需清理它，处理完该请求后<code>HttpServletRequest</code>实例将被丢弃；</li>\n<li>把<code>user.jsp</code>放到<code>/WEB-INF/</code>目录下，是因为<code>WEB-INF</code>是一个特殊目录，Web Server会阻止浏览器对<code>WEB-INF</code>目录下任何资源的访问，这样就防止用户通过<code>/user.jsp</code>路径直接访问到JSP页面；</li>\n<li>JSP页面首先从<code>request</code>变量获取<code>User</code>实例，然后在页面中直接输出，此处未考虑HTML的转义问题，有潜在安全风险。</li>\n</ul>\n<p>我们在浏览器访问<code>http://localhost:8080/user</code>，请求首先由<code>UserServlet</code>处理，然后交给<code>user.jsp</code>渲染：</p>\n<p>![mvc](1.Java Web.assets&#x2F;l-164189724751624.jpeg)</p>\n<p>我们把<code>UserServlet</code>看作业务逻辑处理，把<code>User</code>看作模型，把<code>user.jsp</code>看作渲染，这种设计模式通常被称为MVC：Model-View-Controller，即<code>UserServlet</code>作为控制器（Controller），<code>User</code>作为模型（Model），<code>user.jsp</code>作为视图（View），整个MVC架构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                   ┌───────────────────────┐</span><br><span class=\"line\">             ┌────&gt;│Controller: UserServlet│</span><br><span class=\"line\">             │     └───────────────────────┘</span><br><span class=\"line\">             │                 │</span><br><span class=\"line\">┌───────┐    │           ┌─────┴─────┐</span><br><span class=\"line\">│Browser│────┘           │Model: User│</span><br><span class=\"line\">│       │&lt;───┐           └─────┬─────┘</span><br><span class=\"line\">└───────┘    │                 │</span><br><span class=\"line\">             │                 ▼</span><br><span class=\"line\">             │     ┌───────────────────────┐</span><br><span class=\"line\">             └─────│    View: user.jsp     │</span><br><span class=\"line\">                   └───────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>使用MVC模式的好处是，Controller专注于业务处理，它的处理结果就是Model。Model可以是一个JavaBean，也可以是一个包含多个对象的Map，Controller只负责把Model传递给View，View只负责把Model给“渲染”出来，这样，三者职责明确，且开发更简单，因为开发Controller时无需关注页面，开发View时无需关心如何创建Model。</p>\n<p>MVC模式广泛地应用在Web页面和传统的桌面程序中，我们在这里通过Servlet和JSP实现了一个简单的MVC模型，但它还不够简洁和灵活，后续我们会介绍更简单的Spring MVC开发。</p>\n<h2 id=\"MVC高级开发\"><a href=\"#MVC高级开发\" class=\"headerlink\" title=\"MVC高级开发\"></a>MVC高级开发</h2><p>通过结合Servlet和JSP的MVC模式，我们可以发挥二者各自的优点：</p>\n<ul>\n<li>Servlet实现业务逻辑；</li>\n<li>JSP实现展示逻辑。</li>\n</ul>\n<p>但是，直接把MVC搭在Servlet和JSP之上还是不太好，原因如下：</p>\n<ul>\n<li>Servlet提供的接口仍然偏底层，需要实现Servlet调用相关接口；</li>\n<li>JSP对页面开发不友好，更好的替代品是模板引擎；</li>\n<li>业务逻辑最好由纯粹的Java类实现，而不是强迫继承自Servlet。</li>\n</ul>\n<p>能不能通过普通的Java类实现MVC的Controller？类似下面的代码：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">public</span> <span class=\"selector-tag\">class</span> <span class=\"selector-tag\">UserController</span> &#123;</span><br><span class=\"line\">    <span class=\"variable\">@GetMapping</span>(<span class=\"string\">&quot;/signin&quot;</span>)</span><br><span class=\"line\">    public ModelAndView signin() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@PostMapping</span>(<span class=\"string\">&quot;/signin&quot;</span>)</span><br><span class=\"line\">    public ModelAndView doSignin(SignInBean bean) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@GetMapping</span>(<span class=\"string\">&quot;/signout&quot;</span>)</span><br><span class=\"line\">    public ModelAndView signout(HttpSession session) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面的这个Java类每个方法都对应一个GET或POST请求，方法返回值是<code>ModelAndView</code>，它包含一个View的路径以及一个Model，这样，再由MVC框架处理后返回给浏览器。</p>\n<p>如果是GET请求，我们希望MVC框架能直接把URL参数按方法参数对应起来然后传入：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">&quot;/hello&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> ModelAndView <span class=\"function\"><span class=\"title\">hello</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果是POST请求，我们希望MVC框架能直接把Post参数变成一个JavaBean后通过方法参数传入：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">PostMapping(<span class=\"string\">&quot;/signin&quot;</span>)</span></span><br><span class=\"line\">public ModelAndView <span class=\"keyword\">do</span><span class=\"constructor\">Signin(SignInBean <span class=\"params\">bean</span>)</span> &#123;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了增加灵活性，如果Controller的方法在处理请求时需要访问<code>HttpServletRequest</code>、<code>HttpServletResponse</code>、<code>HttpSession</code>这些实例时，只要方法参数有定义，就可以自动传入：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(<span class=\"string\">&quot;/signout&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> ModelAndView <span class=\"function\"><span class=\"title\">signout</span>(<span class=\"params\">HttpSession session</span>)</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是我们在设计MVC框架时，上层代码所需要的一切信息。</p>\n<h3 id=\"设计MVC框架\"><a href=\"#设计MVC框架\" class=\"headerlink\" title=\"设计MVC框架\"></a>设计MVC框架</h3><p>如何设计一个MVC框架？在上文中，我们已经定义了上层代码编写Controller的一切接口信息，并且并不要求实现特定接口，只需返回<code>ModelAndView</code>对象，该对象包含一个<code>View</code>和一个<code>Model</code>。实际上<code>View</code>就是模板的路径，而<code>Model</code>可以用一个<code>Map&lt;String, Object&gt;</code>表示，因此，<code>ModelAndView</code>定义非常简单：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ModelAndView</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt; model;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> view;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比较复杂的是我们需要在MVC框架中创建一个接收所有请求的<code>Servlet</code>，通常我们把它命名为<code>DispatcherServlet</code>，它总是映射到<code>/</code>，然后，根据不同的Controller的方法定义的<code>@Get</code>或<code>@Post</code>的Path决定调用哪个方法，最后，获得方法返回的<code>ModelAndView</code>后，渲染模板，写入<code>HttpServletResponse</code>，即完成了整个MVC的处理。</p>\n<p>这个MVC的架构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">   HTTP Request    ┌─────────────────┐</span><br><span class=\"line\">──────────────────&gt;│DispatcherServlet│</span><br><span class=\"line\">                   └─────────────────┘</span><br><span class=\"line\">                            │</span><br><span class=\"line\">               ┌────────────┼────────────┐</span><br><span class=\"line\">               ▼            ▼            ▼</span><br><span class=\"line\">         ┌───────────┐┌───────────┐┌───────────┐</span><br><span class=\"line\">         │Controller1││Controller2││Controller3│</span><br><span class=\"line\">         └───────────┘└───────────┘└───────────┘</span><br><span class=\"line\">               │            │            │</span><br><span class=\"line\">               └────────────┼────────────┘</span><br><span class=\"line\">                            ▼</span><br><span class=\"line\">   HTTP Response ┌────────────────────┐</span><br><span class=\"line\">&lt;────────────────│render(ModelAndView)│</span><br><span class=\"line\">                 └────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>DispatcherServlet</code>以及如何渲染均由MVC框架实现，在MVC框架之上只需要编写每一个Controller。</p>\n<p>我们来看看如何编写最复杂的<code>DispatcherServlet</code>。首先，我们需要存储请求路径到某个具体方法的映射：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">GetDispatcher</span>&gt; getMappings = <span class=\"keyword\">new</span> <span class=\"type\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">PostDispatcher</span>&gt; postMappings = <span class=\"keyword\">new</span> <span class=\"type\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>处理一个GET请求是通过<code>GetDispatcher</code>对象完成的，它需要如下信息：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">class GetDispatcher &#123;</span><br><span class=\"line\">    Object instance; <span class=\"regexp\">//</span> Controller实例</span><br><span class=\"line\">    Method method; <span class=\"regexp\">//</span> Controller方法</span><br><span class=\"line\">    String[] parameterNames; <span class=\"regexp\">//</span> 方法参数名称</span><br><span class=\"line\">    Class&lt;?&gt;[] parameterClasses; <span class=\"regexp\">//</span> 方法参数类型</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了以上信息，就可以定义<code>invoke()</code>来处理真正的请求：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> GetDispatcher &#123;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\">    </span>public ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class=\"line\">        Object<span class=\"literal\">[]</span> arguments = <span class=\"keyword\">new</span> Object<span class=\"literal\">[<span class=\"identifier\">parameterClasses</span>.<span class=\"identifier\">length</span>]</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; parameterClasses.length; i++) &#123;</span><br><span class=\"line\">            String parameterName = parameterNames<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">            Class&lt;?&gt; parameterClass = parameterClasses<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpServletRequest</span>.</span></span><span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = request;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpServletResponse</span>.</span></span><span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = response;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpSession</span>.</span></span><span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = request.get<span class=\"constructor\">Session()</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span><span class=\"built_in\">int</span>.<span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>value<span class=\"constructor\">Of(<span class=\"params\">getOrDefault</span>(<span class=\"params\">request</span>, <span class=\"params\">parameterName</span>, <span class=\"string\">&quot;0&quot;</span>)</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span>long.<span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Long</span>.</span></span>value<span class=\"constructor\">Of(<span class=\"params\">getOrDefault</span>(<span class=\"params\">request</span>, <span class=\"params\">parameterName</span>, <span class=\"string\">&quot;0&quot;</span>)</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span>boolean.<span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Boolean</span>.</span></span>value<span class=\"constructor\">Of(<span class=\"params\">getOrDefault</span>(<span class=\"params\">request</span>, <span class=\"params\">parameterName</span>, <span class=\"string\">&quot;false&quot;</span>)</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span><span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = get<span class=\"constructor\">OrDefault(<span class=\"params\">request</span>, <span class=\"params\">parameterName</span>, <span class=\"string\">&quot;&quot;</span>)</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                throw <span class=\"keyword\">new</span> <span class=\"constructor\">RuntimeException(<span class=\"string\">&quot;Missing handler for type: &quot;</span> + <span class=\"params\">parameterClass</span>)</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return (ModelAndView) this.<span class=\"keyword\">method</span>.invoke(this.instance, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String get<span class=\"constructor\">OrDefault(HttpServletRequest <span class=\"params\">request</span>, String <span class=\"params\">name</span>, String <span class=\"params\">defaultValue</span>)</span> &#123;</span><br><span class=\"line\">        String s = request.get<span class=\"constructor\">Parameter(<span class=\"params\">name</span>)</span>;</span><br><span class=\"line\">        return s<span class=\"operator\"> == </span>null ? defaultValue : s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码比较繁琐，但逻辑非常简单，即通过构造某个方法需要的所有参数列表，使用反射调用该方法后返回结果。</p>\n<p>类似的，<code>PostDispatcher</code>需要如下信息：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">class PostDispatcher &#123;</span><br><span class=\"line\">    Object instance; <span class=\"regexp\">//</span> Controller实例</span><br><span class=\"line\">    Method method; <span class=\"regexp\">//</span> Controller方法</span><br><span class=\"line\">    Class&lt;?&gt;[] parameterClasses; <span class=\"regexp\">//</span> 方法参数类型</span><br><span class=\"line\">    ObjectMapper objectMapper; <span class=\"regexp\">//</span> JSON映射</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和GET请求不同，POST请求严格地来说不能有URL参数，所有数据都应当从Post Body中读取。这里我们为了简化处理，<em>只支持</em>JSON格式的POST请求，这样，把Post数据转化为JavaBean就非常容易。</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> PostDispatcher &#123;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\">    </span>public ModelAndView invoke(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class=\"line\">        Object<span class=\"literal\">[]</span> arguments = <span class=\"keyword\">new</span> Object<span class=\"literal\">[<span class=\"identifier\">parameterClasses</span>.<span class=\"identifier\">length</span>]</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; parameterClasses.length; i++) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; parameterClass = parameterClasses<span class=\"literal\">[<span class=\"identifier\">i</span>]</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpServletRequest</span>.</span></span><span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = request;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpServletResponse</span>.</span></span><span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = response;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (parameterClass<span class=\"operator\"> == </span><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpSession</span>.</span></span><span class=\"keyword\">class</span>) &#123;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = request.get<span class=\"constructor\">Session()</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 读取JSON并解析为JavaBean:</span></span><br><span class=\"line\">                BufferedReader reader = request.get<span class=\"constructor\">Reader()</span>;</span><br><span class=\"line\">                arguments<span class=\"literal\">[<span class=\"identifier\">i</span>]</span> = this.objectMapper.read<span class=\"constructor\">Value(<span class=\"params\">reader</span>, <span class=\"params\">parameterClass</span>)</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return (ModelAndView) this.<span class=\"keyword\">method</span>.invoke(instance, arguments);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们来实现整个<code>DispatcherServlet</code>的处理流程，以<code>doGet()</code>为例：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        resp.setCharacterEncoding(<span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> path = req.getRequestURI().substring(req.getContextPath().length());</span><br><span class=\"line\">        <span class=\"comment\">// 根据路径查找GetDispatcher:</span></span><br><span class=\"line\">        <span class=\"type\">GetDispatcher</span> dispatcher = <span class=\"keyword\">this</span>.getMappings.get(path);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dispatcher == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 未找到返回404:</span></span><br><span class=\"line\">            resp.sendError(<span class=\"number\">404</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 调用Controller方法获得返回值:</span></span><br><span class=\"line\">        <span class=\"type\">ModelAndView</span> mv = dispatcher.invoke(req, resp);</span><br><span class=\"line\">        <span class=\"comment\">// 允许返回null:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mv == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 允许返回`redirect:`开头的view表示重定向:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mv.view.startsWith(<span class=\"string\">&quot;redirect:&quot;</span>)) &#123;</span><br><span class=\"line\">            resp.sendRedirect(mv.view.substring(<span class=\"number\">9</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将模板引擎渲染的内容写入响应:</span></span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> pw = resp.getWriter();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.viewEngine.render(mv, pw);</span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里有几个小改进：</p>\n<ul>\n<li>允许Controller方法返回<code>null</code>，表示内部已自行处理完毕；</li>\n<li>允许Controller方法返回以<code>redirect:</code>开头的view名称，表示一个重定向。</li>\n</ul>\n<p>这样使得上层代码编写更灵活。例如，一个显示用户资料的请求可以这样写：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">@GetMapping(&quot;/user/profile&quot;)</span><br><span class=\"line\"><span class=\"built_in\">public</span> ModelAndView profile(HttpServletResponse response, HttpSession <span class=\"keyword\">session</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">User</span> <span class=\"keyword\">user</span> = (<span class=\"keyword\">User</span>) <span class=\"keyword\">session</span>.getAttribute(&quot;user&quot;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">user</span> == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        // 未登录，跳转到登录页:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">new</span> ModelAndView(&quot;redirect:/signin&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"keyword\">user</span>.isManager()) &#123;</span><br><span class=\"line\">        // 权限不够，返回<span class=\"number\">403</span>:</span><br><span class=\"line\">        response.sendError(<span class=\"number\">403</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">new</span> ModelAndView(&quot;/profile.html&quot;, Map.<span class=\"keyword\">of</span>(&quot;user&quot;, <span class=\"keyword\">user</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后一步是在<code>DispatcherServlet</code>的<code>init()</code>方法中初始化所有Get和Post的映射，以及用于渲染的模板引擎：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">GetDispatcher</span>&gt; getMappings = <span class=\"keyword\">new</span> <span class=\"type\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">PostDispatcher</span>&gt; postMappings = <span class=\"keyword\">new</span> <span class=\"type\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">ViewEngine</span> viewEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public void init() <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.getMappings = scanGetInControllers();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.postMappings = scanPostInControllers();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.viewEngine = <span class=\"keyword\">new</span> <span class=\"type\">ViewEngine</span>(getServletContext());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如何扫描所有Controller以获取所有标记有<code>@GetMapping</code>和<code>@PostMapping</code>的方法？当然是使用反射了。虽然代码比较繁琐，但我们相信各位童鞋可以轻松实现。</p>\n<p>这样，整个MVC框架就搭建完毕。</p>\n<h3 id=\"实现渲染\"><a href=\"#实现渲染\" class=\"headerlink\" title=\"实现渲染\"></a>实现渲染</h3><p>有的童鞋对如何使用模板引擎进行渲染有疑问，即如何实现上述的<code>ViewEngine</code>？其实<code>ViewEngine</code>非常简单，只需要实现一个简单的<code>render()</code>方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ViewEngine</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">render</span><span class=\"params\">(ModelAndView mv, Writer writer)</span> throws IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> view = mv.view;</span><br><span class=\"line\">        Map&lt;<span class=\"keyword\">String</span>, Object&gt; model = mv.model;</span><br><span class=\"line\">        <span class=\"comment\">// 根据view找到模板文件:</span></span><br><span class=\"line\">        Template <span class=\"keyword\">template</span> = <span class=\"built_in\">getTemplateByPath</span>(view);</span><br><span class=\"line\">        <span class=\"comment\">// 渲染并写入Writer:</span></span><br><span class=\"line\">        <span class=\"keyword\">template</span>.<span class=\"built_in\">write</span>(writer, model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java有很多开源的模板引擎，常用的有：</p>\n<ul>\n<li><a href=\"https://www.thymeleaf.org/\">Thymeleaf</a></li>\n<li><a href=\"https://freemarker.apache.org/\">FreeMarker</a></li>\n<li><a href=\"https://velocity.apache.org/\">Velocity</a></li>\n</ul>\n<p>他们的用法都大同小异。这里我们推荐一个使用<a href=\"https://palletsprojects.com/p/jinja/\">Jinja</a>语法的模板引擎<a href=\"https://pebbletemplates.io/\">Pebble</a>，它的特点是语法简单，支持模板继承，编写出来的模板类似：</p>\n<figure class=\"highlight django\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  </span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">for</span></span> user <span class=\"keyword\">in</span> users %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;</span></span></span><span class=\"template-variable\">&#123;&#123; user.url &#125;&#125;</span><span class=\"xml\"><span class=\"tag\"><span class=\"string\">&quot;</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; user.username &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">  </span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endfor</span></span> %&#125;</span><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">  <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>即变量用<code>&#123;&#123; xxx &#125;&#125;</code>表示，控制语句用<code>&#123;% xxx %&#125;</code>表示。</p>\n<p>使用Pebble渲染只需要如下几行代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> ViewEngine &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final PebbleEngine engine;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"constructor\">ViewEngine(ServletContext <span class=\"params\">servletContext</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义一个ServletLoader用于加载模板:</span></span><br><span class=\"line\">        ServletLoader loader = <span class=\"keyword\">new</span> <span class=\"constructor\">ServletLoader(<span class=\"params\">servletContext</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 模板编码:</span></span><br><span class=\"line\">        loader.set<span class=\"constructor\">Charset(<span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 模板前缀，这里默认模板必须放在`/WEB-INF/templates`目录:</span></span><br><span class=\"line\">        loader.set<span class=\"constructor\">Prefix(<span class=\"string\">&quot;/WEB-INF/templates&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 模板后缀:</span></span><br><span class=\"line\">        loader.set<span class=\"constructor\">Suffix(<span class=\"string\">&quot;&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 创建Pebble实例:</span></span><br><span class=\"line\">        this.engine = <span class=\"keyword\">new</span> PebbleEngine.<span class=\"constructor\">Builder()</span></span><br><span class=\"line\">            .auto<span class=\"constructor\">Escaping(<span class=\"params\">true</span>)</span> <span class=\"comment\">// 默认打开HTML字符转义，防止XSS攻击</span></span><br><span class=\"line\">            .cache<span class=\"constructor\">Active(<span class=\"params\">false</span>)</span> <span class=\"comment\">// 禁用缓存使得每次修改模板可以立刻看到效果</span></span><br><span class=\"line\">            .loader(loader).build<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void render(ModelAndView mv, Writer writer) throws IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 查找模板:</span></span><br><span class=\"line\">        PebbleTemplate template = this.engine.get<span class=\"constructor\">Template(<span class=\"params\">mv</span>.<span class=\"params\">view</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 渲染:</span></span><br><span class=\"line\">        template.evaluate(writer, mv.model);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后我们来看看整个工程的结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">web-mvc</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │   └── com</span><br><span class=\"line\">        │       └── itranswarp</span><br><span class=\"line\">        │           └── learnjava</span><br><span class=\"line\">        │               ├── Main.java</span><br><span class=\"line\">        │               ├── bean</span><br><span class=\"line\">        │               │   ├── SignInBean.java</span><br><span class=\"line\">        │               │   └── User.java</span><br><span class=\"line\">        │               ├── controller</span><br><span class=\"line\">        │               │   ├── IndexController.java</span><br><span class=\"line\">        │               │   └── UserController.java</span><br><span class=\"line\">        │               └── framework</span><br><span class=\"line\">        │                   ├── DispatcherServlet.java</span><br><span class=\"line\">        │                   ├── FileServlet.java</span><br><span class=\"line\">        │                   ├── GetMapping.java</span><br><span class=\"line\">        │                   ├── ModelAndView.java</span><br><span class=\"line\">        │                   ├── PostMapping.java</span><br><span class=\"line\">        │                   └── ViewEngine.java</span><br><span class=\"line\">        └── webapp</span><br><span class=\"line\">            ├── WEB-INF</span><br><span class=\"line\">            │   ├── templates</span><br><span class=\"line\">            │   │   ├── _base.html</span><br><span class=\"line\">            │   │   ├── hello.html</span><br><span class=\"line\">            │   │   ├── index.html</span><br><span class=\"line\">            │   │   ├── profile.html</span><br><span class=\"line\">            │   │   └── signin.html</span><br><span class=\"line\">            │   └── web.xml</span><br><span class=\"line\">            └── static</span><br><span class=\"line\">                ├── css</span><br><span class=\"line\">                │   └── bootstrap.css</span><br><span class=\"line\">                └── js</span><br><span class=\"line\">                    ├── bootstrap.js</span><br><span class=\"line\">                    └── jquery.js</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>framework</code>包是MVC的框架，完全可以单独编译后作为一个Maven依赖引入，<code>controller</code>包才是我们需要编写的业务逻辑。</p>\n<p>我们还硬性规定模板必须放在<code>webapp/WEB-INF/templates</code>目录下，静态文件必须放在<code>webapp/static</code>目录下，因此，为了便于开发，我们还顺带实现一个<code>FileServlet</code>来处理静态文件：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebServlet(<span class=\"params\">urlPatterns</span> = &#123; <span class=\"string\">&quot;/favicon.ico&quot;</span>, <span class=\"string\">&quot;/static/*&quot;</span> &#125;)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> FileServlet extends HttpServlet &#123;</span><br><span class=\"line\">    protected void <span class=\"keyword\">do</span><span class=\"constructor\">Get(HttpServletRequest <span class=\"params\">req</span>, HttpServletResponse <span class=\"params\">resp</span>)</span> throws ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取当前请求路径:</span></span><br><span class=\"line\">        ServletContext ctx = req.get<span class=\"constructor\">ServletContext()</span>;</span><br><span class=\"line\">        <span class=\"comment\">// RequestURI包含ContextPath,需要去掉:</span></span><br><span class=\"line\">        String urlPath = req.get<span class=\"constructor\">RequestURI()</span>.substring(ctx.get<span class=\"constructor\">ContextPath()</span>.length<span class=\"literal\">()</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取真实文件路径:</span></span><br><span class=\"line\">        String filepath = ctx.get<span class=\"constructor\">RealPath(<span class=\"params\">urlPath</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (filepath<span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 无法获取到路径:</span></span><br><span class=\"line\">            resp.send<span class=\"constructor\">Error(HttpServletResponse.SC_NOT_FOUND)</span>;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Path path = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Paths</span>.</span></span>get(filepath);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!path.<span class=\"keyword\">to</span><span class=\"constructor\">File()</span>.is<span class=\"constructor\">File()</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 文件不存在:</span></span><br><span class=\"line\">            resp.send<span class=\"constructor\">Error(HttpServletResponse.SC_NOT_FOUND)</span>;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据文件名猜测Content-Type:</span></span><br><span class=\"line\">        String mime = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>probe<span class=\"constructor\">ContentType(<span class=\"params\">path</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mime<span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">            mime = <span class=\"string\">&quot;application/octet-stream&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resp.set<span class=\"constructor\">ContentType(<span class=\"params\">mime</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 读取文件并写入Response:</span></span><br><span class=\"line\">        OutputStream output = resp.get<span class=\"constructor\">OutputStream()</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> <span class=\"constructor\">BufferedInputStream(<span class=\"params\">new</span> FileInputStream(<span class=\"params\">filepath</span>)</span>)) &#123;</span><br><span class=\"line\">            input.transfer<span class=\"constructor\">To(<span class=\"params\">output</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        output.flush<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行代码，在浏览器中输入URL<code>http://localhost:8080/hello?name=Bob</code>可以看到如下页面：</p>\n<p>![mvc](1.Java Web.assets&#x2F;l-164189726216926.png)</p>\n<p>为了把方法参数的名称编译到class文件中，以便处理<code>@GetMapping</code>时使用，我们需要打开编译器的一个参数，在Eclipse中勾选<code>Preferences</code>-<code>Java</code>-<code>Compiler</code>-<code>Store information about method parameters (usable via reflection)</code>；在Idea中选择<code>Preferences</code>-<code>Build, Execution, Deployment</code>-<code>Compiler</code>-<code>Java Compiler</code>-<code>Additional command line parameters</code>，填入<code>-parameters</code>；在Maven的<code>pom.xml</code>添加一段配置如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-compiler-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">compilerArgs</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">arg</span>&gt;</span>-parameters<span class=\"tag\">&lt;/<span class=\"name\">arg</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">compilerArgs</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>有些用过Spring MVC的童鞋会发现，本节实现的这个MVC框架，上层代码使用的公共类如<code>GetMapping</code>、<code>PostMapping</code>和<code>ModelAndView</code>都和Spring MVC非常类似。实际上，我们这个MVC框架主要参考就是Spring MVC，通过实现一个“简化版”MVC，可以掌握Java Web MVC开发的核心思想与原理，对将来直接使用Spring MVC是非常有帮助的。</p>\n<h1 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h1><h2 id=\"简介-2\"><a href=\"#简介-2\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在一个比较复杂的Web应用程序中，通常都有很多URL映射，对应的，也会有多个Servlet来处理URL。</p>\n<p>我们考察这样一个论坛应用程序：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">               /             ┌──────────────┐</span><br><span class=\"line\">            │ ┌─────────────&gt;│ IndexServlet │ │</span><br><span class=\"line\">              │              └──────────────┘</span><br><span class=\"line\">            │ │/signin       ┌──────────────┐ │</span><br><span class=\"line\">              ├─────────────&gt;│SignInServlet │</span><br><span class=\"line\">            │ │              └──────────────┘ │</span><br><span class=\"line\">              │/signout      ┌──────────────┐</span><br><span class=\"line\">┌───────┐   │ ├─────────────&gt;│SignOutServlet│ │</span><br><span class=\"line\">│Browser├─────┤              └──────────────┘</span><br><span class=\"line\">└───────┘   │ │/user/profile ┌──────────────┐ │</span><br><span class=\"line\">              ├─────────────&gt;│ProfileServlet│</span><br><span class=\"line\">            │ │              └──────────────┘ │</span><br><span class=\"line\">              │/user/post    ┌──────────────┐</span><br><span class=\"line\">            │ ├─────────────&gt;│ PostServlet  │ │</span><br><span class=\"line\">              │              └──────────────┘</span><br><span class=\"line\">            │ │/user/reply   ┌──────────────┐ │</span><br><span class=\"line\">              └─────────────&gt;│ ReplyServlet │</span><br><span class=\"line\">            │                └──────────────┘ │</span><br><span class=\"line\">             ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br></pre></td></tr></table></figure>\n\n<p>各个Servlet设计功能如下：</p>\n<ul>\n<li>IndexServlet：浏览帖子；</li>\n<li>SignInServlet：登录；</li>\n<li>SignOutServlet：登出；</li>\n<li>ProfileServlet：修改用户资料；</li>\n<li>PostServlet：发帖；</li>\n<li>ReplyServlet：回复。</li>\n</ul>\n<p>其中，ProfileServlet、PostServlet和ReplyServlet都需要用户登录后才能操作，否则，应当直接跳转到登录页面。</p>\n<p>我们可以直接把判断登录的逻辑写到这3个Servlet中，但是，同样的逻辑重复3次没有必要，并且，如果后续继续加Servlet并且也需要验证登录时，还需要继续重复这个检查逻辑。</p>\n<p>为了把一些公用逻辑从各个Servlet中抽离出来，JavaEE的Servlet规范还提供了一种Filter组件，即过滤器，它的作用是，在HTTP请求到达Servlet之前，可以被一个或多个Filter预处理，类似打印日志、登录检查等逻辑，完全可以放到Filter中。</p>\n<p>例如，我们编写一个最简单的EncodingFilter，它强制把输入和输出的编码设置为UTF-8：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebFilter(<span class=\"params\">urlPatterns</span> = <span class=\"string\">&quot;/*&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> EncodingFilter implements Filter &#123;</span><br><span class=\"line\">    public void <span class=\"keyword\">do</span><span class=\"constructor\">Filter(ServletRequest <span class=\"params\">request</span>, ServletResponse <span class=\"params\">response</span>, FilterChain <span class=\"params\">chain</span>)</span></span><br><span class=\"line\">            throws IOException, ServletException &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;EncodingFilter:doFilter&quot;</span>);</span><br><span class=\"line\">        request.set<span class=\"constructor\">CharacterEncoding(<span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\">        response.set<span class=\"constructor\">CharacterEncoding(<span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\">        chain.<span class=\"keyword\">do</span><span class=\"constructor\">Filter(<span class=\"params\">request</span>, <span class=\"params\">response</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写Filter时，必须实现<code>Filter</code>接口，在<code>doFilter()</code>方法内部，要继续处理请求，必须调用<code>chain.doFilter()</code>。最后，用<code>@WebFilter</code>注解标注该Filter需要过滤的URL。这里的<code>/*</code>表示所有路径。</p>\n<p>添加了Filter之后，整个请求的处理架构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">            ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">                                   /             ┌──────────────┐</span><br><span class=\"line\">            │                     ┌─────────────&gt;│ IndexServlet │ │</span><br><span class=\"line\">                                  │              └──────────────┘</span><br><span class=\"line\">            │                     │/signin       ┌──────────────┐ │</span><br><span class=\"line\">                                  ├─────────────&gt;│SignInServlet │</span><br><span class=\"line\">            │                     │              └──────────────┘ │</span><br><span class=\"line\">                                  │/signout      ┌──────────────┐</span><br><span class=\"line\">┌───────┐   │   ┌──────────────┐  ├─────────────&gt;│SignOutServlet│ │</span><br><span class=\"line\">│Browser│──────&gt;│EncodingFilter├──┤              └──────────────┘</span><br><span class=\"line\">└───────┘   │   └──────────────┘  │/user/profile ┌──────────────┐ │</span><br><span class=\"line\">                                  ├─────────────&gt;│ProfileServlet│</span><br><span class=\"line\">            │                     │              └──────────────┘ │</span><br><span class=\"line\">                                  │/user/post    ┌──────────────┐</span><br><span class=\"line\">            │                     ├─────────────&gt;│ PostServlet  │ │</span><br><span class=\"line\">                                  │              └──────────────┘</span><br><span class=\"line\">            │                     │/user/reply   ┌──────────────┐ │</span><br><span class=\"line\">                                  └─────────────&gt;│ ReplyServlet │</span><br><span class=\"line\">            │                                    └──────────────┘ │</span><br><span class=\"line\">             ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br></pre></td></tr></table></figure>\n\n<p>还可以继续添加其他Filter，例如LogFilter：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebFilter(<span class=\"string\">&quot;/*&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> LogFilter implements Filter &#123;</span><br><span class=\"line\">    public void <span class=\"keyword\">do</span><span class=\"constructor\">Filter(ServletRequest <span class=\"params\">request</span>, ServletResponse <span class=\"params\">response</span>, FilterChain <span class=\"params\">chain</span>)</span></span><br><span class=\"line\">            throws IOException, ServletException &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;LogFilter: process &quot;</span> + ((HttpServletRequest) request).get<span class=\"constructor\">RequestURI()</span>);</span><br><span class=\"line\">        chain.<span class=\"keyword\">do</span><span class=\"constructor\">Filter(<span class=\"params\">request</span>, <span class=\"params\">response</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>多个Filter会组成一个链，每个请求都被链上的Filter依次处理：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                                        ┌────────┐</span><br><span class=\"line\">                                     ┌─&gt;│ServletA│</span><br><span class=\"line\">                                     │  └────────┘</span><br><span class=\"line\">    ┌──────────────┐    ┌─────────┐  │  ┌────────┐</span><br><span class=\"line\">───&gt;│EncodingFilter│───&gt;│LogFilter│──┼─&gt;│ServletB│</span><br><span class=\"line\">    └──────────────┘    └─────────┘  │  └────────┘</span><br><span class=\"line\">                                     │  ┌────────┐</span><br><span class=\"line\">                                     └─&gt;│ServletC│</span><br><span class=\"line\">                                        └────────┘</span><br></pre></td></tr></table></figure>\n\n<p>有些细心的童鞋会问，有多个Filter的时候，Filter的顺序如何指定？多个Filter按不同顺序处理会造成处理结果不同吗？</p>\n<p>答案是Filter的顺序确实对处理的结果有影响。但遗憾的是，Servlet规范并没有对<code>@WebFilter</code>注解标注的Filter规定顺序。如果一定要给每个Filter指定顺序，就必须在<code>web.xml</code>文件中对这些Filter再配置一遍。</p>\n<p>注意到上述两个Filter的过滤路径都是<code>/*</code>，即它们会对所有请求进行过滤。也可以编写只对特定路径进行过滤的Filter，例如<code>AuthFilter</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebFilter(<span class=\"string\">&quot;/user/*&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> AuthFilter implements Filter &#123;</span><br><span class=\"line\">    public void <span class=\"keyword\">do</span><span class=\"constructor\">Filter(ServletRequest <span class=\"params\">request</span>, ServletResponse <span class=\"params\">response</span>, FilterChain <span class=\"params\">chain</span>)</span></span><br><span class=\"line\">            throws IOException, ServletException &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;AuthFilter: check authentication&quot;</span>);</span><br><span class=\"line\">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class=\"line\">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.get<span class=\"constructor\">Session()</span>.get<span class=\"constructor\">Attribute(<span class=\"string\">&quot;user&quot;</span>)</span><span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 未登录，自动跳转到登录页:</span></span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;AuthFilter: not signin!&quot;</span>);</span><br><span class=\"line\">            resp.send<span class=\"constructor\">Redirect(<span class=\"string\">&quot;/signin&quot;</span>)</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 已登录，继续处理:</span></span><br><span class=\"line\">            chain.<span class=\"keyword\">do</span><span class=\"constructor\">Filter(<span class=\"params\">request</span>, <span class=\"params\">response</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>AuthFilter</code>只过滤以<code>/user/</code>开头的路径，因此：</p>\n<ul>\n<li>如果一个请求路径类似<code>/user/profile</code>，那么它会被上述3个Filter依次处理；</li>\n<li>如果一个请求路径类似<code>/test</code>，那么它会被上述2个Filter依次处理（不会被AuthFilter处理）。</li>\n</ul>\n<p>再注意观察<code>AuthFilter</code>，当用户没有登录时，在<code>AuthFilter</code>内部，直接调用<code>resp.sendRedirect()</code>发送重定向，且没有调用<code>chain.doFilter()</code>，因此，当用户没有登录时，请求到达<code>AuthFilter</code>后，不再继续处理，即后续的Filter和任何Servlet都没有机会处理该请求了。</p>\n<p>可见，Filter可以有针对性地拦截或者放行HTTP请求。</p>\n<p>如果一个Filter在当前请求中生效，但什么都没有做：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebFilter(&quot;/*&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyFilter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doFilter</span><span class=\"params\">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> IOException, ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么，用户将看到一个空白页，因为请求没有继续处理，默认响应是200+空白输出。</p>\n<p> 如果Filter要使请求继续被处理，就一定要调用chain.doFilter()！</p>\n<p>如果我们使用上一节介绍的MVC模式，即一个统一的<code>DispatcherServlet</code>入口，加上多个Controller，这种模式下Filter仍然是正常工作的。例如，一个处理<code>/user/*</code>的Filter实际上作用于那些处理<code>/user/</code>开头的Controller方法之前。</p>\n<h2 id=\"修改请求\"><a href=\"#修改请求\" class=\"headerlink\" title=\"修改请求\"></a>修改请求</h2><p>Filter可以对请求进行预处理，因此，我们可以把很多公共预处理逻辑放到Filter中完成。</p>\n<p>考察这样一种需求：我们在Web应用中经常需要处理用户上传文件，例如，一个UploadServlet可以简单地编写如下：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\">@WebServlet(urlPatterns = <span class=\"string\">&quot;/upload/file&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> UploadServlet <span class=\"keyword\">extends</span> HttpServlet &#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> doPost(HttpServletRequest req, HttpServletResponse resp) <span class=\"keyword\">throws</span> ServletException, IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取Request Body:</span></span><br><span class=\"line\">        InputStream input = req.getInputStream();</span><br><span class=\"line\">        ByteArrayOutputStream output = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\">        <span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = input.<span class=\"keyword\">read</span>(buffer);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (len == -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            output.<span class=\"keyword\">write</span>(buffer, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 写入文件:</span></span><br><span class=\"line\">        <span class=\"comment\">// 显示上传结果:</span></span><br><span class=\"line\">        String uploadedText = output.toString(StandardCharsets.UTF_8);</span><br><span class=\"line\">        PrintWriter pw = resp.getWriter();</span><br><span class=\"line\">        pw.<span class=\"keyword\">write</span>(<span class=\"string\">&quot;&lt;h1&gt;Uploaded:&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        pw.<span class=\"keyword\">write</span>(<span class=\"string\">&quot;&lt;pre&gt;&lt;code&gt;&quot;</span>);</span><br><span class=\"line\">        pw.<span class=\"keyword\">write</span>(uploadedText);</span><br><span class=\"line\">        pw.<span class=\"keyword\">write</span>(<span class=\"string\">&quot;&lt;/code&gt;&lt;/pre&gt;&quot;</span>);</span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是要保证文件上传的完整性怎么办？在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1304227729113121\">哈希算法</a>一节中，我们知道，如果在上传文件的同时，把文件的哈希也传过来，服务器端做一个验证，就可以确保用户上传的文件一定是完整的。</p>\n<p>这个验证逻辑非常适合写在<code>ValidateUploadFilter</code>中，因为它可以复用。</p>\n<p>我们先写一个简单的版本，快速实现<code>ValidateUploadFilter</code>的逻辑：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebFilter(<span class=\"string\">&quot;/upload/*&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> ValidateUploadFilter implements Filter &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public void <span class=\"keyword\">do</span><span class=\"constructor\">Filter(ServletRequest <span class=\"params\">request</span>, ServletResponse <span class=\"params\">response</span>, FilterChain <span class=\"params\">chain</span>)</span></span><br><span class=\"line\">            throws IOException, ServletException &#123;</span><br><span class=\"line\">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class=\"line\">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class=\"line\">        <span class=\"comment\">// 获取客户端传入的签名方法和签名:</span></span><br><span class=\"line\">        String digest = req.get<span class=\"constructor\">Header(<span class=\"string\">&quot;Signature-Method&quot;</span>)</span>;</span><br><span class=\"line\">        String signature = req.get<span class=\"constructor\">Header(<span class=\"string\">&quot;Signature&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (digest<span class=\"operator\"> == </span>null<span class=\"operator\"> || </span>digest.is<span class=\"constructor\">Empty()</span><span class=\"operator\"> || </span>signature<span class=\"operator\"> == </span>null<span class=\"operator\"> || </span>signature.is<span class=\"constructor\">Empty()</span>) &#123;</span><br><span class=\"line\">            send<span class=\"constructor\">ErrorPage(<span class=\"params\">resp</span>, <span class=\"string\">&quot;Missing signature.&quot;</span>)</span>;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 读取Request的Body并验证签名:</span></span><br><span class=\"line\">        MessageDigest md = get<span class=\"constructor\">MessageDigest(<span class=\"params\">digest</span>)</span>;</span><br><span class=\"line\">        InputStream input = <span class=\"keyword\">new</span> <span class=\"constructor\">DigestInputStream(<span class=\"params\">request</span>.<span class=\"params\">getInputStream</span>()</span>, md);</span><br><span class=\"line\">        byte<span class=\"literal\">[]</span> buffer = <span class=\"keyword\">new</span> byte<span class=\"literal\">[<span class=\"number\">1024</span>]</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">int</span> len = input.read(buffer);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (len<span class=\"operator\"> == </span>-<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String actual = <span class=\"keyword\">to</span><span class=\"constructor\">HexString(<span class=\"params\">md</span>.<span class=\"params\">digest</span>()</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!signature.equals(actual)) &#123;</span><br><span class=\"line\">            send<span class=\"constructor\">ErrorPage(<span class=\"params\">resp</span>, <span class=\"string\">&quot;Invalid signature.&quot;</span>)</span>;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 验证成功后继续处理:</span></span><br><span class=\"line\">        chain.<span class=\"keyword\">do</span><span class=\"constructor\">Filter(<span class=\"params\">request</span>, <span class=\"params\">response</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 将byte[]转换为hex string:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String <span class=\"keyword\">to</span><span class=\"constructor\">HexString(<span class=\"params\">byte</span>[] <span class=\"params\">digest</span>)</span> &#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> <span class=\"constructor\">StringBuilder()</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (byte b : digest) &#123;</span><br><span class=\"line\">            sb.append(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>format(<span class=\"string\">&quot;%02x&quot;</span>, b));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return sb.<span class=\"keyword\">to</span><span class=\"constructor\">String()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 根据名称创建MessageDigest:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MessageDigest get<span class=\"constructor\">MessageDigest(String <span class=\"params\">name</span>)</span> throws ServletException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">MessageDigest</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"params\">name</span>)</span>;</span><br><span class=\"line\">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class=\"line\">            throw <span class=\"keyword\">new</span> <span class=\"constructor\">ServletException(<span class=\"params\">e</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 发送一个错误响应:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> void send<span class=\"constructor\">ErrorPage(HttpServletResponse <span class=\"params\">resp</span>, String <span class=\"params\">errorMessage</span>)</span> throws IOException &#123;</span><br><span class=\"line\">        resp.set<span class=\"constructor\">Status(HttpServletResponse.SC_BAD_REQUEST)</span>;</span><br><span class=\"line\">        PrintWriter pw = resp.get<span class=\"constructor\">Writer()</span>;</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;&quot;</span>);</span><br><span class=\"line\">        pw.write(errorMessage);</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class=\"line\">        pw.flush<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>ValidateUploadFilter</code>的逻辑似乎没有问题，我们可以用curl命令测试：</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl http://localhos<span class=\"variable\">t:8080</span>/upload/<span class=\"keyword\">file</span> -v -d <span class=\"string\">&#x27;test-data&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Signature-Method: SHA-1&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Signature: 7115e9890f5b5cc6914bdfa3b7c011db1cdafedb&#x27;</span> \\</span><br><span class=\"line\">  -H <span class=\"string\">&#x27;Content-Type: application/octet-stream&#x27;</span></span><br><span class=\"line\">*   Trying ::<span class=\"number\">1</span>...</span><br><span class=\"line\">* TCP_NODELAY <span class=\"keyword\">set</span></span><br><span class=\"line\">* Connected <span class=\"keyword\">to</span> localhost (::<span class=\"number\">1</span>) port <span class=\"number\">8080</span> (#<span class=\"number\">0</span>)</span><br><span class=\"line\">&gt; POST /upload/<span class=\"keyword\">file</span> HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">&gt; Hos<span class=\"variable\">t:</span> localhos<span class=\"variable\">t:8080</span></span><br><span class=\"line\">&gt; User-Agen<span class=\"variable\">t:</span> curl/<span class=\"number\">7.64</span>.<span class=\"number\">1</span></span><br><span class=\"line\">&gt; Accep<span class=\"variable\">t:</span> */*</span><br><span class=\"line\">&gt; Signature-Method: SHA-<span class=\"number\">1</span></span><br><span class=\"line\">&gt; Signature: <span class=\"number\">7115</span>e9890f5b5cc6914bdfa3b7c011db1cdafedb</span><br><span class=\"line\">&gt; Content-Type: application/octet-stream</span><br><span class=\"line\">&gt; Content-Length: <span class=\"number\">9</span></span><br><span class=\"line\">&gt; </span><br><span class=\"line\">* upload completely sent off: <span class=\"number\">9</span> out of <span class=\"number\">9</span> bytes</span><br><span class=\"line\">&lt; HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> </span><br><span class=\"line\">&lt; Transfer-Encodin<span class=\"variable\">g:</span> chunked</span><br><span class=\"line\">&lt; Date: Thu, <span class=\"number\">30</span> Jan <span class=\"number\">2020</span> <span class=\"number\">13</span>:<span class=\"number\">56</span>:<span class=\"number\">39</span> GMT</span><br><span class=\"line\">&lt; </span><br><span class=\"line\">* Connection #<span class=\"number\">0</span> <span class=\"keyword\">to</span> host localhost <span class=\"keyword\">left</span> intact</span><br><span class=\"line\"><span class=\"symbol\">&lt;h1&gt;</span>Uploaded:&lt;/h1&gt;<span class=\"symbol\">&lt;pre&gt;</span><span class=\"symbol\">&lt;code&gt;</span>&lt;/code&gt;&lt;/<span class=\"keyword\">pre</span>&gt;</span><br><span class=\"line\">* Closing connection <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p><code>ValidateUploadFilter</code>对签名进行验证的逻辑是没有问题的，但是，细心的童鞋注意到，<code>UploadServlet</code>并未读取到任何数据！</p>\n<p>这里的原因是对<code>HttpServletRequest</code>进行读取时，只能读取一次。如果Filter调用<code>getInputStream()</code>读取了一次数据，后续Servlet处理时，再次读取，将无法读到任何数据。怎么办？</p>\n<p>这个时候，我们需要一个“伪造”的<code>HttpServletRequest</code>，具体做法是使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017\">代理模式</a>，对<code>getInputStream()</code>和<code>getReader()</code>返回一个新的流：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReReadableHttpServletRequest</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] body;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> open = <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReReadableHttpServletRequest</span><span class=\"params\">(HttpServletRequest request, <span class=\"keyword\">byte</span>[] body)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(request);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.body = body;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回InputStream:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ServletInputStream <span class=\"title\">getInputStream</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (open) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Cannot re-open input stream!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        open = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServletInputStream() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> offset = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isFinished</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> offset &gt;= body.length;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isReady</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setReadListener</span><span class=\"params\">(ReadListener listener)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">read</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (offset &gt;= body.length) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> n = body[offset] &amp; <span class=\"number\">0xff</span>;</span><br><span class=\"line\">                offset++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回Reader:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> BufferedReader <span class=\"title\">getReader</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (open) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Cannot re-open reader!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        open = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> ByteArrayInputStream(body), <span class=\"string\">&quot;UTF-8&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意观察<code>ReReadableHttpServletRequest</code>的构造方法，它保存了<code>ValidateUploadFilter</code>读取的<code>byte[]</code>内容，并在调用<code>getInputStream()</code>时通过<code>byte[]</code>构造了一个新的<code>ServletInputStream</code>。</p>\n<p>然后，我们在<code>ValidateUploadFilter</code>中，把<code>doFilter()</code>调用时传给下一个处理者的<code>HttpServletRequest</code>替换为我们自己“伪造”的<code>ReReadableHttpServletRequest</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void <span class=\"keyword\">do</span><span class=\"constructor\">Filter(ServletRequest <span class=\"params\">request</span>, ServletResponse <span class=\"params\">response</span>, FilterChain <span class=\"params\">chain</span>)</span></span><br><span class=\"line\">        throws IOException, ServletException &#123;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\">    </span>chain.<span class=\"keyword\">do</span><span class=\"constructor\">Filter(<span class=\"params\">new</span> ReReadableHttpServletRequest(<span class=\"params\">req</span>, <span class=\"params\">output</span>.<span class=\"params\">toByteArray</span>()</span>), response);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再注意到我们编写<code>ReReadableHttpServletRequest</code>时，是从<code>HttpServletRequestWrapper</code>继承，而不是直接实现<code>HttpServletRequest</code>接口。这是因为，Servlet的每个新版本都会对接口增加一些新方法，从<code>HttpServletRequestWrapper</code>继承可以确保新方法被正确地覆写了，因为<code>HttpServletRequestWrapper</code>是由Servlet的jar包提供的，目的就是为了让我们方便地实现对<code>HttpServletRequest</code>接口的代理。</p>\n<p>我们总结一下对<code>HttpServletRequest</code>接口进行代理的步骤：</p>\n<ol>\n<li>从<code>HttpServletRequestWrapper</code>继承一个<code>XxxHttpServletRequest</code>，需要传入原始的<code>HttpServletRequest</code>实例；</li>\n<li>覆写某些方法，使得新的<code>XxxHttpServletRequest</code>实例看上去“改变”了原始的<code>HttpServletRequest</code>实例；</li>\n<li>在<code>doFilter()</code>中传入新的<code>XxxHttpServletRequest</code>实例。</li>\n</ol>\n<p>虽然整个Filter的代码比较复杂，但它的好处在于：这个Filter在整个处理链中实现了灵活的“可插拔”特性，即是否启用对Web应用程序的其他组件（Filter、Servlet）完全没有影响。</p>\n<h2 id=\"修改响应\"><a href=\"#修改响应\" class=\"headerlink\" title=\"修改响应\"></a>修改响应</h2><p>既然我们能通过Filter修改<code>HttpServletRequest</code>，自然也能修改<code>HttpServletResponse</code>，因为这两者都是接口。</p>\n<p>我们来看一下在什么情况下我们需要修改<code>HttpServletResponse</code>。</p>\n<p>假设我们编写了一个Servlet，但由于业务逻辑比较复杂，处理该请求需要耗费很长的时间：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(urlPatterns = <span class=\"string\">&quot;/slow/hello&quot;</span>)</span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void doGet(<span class=\"type\">HttpServletRequest</span> req, <span class=\"type\">HttpServletResponse</span> resp) <span class=\"keyword\">throws</span> <span class=\"type\">ServletException</span>, <span class=\"type\">IOException</span> &#123;</span><br><span class=\"line\">        resp.setContentType(<span class=\"string\">&quot;text/html&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 模拟耗时1秒:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span>.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (<span class=\"type\">InterruptedException</span> e) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">PrintWriter</span> pw = resp.getWriter();</span><br><span class=\"line\">        pw.write(<span class=\"string\">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>);</span><br><span class=\"line\">        pw.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>好消息是每次返回的响应内容是固定的，因此，如果我们能使用缓存将结果缓存起来，就可以大大提高Web应用程序的运行效率。</p>\n<p>缓存逻辑最好不要在Servlet内部实现，因为我们希望能复用缓存逻辑，所以，编写一个<code>CacheFilter</code>最合适：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebFilter(<span class=\"string\">&quot;/slow/*&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> CacheFilter implements Filter &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Path到byte[]的缓存:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, byte<span class=\"literal\">[]</span>&gt; cache = <span class=\"keyword\">new</span> ConcurrentHashMap&lt;&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"keyword\">do</span><span class=\"constructor\">Filter(ServletRequest <span class=\"params\">request</span>, ServletResponse <span class=\"params\">response</span>, FilterChain <span class=\"params\">chain</span>)</span></span><br><span class=\"line\">            throws IOException, ServletException &#123;</span><br><span class=\"line\">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class=\"line\">        HttpServletResponse resp = (HttpServletResponse) response;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Path:</span></span><br><span class=\"line\">        String url = req.get<span class=\"constructor\">RequestURI()</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 获取缓存内容:</span></span><br><span class=\"line\">        byte<span class=\"literal\">[]</span> data = this.cache.get(url);</span><br><span class=\"line\">        resp.set<span class=\"constructor\">Header(<span class=\"string\">&quot;X-Cache-Hit&quot;</span>, <span class=\"params\">data</span> <span class=\"operator\">==</span> <span class=\"params\">null</span> ? <span class=\"string\">&quot;No&quot;</span> : <span class=\"string\">&quot;Yes&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (data<span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存未找到,构造一个伪造的Response:</span></span><br><span class=\"line\">            CachedHttpServletResponse wrapper = <span class=\"keyword\">new</span> <span class=\"constructor\">CachedHttpServletResponse(<span class=\"params\">resp</span>)</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 让下游组件写入数据到伪造的Response:</span></span><br><span class=\"line\">            chain.<span class=\"keyword\">do</span><span class=\"constructor\">Filter(<span class=\"params\">request</span>, <span class=\"params\">wrapper</span>)</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 从伪造的Response中读取写入的内容并放入缓存:</span></span><br><span class=\"line\">            data = wrapper.get<span class=\"constructor\">Content()</span>;</span><br><span class=\"line\">            cache.put(url, data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 写入到原始的Response:</span></span><br><span class=\"line\">        ServletOutputStream output = resp.get<span class=\"constructor\">OutputStream()</span>;</span><br><span class=\"line\">        output.write(data);</span><br><span class=\"line\">        output.flush<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现缓存的关键在于，调用<code>doFilter()</code>时，我们不能传入原始的<code>HttpServletResponse</code>，因为这样就会写入Socket，我们也就无法获取下游组件写入的内容。如果我们传入的是“伪造”的<code>HttpServletResponse</code>，让下游组件写入到我们预设的<code>ByteArrayOutputStream</code>，我们就“截获”了下游组件写入的内容，于是，就可以把内容缓存起来，再通过原始的<code>HttpServletResponse</code>实例写入到网络。</p>\n<p>这个<code>CachedHttpServletResponse</code>实现如下：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CachedHttpServletResponse</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServletResponseWrapper</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> open = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ByteArrayOutputStream output = <span class=\"keyword\">new</span> ByteArrayOutputStream();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CachedHttpServletResponse</span><span class=\"params\">(HttpServletResponse response)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取Writer:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">PrintWriter <span class=\"title\">getWriter</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (open) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Cannot re-open writer!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        open = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PrintWriter(output, <span class=\"keyword\">false</span>, StandardCharsets.UTF_8);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取OutputStream:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">ServletOutputStream <span class=\"title\">getOutputStream</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (open) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Cannot re-open output stream!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        open = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ServletOutputStream() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isReady</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setWriteListener</span><span class=\"params\">(WriteListener listener)</span> </span>&#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 实际写入ByteArrayOutputStream:</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">int</span> b)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">                output.write(b);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回写入的byte[]:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">byte</span>[] getContent() &#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">return</span> output.<span class=\"title\">toByteArray</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，如果我们想要修改响应，就可以通过<code>HttpServletResponseWrapper</code>构造一个“伪造”的<code>HttpServletResponse</code>，这样就能拦截到写入的数据。</p>\n<p>修改响应时，最后不要忘记把数据写入原始的<code>HttpServletResponse</code>实例。</p>\n<p>这个<code>CacheFilter</code>同样是一个“可插拔”组件，它是否启用不影响Web应用程序的其他组件（Filter、Servlet）。</p>\n<h1 id=\"Listener\"><a href=\"#Listener\" class=\"headerlink\" title=\"Listener\"></a>Listener</h1><p>除了Servlet和Filter外，JavaEE的Servlet规范还提供了第三种组件：Listener。</p>\n<p>Listener顾名思义就是监听器，有好几种Listener，其中最常用的是<code>ServletContextListener</code>，我们编写一个实现了<code>ServletContextListener</code>接口的类如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebListener</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppListener</span> <span class=\"keyword\">implements</span> <span class=\"title\">ServletContextListener</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在此初始化WebApp,例如打开数据库连接池等:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextInitialized</span><span class=\"params\">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;WebApp initialized.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在此清理WebApp,例如关闭数据库连接池等:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">contextDestroyed</span><span class=\"params\">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;WebApp destroyed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>任何标注为<code>@WebListener</code>，且实现了特定接口的类会被Web服务器自动初始化。上述<code>AppListener</code>实现了<code>ServletContextListener</code>接口，它会在整个Web应用程序初始化完成后，以及Web应用程序关闭后获得回调通知。我们可以把初始化数据库连接池等工作放到<code>contextInitialized()</code>回调方法中，把清理资源的工作放到<code>contextDestroyed()</code>回调方法中，因为Web服务器保证在<code>contextInitialized()</code>执行后，才会接受用户的HTTP请求。</p>\n<p>很多第三方Web框架都会通过一个<code>ServletContextListener</code>接口初始化自己。</p>\n<p>除了<code>ServletContextListener</code>外，还有几种Listener：</p>\n<ul>\n<li>HttpSessionListener：监听HttpSession的创建和销毁事件；</li>\n<li>ServletRequestListener：监听ServletRequest请求的创建和销毁事件；</li>\n<li>ServletRequestAttributeListener：监听ServletRequest请求的属性变化事件（即调用<code>ServletRequest.setAttribute()</code>方法）；</li>\n<li>ServletContextAttributeListener：监听ServletContext的属性变化事件（即调用<code>ServletContext.setAttribute()</code>方法）；</li>\n</ul>\n<h3 id=\"ServletContext\"><a href=\"#ServletContext\" class=\"headerlink\" title=\"ServletContext\"></a>ServletContext</h3><p>一个Web服务器可以运行一个或多个WebApp，对于每个WebApp，Web服务器都会为其创建一个全局唯一的<code>ServletContext</code>实例，我们在<code>AppListener</code>里面编写的两个回调方法实际上对应的就是<code>ServletContext</code>实例的创建和销毁：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public void context<span class=\"constructor\">Initialized(ServletContextEvent <span class=\"params\">sce</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;WebApp initialized: ServletContext = &quot;</span> + sce.get<span class=\"constructor\">ServletContext()</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ServletRequest</code>、<code>HttpSession</code>等很多对象也提供<code>getServletContext()</code>方法获取到同一个<code>ServletContext</code>实例。<code>ServletContext</code>实例最大的作用就是设置和共享全局信息。</p>\n<p>此外，<code>ServletContext</code>还提供了动态添加Servlet、Filter、Listener等功能，它允许应用程序在运行期间动态添加一个组件，虽然这个功能不是很常用。</p>\n<h1 id=\"JSTL\"><a href=\"#JSTL\" class=\"headerlink\" title=\"JSTL\"></a>JSTL</h1><h1 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h1><p>对一个Web应用程序来说，除了Servlet、Filter这些逻辑组件，还需要JSP这样的视图文件，外加一堆静态资源文件，如CSS、JS等。</p>\n<p>合理组织文件结构非常重要。我们以一个具体的Web应用程序为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">webapp</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │   └── com</span><br><span class=\"line\">        │       └── itranswarp</span><br><span class=\"line\">        │           └── learnjava</span><br><span class=\"line\">        │               ├── Main.java</span><br><span class=\"line\">        │               ├── filter</span><br><span class=\"line\">        │               │   └── EncodingFilter.java</span><br><span class=\"line\">        │               └── servlet</span><br><span class=\"line\">        │                   ├── FileServlet.java</span><br><span class=\"line\">        │                   └── HelloServlet.java</span><br><span class=\"line\">        ├── resources</span><br><span class=\"line\">        └── webapp</span><br><span class=\"line\">            ├── WEB-INF</span><br><span class=\"line\">            │   └── web.xml</span><br><span class=\"line\">            ├── favicon.ico</span><br><span class=\"line\">            └── static</span><br><span class=\"line\">                └── bootstrap.css</span><br></pre></td></tr></table></figure>\n\n<p>我们把所有的静态资源文件放入<code>/static/</code>目录，在开发阶段，有些Web服务器会自动为我们加一个专门负责处理静态文件的Servlet，但如果<code>IndexServlet</code>映射路径为<code>/</code>，会屏蔽掉处理静态文件的Servlet映射。因此，我们需要自己编写一个处理静态文件的<code>FileServlet</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">WebServlet(<span class=\"params\">urlPatterns</span> = <span class=\"string\">&quot;/static/*&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> FileServlet extends HttpServlet &#123;</span><br><span class=\"line\">    protected void <span class=\"keyword\">do</span><span class=\"constructor\">Get(HttpServletRequest <span class=\"params\">req</span>, HttpServletResponse <span class=\"params\">resp</span>)</span> throws ServletException, IOException &#123;</span><br><span class=\"line\">        ServletContext ctx = req.get<span class=\"constructor\">ServletContext()</span>;</span><br><span class=\"line\">        <span class=\"comment\">// RequestURI包含ContextPath,需要去掉:</span></span><br><span class=\"line\">        String urlPath = req.get<span class=\"constructor\">RequestURI()</span>.substring(ctx.get<span class=\"constructor\">ContextPath()</span>.length<span class=\"literal\">()</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 获取真实文件路径:</span></span><br><span class=\"line\">        String filepath = ctx.get<span class=\"constructor\">RealPath(<span class=\"params\">urlPath</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (filepath<span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 无法获取到路径:</span></span><br><span class=\"line\">            resp.send<span class=\"constructor\">Error(HttpServletResponse.SC_NOT_FOUND)</span>;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Path path = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Paths</span>.</span></span>get(filepath);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!path.<span class=\"keyword\">to</span><span class=\"constructor\">File()</span>.is<span class=\"constructor\">File()</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 文件不存在:</span></span><br><span class=\"line\">            resp.send<span class=\"constructor\">Error(HttpServletResponse.SC_NOT_FOUND)</span>;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 根据文件名猜测Content-Type:</span></span><br><span class=\"line\">        String mime = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>probe<span class=\"constructor\">ContentType(<span class=\"params\">path</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mime<span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">            mime = <span class=\"string\">&quot;application/octet-stream&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resp.set<span class=\"constructor\">ContentType(<span class=\"params\">mime</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 读取文件并写入Response:</span></span><br><span class=\"line\">        OutputStream output = resp.get<span class=\"constructor\">OutputStream()</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream input = <span class=\"keyword\">new</span> <span class=\"constructor\">BufferedInputStream(<span class=\"params\">new</span> FileInputStream(<span class=\"params\">filepath</span>)</span>)) &#123;</span><br><span class=\"line\">            input.transfer<span class=\"constructor\">To(<span class=\"params\">output</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        output.flush<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，在开发阶段，我们就可以方便地高效开发。</p>\n<p>类似Tomcat这样的Web服务器，运行的Web应用程序通常都是业务系统，因此，这类服务器也被称为应用服务器。应用服务器并不擅长处理静态文件，也不适合直接暴露给用户。通常，我们在生产环境部署时，总是使用类似Nginx这样的服务器充当反向代理和静态服务器，只有动态请求才会放行给应用服务器，所以，部署架构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">             ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\"></span><br><span class=\"line\">             │  /static/*            │</span><br><span class=\"line\">┌───────┐      ┌──────────&gt; file</span><br><span class=\"line\">│Browser├────┼─┤                     │    ┌ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">└───────┘      │/          proxy_pass</span><br><span class=\"line\">             │ └─────────────────────┼───&gt;│  Web Server │</span><br><span class=\"line\">                       Nginx</span><br><span class=\"line\">             └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘    └ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>实现上述功能的Nginx配置文件如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    server_name www.local.liaoxuefeng.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 静态文件根目录:</span></span><br><span class=\"line\">    root <span class=\"regexp\">/path/</span>to<span class=\"regexp\">/src/m</span>ain/webapp;</span><br><span class=\"line\"></span><br><span class=\"line\">    access_log <span class=\"regexp\">/var/</span>log<span class=\"regexp\">/nginx/</span>webapp_access_log;</span><br><span class=\"line\">    error_log  <span class=\"regexp\">/var/</span>log<span class=\"regexp\">/nginx/</span>webapp_error_log;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 处理静态文件请求:</span></span><br><span class=\"line\">    location /static &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 处理静态文件请求:</span></span><br><span class=\"line\">    location /favicon.ico &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 不允许请求/WEB-INF:</span></span><br><span class=\"line\">    location /WEB-INF &#123;</span><br><span class=\"line\">        return <span class=\"number\">404</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 其他请求转发给Tomcat:</span></span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass       http:<span class=\"regexp\">//</span><span class=\"number\">127.0</span>.<span class=\"number\">0.1</span>:<span class=\"number\">8080</span>;</span><br><span class=\"line\">        proxy_set_header Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">        proxy_set_header X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-Proto <span class=\"variable\">$scheme</span>;</span><br><span class=\"line\">        proxy_set_header X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用Nginx配合Tomcat服务器，可以充分发挥Nginx作为网关的优势，既可以高效处理静态文件，也可以把https、防火墙、限速、反爬虫等功能放到Nginx中，使得我们自己的WebApp能专注于业务逻辑。</p>\n","categories":["Java","4.开发框架","1.JavaWeb"],"tags":["写作"]},{"title":"5.MyBatis Plis","url":"/2022/02/04/4-Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_5.MyBatis%20Plus/","content":"<h1 id=\"描述：Mybatis-的增强工具，能够简化开发、提高效率\"><a href=\"#描述：Mybatis-的增强工具，能够简化开发、提高效率\" class=\"headerlink\" title=\"描述：Mybatis. 的增强工具，能够简化开发、提高效率\"></a>描述：Mybatis. 的增强工具，能够简化开发、提高效率</h1><h1 id=\"引入\"><a href=\"#引入\" class=\"headerlink\" title=\"引入\"></a>引入</h1><h1 id=\"通用-CRUD\"><a href=\"#通用-CRUD\" class=\"headerlink\" title=\"通用. CRUD\"></a>通用. CRUD</h1><h1 id=\"条件构造器\"><a href=\"#条件构造器\" class=\"headerlink\" title=\"条件构造器\"></a>条件构造器</h1><h1 id=\"代码生成器\"><a href=\"#代码生成器\" class=\"headerlink\" title=\"代码生成器\"></a>代码生成器</h1><h1 id=\"插件扩展\"><a href=\"#插件扩展\" class=\"headerlink\" title=\"插件扩展\"></a>插件扩展</h1><h1 id=\"自定义全局操作\"><a href=\"#自定义全局操作\" class=\"headerlink\" title=\"自定义全局操作\"></a>自定义全局操作</h1>","categories":["Java","4.开发框架","5.MyBatis Plis"],"tags":["写作"]},{"title":"3.Spring MVC","url":"/2022/02/04/4-Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_3.Spring%20MVC/","content":"<h1 id=\"描述：Java-轻量级-web-开发框架\"><a href=\"#描述：Java-轻量级-web-开发框架\" class=\"headerlink\" title=\"描述：Java. 轻量级. web. 开发框架\"></a>描述：Java. 轻量级. web. 开发框架</h1><h1 id=\"什么是-MVC？\"><a href=\"#什么是-MVC？\" class=\"headerlink\" title=\"什么是. MVC？\"></a>什么是. MVC？</h1><h1 id=\"请求与响应\"><a href=\"#请求与响应\" class=\"headerlink\" title=\"请求与响应\"></a>请求与响应</h1><h1 id=\"Restful-API\"><a href=\"#Restful-API\" class=\"headerlink\" title=\"Restful. API\"></a>Restful. API</h1><h1 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h1><h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><h1 id=\"执行过程\"><a href=\"#执行过程\" class=\"headerlink\" title=\"执行过程\"></a>执行过程</h1>","categories":["Java","4.开发框架","3.Spring MVC"],"tags":["写作"]},{"title":"2.Spring 5","url":"/2022/02/04/4-Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_2.Spring%205/","content":"<h1 id=\"描述：Java-轻量级应用框架\"><a href=\"#描述：Java-轻量级应用框架\" class=\"headerlink\" title=\"描述：Java. 轻量级应用框架\"></a>描述：Java. 轻量级应用框架</h1><p>什么是Spring？</p>\n<p>Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。</p>\n<p>![java-spring](2.Spring 5.assets&#x2F;l.jpeg)</p>\n<p>Spring最早是由Rod Johnson这哥们在他的《<a href=\"https://book.douban.com/subject/1426848/\">Expert One-on-One J2EE Development without EJB</a>》一书中提出的用来取代EJB的轻量级框架。随后这哥们又开始专心开发这个基础框架，并起名为Spring Framework。</p>\n<p>随着Spring越来越受欢迎，在Spring Framework基础上，又诞生了Spring Boot、Spring Cloud、Spring Data、Spring Security等一系列基于Spring Framework的项目。本章我们只介绍Spring Framework，即最核心的Spring框架。后续章节我们还会涉及Spring Boot、Spring Cloud等其他框架。</p>\n<h3 id=\"Spring-Framework\"><a href=\"#Spring-Framework\" class=\"headerlink\" title=\"Spring Framework\"></a>Spring Framework</h3><p>Spring Framework主要包括几个模块：</p>\n<ul>\n<li>支持IoC和AOP的容器；</li>\n<li>支持JDBC和ORM的数据访问模块；</li>\n<li>支持声明式事务的模块；</li>\n<li>支持基于Servlet的MVC开发；</li>\n<li>支持基于Reactive的Web开发；</li>\n<li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li>\n</ul>\n<p>我们会依次介绍Spring Framework的主要功能。</p>\n<h1 id=\"IOC容器\"><a href=\"#IOC容器\" class=\"headerlink\" title=\"IOC容器\"></a>IOC容器</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。</p>\n<p>什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p>\n<p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p>\n<p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p>\n<p>本章我们讨论的IoC容器，主要介绍Spring容器如何对组件进行生命周期管理和配置组装服务。</p>\n<h2 id=\"IOC原理\"><a href=\"#IOC原理\" class=\"headerlink\" title=\"IOC原理\"></a>IOC原理</h2><p>Spring提供的容器又称为IoC容器，什么是IoC？</p>\n<p>IoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。</p>\n<p>我们假定一个在线书店，通过<code>BookService</code>获取书籍：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookService</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HikariConfig config = <span class=\"keyword\">new</span> <span class=\"built_in\">HikariConfig</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSource dataSource = <span class=\"keyword\">new</span> <span class=\"built_in\">HikariDataSource</span>(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Book <span class=\"title\">getBook</span><span class=\"params\">(<span class=\"keyword\">long</span> bookId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">try</span></span> (Connection conn = dataSource.<span class=\"built_in\">getConnection</span>()) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">return</span> book;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了从数据库查询书籍，<code>BookService</code>持有一个<code>DataSource</code>。为了实例化一个<code>HikariDataSource</code>，又不得不实例化一个<code>HikariConfig</code>。</p>\n<p>现在，我们继续编写<code>UserService</code>获取用户：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HikariConfig config = <span class=\"keyword\">new</span> <span class=\"built_in\">HikariConfig</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSource dataSource = <span class=\"keyword\">new</span> <span class=\"built_in\">HikariDataSource</span>(config);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">(<span class=\"keyword\">long</span> userId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">try</span></span> (Connection conn = dataSource.<span class=\"built_in\">getConnection</span>()) &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">            <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>UserService</code>也需要访问数据库，因此，我们不得不也实例化一个<code>HikariDataSource</code>。</p>\n<p>在处理用户购买的<code>CartServlet</code>中，我们需要实例化<code>UserService</code>和<code>BookService</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> CartServlet extends HttpServlet &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BookService bookService = <span class=\"keyword\">new</span> <span class=\"constructor\">BookService()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService userService = <span class=\"keyword\">new</span> <span class=\"constructor\">UserService()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    protected void <span class=\"keyword\">do</span><span class=\"constructor\">Get(HttpServletRequest <span class=\"params\">req</span>, HttpServletResponse <span class=\"params\">resp</span>)</span> throws ServletException, IOException &#123;</span><br><span class=\"line\">        long currentUserId = get<span class=\"constructor\">FromCookie(<span class=\"params\">req</span>)</span>;</span><br><span class=\"line\">        User currentUser = userService.get<span class=\"constructor\">User(<span class=\"params\">currentUserId</span>)</span>;</span><br><span class=\"line\">        Book book = bookService.get<span class=\"constructor\">Book(<span class=\"params\">req</span>.<span class=\"params\">getParameter</span>(<span class=\"string\">&quot;bookId&quot;</span>)</span>);</span><br><span class=\"line\">        cartService.add<span class=\"constructor\">ToCart(<span class=\"params\">currentUser</span>, <span class=\"params\">book</span>)</span>;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">        ...</span></span><br><span class=\"line\"><span class=\"operator\">    </span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似的，在购买历史<code>HistoryServlet</code>中，也需要实例化<code>UserService</code>和<code>BookService</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HistoryServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">BookService</span> bookService = <span class=\"keyword\">new</span> <span class=\"type\">BookService</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">UserService</span> userService = <span class=\"keyword\">new</span> <span class=\"type\">UserService</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述每个组件都采用了一种简单的通过<code>new</code>创建实例并持有的方式。仔细观察，会发现以下缺点：</p>\n<ol>\n<li>实例化一个组件其实很难，例如，<code>BookService</code>和<code>UserService</code>要创建<code>HikariDataSource</code>，实际上需要读取配置，才能先实例化<code>HikariConfig</code>，再实例化<code>HikariDataSource</code>。</li>\n<li>没有必要让<code>BookService</code>和<code>UserService</code>分别创建<code>DataSource</code>实例，完全可以共享同一个<code>DataSource</code>，但谁负责创建<code>DataSource</code>，谁负责获取其他组件已经创建的<code>DataSource</code>，不好处理。类似的，<code>CartServlet</code>和<code>HistoryServlet</code>也应当共享<code>BookService</code>实例和<code>UserService</code>实例，但也不好处理。</li>\n<li>很多组件需要销毁以便释放资源，例如<code>DataSource</code>，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</li>\n<li>随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。</li>\n<li>测试某个组件，例如<code>BookService</code>，是复杂的，因为必须要在真实的数据库环境下执行。</li>\n</ol>\n<p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p>\n<p>因此，核心问题是：</p>\n<ol>\n<li>谁负责创建组件？</li>\n<li>谁负责根据依赖关系组装组件？</li>\n<li>销毁时，如何按依赖顺序正确销毁？</li>\n</ol>\n<p>解决这一问题的核心方案就是IoC。</p>\n<p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：</p>\n<p><code>CartServlet</code>创建了<code>BookService</code>，在创建<code>BookService</code>的过程中，又创建了<code>DataSource</code>组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p>\n<p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，<code>BookService</code>自己并不会创建<code>DataSource</code>，而是等待外部通过<code>setDataSource()</code>方法来注入一个<code>DataSource</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSource dataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setDataSource</span><span class=\"params\">(DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataSource = dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p>\n<ol>\n<li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li>\n<li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li>\n<li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li>\n</ol>\n<p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p>\n<p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;beans&gt;</span><br><span class=\"line\">    &lt;bean id=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"keyword\">class</span>=&quot;<span class=\"symbol\">HikariDataSource</span>&quot; /&gt;</span><br><span class=\"line\">    &lt;<span class=\"symbol\">bean</span> <span class=\"symbol\">id</span>=&quot;<span class=\"symbol\">bookService</span>&quot; <span class=\"symbol\">class</span>=&quot;<span class=\"symbol\">BookService</span>&quot;&gt;</span><br><span class=\"line\">        &lt;<span class=\"symbol\">property</span> <span class=\"symbol\">name</span>=&quot;<span class=\"symbol\">dataSource</span>&quot; <span class=\"symbol\">ref</span>=&quot;<span class=\"symbol\">dataSource</span>&quot; /&gt;</span><br><span class=\"line\">    &lt;/<span class=\"symbol\">bean</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"symbol\">bean</span> <span class=\"symbol\">id</span>=&quot;<span class=\"symbol\">userService</span>&quot; <span class=\"symbol\">class</span>=&quot;<span class=\"symbol\">UserService</span>&quot;&gt;</span><br><span class=\"line\">        &lt;<span class=\"symbol\">property</span> <span class=\"symbol\">name</span>=&quot;<span class=\"symbol\">dataSource</span>&quot; <span class=\"symbol\">ref</span>=&quot;<span class=\"symbol\">dataSource</span>&quot; /&gt;</span><br><span class=\"line\">    &lt;/<span class=\"symbol\">bean</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"symbol\">beans</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p>\n<p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p>\n<h3 id=\"依赖注入方式\"><a href=\"#依赖注入方式\" class=\"headerlink\" title=\"依赖注入方式\"></a>依赖注入方式</h3><p>我们从上面的代码可以看到，依赖注入可以通过<code>set()</code>方法实现。但依赖注入也可以通过构造方法实现。</p>\n<p>很多Java类都具有带参数的构造方法，如果我们把<code>BookService</code>改造为通过构造方法注入，那么实现代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSource dataSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BookService</span><span class=\"params\">(DataSource dataSource)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataSource = dataSource;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p>\n<h3 id=\"无侵入容器\"><a href=\"#无侵入容器\" class=\"headerlink\" title=\"无侵入容器\"></a>无侵入容器</h3><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p>\n<ol>\n<li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li>\n<li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li>\n</ol>\n<h2 id=\"装配Bean\"><a href=\"#装配Bean\" class=\"headerlink\" title=\"装配Bean\"></a>装配Bean</h2><p>我们前面讨论了为什么要使用Spring的IoC容器，因为让容器来为我们创建并装配Bean能获得很大的好处，那么到底如何使用IoC容器？装配好的Bean又如何使用？</p>\n<p>我们来看一个具体的用户注册登录的例子。整个工程的结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring-ioc-appcontext</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │   └── com</span><br><span class=\"line\">        │       └── itranswarp</span><br><span class=\"line\">        │           └── learnjava</span><br><span class=\"line\">        │               ├── Main.java</span><br><span class=\"line\">        │               └── service</span><br><span class=\"line\">        │                   ├── MailService.java</span><br><span class=\"line\">        │                   ├── User.java</span><br><span class=\"line\">        │                   └── UserService.java</span><br><span class=\"line\">        └── resources</span><br><span class=\"line\">            └── application.xml</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们用Maven创建工程并引入<code>spring-context</code>依赖：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-ioc-appcontext<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">spring.version</span>&gt;</span>5.2.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">spring.version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$</span><span class=\"template-variable\">&#123;spring.version&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>我们先编写一个<code>MailService</code>，用于在用户登录和注册成功后发送邮件通知：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> MailService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ZoneId zoneId = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ZoneId</span>.</span></span>system<span class=\"constructor\">Default()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void set<span class=\"constructor\">ZoneId(ZoneId <span class=\"params\">zoneId</span>)</span> &#123;</span><br><span class=\"line\">        this.zoneId = zoneId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public String get<span class=\"constructor\">Time()</span> &#123;</span><br><span class=\"line\">        return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ZonedDateTime</span>.</span></span>now(this.zoneId).format(DateTimeFormatter.ISO_ZONED_DATE_TIME);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void send<span class=\"constructor\">LoginMail(User <span class=\"params\">user</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>err.println(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>format(<span class=\"string\">&quot;Hi, %s! You are logged in at %s&quot;</span>, user.get<span class=\"constructor\">Name()</span>, get<span class=\"constructor\">Time()</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void send<span class=\"constructor\">RegistrationMail(User <span class=\"params\">user</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>err.println(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>format(<span class=\"string\">&quot;Welcome, %s!&quot;</span>, user.get<span class=\"constructor\">Name()</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再编写一个<code>UserService</code>，实现用户注册和登录：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> UserService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> MailService mailService;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void set<span class=\"constructor\">MailService(MailService <span class=\"params\">mailService</span>)</span> &#123;</span><br><span class=\"line\">        this.mailService = mailService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;User&gt; users = <span class=\"keyword\">new</span> ArrayList&lt;&gt;(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">List</span>.</span></span><span class=\"keyword\">of</span>( <span class=\"comment\">// users:</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"constructor\">User(1, <span class=\"string\">&quot;bob@example.com&quot;</span>, <span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>)</span>, <span class=\"comment\">// bob</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"constructor\">User(2, <span class=\"string\">&quot;alice@example.com&quot;</span>, <span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>)</span>, <span class=\"comment\">// alice</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"constructor\">User(3, <span class=\"string\">&quot;tom@example.com&quot;</span>, <span class=\"string\">&quot;password&quot;</span>, <span class=\"string\">&quot;Tom&quot;</span>)</span>)); <span class=\"comment\">// tom</span></span><br><span class=\"line\"></span><br><span class=\"line\">    public User login(String email, String password) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (User user : users) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (user.get<span class=\"constructor\">Email()</span>.equals<span class=\"constructor\">IgnoreCase(<span class=\"params\">email</span>)</span><span class=\"operator\"> &amp;&amp; </span>user.get<span class=\"constructor\">Password()</span>.equals(password)) &#123;</span><br><span class=\"line\">                mailService.send<span class=\"constructor\">LoginMail(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">                return user;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        throw <span class=\"keyword\">new</span> <span class=\"constructor\">RuntimeException(<span class=\"string\">&quot;login failed.&quot;</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User get<span class=\"constructor\">User(<span class=\"params\">long</span> <span class=\"params\">id</span>)</span> &#123;</span><br><span class=\"line\">        return this.users.stream<span class=\"literal\">()</span>.filter(user -&gt; user.get<span class=\"constructor\">Id()</span><span class=\"operator\"> == </span>id).find<span class=\"constructor\">First()</span>.<span class=\"keyword\">or</span><span class=\"constructor\">ElseThrow()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User register(String email, String password, String name) &#123;</span><br><span class=\"line\">        users.<span class=\"keyword\">for</span><span class=\"constructor\">Each((<span class=\"params\">user</span>)</span> -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (user.get<span class=\"constructor\">Email()</span>.equals<span class=\"constructor\">IgnoreCase(<span class=\"params\">email</span>)</span>) &#123;</span><br><span class=\"line\">                throw <span class=\"keyword\">new</span> <span class=\"constructor\">RuntimeException(<span class=\"string\">&quot;email exist.&quot;</span>)</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> <span class=\"constructor\">User(<span class=\"params\">users</span>.<span class=\"params\">stream</span>()</span>.map<span class=\"constructor\">ToLong(<span class=\"params\">u</span> -&gt; <span class=\"params\">u</span>.<span class=\"params\">getId</span>()</span>).max<span class=\"literal\">()</span>.get<span class=\"constructor\">AsLong()</span> + <span class=\"number\">1</span>, email, password, name);</span><br><span class=\"line\">        users.add(user);</span><br><span class=\"line\">        mailService.send<span class=\"constructor\">RegistrationMail(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">        return user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>UserService</code>通过<code>setMailService()</code>注入了一个<code>MailService</code>。</p>\n<p>然后，我们需要编写一个特定的<code>application.xml</code>配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.itranswarp.learnjava.service.UserService&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mailService&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;mailService&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;mailService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.itranswarp.learnjava.service.MailService&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意观察上述配置文件，其中与XML Schema相关的部分格式是固定的，我们只关注两个<code>&lt;bean ...&gt;</code>的配置：</p>\n<ul>\n<li>每个<code>&lt;bean ...&gt;</code>都有一个<code>id</code>标识，相当于Bean的唯一ID；</li>\n<li>在<code>userService</code>Bean中，通过<code>&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;</code>注入了另一个Bean；</li>\n<li>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</li>\n</ul>\n<p>把上述XML配置文件用Java代码写出来，就像这样：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">UserService userService = <span class=\"keyword\">new</span> <span class=\"constructor\">UserService()</span>;</span><br><span class=\"line\">MailService mailService = <span class=\"keyword\">new</span> <span class=\"constructor\">MailService()</span>;</span><br><span class=\"line\">userService.set<span class=\"constructor\">MailService(<span class=\"params\">mailService</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>只不过Spring容器是通过读取XML文件后使用反射完成的。</p>\n<p>如果注入的不是Bean，而是<code>boolean</code>、<code>int</code>、<code>String</code>这样的数据类型，则通过<code>value</code>注入，例如，创建一个<code>HikariDataSource</code>：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;bean <span class=\"built_in\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"built_in\">class</span>=<span class=\"string\">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">property</span> <span class=\"built_in\">name</span>=<span class=\"string\">&quot;jdbcUrl&quot;</span> value=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">property</span> <span class=\"built_in\">name</span>=<span class=\"string\">&quot;username&quot;</span> value=<span class=\"string\">&quot;root&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">property</span> <span class=\"built_in\">name</span>=<span class=\"string\">&quot;password&quot;</span> value=<span class=\"string\">&quot;password&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">property</span> <span class=\"built_in\">name</span>=<span class=\"string\">&quot;maximumPoolSize&quot;</span> value=<span class=\"string\">&quot;10&quot;</span> /&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">property</span> <span class=\"built_in\">name</span>=<span class=\"string\">&quot;autoCommit&quot;</span> value=<span class=\"string\">&quot;true&quot;</span> /&gt;</span><br><span class=\"line\">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<p>最后一步，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ApplicationContext context</span> = new ClassPathXmlApplicationContext(<span class=\"string\">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 获取Bean:</span><br><span class=\"line\">UserService userService = context.getBean(UserService.class);</span><br><span class=\"line\"><span class=\"regexp\">//</span> 正常调用:</span><br><span class=\"line\">User user = userService.login(<span class=\"string\">&quot;bob@example.com&quot;</span>, <span class=\"string\">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>完整的<code>main()</code>方法如下：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    <span class=\"built_in\">public</span> static <span class=\"type\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">        ApplicationContext context = <span class=\"built_in\">new</span> ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class=\"line\">        UserService userService = context.getBean(UserService.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">        <span class=\"keyword\">User</span> <span class=\"keyword\">user</span> = userService.<span class=\"keyword\">login</span>(&quot;bob@example.com&quot;, &quot;password&quot;);</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(<span class=\"keyword\">user</span>.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ApplicationContext\"><a href=\"#ApplicationContext\" class=\"headerlink\" title=\"ApplicationContext\"></a>ApplicationContext</h3><p>我们从创建Spring容器的代码：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ApplicationContext context</span> = new ClassPathXmlApplicationContext(<span class=\"string\">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p>\n<p>获得了<code>ApplicationContext</code>的实例，就获得了IoC容器的引用。从<code>ApplicationContext</code>中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">UserService userService = context.get<span class=\"constructor\">Bean(UserService.<span class=\"params\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>Spring还提供另一种IoC容器叫<code>BeanFactory</code>，使用方式和<code>ApplicationContext</code>类似：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\">BeanFactory <span class=\"keyword\">factory</span> = <span class=\"keyword\">new</span> XmlBeanFactory(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">&quot;application.xml&quot;</span>));</span><br><span class=\"line\">MailService mailService = <span class=\"keyword\">factory</span>.getBean(MailService.<span class=\"keyword\">class</span>);</span><br></pre></td></tr></table></figure>\n\n<p><code>BeanFactory</code>和<code>ApplicationContext</code>的区别在于，<code>BeanFactory</code>的实现是按需创建，即第一次获取Bean时才创建这个Bean，而<code>ApplicationContext</code>会一次性创建所有的Bean。实际上，<code>ApplicationContext</code>接口是从<code>BeanFactory</code>接口继承而来的，并且，<code>ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用<code>ApplicationContext</code>，很少会考虑使用<code>BeanFactory</code>。</p>\n<h2 id=\"使用Annotation配置\"><a href=\"#使用Annotation配置\" class=\"headerlink\" title=\"使用Annotation配置\"></a>使用Annotation配置</h2><p>使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。</p>\n<p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p>\n<p>有没有其他更简单的配置方式呢？</p>\n<p>有！我们可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p>\n<p>我们把上一节的示例改造一下，先删除XML配置文件，然后，给<code>UserService</code>和<code>MailService</code>添加几个注解。</p>\n<p>首先，我们给<code>MailService</code>添加一个<code>@Component</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。</p>\n<p>然后，我们给<code>UserService</code>添加一个<code>@Component</code>注解和一个<code>@Autowired</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    MailService mailService;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>@Autowired</code>就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，<code>@Autowired</code>大幅简化了注入，因为它不但可以写在<code>set()</code>方法上，还可以直接写在字段上，甚至可以写在构造方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    MailService mailService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">(<span class=\"meta\">@Autowired</span> MailService mailService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.mailService = mailService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们一般把<code>@Autowired</code>写在字段上，通常使用package权限的字段，便于测试。</p>\n<p>最后，编写一个<code>AppConfig</code>类启动容器：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"keyword\">Configuration</span></span><br><span class=\"line\">@ComponentScan</span><br><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">class</span> AppConfig &#123;</span><br><span class=\"line\">    <span class=\"built_in\">public</span> static <span class=\"type\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">        ApplicationContext context = <span class=\"built_in\">new</span> AnnotationConfigApplicationContext(AppConfig.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">        UserService userService = context.getBean(UserService.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">        <span class=\"keyword\">User</span> <span class=\"keyword\">user</span> = userService.<span class=\"keyword\">login</span>(&quot;bob@example.com&quot;, &quot;password&quot;);</span><br><span class=\"line\">        <span class=\"keyword\">System</span>.<span class=\"keyword\">out</span>.println(<span class=\"keyword\">user</span>.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了<code>main()</code>方法外，<code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类，因为我们创建<code>ApplicationContext</code>时：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> <span class=\"constructor\">AnnotationConfigApplicationContext(AppConfig.<span class=\"params\">class</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用的实现类是<code>AnnotationConfigApplicationContext</code>，必须传入一个标注了<code>@Configuration</code>的类名。</p>\n<p>此外，<code>AppConfig</code>还标注了<code>@ComponentScan</code>，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p>\n<p>整个工程结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring-ioc-annoconfig</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        └── java</span><br><span class=\"line\">            └── com</span><br><span class=\"line\">                └── itranswarp</span><br><span class=\"line\">                    └── learnjava</span><br><span class=\"line\">                        ├── AppConfig.java</span><br><span class=\"line\">                        └── service</span><br><span class=\"line\">                            ├── MailService.java</span><br><span class=\"line\">                            ├── User.java</span><br><span class=\"line\">                            └── UserService.java</span><br></pre></td></tr></table></figure>\n\n<p>使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：</p>\n<ul>\n<li>每个Bean被标注为<code>@Component</code>并正确使用<code>@Autowired</code>注入；</li>\n<li>配置类被标注为<code>@Configuration</code>和<code>@ComponentScan</code>；</li>\n<li>所有Bean均在指定包以及子包内。</li>\n</ul>\n<p>使用<code>@ComponentScan</code>非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置<code>AppConfig</code>位于自定义的顶层包（例如<code>com.itranswarp.learnjava</code>），其他Bean按类别放入子包。</p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>如果我们想给<code>UserService</code>注入<code>HikariDataSource</code>，但是这个类位于<code>com.zaxxer.hikari</code>包中，并且<code>HikariDataSource</code>也不可能有<code>@Component</code>注解，如何告诉IoC容器创建并配置<code>HikariDataSource</code>？或者换个说法，如何创建并配置一个第三方Bean？</p>\n<h2 id=\"定制Bean\"><a href=\"#定制Bean\" class=\"headerlink\" title=\"定制Bean\"></a>定制Bean</h2><h3 id=\"Scope\"><a href=\"#Scope\" class=\"headerlink\" title=\"Scope\"></a>Scope</h3><p>对于Spring容器来说，当我们把一个Bean标记为<code>@Component</code>后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用<code>getBean(Class)</code>获取到的Bean总是同一个实例。</p>\n<p>还有一种Bean，我们每次调用<code>getBean(Class)</code>，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的<code>@Scope</code>注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE) <span class=\"comment\">// @Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\">public class MailSession &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注入List\"><a href=\"#注入List\" class=\"headerlink\" title=\"注入List\"></a>注入List</h3><p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> interface Validator &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">validate</span><span class=\"params\">(<span class=\"keyword\">String</span> email, <span class=\"keyword\">String</span> password, <span class=\"keyword\">String</span> name)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，分别使用3个<code>Validator</code>对用户参数进行验证：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EmailValidator</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">Validator</span></span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> void validate(<span class=\"keyword\">String</span> email, <span class=\"keyword\">String</span> password, <span class=\"keyword\">String</span> name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!email.matches(<span class=\"string\">&quot;^[a-z0-9]+\\\\@[a-z0-9]+\\\\.[a-z]&#123;2,10&#125;$&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">IllegalArgumentException</span>(<span class=\"string\">&quot;invalid email: &quot;</span> + email);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PasswordValidator</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">Validator</span></span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> void validate(<span class=\"keyword\">String</span> email, <span class=\"keyword\">String</span> password, <span class=\"keyword\">String</span> name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!password.matches(<span class=\"string\">&quot;^.&#123;6,20&#125;$&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">IllegalArgumentException</span>(<span class=\"string\">&quot;invalid password&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NameValidator</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">Validator</span></span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> void validate(<span class=\"keyword\">String</span> email, <span class=\"keyword\">String</span> password, <span class=\"keyword\">String</span> name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name == <span class=\"literal\">null</span> || name.isBlank() || name.length() &gt; <span class=\"number\">20</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">IllegalArgumentException</span>(<span class=\"string\">&quot;invalid name: &quot;</span> + name);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们通过一个<code>Validators</code>作为入口进行验证：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">class</span> Validators &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">Validator</span>&gt; validators;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">public</span> <span class=\"type\">void</span> <span class=\"keyword\">validate</span>(String email, String <span class=\"keyword\">password</span>, String <span class=\"type\">name</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (var <span class=\"keyword\">validator</span> : this.validators) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">validator</span>.<span class=\"keyword\">validate</span>(email, <span class=\"keyword\">password</span>, <span class=\"type\">name</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>Validators</code>被注入了一个<code>List&lt;Validator&gt;</code>，Spring会自动把所有类型为<code>Validator</code>的Bean装配为一个<code>List</code>注入进来，这样一来，我们每新增一个<code>Validator</code>类型，就自动被Spring装配到<code>Validators</code>中了，非常方便。</p>\n<p>因为Spring是通过扫描classpath获取到所有的Bean，而<code>List</code>是有序的，要指定<code>List</code>中Bean的顺序，可以加上<code>@Order</code>注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\">public class EmailValidator implements Validator &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Order</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\">public class PasswordValidator implements Validator &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Order</span>(<span class=\"number\">3</span>)</span><br><span class=\"line\">public class NameValidator implements Validator &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可选注入\"><a href=\"#可选注入\" class=\"headerlink\" title=\"可选注入\"></a>可选注入</h3><p>默认情况下，当我们标记了一个<code>@Autowired</code>后，Spring如果没有找到对应类型的Bean，它会抛出<code>NoSuchBeanDefinitionException</code>异常。</p>\n<p>可以给<code>@Autowired</code>增加一个<code>required = false</code>的参数：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public <span class=\"keyword\">class</span> MailService &#123;</span><br><span class=\"line\">    @<span class=\"constructor\">Autowired(<span class=\"params\">required</span> = <span class=\"params\">false</span>)</span></span><br><span class=\"line\">    ZoneId zoneId = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">ZoneId</span>.</span></span>system<span class=\"constructor\">Default()</span>;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个参数告诉Spring容器，如果找到一个类型为<code>ZoneId</code>的Bean，就注入，如果找不到，就忽略。</p>\n<p>这种方式非常适合有定义就使用定义，没有就使用默认值的情况。</p>\n<h3 id=\"创建第三方Bean\"><a href=\"#创建第三方Bean\" class=\"headerlink\" title=\"创建第三方Bean\"></a>创建第三方Bean</h3><p>如果一个Bean不在我们自己的package管理之内，例如<code>ZoneId</code>，如何创建它？</p>\n<p>答案是我们自己在<code>@Configuration</code>类中编写一个Java方法创建并返回它，注意给方法标记一个<code>@Bean</code>注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个Bean:</span></span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    ZoneId createZoneId() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;Z&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring对标记为<code>@Bean</code>的方法只调用一次，因此返回的Bean仍然是单例。</p>\n<h3 id=\"初始化和销毁\"><a href=\"#初始化和销毁\" class=\"headerlink\" title=\"初始化和销毁\"></a>初始化和销毁</h3><p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个<code>init()</code>方法进行初始化，定义一个<code>shutdown()</code>方法进行清理，然后，引入JSR-250定义的Annotation：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.annotation<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.annotation-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在Bean的初始化和清理方法上标记<code>@PostConstruct</code>和<code>@PreDestroy</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>(required = <span class=\"literal\">false</span>)</span><br><span class=\"line\">    ZoneId zoneId = ZoneId.systemDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Init mail service with zoneId = &quot;</span> + <span class=\"built_in\">this</span>.zoneId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PreDestroy</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">shutdown</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Shutdown mail service&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring容器会对上述Bean做如下初始化流程：</p>\n<ul>\n<li>调用构造方法创建<code>MailService</code>实例；</li>\n<li>根据<code>@Autowired</code>进行注入；</li>\n<li>调用标记有<code>@PostConstruct</code>的<code>init()</code>方法进行初始化。</li>\n</ul>\n<p>而销毁时，容器会首先调用标记有<code>@PreDestroy</code>的<code>shutdown()</code>方法。</p>\n<p>Spring只根据Annotation查找<em>无参数</em>方法，对方法名不作要求。</p>\n<h3 id=\"使用别名\"><a href=\"#使用别名\" class=\"headerlink\" title=\"使用别名\"></a>使用别名</h3><p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个<code>DataSource</code>实例。</p>\n<p>如果我们在<code>@Configuration</code>类中创建了多个同类型的Bean：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    ZoneId createZoneOfZ() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;Z&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"selector-tag\">Bean</span></span><br><span class=\"line\">    <span class=\"selector-tag\">ZoneId</span> <span class=\"selector-tag\">createZoneOfUTC8</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;UTC+08:00&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring会报<code>NoUniqueBeanDefinitionException</code>异常，意思是出现了重复的Bean定义。</p>\n<p>这个时候，需要给每个Bean添加不同的名字：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span>(<span class=\"string\">&quot;z&quot;</span>)</span><br><span class=\"line\">    ZoneId createZoneOfZ() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;Z&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"selector-tag\">Bean</span></span><br><span class=\"line\">    @<span class=\"selector-tag\">Qualifier</span>(<span class=\"string\">&quot;utc8&quot;</span>)</span><br><span class=\"line\">    <span class=\"selector-tag\">ZoneId</span> <span class=\"selector-tag\">createZoneOfUTC8</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;UTC+08:00&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以用<code>@Bean(&quot;name&quot;)</code>指定别名，也可以用<code>@Bean</code>+<code>@Qualifier(&quot;name&quot;)</code>指定别名。</p>\n<p>存在多个同类型的Bean时，注入<code>ZoneId</code>又会报错：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">NoUniqueBeanDefinitionException: <span class=\"keyword\">No</span> qualifying bean <span class=\"keyword\">of</span> <span class=\"keyword\">type</span> <span class=\"string\">&#x27;java.time.ZoneId&#x27;</span> available: expected single matching bean but <span class=\"built_in\">found</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>意思是期待找到唯一的<code>ZoneId</code>类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\">public class MailService &#123;</span><br><span class=\"line\">\t<span class=\"variable\">@Autowired</span>(required = false)</span><br><span class=\"line\">\t<span class=\"variable\">@Qualifier</span>(<span class=\"string\">&quot;z&quot;</span>) <span class=\"comment\">// 指定注入名称为&quot;z&quot;的ZoneId</span></span><br><span class=\"line\">\tZoneId zoneId = ZoneId.systemDefault();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一种方法是把其中某个Bean指定为<code>@Primary</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    <span class=\"variable\">@Primary</span> <span class=\"comment\">// 指定为主要Bean</span></span><br><span class=\"line\">    <span class=\"variable\">@Qualifier</span>(<span class=\"string\">&quot;z&quot;</span>)</span><br><span class=\"line\">    ZoneId createZoneOfZ() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;Z&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"selector-tag\">Bean</span></span><br><span class=\"line\">    @<span class=\"selector-tag\">Qualifier</span>(<span class=\"string\">&quot;utc8&quot;</span>)</span><br><span class=\"line\">    <span class=\"selector-tag\">ZoneId</span> <span class=\"selector-tag\">createZoneOfUTC8</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;UTC+08:00&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有<code>@Primary</code>的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为<code>@Primary</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    <span class=\"variable\">@Primary</span></span><br><span class=\"line\">    DataSource createMasterDataSource() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    <span class=\"variable\">@Qualifier</span>(<span class=\"string\">&quot;slave&quot;</span>)</span><br><span class=\"line\">    DataSource createSlaveDataSource() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p>\n<h3 id=\"使用FactoryBean\"><a href=\"#使用FactoryBean\" class=\"headerlink\" title=\"使用FactoryBean\"></a>使用FactoryBean</h3><p>我们在设计模式的<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1281319170474017\">工厂方法</a>中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p>\n<p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ZoneIdFactoryBean</span> <span class=\"keyword\">implements</span> <span class=\"title\">FactoryBean</span>&lt;<span class=\"title\">ZoneId</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String zone = <span class=\"string\">&quot;Z&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">ZoneId <span class=\"title\">getObject</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">return</span> ZoneId.<span class=\"title\">of</span><span class=\"params\">(zone)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ZoneId.class;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p>\n<p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p>\n<h2 id=\"使用Resource\"><a href=\"#使用Resource\" class=\"headerlink\" title=\"使用Resource\"></a>使用Resource</h2><p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p>\n<p>例如，AppService需要读取<code>logo.txt</code>这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p>\n<p>Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;classpath:/logo.txt&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Resource resource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String logo;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"keyword\">var</span> reader = <span class=\"keyword\">new</span> BufferedReader(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.logo = reader.lines().collect(Collectors.joining(<span class=\"string\">&quot;\\n&quot;</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注入<code>Resource</code>最常用的方式是通过classpath，即类似<code>classpath:/logo.txt</code>表示在classpath中搜索<code>logo.txt</code>文件，然后，我们直接调用<code>Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p>\n<p>也可以直接指定文件的路径，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value(<span class=\"meta-string\">&quot;file:/path/to/logo.txt&quot;</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Resource resource;</span><br></pre></td></tr></table></figure>\n\n<p>但使用classpath是最简单的方式。上述工程结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring-ioc-resource</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │   └── com</span><br><span class=\"line\">        │       └── itranswarp</span><br><span class=\"line\">        │           └── learnjava</span><br><span class=\"line\">        │               ├── AppConfig.java</span><br><span class=\"line\">        │               └── AppService.java</span><br><span class=\"line\">        └── resources</span><br><span class=\"line\">            └── logo.txt</span><br></pre></td></tr></table></figure>\n\n<p>使用Maven的标准目录结构，所有资源文件放入<code>src/main/resources</code>即可。</p>\n<h2 id=\"注入配置\"><a href=\"#注入配置\" class=\"headerlink\" title=\"注入配置\"></a>注入配置</h2><p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以<code>key=value</code>的形式写在<code>.properties</code>文件中。</p>\n<p>例如，<code>MailService</code>根据配置的<code>app.zone=Asia/Shanghai</code>来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的<code>Resource</code>来读取位于classpath下的一个<code>app.properties</code>文件。但是，这样仍然比较繁琐。</p>\n<p>Spring容器还提供了一个更简单的<code>@PropertySource</code>来自动读取配置文件。我们只需要在<code>@Configuration</code>配置类上再添加一个注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(<span class=\"string\">&quot;app.properties&quot;</span>) <span class=\"comment\">// 表示读取classpath的app.properties</span></span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Value</span>(<span class=\"string\">&quot;$&#123;app.zone:Z&#125;&quot;</span>)</span><br><span class=\"line\">    String zoneId;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    ZoneId createZoneId() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(zoneId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring容器看到<code>@PropertySource(&quot;app.properties&quot;)</code>注解后，自动读取这个配置文件，然后，我们使用<code>@Value</code>正常注入：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Value</span>(<span class=\"string\">&quot;<span class=\"subst\">$&#123;app.zone:Z&#125;</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">String</span> zoneId;</span><br></pre></td></tr></table></figure>\n\n<p>注意注入的字符串语法，它的格式如下：</p>\n<ul>\n<li><code>&quot;$&#123;app.zone&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，如果key不存在，启动将报错；</li>\n<li><code>&quot;$&#123;app.zone:Z&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，但如果key不存在，就使用默认值<code>Z</code>。</li>\n</ul>\n<p>这样一来，我们就可以根据<code>app.zone</code>的配置来创建<code>ZoneId</code>。</p>\n<p>还可以把注入的注解写到方法参数中：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Bean</span></span><br><span class=\"line\">ZoneId createZoneId(<span class=\"variable\">@Value</span>(<span class=\"string\">&quot;$&#123;app.zone:Z&#125;&quot;</span>) String zoneId) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(zoneId);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，先使用<code>@PropertySource</code>读取配置文件，然后通过<code>@Value</code>以<code>$&#123;key:defaultValue&#125;</code>的形式注入，可以极大地简化读取配置的麻烦。</p>\n<p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个<code>SmtpConfig</code>：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SmtpConfig</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(<span class=\"meta-string\">&quot;<span class=\"subst\">$&#123;smtp.host&#125;</span>&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String host;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(<span class=\"meta-string\">&quot;<span class=\"subst\">$&#123;smtp.port:<span class=\"number\">25</span>&#125;</span>&quot;</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> int port;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String getHost() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> host;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> int getPort() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> port;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，在需要读取的地方，使用<code>#&#123;smtpConfig.host&#125;</code>注入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String smtpHost;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Value(&quot;#&#123;smtpConfig.port&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> smtpPort;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意观察<code>#&#123;&#125;</code>这种注入语法，它和<code>$&#123;key&#125;</code>不同的是，<code>#&#123;&#125;</code>表示从JavaBean读取属性。<code>&quot;#&#123;smtpConfig.host&#125;&quot;</code>的意思是，从名称为<code>smtpConfig</code>的Bean读取<code>host</code>属性，即调用<code>getHost()</code>方法。一个Class名为<code>SmtpConfig</code>的Bean，它在Spring容器中的默认名称就是<code>smtpConfig</code>，除非用<code>@Qualifier</code>指定了名称。</p>\n<p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以<code>#&#123;bean.property&#125;</code>注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果<code>SmtpConfig</code>决定从数据库中读取相关配置项，那么<code>MailService</code>注入的<code>@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</code>仍然可以不修改正常运行。</p>\n<h2 id=\"使用条件装配\"><a href=\"#使用条件装配\" class=\"headerlink\" title=\"使用条件装配\"></a>使用条件装配</h2><p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p>\n<p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p>\n<ul>\n<li>native</li>\n<li>test</li>\n<li>production</li>\n</ul>\n<p>创建某个Bean时，Spring容器可以根据注解<code>@Profile</code>来决定是否创建。例如，以下配置：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    <span class=\"variable\">@Profile</span>(<span class=\"string\">&quot;!test&quot;</span>)</span><br><span class=\"line\">    ZoneId createZoneId() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.systemDefault</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"selector-tag\">Bean</span></span><br><span class=\"line\">    @<span class=\"selector-tag\">Profile</span>(<span class=\"string\">&quot;test&quot;</span>)</span><br><span class=\"line\">    <span class=\"selector-tag\">ZoneId</span> <span class=\"selector-tag\">createZoneIdForTest</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">ZoneId</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;America/New_York&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果当前的Profile设置为<code>test</code>，则Spring容器会调用<code>createZoneIdForTest()</code>创建<code>ZoneId</code>，否则，调用<code>createZoneId()</code>创建<code>ZoneId</code>。注意到<code>@Profile(&quot;!test&quot;)</code>表示非test环境。</p>\n<p>在运行程序时，加上JVM参数<code>-Dspring.profiles.active=test</code>就可以指定以<code>test</code>环境启动。</p>\n<p>实际上，Spring允许指定多个Profile，例如：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">-Dspring.profiles.active</span>=test,master</span><br></pre></td></tr></table></figure>\n\n<p>可以表示<code>test</code>环境，并使用<code>master</code>分支代码。</p>\n<p>要满足多个Profile条件，可以这样写：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Bean</span></span><br><span class=\"line\"><span class=\"variable\">@Profile</span>(&#123; <span class=\"string\">&quot;test&quot;</span>, <span class=\"string\">&quot;master&quot;</span> &#125;) <span class=\"comment\">// 同时满足test和master</span></span><br><span class=\"line\">ZoneId createZoneId() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用Conditional\"><a href=\"#使用Conditional\" class=\"headerlink\" title=\"使用Conditional\"></a>使用Conditional</h3><p>除了根据<code>@Profile</code>条件来决定是否创建某个Bean外，Spring还可以根据<code>@Conditional</code>决定是否创建某个Bean。</p>\n<p>例如，我们对<code>SmtpMailService</code>添加如下注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Conditional</span>(OnSmtpEnvCondition.class)</span><br><span class=\"line\">public class SmtpMailService implements MailService &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的意思是，如果满足<code>OnSmtpEnvCondition</code>的条件，才会创建<code>SmtpMailService</code>这个Bean。<code>OnSmtpEnvCondition</code>的条件是什么呢？我们看一下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnSmtpEnvCondition</span> <span class=\"keyword\">implements</span> <span class=\"title\">Condition</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matches</span><span class=\"params\">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;true&quot;</span>.equalsIgnoreCase(System.getenv(<span class=\"string\">&quot;smtp&quot;</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，<code>OnSmtpEnvCondition</code>的条件是存在环境变量<code>smtp</code>，值为<code>true</code>。这样，我们就可以通过环境变量来控制是否创建<code>SmtpMailService</code>。</p>\n<p>Spring只提供了<code>@Conditional</code>注解，具体判断逻辑还需要我们自己实现。Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在<code>app.smtp=true</code>，则创建<code>MailService</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@ConditionalOnProperty</span>(name=<span class=\"string\">&quot;app.smtp&quot;</span>, havingValue=<span class=\"string\">&quot;true&quot;</span>)</span><br><span class=\"line\">public class MailService &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果当前classpath中存在类<code>javax.mail.Transport</code>，则创建<code>MailService</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@ConditionalOnClass</span>(name = <span class=\"string\">&quot;javax.mail.Transport&quot;</span>)</span><br><span class=\"line\">public class MailService &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>后续我们会介绍Spring Boot的条件装配。我们以文件存储为例，假设我们需要保存用户上传的头像，并返回存储路径，在本地开发运行时，我们总是存储到文件：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@ConditionalOnProperty</span>(name = <span class=\"string\">&quot;app.storage&quot;</span>, havingValue = <span class=\"string\">&quot;file&quot;</span>, matchIfMissing = true)</span><br><span class=\"line\">public class FileUploader implements Uploader &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在生产环境运行时，我们会把文件存储到类似AWS S3上：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@ConditionalOnProperty</span>(name = <span class=\"string\">&quot;app.storage&quot;</span>, havingValue = <span class=\"string\">&quot;s3&quot;</span>)</span><br><span class=\"line\">public class S3Uploader implements Uploader &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其他需要存储的服务则注入<code>Uploader</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserImageService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    Uploader uploader;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当应用程序检测到配置文件存在<code>app.storage=s3</code>时，自动使用<code>S3Uploader</code>，如果存在配置<code>app.storage=file</code>，或者配置<code>app.storage</code>不存在，则使用<code>FileUploader</code>。</p>\n<p>可见，使用条件注解，能更灵活地装配Bean。</p>\n<h1 id=\"使用AOP\"><a href=\"#使用AOP\" class=\"headerlink\" title=\"使用AOP\"></a>使用AOP</h1><h2 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>AOP是Aspect Oriented Programming，即面向切面编程。</p>\n<p>那什么是AOP？</p>\n<p>我们先回顾一下OOP：Object Oriented Programming，OOP作为面向对象编程的模式，获得了巨大的成功，OOP的主要功能是数据封装、继承和多态。</p>\n<p>而AOP是一种新的编程方式，它和OOP不同，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，或者称之为切面（Aspect）。</p>\n<p>要理解AOP的概念，我们先用OOP举例，比如一个业务组件<code>BookService</code>，它有几个业务方法：</p>\n<ul>\n<li>createBook：添加新的Book；</li>\n<li>updateBook：修改Book；</li>\n<li>deleteBook：删除Book。</li>\n</ul>\n<p>对每个业务方法，例如，<code>createBook()</code>，除了业务逻辑，还需要安全检查、日志记录和事务处理，它的代码像这样：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookService</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">createBook</span><span class=\"params\">(Book book)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">securityCheck</span>();</span><br><span class=\"line\">        Transaction tx = <span class=\"built_in\">startTransaction</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 核心业务逻辑</span></span><br><span class=\"line\">            tx.<span class=\"built_in\">commit</span>();</span><br><span class=\"line\">        &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (RuntimeException e) &#123;</span><br><span class=\"line\">            tx.<span class=\"built_in\">rollback</span>();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">log</span>(<span class=\"string\">&quot;created book: &quot;</span> + book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>继续编写<code>updateBook()</code>，代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BookService</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateBook</span><span class=\"params\">(Book book)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">securityCheck</span>();</span><br><span class=\"line\">        Transaction tx = <span class=\"built_in\">startTransaction</span>();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 核心业务逻辑</span></span><br><span class=\"line\">            tx.<span class=\"built_in\">commit</span>();</span><br><span class=\"line\">        &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (RuntimeException e) &#123;</span><br><span class=\"line\">            tx.<span class=\"built_in\">rollback</span>();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">log</span>(<span class=\"string\">&quot;updated book: &quot;</span> + book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化。</p>\n<p>考察业务模型可以发现，<code>BookService</code>关心的是自身的核心逻辑，但整个系统还要求关注安全检查、日志、事务等功能，这些功能实际上“横跨”多个业务方法，为了实现这些功能，不得不在每个业务方法上重复编写代码。</p>\n<p>一种可行的方式是使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017\">Proxy模式</a>，将某个功能，例如，权限检查，放入Proxy中：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityCheckBookService</span> <span class=\"keyword\">implements</span> <span class=\"title\">BookService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BookService <span class=\"keyword\">target</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SecurityCheckBookService</span><span class=\"params\">(BookService <span class=\"keyword\">target</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">target</span> = <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createBook</span><span class=\"params\">(Book book)</span> </span>&#123;</span><br><span class=\"line\">        securityCheck();</span><br><span class=\"line\">        <span class=\"keyword\">target</span>.createBook(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">updateBook</span><span class=\"params\">(Book book)</span> </span>&#123;</span><br><span class=\"line\">        securityCheck();</span><br><span class=\"line\">        <span class=\"keyword\">target</span>.updateBook(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteBook</span><span class=\"params\">(Book book)</span> </span>&#123;</span><br><span class=\"line\">        securityCheck();</span><br><span class=\"line\">        <span class=\"keyword\">target</span>.deleteBook(book);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">securityCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式的缺点是比较麻烦，必须先抽取接口，然后，针对每个方法实现Proxy。</p>\n<p>另一种方法是，既然<code>SecurityCheckBookService</code>的代码都是标准的Proxy样板代码，不如把权限检查视作一种切面（Aspect），把日志、事务也视为切面，然后，以某种自动化的方式，把切面织入到核心逻辑中，实现Proxy模式。</p>\n<p>如果我们以AOP的视角来编写上述业务，可以依次实现：</p>\n<ol>\n<li>核心逻辑，即BookService；</li>\n<li>切面逻辑，即：</li>\n<li>权限检查的Aspect；</li>\n<li>日志的Aspect；</li>\n<li>事务的Aspect。</li>\n</ol>\n<p>然后，以某种方式，让框架来把上述3个Aspect以Proxy的方式“织入”到<code>BookService</code>中，这样一来，就不必编写复杂而冗长的Proxy模式。</p>\n<h3 id=\"AOP原理\"><a href=\"#AOP原理\" class=\"headerlink\" title=\"AOP原理\"></a>AOP原理</h3><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p>\n<p>在Java平台上，对于AOP的织入，有3种方式：</p>\n<ol>\n<li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li>\n<li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>\n<li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li>\n</ol>\n<p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a href=\"https://github.com/cglib/cglib\">CGLIB</a>或者<a href=\"https://www.javassist.org/\">Javassist</a>这些第三方库实现。</p>\n<p>AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p>\n<p>需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。</p>\n<h2 id=\"装配AOP\"><a href=\"#装配AOP\" class=\"headerlink\" title=\"装配AOP\"></a>装配AOP</h2><p>在AOP编程中，我们经常会遇到下面的概念：</p>\n<ul>\n<li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li>\n<li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li>\n<li>Pointcut：切入点，即一组连接点的集合；</li>\n<li>Advice：增强，指特定连接点上执行的动作；</li>\n<li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li>\n<li>Weaving：织入，指将切面整合到程序的执行流程中；</li>\n<li>Interceptor：拦截器，是一种实现增强的方式；</li>\n<li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li>\n<li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li>\n</ul>\n<p>看完上述术语，是不是感觉对AOP有了进一步的困惑？其实，我们不用关心AOP创造的“术语”，只需要理解AOP本质上只是一种代理模式的实现方式，在Spring的容器中实现AOP特别方便。</p>\n<p>我们以<code>UserService</code>和<code>MailService</code>为例，这两个属于核心业务逻辑，现在，我们准备给<code>UserService</code>的每个业务方法执行前添加日志，给<code>MailService</code>的每个业务方法执行前后添加日志，在Spring中，需要以下步骤：</p>\n<p>首先，我们通过Maven引入Spring对AOP的支持：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aspects<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$</span><span class=\"template-variable\">&#123;spring.version&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>上述依赖会自动引入AspectJ，使用AspectJ实现AOP比较方便，因为它的定义比较简单。</p>\n<p>然后，我们定义一个<code>LoggingAspect</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggingAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 在执行UserService的每个方法前执行:</span></span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">doAccessCheck</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.err.println(<span class=\"string\">&quot;[Before] do access check...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在执行MailService的每个方法前后执行:</span></span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">doLogging</span><span class=\"params\">(ProceedingJoinPoint pjp)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.err.println(<span class=\"string\">&quot;[Around] start &quot;</span> + pjp.getSignature());</span><br><span class=\"line\">        Object retVal = pjp.proceed();</span><br><span class=\"line\">        System.err.println(<span class=\"string\">&quot;[Around] done &quot;</span> + pjp.getSignature());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> retVal;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察<code>doAccessCheck()</code>方法，我们定义了一个<code>@Before</code>注解，后面的字符串是告诉AspectJ应该在何处执行该方法，这里写的意思是：执行<code>UserService</code>的每个<code>public</code>方法前执行<code>doAccessCheck()</code>代码。</p>\n<p>再观察<code>doLogging()</code>方法，我们定义了一个<code>@Around</code>注解，它和<code>@Before</code>不同，<code>@Around</code>可以决定是否执行目标方法，因此，我们在<code>doLogging()</code>内部先打印日志，再调用方法，最后打印日志后返回结果。</p>\n<p>在<code>LoggingAspect</code>类的声明处，除了用<code>@Component</code>表示它本身也是一个Bean外，我们再加上<code>@Aspect</code>注解，表示它的<code>@Before</code>标注的方法需要注入到<code>UserService</code>的每个<code>public</code>方法执行前，<code>@Around</code>标注的方法需要注入到<code>MailService</code>的每个<code>public</code>方法执行前后。</p>\n<p>紧接着，我们需要给<code>@Configuration</code>类加上一个<code>@EnableAspectJAutoProxy</code>注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring的IoC容器看到这个注解，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。执行代码，我们可以看到以下输出：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-attr\">[Before]</span> do access check...</span><br><span class=\"line\"><span class=\"selector-attr\">[Around]</span> start void com<span class=\"selector-class\">.itranswarp</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.service</span><span class=\"selector-class\">.MailService</span><span class=\"selector-class\">.sendRegistrationMail</span>(User)</span><br><span class=\"line\">Welcome, test!</span><br><span class=\"line\"><span class=\"selector-attr\">[Around]</span> done void com<span class=\"selector-class\">.itranswarp</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.service</span><span class=\"selector-class\">.MailService</span><span class=\"selector-class\">.sendRegistrationMail</span>(User)</span><br><span class=\"line\"><span class=\"selector-attr\">[Before]</span> do access check...</span><br><span class=\"line\"><span class=\"selector-attr\">[Around]</span> start void com<span class=\"selector-class\">.itranswarp</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.service</span><span class=\"selector-class\">.MailService</span><span class=\"selector-class\">.sendLoginMail</span>(User)</span><br><span class=\"line\">Hi, Bob! You are logged <span class=\"keyword\">in</span> at <span class=\"number\">2020</span>-<span class=\"number\">02</span>-<span class=\"number\">14</span>T23:<span class=\"number\">13</span>:<span class=\"number\">52.167996</span>+<span class=\"number\">08</span>:<span class=\"number\">00</span><span class=\"selector-attr\">[Asia/Shanghai]</span></span><br><span class=\"line\"><span class=\"selector-attr\">[Around]</span> done void com<span class=\"selector-class\">.itranswarp</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.service</span><span class=\"selector-class\">.MailService</span><span class=\"selector-class\">.sendLoginMail</span>(User)</span><br></pre></td></tr></table></figure>\n\n<p>这说明执行业务逻辑前后，确实执行了我们定义的Aspect（即<code>LoggingAspect</code>的方法）。</p>\n<p>有些童鞋会问，<code>LoggingAspect</code>定义的方法，是如何注入到其他Bean的呢？</p>\n<p>其实AOP的原理非常简单。我们以<code>LoggingAspect.doAccessCheck()</code>为例，要把它注入到<code>UserService</code>的每个<code>public</code>方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> UserServiceAopProxy <span class=\"keyword\">extends</span> UserService &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserService <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoggingAspect <span class=\"class\"><span class=\"keyword\">aspect</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserServiceAopProxy</span><span class=\"params\">(UserService <span class=\"keyword\">target</span>, LoggingAspect aspect)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">target</span> = <span class=\"keyword\">target</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.aspect = <span class=\"class\"><span class=\"keyword\">aspect</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">User <span class=\"title\">login</span><span class=\"params\">(String email, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先执行Aspect的代码:</span></span><br><span class=\"line\">        aspect.doAccessCheck();</span><br><span class=\"line\">        <span class=\"comment\">// 再执行UserService的逻辑:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">return</span> <span class=\"keyword\">target</span>.<span class=\"title\">login</span><span class=\"params\">(email, password)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">User <span class=\"title\">register</span><span class=\"params\">(String email, String password, String name)</span> </span>&#123;</span><br><span class=\"line\">        aspect.doAccessCheck();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">return</span> <span class=\"keyword\">target</span>.<span class=\"title\">register</span><span class=\"params\">(email, password, name)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这些都是Spring容器启动时为我们自动创建的注入了Aspect的子类，它取代了原始的<code>UserService</code>（原始的<code>UserService</code>实例作为内部变量隐藏在<code>UserServiceAopProxy</code>中）。如果我们打印从Spring容器获取的<code>UserService</code>实例类型，它类似<code>UserService$$EnhancerBySpringCGLIB$$1f44e01c</code>，实际上是Spring使用CGLIB动态创建的子类，但对于调用方来说，感觉不到任何区别。</p>\n<p> Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</p>\n<p>可见，虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：</p>\n<ol>\n<li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li>\n<li>标记<code>@Component</code>和<code>@Aspect</code>；</li>\n<li>在<code>@Configuration</code>类上标注<code>@EnableAspectJAutoProxy</code>。</li>\n</ol>\n<p>至于AspectJ的注入语法则比较复杂，请参考<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples\">Spring文档</a>。</p>\n<p>Spring也提供其他方法来装配AOP，但都没有使用AspectJ注解的方式来得简洁明了，所以我们不再作介绍。</p>\n<h3 id=\"拦截器类型\"><a href=\"#拦截器类型\" class=\"headerlink\" title=\"拦截器类型\"></a>拦截器类型</h3><p>顾名思义，拦截器有以下类型：</p>\n<ul>\n<li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li>\n<li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li>\n<li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li>\n<li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li>\n<li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li>\n</ul>\n<h2 id=\"使用注解装配AOP\"><a href=\"#使用注解装配AOP\" class=\"headerlink\" title=\"使用注解装配AOP\"></a>使用注解装配AOP</h2><p>上一节我们讲解了使用AspectJ的注解，并配合一个复杂的<code>execution(* xxx.Xyz.*(..))</code>语法来定义应该如何装配AOP。</p>\n<p>在实际项目中，这种写法其实很少使用。假设你写了一个<code>SecurityAspect</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SecurityAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;execution(public * com.itranswarp.learnjava.service.*.*(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">check</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (SecurityContext.getCurrentUser() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;check failed&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>基本能实现无差别全覆盖，即某个包下面的所有Bean的所有方法都会被这个<code>check()</code>方法拦截。</p>\n<p>还有的童鞋喜欢用方法名前缀进行拦截：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Around(&quot;execution(public * update*(..))&quot;)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">doLogging</span><span class=\"params\">(ProceedingJoinPoint pjp)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对update开头的方法切换数据源:</span></span><br><span class=\"line\">    String old = setCurrentDataSource(<span class=\"string\">&quot;master&quot;</span>);</span><br><span class=\"line\">    Object retVal = pjp.proceed();</span><br><span class=\"line\">    restoreCurrentDataSource(old);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> retVal;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。</p>\n<p>我们在使用AOP时，要注意到虽然Spring容器可以把指定的方法通过AOP规则装配到指定的Bean的指定方法前后，但是，如果自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。</p>\n<p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。例如，Spring提供的<code>@Transactional</code>就是一个非常好的例子。如果我们自己写的Bean希望在一个数据库事务中被调用，就标注上<code>@Transactional</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 有事务:</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"function\"><span class=\"title\">createUser</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 无事务:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">isValidName</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 有事务:</span></span><br><span class=\"line\">    <span class=\"meta\">@Transactional</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">updateUser</span>(<span class=\"params\">User user</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者直接在class级别注解，表示“所有public方法都被安排了”：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Transactional</span></span><br><span class=\"line\">public class UserService &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>@Transactional</code>，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p>\n<p>我们以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，我们定义一个性能监控的注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Target</span>(METHOD)</span><br><span class=\"line\"><span class=\"variable\">@Retention</span>(RUNTIME)</span><br><span class=\"line\">public <span class=\"variable\">@interface</span> MetricTime &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">String</span> <span class=\"selector-tag\">value</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在需要被监控的关键方法上标注该注解：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 监控register()方法性能:</span></span><br><span class=\"line\">    <span class=\"meta\">@MetricTime</span>(<span class=\"string\">&quot;register&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"function\"><span class=\"title\">register</span>(<span class=\"params\"><span class=\"built_in\">String</span> email, <span class=\"built_in\">String</span> password, <span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们定义<code>MetricAspect</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MetricAspect</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;@annotation(metricTime)&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">metric</span><span class=\"params\">(ProceedingJoinPoint joinPoint, MetricTime metricTime)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        String name = metricTime.value();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> joinPoint.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">long</span> t = System.currentTimeMillis() - start;</span><br><span class=\"line\">            <span class=\"comment\">// 写入日志或发送至JMX:</span></span><br><span class=\"line\">            System.err.println(<span class=\"string\">&quot;[Metrics] &quot;</span> + name + <span class=\"string\">&quot;: &quot;</span> + t + <span class=\"string\">&quot;ms&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意<code>metric()</code>方法标注了<code>@Around(&quot;@annotation(metricTime)&quot;)</code>，它的意思是，符合条件的目标方法是带有<code>@MetricTime</code>注解的方法，因为<code>metric()</code>方法参数类型是<code>MetricTime</code>（注意参数名是<code>metricTime</code>不是<code>MetricTime</code>），我们通过它获取性能监控的名称。</p>\n<p>有了<code>@MetricTime</code>注解，再配合<code>MetricAspect</code>，任何Bean，只要方法标注了<code>@MetricTime</code>注解，就可以自动实现性能监控。运行代码，输出结果如下：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Welcome, Bob!</span><br><span class=\"line\"><span class=\"string\">[Metrics]</span> register: <span class=\"number\">16</span>ms</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"AOP避坑指南\"><a href=\"#AOP避坑指南\" class=\"headerlink\" title=\"AOP避坑指南\"></a>AOP避坑指南</h2><p>无论是使用AspectJ语法，还是配合Annotation，使用AOP，实际上就是让Spring自动为我们创建一个Proxy，使得调用方能无感知地调用指定方法，但运行期却动态“织入”了其他逻辑，因此，AOP本质上就是一个<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017\">代理模式</a>。</p>\n<p>因为Spring使用了CGLIB来实现运行期动态创建Proxy，如果我们没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。</p>\n<p>我们来看一个实际的例子。</p>\n<p>假设我们定义了一个<code>UserService</code>的Bean：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 成员变量:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ZoneId zoneId = ZoneId.systemDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造方法:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> UserService() &#123;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">&quot;UserService(): init...&quot;</span>);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">&quot;UserService(): zoneId = &quot;</span> + <span class=\"keyword\">this</span>.zoneId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// public方法:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ZoneId getZoneId() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zoneId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// public final方法:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ZoneId getFinalZoneId() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zoneId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再写个<code>MailService</code>，并注入<code>UserService</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">sendMail</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        ZoneId zoneId = userService.zoneId;</span><br><span class=\"line\">        <span class=\"built_in\">String</span> dt = ZonedDateTime.now(zoneId).toString();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello, it is &quot;</span> + dt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后用<code>main()</code>方法测试一下：</p>\n<figure class=\"highlight d\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> AppConfig &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String[] args) &#123;</span><br><span class=\"line\">        ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(AppConfig.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">        MailService mailService = context.getBean(MailService.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(mailService.sendMail());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>查看输出，一切正常：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">UserService</span>(): init...</span><br><span class=\"line\"><span class=\"attribute\">UserService</span>(): zoneId = Asia/Shanghai</span><br><span class=\"line\"><span class=\"attribute\">Hello</span>, it is <span class=\"number\">2020</span>-<span class=\"number\">04</span>-<span class=\"number\">12</span>T<span class=\"number\">10</span>:<span class=\"number\">23</span>:<span class=\"number\">22</span>.<span class=\"number\">917721</span>+<span class=\"number\">08</span>:<span class=\"number\">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>\n\n<p>下一步，我们给<code>UserService</code>加上AOP支持，就添加一个最简单的<code>LoggingAspect</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Aspect</span></span><br><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\">public class LoggingAspect &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Before</span>(<span class=\"string\">&quot;execution(public * com..*.UserService.*(..))&quot;</span>)</span><br><span class=\"line\">    public void doAccessCheck() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">System</span><span class=\"selector-class\">.err</span><span class=\"selector-class\">.println</span>(<span class=\"string\">&quot;[Before] do access check...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>别忘了在<code>AppConfig</code>上加上<code>@EnableAspectJAutoProxy</code>。再次运行，不出意外的话，会得到一个<code>NullPointerException</code>：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception <span class=\"keyword\">in</span> thread <span class=\"string\">&quot;main&quot;</span> java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.NullPointerException</span>: zone</span><br><span class=\"line\">    at java.base/java<span class=\"selector-class\">.util</span><span class=\"selector-class\">.Objects</span><span class=\"selector-class\">.requireNonNull</span>(Objects<span class=\"selector-class\">.java</span>:<span class=\"number\">246</span>)</span><br><span class=\"line\">    at java.base/java<span class=\"selector-class\">.time</span><span class=\"selector-class\">.Clock</span><span class=\"selector-class\">.system</span>(Clock<span class=\"selector-class\">.java</span>:<span class=\"number\">203</span>)</span><br><span class=\"line\">    at java.base/java<span class=\"selector-class\">.time</span><span class=\"selector-class\">.ZonedDateTime</span><span class=\"selector-class\">.now</span>(ZonedDateTime<span class=\"selector-class\">.java</span>:<span class=\"number\">216</span>)</span><br><span class=\"line\">    at com<span class=\"selector-class\">.itranswarp</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.service</span><span class=\"selector-class\">.MailService</span><span class=\"selector-class\">.sendMail</span>(MailService<span class=\"selector-class\">.java</span>:<span class=\"number\">19</span>)</span><br><span class=\"line\">    at com<span class=\"selector-class\">.itranswarp</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.AppConfig</span><span class=\"selector-class\">.main</span>(AppConfig<span class=\"selector-class\">.java</span>:<span class=\"number\">21</span>)</span><br></pre></td></tr></table></figure>\n\n<p>仔细跟踪代码，会发现<code>null</code>值出现在<code>MailService.sendMail()</code>内部的这一行代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">sendMail</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        ZoneId zoneId = userService.zoneId;</span><br><span class=\"line\">        System.out.println(zoneId); <span class=\"comment\">// null</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们还故意在<code>UserService</code>中特意用<code>final</code>修饰了一下成员变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ZoneId zoneId = ZoneId.systemDefault();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>用<code>final</code>标注的成员变量为<code>null</code>？逗我呢？</p>\n<h3 id=\"怎么肥四？\"><a href=\"#怎么肥四？\" class=\"headerlink\" title=\"怎么肥四？\"></a>怎么肥四？</h3><p>为什么加了AOP就报NPE，去了AOP就一切正常？<code>final</code>字段不执行，难道JVM有问题？为了解答这个诡异的问题，我们需要深入理解Spring使用CGLIB生成Proxy的原理：</p>\n<p>第一步，正常创建一个<code>UserService</code>的原始实例，这是通过反射调用构造方法实现的，它的行为和我们预期的完全一致；</p>\n<p>第二步，通过CGLIB创建一个<code>UserService</code>的子类，并引用了原始实例和<code>LoggingAspect</code>：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> UserService$$EnhancerBySpringCGLIB <span class=\"keyword\">extends</span> UserService &#123;</span><br><span class=\"line\">    UserService <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    LoggingAspect <span class=\"class\"><span class=\"keyword\">aspect</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> UserService$$EnhancerBySpringCGLIB() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">ZoneId <span class=\"title\">getZoneId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        aspect.doAccessCheck();</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">return</span> <span class=\"keyword\">target</span>.<span class=\"title\">getZoneId</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们观察Spring创建的AOP代理，它的类名总是类似<code>UserService$$EnhancerBySpringCGLIB$$1c76af9d</code>（你没看错，Java的类名实际上允许<code>$</code>字符）。为了让调用方获得<code>UserService</code>的引用，它必须继承自<code>UserService</code>。然后，该代理类会覆写所有<code>public</code>和<code>protected</code>方法，并在内部将调用委托给原始的<code>UserService</code>实例。</p>\n<p>这里出现了两个<code>UserService</code>实例：</p>\n<p>一个是我们代码中定义的<em>原始实例</em>，它的成员变量已经按照我们预期的方式被初始化完成：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">UserService original</span> = new UserService();</span><br></pre></td></tr></table></figure>\n\n<p>第二个<code>UserService</code>实例实际上类型是<code>UserService$$EnhancerBySpringCGLIB</code>，它引用了原始的<code>UserService</code>实例：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"code\"><pre><span class=\"line\">UserService<span class=\"symbol\">$</span><span class=\"symbol\">$</span>EnhancerBySpringCGLIB proxy = new UserService<span class=\"symbol\">$</span><span class=\"symbol\">$</span>EnhancerBySpringCGLIB();</span><br><span class=\"line\">proxy.target = original;</span><br><span class=\"line\">proxy.aspect = ...</span><br></pre></td></tr></table></figure>\n\n<p>注意到这种情况仅出现在启用了AOP的情况，此刻，从<code>ApplicationContext</code>中获取的<code>UserService</code>实例是proxy，注入到<code>MailService</code>中的<code>UserService</code>实例也是proxy。</p>\n<p>那么最终的问题来了：proxy实例的成员变量，也就是从<code>UserService</code>继承的<code>zoneId</code>，它的值是<code>null</code>。</p>\n<p>原因在于，<code>UserService</code>成员变量的初始化：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">UserService</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ZoneId zoneId = ZoneId.systemDefault();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>UserService$$EnhancerBySpringCGLIB</code>中，并未执行。原因是，没必要初始化proxy的成员变量，因为proxy的目的是代理方法。</p>\n<p>实际上，成员变量的初始化是在构造方法中完成的。这是我们看到的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ZoneId zoneId = ZoneId.systemDefault();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是编译器实际编译的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ZoneId zoneId;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(); <span class=\"comment\">// 构造方法的第一行代码总是调用super()</span></span><br><span class=\"line\">        zoneId = ZoneId.systemDefault(); <span class=\"comment\">// 继续初始化成员变量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而，对于Spring通过CGLIB动态创建的<code>UserService$$EnhancerBySpringCGLIB</code>代理类，它的构造方法中，并未调用<code>super()</code>，因此，从父类继承的成员变量，包括<code>final</code>类型的成员变量，统统都没有初始化。</p>\n<p>有的童鞋会问：Java语言规定，任何类的构造方法，第一行必须调用<code>super()</code>，如果没有，编译器会自动加上，怎么Spring的CGLIB就可以搞特殊？</p>\n<p>这是因为自动加<code>super()</code>的功能是Java编译器实现的，它发现你没加，就自动给加上，发现你加错了，就报编译错误。但实际上，如果直接构造字节码，一个类的构造方法中，不一定非要调用<code>super()</code>。Spring使用CGLIB构造的Proxy类，是直接生成字节码，并没有源码-编译-字节码这个步骤，因此：</p>\n<p> Spring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！</p>\n<p>再考察<code>MailService</code>的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">sendMail</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        ZoneId zoneId = userService.zoneId;</span><br><span class=\"line\">        System.out.println(zoneId); <span class=\"comment\">// null</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果没有启用AOP，注入的是原始的<code>UserService</code>实例，那么一切正常，因为<code>UserService</code>实例的<code>zoneId</code>字段已经被正确初始化了。</p>\n<p>如果启动了AOP，注入的是代理后的<code>UserService$$EnhancerBySpringCGLIB</code>实例，那么问题大了：获取的<code>UserService$$EnhancerBySpringCGLIB</code>实例的<code>zoneId</code>字段，永远为<code>null</code>。</p>\n<p>那么问题来了：启用了AOP，如何修复？</p>\n<p>修复很简单，只需要把直接访问字段的代码，改为通过方法访问：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MailService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">sendMail</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不要直接访问UserService的字段:</span></span><br><span class=\"line\">        ZoneId zoneId = userService.getZoneId();</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无论注入的<code>UserService</code>是原始实例还是代理实例，<code>getZoneId()</code>都能正常工作，因为代理类会覆写<code>getZoneId()</code>方法，并将其委托给原始实例：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> UserService$$EnhancerBySpringCGLIB <span class=\"keyword\">extends</span> UserService &#123;</span><br><span class=\"line\">    UserService <span class=\"keyword\">target</span> = ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\">ZoneId <span class=\"title\">getZoneId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">return</span> <span class=\"keyword\">target</span>.<span class=\"title\">getZoneId</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到我们还给<code>UserService</code>添加了一个<code>public</code>+<code>final</code>的方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> ZoneId <span class=\"title\">getFinalZoneId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> zoneId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果在<code>MailService</code>中，调用的不是<code>getZoneId()</code>，而是<code>getFinalZoneId()</code>，又会出现<code>NullPointerException</code>，这是因为，代理类无法覆写<code>final</code>方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的<code>zoneId</code>字段，即<code>null</code>。</p>\n<p>实际上，如果我们加上日志，Spring在启动时会打印一个警告：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">10</span>:<span class=\"number\">43</span>:<span class=\"number\">09.929</span> [main] DEBUG org.springframework.aop.framework.CglibAopProxy - <span class=\"keyword\">Final</span> <span class=\"function\"><span class=\"keyword\">method</span> [<span class=\"title\">public</span> <span class=\"title\">final</span> <span class=\"title\">java</span>.<span class=\"title\">time</span>.<span class=\"title\">ZoneId</span> <span class=\"title\">xxx</span>.<span class=\"title\">UserService</span>.<span class=\"title\">getFinalZoneId</span><span class=\"params\">()</span>] <span class=\"title\">cannot</span> <span class=\"title\">get</span> <span class=\"title\">proxied</span> <span class=\"title\">via</span> <span class=\"title\">CGLIB</span>:</span> Calls <span class=\"keyword\">to</span> this <span class=\"function\"><span class=\"keyword\">method</span> <span class=\"title\">will</span> <span class=\"title\">NOT</span> <span class=\"title\">be</span> <span class=\"title\">routed</span> <span class=\"title\">to</span> <span class=\"title\">the</span> <span class=\"title\">target</span> <span class=\"title\">instance</span> <span class=\"title\">and</span> <span class=\"title\">might</span> <span class=\"title\">lead</span> <span class=\"title\">to</span> <span class=\"title\">NPEs</span> <span class=\"title\">against</span> <span class=\"title\">uninitialized</span> <span class=\"title\">fields</span> <span class=\"title\">in</span> <span class=\"title\">the</span> <span class=\"title\">proxy</span> <span class=\"title\">instance</span>.</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的日志大意就是，因为被代理的<code>UserService</code>有一个<code>final</code>方法<code>getFinalZoneId()</code>，这会导致其他Bean如果调用此方法，无法将其代理到真正的原始实例，从而可能发生NPE异常。</p>\n<p>因此，正确使用AOP，我们需要一个避坑指南：</p>\n<ol>\n<li>访问被注入的Bean时，总是调用方法而非直接访问字段；</li>\n<li>编写Bean时，如果可能会被代理，就不要编写<code>public final</code>方法。</li>\n</ol>\n<p>这样才能保证有没有AOP，代码都能正常工作。</p>\n<h3 id=\"思考-1\"><a href=\"#思考-1\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p>为什么Spring刻意不初始化Proxy继承的字段？</p>\n<p>如果一个Bean不允许任何AOP代理，应该怎么做来“保护”自己在运行期不会被代理？</p>\n<h1 id=\"4-访问数据库\"><a href=\"#4-访问数据库\" class=\"headerlink\" title=\"4. 访问数据库\"></a>4. 访问数据库</h1><h2 id=\"4-0-简介\"><a href=\"#4-0-简介\" class=\"headerlink\" title=\"4.0 简介\"></a>4.0 简介</h2><p>数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。</p>\n<p>我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特定厂商的驱动。</p>\n<p>使用JDBC虽然简单，但代码比较繁琐。Spring为了简化数据库访问，主要做了以下几点工作：</p>\n<ul>\n<li>提供了简化的访问JDBC的模板类，不必手动释放资源；</li>\n<li>提供了一个统一的DAO类以实现Data Access Object模式；</li>\n<li>把<code>SQLException</code>封装为<code>DataAccessException</code>，这个异常是一个<code>RuntimeException</code>，并且让我们能区分SQL异常的原因，例如，<code>DuplicateKeyException</code>表示违反了一个唯一约束；</li>\n<li>能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。</li>\n</ul>\n<p>本章我们将详细讲解在Spring中访问数据库的最佳实践。</p>\n<h2 id=\"4-1-使用声明式事务\"><a href=\"#4-1-使用声明式事务\" class=\"headerlink\" title=\"4.1 使用声明式事务\"></a>4.1 使用声明式事务</h2><p>我们在前面介绍<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255943820274272\">JDBC编程</a>时已经讲过，Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：</p>\n<ul>\n<li>创建全局<code>DataSource</code>实例，表示数据库连接池；</li>\n<li>在需要读写数据库的方法内部，按如下步骤访问数据库：<ul>\n<li>从全局<code>DataSource</code>实例获取<code>Connection</code>实例；</li>\n<li>通过<code>Connection</code>实例创建<code>PreparedStatement</code>实例；</li>\n<li>执行SQL语句，如果是查询，则通过<code>ResultSet</code>读取结果集，如果是修改，则获得<code>int</code>结果。</li>\n</ul>\n</li>\n</ul>\n<p>正确编写JDBC代码的关键是使用<code>try ... finally</code>释放资源，涉及到事务的代码需要正确提交或回滚事务。</p>\n<p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个<code>DataSource</code>实例，然后，Spring提供了一个<code>JdbcTemplate</code>，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个<code>JdbcTemplate</code>。顾名思义，这个类主要使用了<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1281319636041762\">Template模式</a>。</p>\n<p>编写示例代码或者测试代码时，我们强烈推荐使用<a href=\"http://hsqldb.org/\">HSQLDB</a>这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p>\n<p>我们以实际工程为例，先创建Maven工程<code>spring-data-jdbc</code>，然后引入以下依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.annotation<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.annotation-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.zaxxer<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>HikariCP<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.4.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.hsqldb<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hsqldb<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在AppConfig中，我们需要创建以下几个必须的Bean：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Configuration</span><br><span class=\"line\">@ComponentScan</span><br><span class=\"line\">@<span class=\"constructor\">PropertySource(<span class=\"string\">&quot;jdbc.properties&quot;</span>)</span></span><br><span class=\"line\">public <span class=\"keyword\">class</span> AppConfig &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"constructor\">Value(<span class=\"string\">&quot;$&#123;jdbc.url&#125;&quot;</span>)</span></span><br><span class=\"line\">    String jdbcUrl;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"constructor\">Value(<span class=\"string\">&quot;$&#123;jdbc.username&#125;&quot;</span>)</span></span><br><span class=\"line\">    String jdbcUsername;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"constructor\">Value(<span class=\"string\">&quot;$&#123;jdbc.password&#125;&quot;</span>)</span></span><br><span class=\"line\">    String jdbcPassword;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    DataSource create<span class=\"constructor\">DataSource()</span> &#123;</span><br><span class=\"line\">        HikariConfig config = <span class=\"keyword\">new</span> <span class=\"constructor\">HikariConfig()</span>;</span><br><span class=\"line\">        config.set<span class=\"constructor\">JdbcUrl(<span class=\"params\">jdbcUrl</span>)</span>;</span><br><span class=\"line\">        config.set<span class=\"constructor\">Username(<span class=\"params\">jdbcUsername</span>)</span>;</span><br><span class=\"line\">        config.set<span class=\"constructor\">Password(<span class=\"params\">jdbcPassword</span>)</span>;</span><br><span class=\"line\">        config.add<span class=\"constructor\">DataSourceProperty(<span class=\"string\">&quot;autoCommit&quot;</span>, <span class=\"string\">&quot;true&quot;</span>)</span>;</span><br><span class=\"line\">        config.add<span class=\"constructor\">DataSourceProperty(<span class=\"string\">&quot;connectionTimeout&quot;</span>, <span class=\"string\">&quot;5&quot;</span>)</span>;</span><br><span class=\"line\">        config.add<span class=\"constructor\">DataSourceProperty(<span class=\"string\">&quot;idleTimeout&quot;</span>, <span class=\"string\">&quot;60&quot;</span>)</span>;</span><br><span class=\"line\">        return <span class=\"keyword\">new</span> <span class=\"constructor\">HikariDataSource(<span class=\"params\">config</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    JdbcTemplate create<span class=\"constructor\">JdbcTemplate(@Autowired DataSource <span class=\"params\">dataSource</span>)</span> &#123;</span><br><span class=\"line\">        return <span class=\"keyword\">new</span> <span class=\"constructor\">JdbcTemplate(<span class=\"params\">dataSource</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上述配置中：</p>\n<ol>\n<li>通过<code>@PropertySource(&quot;jdbc.properties&quot;)</code>读取数据库配置文件；</li>\n<li>通过<code>@Value(&quot;$&#123;jdbc.url&#125;&quot;)</code>注入配置文件的相关配置；</li>\n<li>创建一个DataSource实例，它的实际类型是<code>HikariDataSource</code>，创建时需要用到注入的配置；</li>\n<li>创建一个JdbcTemplate实例，它需要注入<code>DataSource</code>，这是通过方法参数完成注入的。</li>\n</ol>\n<p>最后，针对HSQLDB写一个配置文件<code>jdbc.properties</code>：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 数据库文件名为testdb:</span></span><br><span class=\"line\">jdbc.<span class=\"attribute\">url</span>=jdbc:hsqldb:file:testdb</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Hsqldb默认的用户名是sa，口令是空字符串:</span></span><br><span class=\"line\">jdbc.<span class=\"attribute\">username</span>=sa</span><br><span class=\"line\">jdbc.password=</span><br></pre></td></tr></table></figure>\n\n<p>可以通过HSQLDB自带的工具来初始化数据库表，这里我们写一个Bean，在Spring容器启动时自动创建一个<code>users</code>表：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DatabaseInitializer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    JdbcTemplate jdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        jdbcTemplate.update(<span class=\"string\">&quot;CREATE TABLE IF NOT EXISTS users (&quot;</span> <span class=\"comment\">//</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot;</span> <span class=\"comment\">//</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;email VARCHAR(100) NOT NULL, &quot;</span> <span class=\"comment\">//</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;password VARCHAR(100) NOT NULL, &quot;</span> <span class=\"comment\">//</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;name VARCHAR(100) NOT NULL, &quot;</span> <span class=\"comment\">//</span></span><br><span class=\"line\">                + <span class=\"string\">&quot;UNIQUE (email))&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，所有准备工作都已完毕。我们只需要在需要访问数据库的Bean中，注入<code>JdbcTemplate</code>即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    JdbcTemplate jdbcTemplate;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JdbcTemplate用法\"><a href=\"#JdbcTemplate用法\" class=\"headerlink\" title=\"JdbcTemplate用法\"></a>JdbcTemplate用法</h3><p>Spring提供的<code>JdbcTemplate</code>采用Template模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的<code>try...catch</code>语句。</p>\n<p>我们以具体的示例来说明JdbcTemplate的用法。</p>\n<p>首先我们看<code>T execute(ConnectionCallback&lt;T&gt; action)</code>方法，它提供了Jdbc的<code>Connection</code>供我们使用：</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> User getUserById(<span class=\"built_in\">long</span> id) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意传入的是ConnectionCallback:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jdbcTemplate.execute((Connection conn) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:</span></span><br><span class=\"line\">        <span class=\"comment\">// 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"built_in\">var</span> ps = conn.prepareStatement(<span class=\"string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)) &#123;</span><br><span class=\"line\">            ps.setObject(<span class=\"number\">1</span>, id);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (<span class=\"built_in\">var</span> rs = ps.executeQuery()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs.<span class=\"keyword\">next</span>()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User( <span class=\"comment\">// new User object:</span></span><br><span class=\"line\">                            rs.getLong(<span class=\"string\">&quot;id&quot;</span>), <span class=\"comment\">// id</span></span><br><span class=\"line\">                            rs.getString(<span class=\"string\">&quot;email&quot;</span>), <span class=\"comment\">// email</span></span><br><span class=\"line\">                            rs.getString(<span class=\"string\">&quot;password&quot;</span>), <span class=\"comment\">// password</span></span><br><span class=\"line\">                            rs.getString(<span class=\"string\">&quot;name&quot;</span>)); <span class=\"comment\">// name</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;user not found by id.&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>也就是说，上述回调方法允许获取Connection，然后做任何基于Connection的操作。</p>\n<p>我们再看<code>T execute(String sql, PreparedStatementCallback&lt;T&gt; action)</code>的用法：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> User getUserByName(<span class=\"keyword\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 需要传入SQL语句，以及PreparedStatementCallback:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jdbcTemplate.execute(<span class=\"string\">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, (PreparedStatement ps) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:</span></span><br><span class=\"line\">        ps.setObject(<span class=\"number\">1</span>, name);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (<span class=\"keyword\">var</span> rs = ps.executeQuery()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs.next()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">User</span>( <span class=\"comment\">// new User object:</span></span><br><span class=\"line\">                        rs.getLong(<span class=\"string\">&quot;id&quot;</span>), <span class=\"comment\">// id</span></span><br><span class=\"line\">                        rs.getString(<span class=\"string\">&quot;email&quot;</span>), <span class=\"comment\">// email</span></span><br><span class=\"line\">                        rs.getString(<span class=\"string\">&quot;password&quot;</span>), <span class=\"comment\">// password</span></span><br><span class=\"line\">                        rs.getString(<span class=\"string\">&quot;name&quot;</span>)); <span class=\"comment\">// name</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">RuntimeException</span>(<span class=\"string\">&quot;user not found by id.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，我们看<code>T queryForObject(String sql, Object[] args, RowMapper&lt;T&gt; rowMapper)</code>方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> User <span class=\"function\"><span class=\"title\">getUserByEmail</span>(<span class=\"params\"><span class=\"built_in\">String</span> email</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 传入SQL，参数和RowMapper实例:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> jdbcTemplate.queryForObject(<span class=\"string\">&quot;SELECT * FROM users WHERE email = ?&quot;</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>[] &#123; email &#125;,</span><br><span class=\"line\">            (ResultSet rs, int rowNum) -&gt; &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将ResultSet的当前行映射为一个JavaBean:</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> User( <span class=\"comment\">// new User object:</span></span><br><span class=\"line\">                        rs.getLong(<span class=\"string\">&quot;id&quot;</span>), <span class=\"comment\">// id</span></span><br><span class=\"line\">                        rs.getString(<span class=\"string\">&quot;email&quot;</span>), <span class=\"comment\">// email</span></span><br><span class=\"line\">                        rs.getString(<span class=\"string\">&quot;password&quot;</span>), <span class=\"comment\">// password</span></span><br><span class=\"line\">                        rs.getString(<span class=\"string\">&quot;name&quot;</span>)); <span class=\"comment\">// name</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>queryForObject()</code>方法中，传入SQL以及SQL参数后，<code>JdbcTemplate</code>会自动创建<code>PreparedStatement</code>，自动执行查询并返回<code>ResultSet</code>，我们提供的<code>RowMapper</code>需要做的事情就是把<code>ResultSet</code>的当前行映射成一个JavaBean并返回。整个过程中，使用<code>Connection</code>、<code>PreparedStatement</code>和<code>ResultSet</code>都不需要我们手动管理。</p>\n<p><code>RowMapper</code>不一定返回JavaBean，实际上它可以返回任何Java对象。例如，使用<code>SELECT COUNT(*)</code>查询时，可以返回<code>Long</code>：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">getUsers</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jdbcTemplate.queryForObject(<span class=\"string\">&quot;SELECT COUNT(*) FROM users&quot;</span>, <span class=\"keyword\">null</span>, (ResultSet rs, <span class=\"keyword\">int</span> rowNum) -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// SELECT COUNT(*)查询只有一列，取第一列数据:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">return</span> rs.<span class=\"title\">getLong</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们期望返回多行记录，而不是一行，可以用<code>query()</code>方法：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> List&lt;<span class=\"keyword\">User</span>&gt; getUsers(<span class=\"type\">int</span> pageIndex) &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"keyword\">limit</span> = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"keyword\">offset</span> = <span class=\"keyword\">limit</span> * (pageIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jdbcTemplate.query(&quot;SELECT * FROM users LIMIT ? OFFSET ?&quot;, <span class=\"built_in\">new</span> <span class=\"keyword\">Object</span>[] &#123; <span class=\"keyword\">limit</span>, <span class=\"keyword\">offset</span> &#125;,</span><br><span class=\"line\">            <span class=\"built_in\">new</span> BeanPropertyRowMapper&lt;&gt;(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述<code>query()</code>方法传入的参数仍然是SQL、SQL参数以及<code>RowMapper</code>实例。这里我们直接使用Spring提供的<code>BeanPropertyRowMapper</code>。如果数据库表的结构恰好和JavaBean的属性名称一致，那么<code>BeanPropertyRowMapper</code>就可以直接把一行记录按列名转换为JavaBean。</p>\n<p>如果我们执行的不是查询，而是插入、更新和删除操作，那么需要使用<code>update()</code>方法：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"type\">void</span> updateUser(<span class=\"keyword\">User</span> <span class=\"keyword\">user</span>) &#123;</span><br><span class=\"line\">    // 传入<span class=\"keyword\">SQL</span>，<span class=\"keyword\">SQL</span>参数，返回更新的行数:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> != jdbcTemplate.<span class=\"keyword\">update</span>(&quot;UPDATE user SET name = ? WHERE id=?&quot;, <span class=\"keyword\">user</span>.getName(), <span class=\"keyword\">user</span>.getId())) &#123;</span><br><span class=\"line\">        throw <span class=\"built_in\">new</span> RuntimeException(&quot;User not found by id&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>只有一种<code>INSERT</code>操作比较特殊，那就是如果某一列是自增列（例如自增主键），通常，我们需要获取插入后的自增值。<code>JdbcTemplate</code>提供了一个<code>KeyHolder</code>来简化这一操作：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> User register(<span class=\"keyword\">String</span> email, <span class=\"keyword\">String</span> password, <span class=\"keyword\">String</span> name) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个KeyHolder:</span></span><br><span class=\"line\">    KeyHolder holder = <span class=\"keyword\">new</span> <span class=\"type\">GeneratedKeyHolder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> != jdbcTemplate.update(</span><br><span class=\"line\">        <span class=\"comment\">// 参数1:PreparedStatementCreator</span></span><br><span class=\"line\">        (conn) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> ps = conn.prepareStatement(<span class=\"string\">&quot;INSERT INTO users(email,password,name) VALUES(?,?,?)&quot;</span>,</span><br><span class=\"line\">                    Statement.RETURN_GENERATED_KEYS);</span><br><span class=\"line\">            ps.setObject(<span class=\"number\">1</span>, email);</span><br><span class=\"line\">            ps.setObject(<span class=\"number\">2</span>, password);</span><br><span class=\"line\">            ps.setObject(<span class=\"number\">3</span>, name);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ps;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">// 参数2:KeyHolder</span></span><br><span class=\"line\">        holder)</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">RuntimeException</span>(<span class=\"string\">&quot;Insert failed.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 从KeyHolder中获取返回的自增值:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">User</span>(holder.getKey().longValue(), email, password, name);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>JdbcTemplate</code>还有许多重载方法，这里我们不一一介绍。需要强调的是，<code>JdbcTemplate</code>只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写<code>try(resource) &#123;...&#125;</code>的代码，对于查询，主要通过<code>RowMapper</code>实现了JDBC结果集到Java对象的转换。</p>\n<p>我们总结一下<code>JdbcTemplate</code>的用法，那就是：</p>\n<ul>\n<li>针对简单查询，优选<code>query()</code>和<code>queryForObject()</code>，因为只需提供SQL语句、参数和<code>RowMapper</code>；</li>\n<li>针对更新操作，优选<code>update()</code>，因为只需提供SQL语句和参数；</li>\n<li>任何复杂的操作，最终也可以通过<code>execute(ConnectionCallback)</code>实现，因为拿到<code>Connection</code>就可以做任何JDBC操作。</li>\n</ul>\n<p>实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用<code>BeanPropertyRowMapper</code>就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。</p>\n<p>例如，表的列名是<code>office_address</code>，而JavaBean属性是<code>workAddress</code>，就需要指定别名，改写查询如下：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, email, office_address <span class=\"keyword\">AS</span> workAddress, <span class=\"type\">name</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> email = ?</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3-使用DAO\"><a href=\"#4-3-使用DAO\" class=\"headerlink\" title=\"4.3 使用DAO\"></a>4.3 使用DAO</h2><p>在传统的多层应用程序中，通常是Web层调用业务层，业务层调用数据访问层。业务层负责处理各种业务逻辑，而数据访问层只负责对数据进行增删改查。因此，实现数据访问层就是用<code>JdbcTemplate</code>实现对数据库的操作。</p>\n<p>编写数据访问层的时候，可以使用DAO模式。DAO即Data Access Object的缩写，它没有什么神秘之处，实现起来基本如下：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class UserDao &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JdbcTemplate jdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">User</span> <span class=\"title\">getById</span>(long id) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List<span class=\"tag\">&lt;User&gt;</span> getUsers(int page) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">User</span> <span class=\"title\">createUser</span>(<span class=\"keyword\">User</span> <span class=\"title\">user</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">User</span> <span class=\"title\">updateUser</span>(<span class=\"keyword\">User</span> <span class=\"title\">user</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    void deleteUser(<span class=\"keyword\">User</span> <span class=\"title\">user</span>) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring提供了一个<code>JdbcDaoSupport</code>类，用于简化DAO的实现。这个<code>JdbcDaoSupport</code>没什么复杂的，核心代码就是持有一个<code>JdbcTemplate</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcDaoSupport</span> <span class=\"keyword\">extends</span> <span class=\"title\">DaoSupport</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">JdbcTemplate</span> jdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"keyword\">final</span> void setJdbcTemplate(<span class=\"type\">JdbcTemplate</span> jdbcTemplate) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class=\"line\">        initTemplateConfig();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"keyword\">final</span> <span class=\"type\">JdbcTemplate</span> getJdbcTemplate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.jdbcTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的意图是子类直接从<code>JdbcDaoSupport</code>继承后，可以随时调用<code>getJdbcTemplate()</code>获得<code>JdbcTemplate</code>的实例。那么问题来了：因为<code>JdbcDaoSupport</code>的<code>jdbcTemplate</code>字段没有标记<code>@Autowired</code>，所以，子类想要注入<code>JdbcTemplate</code>，还得自己想个办法：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">extends</span> <span class=\"title\">JdbcDaoSupport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"type\">JdbcTemplate</span> jdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    public void init() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setJdbcTemplate(jdbcTemplate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有的童鞋可能看出来了：既然<code>UserDao</code>都已经注入了<code>JdbcTemplate</code>，那再把它放到父类里，通过<code>getJdbcTemplate()</code>访问岂不是多此一举？</p>\n<p>如果使用传统的XML配置，并不需要编写<code>@Autowired JdbcTemplate jdbcTemplate</code>，但是考虑到现在基本上是使用注解的方式，我们可以编写一个<code>AbstractDao</code>，专门负责注入<code>JdbcTemplate</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractDao</span> <span class=\"keyword\">extends</span> <span class=\"title\">JdbcDaoSupport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">JdbcTemplate</span> jdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    public void init() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setJdbcTemplate(jdbcTemplate);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，子类的代码就非常干净，可以直接调用<code>getJdbcTemplate()</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractDao</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">User</span> getById(long id) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getJdbcTemplate().queryForObject(</span><br><span class=\"line\">                <span class=\"string\">&quot;SELECT * FROM users WHERE id = ?&quot;</span>,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> <span class=\"type\">BeanPropertyRowMapper</span>&lt;&gt;(<span class=\"type\">User</span>.<span class=\"keyword\">class</span>),</span><br><span class=\"line\">                id</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>倘若肯再多写一点样板代码，就可以把<code>AbstractDao</code>改成泛型，并实现<code>getById()</code>，<code>getAll()</code>，<code>deleteById()</code>这样的通用方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractDao</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">JdbcDaoSupport</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String table;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Class&lt;T&gt; entityClass;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> RowMapper&lt;T&gt; rowMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AbstractDao</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取当前类型的泛型类型:</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.entityClass = getParameterizedType();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.table = <span class=\"keyword\">this</span>.entityClass.getSimpleName().toLowerCase() + <span class=\"string\">&quot;s&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.rowMapper = <span class=\"keyword\">new</span> BeanPropertyRowMapper&lt;&gt;(entityClass);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">getById</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getJdbcTemplate().queryForObject(<span class=\"string\">&quot;SELECT * FROM &quot;</span> + table + <span class=\"string\">&quot; WHERE id = ?&quot;</span>, <span class=\"keyword\">this</span>.rowMapper, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;T&gt; <span class=\"title\">getAll</span><span class=\"params\">(<span class=\"keyword\">int</span> pageIndex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> limit = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> offset = limit * (pageIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getJdbcTemplate().query(<span class=\"string\">&quot;SELECT * FROM &quot;</span> + table + <span class=\"string\">&quot; LIMIT ? OFFSET ?&quot;</span>,</span><br><span class=\"line\">                <span class=\"keyword\">new</span> Object[] &#123; limit, offset &#125;,</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.rowMapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteById</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">        getJdbcTemplate().update(<span class=\"string\">&quot;DELETE FROM &quot;</span> + table + <span class=\"string\">&quot; WHERE id = ?&quot;</span>, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，每个子类就自动获得了这些通用方法：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Transactional</span></span><br><span class=\"line\">public class UserDao extends AbstractDao&lt;User&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 已经有了:</span></span><br><span class=\"line\">    <span class=\"comment\">// User getById(long)</span></span><br><span class=\"line\">    <span class=\"comment\">// List&lt;User&gt; getAll(int)</span></span><br><span class=\"line\">    <span class=\"comment\">// void deleteById(long)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Transactional</span></span><br><span class=\"line\">public class BookDao extends AbstractDao&lt;Book&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 已经有了:</span></span><br><span class=\"line\">    <span class=\"comment\">// Book getById(long)</span></span><br><span class=\"line\">    <span class=\"comment\">// List&lt;Book&gt; getAll(int)</span></span><br><span class=\"line\">    <span class=\"comment\">// void deleteById(long)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，DAO模式就是一个简单的数据访问模式，是否使用DAO，根据实际情况决定，因为很多时候，直接在Service层操作数据库也是完全没有问题的。</p>\n<h2 id=\"4-4-集成Hibernate\"><a href=\"#4-4-集成Hibernate\" class=\"headerlink\" title=\"4.4 集成Hibernate\"></a>4.4 集成Hibernate</h2><p>使用<code>JdbcTemplate</code>的时候，我们用得最多的方法就是<code>List&lt;T&gt; query(String sql, Object[] args, RowMapper rowMapper)</code>。这个<code>RowMapper</code>的作用就是把<code>ResultSet</code>的一行记录映射为Java Bean。</p>\n<p>这种把关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping。ORM既可以把记录转换成Java对象，也可以把Java对象转换为行记录。</p>\n<p>使用<code>JdbcTemplate</code>配合<code>RowMapper</code>可以看作是最原始的ORM。如果要实现更自动化的ORM，可以选择成熟的ORM框架，例如<a href=\"https://hibernate.org/\">Hibernate</a>。</p>\n<p>我们来看看如何在Spring中集成Hibernate。</p>\n<p>Hibernate作为ORM框架，它可以替代<code>JdbcTemplate</code>，但Hibernate仍然需要JDBC驱动，所以，我们需要引入JDBC驱动、连接池，以及Hibernate本身。在Maven中，我们加入以下依赖项：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- JDBC驱动，这里使用HSQLDB --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.hsqldb<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hsqldb<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.5.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- JDBC连接池 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.zaxxer<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>HikariCP<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.4.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Hibernate --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.hibernate<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hibernate-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.4.2.Final<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Context和Spring ORM --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-orm<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在AppConfig中，我们仍然需要创建DataSource、引入JDBC配置文件，以及启用声明式事务：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(<span class=\"string\">&quot;jdbc.properties&quot;</span>)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    DataSource createDataSource() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了启用Hibernate，我们需要创建一个<code>LocalSessionFactoryBean</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> AppConfig &#123;</span><br><span class=\"line\">    @Bean</span><br><span class=\"line\">    LocalSessionFactoryBean create<span class=\"constructor\">SessionFactory(@Autowired DataSource <span class=\"params\">dataSource</span>)</span> &#123;</span><br><span class=\"line\">        var props = <span class=\"keyword\">new</span> <span class=\"constructor\">Properties()</span>;</span><br><span class=\"line\">        props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class=\"string\">&quot;update&quot;</span>)</span>; <span class=\"comment\">// 生产环境不要使用</span></span><br><span class=\"line\">        props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;hibernate.dialect&quot;</span>, <span class=\"string\">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>)</span>;</span><br><span class=\"line\">        props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;hibernate.show_sql&quot;</span>, <span class=\"string\">&quot;true&quot;</span>)</span>;</span><br><span class=\"line\">        var sessionFactoryBean = <span class=\"keyword\">new</span> <span class=\"constructor\">LocalSessionFactoryBean()</span>;</span><br><span class=\"line\">        sessionFactoryBean.set<span class=\"constructor\">DataSource(<span class=\"params\">dataSource</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 扫描指定的package获取所有entity class:</span></span><br><span class=\"line\">        sessionFactoryBean.set<span class=\"constructor\">PackagesToScan(<span class=\"string\">&quot;com.itranswarp.learnjava.entity&quot;</span>)</span>;</span><br><span class=\"line\">        sessionFactoryBean.set<span class=\"constructor\">HibernateProperties(<span class=\"params\">props</span>)</span>;</span><br><span class=\"line\">        return sessionFactoryBean;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意我们在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1308043627200545\">定制Bean</a>中讲到过<code>FactoryBean</code>，<code>LocalSessionFactoryBean</code>是一个<code>FactoryBean</code>，它会再自动创建一个<code>SessionFactory</code>，在Hibernate中，<code>Session</code>是封装了一个JDBC <code>Connection</code>的实例，而<code>SessionFactory</code>是封装了JDBC <code>DataSource</code>的实例，即<code>SessionFactory</code>持有连接池，每次需要操作数据库的时候，<code>SessionFactory</code>创建一个新的<code>Session</code>，相当于从连接池获取到一个新的<code>Connection</code>。<code>SessionFactory</code>就是Hibernate提供的最核心的一个对象，但<code>LocalSessionFactoryBean</code>是Spring提供的为了让我们方便创建<code>SessionFactory</code>的类。</p>\n<p>注意到上面创建<code>LocalSessionFactoryBean</code>的代码，首先用<code>Properties</code>持有Hibernate初始化<code>SessionFactory</code>时用到的所有设置，常用的设置请参考<a href=\"https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#configurations\">Hibernate文档</a>，这里我们只定义了3个设置：</p>\n<ul>\n<li><code>hibernate.hbm2ddl.auto=update</code>：表示自动创建数据库的表结构，注意不要在生产环境中启用；</li>\n<li><code>hibernate.dialect=org.hibernate.dialect.HSQLDialect</code>：指示Hibernate使用的数据库是HSQLDB。Hibernate使用一种HQL的查询语句，它和SQL类似，但真正在“翻译”成SQL时，会根据设定的数据库“方言”来生成针对数据库优化的SQL；</li>\n<li><code>hibernate.show_sql=true</code>：让Hibernate打印执行的SQL，这对于调试非常有用，我们可以方便地看到Hibernate生成的SQL语句是否符合我们的预期。</li>\n</ul>\n<p>除了设置<code>DataSource</code>和<code>Properties</code>之外，注意到<code>setPackagesToScan()</code>我们传入了一个<code>package</code>名称，它指示Hibernate扫描这个包下面的所有Java类，自动找出能映射为数据库表记录的JavaBean。后面我们会仔细讨论如何编写符合Hibernate要求的JavaBean。</p>\n<p>紧接着，我们还需要创建<code>HibernateTemplate</code>以及<code>HibernateTransactionManager</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">public</span> <span class=\"selector-tag\">class</span> <span class=\"selector-tag\">AppConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    HibernateTemplate createHibernateTemplate(<span class=\"variable\">@Autowired</span> SessionFactory sessionFactory) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">HibernateTemplate</span>(sessionFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"selector-tag\">Bean</span></span><br><span class=\"line\">    <span class=\"selector-tag\">PlatformTransactionManager</span> <span class=\"selector-tag\">createTxManager</span>(<span class=\"variable\">@Autowired</span> SessionFactory sessionFactory) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">HibernateTransactionManager</span>(sessionFactory);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两个Bean的创建都十分简单。<code>HibernateTransactionManager</code>是配合Hibernate使用声明式事务所必须的，而<code>HibernateTemplate</code>则是Spring为了便于我们使用Hibernate提供的工具类，不是非用不可，但推荐使用以简化代码。</p>\n<p>到此为止，所有的配置都定义完毕，我们来看看如何将数据库表结构映射为Java对象。</p>\n<p>考察如下的数据库表：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">user</span></span><br><span class=\"line\">    id <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">    email <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    password <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    name <span class=\"type\">VARCHAR</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    createdAt <span class=\"type\">BIGINT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">    <span class=\"keyword\">PRIMARY</span> KEY (`id`),</span><br><span class=\"line\">    <span class=\"keyword\">UNIQUE</span> KEY `email` (`email`)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>id</code>是自增主键，<code>email</code>、<code>password</code>、<code>name</code>是<code>VARCHAR</code>类型，<code>email</code>带唯一索引以确保唯一性，<code>createdAt</code>存储整型类型的时间戳。用JavaBean表示如下：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> email;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> password;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long createdAt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getters and setters</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种映射关系十分易懂，但我们需要添加一些注解来告诉Hibernate如何把<code>User</code>类映射到表记录：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Entity</span></span><br><span class=\"line\">public class User &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Id</span></span><br><span class=\"line\">    <span class=\"variable\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, updatable = false)</span><br><span class=\"line\">    public Long getId() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, unique = true, length = <span class=\"number\">100</span>)</span><br><span class=\"line\">    public String getEmail() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, length = <span class=\"number\">100</span>)</span><br><span class=\"line\">    public String getPassword() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, length = <span class=\"number\">100</span>)</span><br><span class=\"line\">    public String getName() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, updatable = false)</span><br><span class=\"line\">    public Long getCreatedAt() &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果一个JavaBean被用于映射，我们就标记一个<code>@Entity</code>。默认情况下，映射的表名是<code>user</code>，如果实际的表名不同，例如实际表名是<code>users</code>，可以追加一个<code>@Table(name=&quot;users&quot;)</code>表示：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Entity</span></span><br><span class=\"line\"><span class=\"variable\">@Table</span>(name=&quot;users)</span><br><span class=\"line\">public class User &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个属性到数据库列的映射用<code>@Column()</code>标识，<code>nullable</code>指示列是否允许为<code>NULL</code>，<code>updatable</code>指示该列是否允许被用在<code>UPDATE</code>语句，<code>length</code>指示<code>String</code>类型的列的长度（如果没有指定，默认是<code>255</code>）。</p>\n<p>对于主键，还需要用<code>@Id</code>标识，自增主键再追加一个<code>@GeneratedValue</code>，以便Hibernate能读取到自增主键的值。</p>\n<p>细心的童鞋可能还注意到，主键<code>id</code>定义的类型不是<code>long</code>，而是<code>Long</code>。这是因为Hibernate如果检测到主键为<code>null</code>，就不会在<code>INSERT</code>语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate认为我们的程序指定了主键的值，会在<code>INSERT</code>语句中直接列出。<code>long</code>型字段总是具有默认值<code>0</code>，因此，每次插入的主键值总是0，导致除第一次外后续插入都将失败。</p>\n<p><code>createdAt</code>虽然是整型，但我们并没有使用<code>long</code>，而是<code>Long</code>，这是因为使用基本类型会导致某种查询会添加意外的条件，后面我们会详细讨论，这里只需牢记，作为映射使用的JavaBean，所有属性都使用包装类型而不是基本类型。</p>\n<p> 使用Hibernate时，不要使用基本类型的属性，总是使用包装类型，如Long或Integer。</p>\n<p>类似的，我们再定义一个<code>Book</code>类：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Entity</span></span><br><span class=\"line\">public class Book &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Id</span></span><br><span class=\"line\">    <span class=\"variable\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, updatable = false)</span><br><span class=\"line\">    public Long getId() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, length = <span class=\"number\">100</span>)</span><br><span class=\"line\">    public String getTitle() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, updatable = false)</span><br><span class=\"line\">    public Long getCreatedAt() &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果仔细观察<code>User</code>和<code>Book</code>，会发现它们定义的<code>id</code>、<code>createdAt</code>属性是一样的，这在数据库表结构的设计中很常见：对于每个表，通常我们会统一使用一种主键生成机制，并添加<code>createdAt</code>表示创建时间，<code>updatedAt</code>表示修改时间等通用字段。</p>\n<p>不必在<code>User</code>和<code>Book</code>中重复定义这些通用字段，我们可以把它们提到一个抽象类中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MappedSuperclass</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractEntity</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Long createdAt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"literal\">false</span>, updatable = <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"function\"><span class=\"title\">getId</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(nullable = <span class=\"literal\">false</span>, updatable = <span class=\"literal\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Long <span class=\"function\"><span class=\"title\">getCreatedAt</span>(<span class=\"params\"></span>)</span> &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Transient</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ZonedDateTime <span class=\"function\"><span class=\"title\">getCreatedDateTime</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Instant.ofEpochMilli(<span class=\"built_in\">this</span>.createdAt).atZone(ZoneId.systemDefault());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PrePersist</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">preInsert</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        setCreatedAt(System.currentTimeMillis());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于<code>AbstractEntity</code>来说，我们要标注一个<code>@MappedSuperclass</code>表示它用于继承。此外，注意到我们定义了一个<code>@Transient</code>方法，它返回一个“虚拟”的属性。因为<code>getCreatedDateTime()</code>是计算得出的属性，而不是从数据库表读出的值，因此必须要标注<code>@Transient</code>，否则Hibernate会尝试从数据库读取名为<code>createdDateTime</code>这个不存在的字段从而出错。</p>\n<p>再注意到<code>@PrePersist</code>标识的方法，它表示在我们将一个JavaBean持久化到数据库之前（即执行INSERT语句），Hibernate会先执行该方法，这样我们就可以自动设置好<code>createdAt</code>属性。</p>\n<p>有了<code>AbstractEntity</code>，我们就可以大幅简化<code>User</code>和<code>Book</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Entity</span></span><br><span class=\"line\">public class User extends AbstractEntity &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, unique = true, length = <span class=\"number\">100</span>)</span><br><span class=\"line\">    public String getEmail() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, length = <span class=\"number\">100</span>)</span><br><span class=\"line\">    public String getPassword() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Column</span>(nullable = false, length = <span class=\"number\">100</span>)</span><br><span class=\"line\">    public String getName() &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到使用的所有注解均来自<code>javax.persistence</code>，它是JPA规范的一部分。这里我们只介绍使用注解的方式配置Hibernate映射关系，不再介绍传统的比较繁琐的XML配置。通过Spring集成Hibernate时，也不再需要<code>hibernate.cfg.xml</code>配置文件，用一句话总结：</p>\n<p> 使用Spring集成Hibernate，配合JPA注解，无需任何额外的XML配置。</p>\n<p>类似<code>User</code>、<code>Book</code>这样的用于ORM的Java Bean，我们通常称之为Entity Bean。</p>\n<p>最后，我们来看看如果对<code>user</code>表进行增删改查。因为使用了Hibernate，因此，我们要做的，实际上是对<code>User</code>这个JavaBean进行“增删改查”。我们编写一个<code>UserService</code>，注入<code>HibernateTemplate</code>以便简化代码：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Transactional</span></span><br><span class=\"line\">public class UserService &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Autowired</span></span><br><span class=\"line\">    HibernateTemplate hibernateTemplate;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Insert操作\"><a href=\"#Insert操作\" class=\"headerlink\" title=\"Insert操作\"></a>Insert操作</h3><p>要持久化一个<code>User</code>实例，我们只需调用<code>save()</code>方法。以<code>register()</code>方法为例，代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public User register(String email, String password, String name) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个User对象:</span></span><br><span class=\"line\">    User user = <span class=\"keyword\">new</span> <span class=\"constructor\">User()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置好各个属性:</span></span><br><span class=\"line\">    user.set<span class=\"constructor\">Email(<span class=\"params\">email</span>)</span>;</span><br><span class=\"line\">    user.set<span class=\"constructor\">Password(<span class=\"params\">password</span>)</span>;</span><br><span class=\"line\">    user.set<span class=\"constructor\">Name(<span class=\"params\">name</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 不要设置id，因为使用了自增主键</span></span><br><span class=\"line\">    <span class=\"comment\">// 保存到数据库:</span></span><br><span class=\"line\">    hibernateTemplate.save(user);</span><br><span class=\"line\">    <span class=\"comment\">// 现在已经自动获得了id:</span></span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(user.get<span class=\"constructor\">Id()</span>);</span><br><span class=\"line\">    return user;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Delete操作\"><a href=\"#Delete操作\" class=\"headerlink\" title=\"Delete操作\"></a>Delete操作</h3><p>删除一个<code>User</code>相当于从表中删除对应的记录。注意Hibernate总是用<code>id</code>来删除记录，因此，要正确设置<code>User</code>的<code>id</code>属性才能正常删除记录：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"type\">boolean</span> deleteUser(Long id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">User</span> <span class=\"keyword\">user</span> = hibernateTemplate.<span class=\"keyword\">get</span>(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>, id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">user</span> != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        hibernateTemplate.<span class=\"keyword\">delete</span>(<span class=\"keyword\">user</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除。<code>load()</code>和<code>get()</code>都可以根据主键加载记录，它们的区别在于，当记录不存在时，<code>get()</code>返回<code>null</code>，而<code>load()</code>抛出异常。</p>\n<h3 id=\"Update操作\"><a href=\"#Update操作\" class=\"headerlink\" title=\"Update操作\"></a>Update操作</h3><p>更新记录相当于先更新<code>User</code>的指定属性，然后调用<code>update()</code>方法：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"type\">void</span> updateUser(Long id, String <span class=\"type\">name</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">User</span> <span class=\"keyword\">user</span> = hibernateTemplate.<span class=\"keyword\">load</span>(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>, id);</span><br><span class=\"line\">    <span class=\"keyword\">user</span>.setName(<span class=\"type\">name</span>);</span><br><span class=\"line\">    hibernateTemplate.<span class=\"keyword\">update</span>(<span class=\"keyword\">user</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>前面我们在定义<code>User</code>时，对有的属性标注了<code>@Column(updatable=false)</code>。Hibernate在更新记录时，它只会把<code>@Column(updatable=true)</code>的属性加入到<code>UPDATE</code>语句中，这样可以提供一层额外的安全性，即如果不小心修改了<code>User</code>的<code>email</code>、<code>createdAt</code>等属性，执行<code>update()</code>时并不会更新对应的数据库列。但也必须牢记：这个功能是Hibernate提供的，如果绕过Hibernate直接通过JDBC执行<code>UPDATE</code>语句仍然可以更新数据库的任意列的值。</p>\n<p>最后，我们编写的大部分方法都是各种各样的查询。根据<code>id</code>查询我们可以直接调用<code>load()</code>或<code>get()</code>，如果要使用条件查询，有3种方法。</p>\n<p>假设我们想执行以下查询：</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> email = ? <span class=\"keyword\">AND</span> <span class=\"keyword\">password</span> = ?</span><br></pre></td></tr></table></figure>\n\n<p>我们来看看可以使用什么查询。</p>\n<h3 id=\"使用Example查询\"><a href=\"#使用Example查询\" class=\"headerlink\" title=\"使用Example查询\"></a>使用Example查询</h3><p>第一种方法是使用<code>findByExample()</code>，给出一个<code>User</code>实例，Hibernate把该实例所有非<code>null</code>的属性拼成<code>WHERE</code>条件：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">User</span> <span class=\"keyword\">login</span>(String email, String <span class=\"keyword\">password</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">User</span> example = <span class=\"built_in\">new</span> <span class=\"keyword\">User</span>();</span><br><span class=\"line\">    example.setEmail(email);</span><br><span class=\"line\">    example.setPassword(<span class=\"keyword\">password</span>);</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">User</span>&gt; list = hibernateTemplate.findByExample(example);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.isEmpty() ? <span class=\"keyword\">null</span> : list.<span class=\"keyword\">get</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>example</code>实例只有<code>email</code>和<code>password</code>两个属性为非<code>null</code>，所以最终生成的<code>WHERE</code>语句就是<code>WHERE email = ? AND password = ?</code>。</p>\n<p>如果我们把<code>User</code>的<code>createdAt</code>的类型从<code>Long</code>改为<code>long</code>，<code>findByExample()</code>的查询将出问题，原因在于<code>example</code>实例的<code>long</code>类型字段有了默认值0，导致Hibernate最终生成的<code>WHERE</code>语句意外变成了<code>WHERE email = ? AND password = ? AND createdAt = 0</code>。显然，额外的查询条件将导致错误的查询结果。</p>\n<p> 使用findByExample()时，注意基本类型字段总是会加入到WHERE条件！</p>\n<h3 id=\"使用Criteria查询\"><a href=\"#使用Criteria查询\" class=\"headerlink\" title=\"使用Criteria查询\"></a>使用Criteria查询</h3><p>第二种查询方法是使用Criteria查询，可以实现如下：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">User</span> <span class=\"keyword\">login</span>(String email, String <span class=\"keyword\">password</span>) &#123;</span><br><span class=\"line\">    DetachedCriteria criteria = DetachedCriteria.forClass(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    criteria.<span class=\"keyword\">add</span>(Restrictions.eq(&quot;email&quot;, email))</span><br><span class=\"line\">            .<span class=\"keyword\">add</span>(Restrictions.eq(&quot;password&quot;, <span class=\"keyword\">password</span>));</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">User</span>&gt; list = (List&lt;<span class=\"keyword\">User</span>&gt;) hibernateTemplate.findByCriteria(criteria);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.isEmpty() ? <span class=\"keyword\">null</span> : list.<span class=\"keyword\">get</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>DetachedCriteria</code>使用链式语句来添加多个<code>AND</code>条件。和<code>findByExample()</code>相比，<code>findByCriteria()</code>可以组装出更灵活的<code>WHERE</code>条件，例如：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> (email = ? <span class=\"keyword\">OR</span> <span class=\"type\">name</span> = ?) <span class=\"keyword\">AND</span> <span class=\"keyword\">password</span> = ?</span><br></pre></td></tr></table></figure>\n\n<p>上述查询没法用<code>findByExample()</code>实现，但用Criteria查询可以实现如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DetachedCriteria criteria = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DetachedCriteria</span>.</span></span><span class=\"keyword\">for</span><span class=\"constructor\">Class(User.<span class=\"params\">class</span>)</span>;</span><br><span class=\"line\">criteria.add(</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Restrictions</span>.</span></span><span class=\"keyword\">and</span>(</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Restrictions</span>.</span></span><span class=\"keyword\">or</span>(</span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Restrictions</span>.</span></span>eq(<span class=\"string\">&quot;email&quot;</span>, email),</span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Restrictions</span>.</span></span>eq(<span class=\"string\">&quot;name&quot;</span>, email)</span><br><span class=\"line\">        ),</span><br><span class=\"line\">\t\t<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Restrictions</span>.</span></span>eq(<span class=\"string\">&quot;password&quot;</span>, password)</span><br><span class=\"line\">    )</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n\n<p>只要组织好<code>Restrictions</code>的嵌套关系，Criteria查询可以实现任意复杂的查询。</p>\n<h3 id=\"使用HQL查询\"><a href=\"#使用HQL查询\" class=\"headerlink\" title=\"使用HQL查询\"></a>使用HQL查询</h3><p>最后一种常用的查询是直接编写Hibernate内置的HQL查询：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;<span class=\"keyword\">User</span>&gt; list = (List&lt;<span class=\"keyword\">User</span>&gt;) hibernateTemplate.find(&quot;FROM User WHERE email=? AND password=?&quot;, email, <span class=\"keyword\">password</span>);</span><br></pre></td></tr></table></figure>\n\n<p>和SQL相比，HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名。详细的HQL语法可以参考<a href=\"https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql\">Hibernate文档</a>。</p>\n<p>除了可以直接传入HQL字符串外，Hibernate还可以使用一种<code>NamedQuery</code>，它给查询起个名字，然后保存在注解中。使用<code>NamedQuery</code>时，我们要先在<code>User</code>类标注：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@NamedQueries</span>(</span><br><span class=\"line\">    <span class=\"variable\">@NamedQuery</span>(</span><br><span class=\"line\">        <span class=\"comment\">// 查询名称:</span></span><br><span class=\"line\">        name = <span class=\"string\">&quot;login&quot;</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 查询语句:</span></span><br><span class=\"line\">        query = <span class=\"string\">&quot;SELECT u FROM User u WHERE u.email=?0 AND u.password=?1&quot;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"variable\">@Entity</span></span><br><span class=\"line\">public class User extends AbstractEntity &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到引入的NamedQuery是<code>javax.persistence.NamedQuery</code>，它和直接传入HQL有点不同的是，占位符使用<code>?0</code>、<code>?1</code>，并且索引是从<code>0</code>开始的（真乱）。</p>\n<p>使用<code>NamedQuery</code>只需要引入查询名和参数：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">User</span> <span class=\"keyword\">login</span>(String email, String <span class=\"keyword\">password</span>) &#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">User</span>&gt; list = (List&lt;<span class=\"keyword\">User</span>&gt;) hibernateTemplate.findByNamedQuery(&quot;login&quot;, email, <span class=\"keyword\">password</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.isEmpty() ? <span class=\"keyword\">null</span> : list.<span class=\"keyword\">get</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>直接写HQL和使用<code>NamedQuery</code>各有优劣。前者可以在代码中直观地看到查询语句，后者可以在<code>User</code>类统一管理所有相关查询。</p>\n<h3 id=\"使用Hibernate原生接口\"><a href=\"#使用Hibernate原生接口\" class=\"headerlink\" title=\"使用Hibernate原生接口\"></a>使用Hibernate原生接口</h3><p>如果要使用Hibernate原生接口，但不知道怎么写，可以参考<code>HibernateTemplate</code>的源码。使用Hibernate的原生接口实际上总是从<code>SessionFactory</code>出发，它通常用全局变量存储，在<code>HibernateTemplate</code>中以成员变量被注入。有了<code>SessionFactory</code>，使用Hibernate用法如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">operation</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    Session session = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"built_in\">boolean</span> isNew = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取当前Session或者打开新的Session:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        session = <span class=\"built_in\">this</span>.sessionFactory.getCurrentSession();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (HibernateException e) &#123;</span><br><span class=\"line\">        session = <span class=\"built_in\">this</span>.sessionFactory.openSession();</span><br><span class=\"line\">        isNew = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 操作Session:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        User user = session.load(User.class, 123L);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭新打开的Session:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isNew) &#123;</span><br><span class=\"line\">            session.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-5-集成JPA\"><a href=\"#4-5-集成JPA\" class=\"headerlink\" title=\"4.5 集成JPA\"></a>4.5 集成JPA</h2><p>上一节我们讲了在Spring中集成Hibernate。Hibernate是第一个被广泛使用的ORM框架，但是很多小伙伴还听说过JPA：Java Persistence API，这又是啥？</p>\n<p>在讨论JPA之前，我们要注意到JavaEE早在1999年就发布了，并且有Servlet、JMS等诸多标准。和其他平台不同，Java世界早期非常热衷于标准先行，各家跟进：大家先坐下来把接口定了，然后，各自回家干活去实现接口，这样，用户就可以在不同的厂家提供的产品进行选择，还可以随意切换，因为用户编写代码的时候只需要引用接口，并不需要引用具体的底层实现（想想JDBC）。</p>\n<p>JPA就是JavaEE的一个ORM标准，它的实现其实和Hibernate没啥本质区别，但是用户如果使用JPA，那么引用的就是<code>javax.persistence</code>这个“标准”包，而不是<code>org.hibernate</code>这样的第三方包。因为JPA只是接口，所以，还需要选择一个实现产品，跟JDBC接口和MySQL驱动一个道理。</p>\n<p>我们使用JPA时也完全可以选择Hibernate作为底层实现，但也可以选择其它的JPA提供方，比如<a href=\"https://www.eclipse.org/eclipselink/\">EclipseLink</a>。Spring内置了JPA的集成，并支持选择Hibernate或EclipseLink作为实现。这里我们仍然以主流的Hibernate作为JPA实现为例子，演示JPA的基本用法。</p>\n<p>和使用Hibernate一样，我们只需要引入如下依赖：</p>\n<ul>\n<li>org.springframework:spring-context:5.2.0.RELEASE</li>\n<li>org.springframework:spring-orm:5.2.0.RELEASE</li>\n<li>javax.annotation:javax.annotation-api:1.3.2</li>\n<li>org.hibernate:hibernate-core:5.4.2.Final</li>\n<li>com.zaxxer:HikariCP:3.4.2</li>\n<li>org.hsqldb:hsqldb:2.5.0</li>\n</ul>\n<p>然后，在<code>AppConfig</code>中启用声明式事务管理，创建<code>DataSource</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(<span class=\"string\">&quot;jdbc.properties&quot;</span>)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    DataSource createDataSource() &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用Hibernate时，我们需要创建一个<code>LocalSessionFactoryBean</code>，并让它再自动创建一个<code>SessionFactory</code>。使用JPA也是类似的，我们需要创建一个<code>LocalContainerEntityManagerFactoryBean</code>，并让它再自动创建一个<code>EntityManagerFactory</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">LocalContainerEntityManagerFactoryBean create<span class=\"constructor\">EntityManagerFactory(@Autowired DataSource <span class=\"params\">dataSource</span>)</span> &#123;</span><br><span class=\"line\">    var entityManagerFactoryBean = <span class=\"keyword\">new</span> <span class=\"constructor\">LocalContainerEntityManagerFactoryBean()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设置DataSource:</span></span><br><span class=\"line\">    entityManagerFactoryBean.set<span class=\"constructor\">DataSource(<span class=\"params\">dataSource</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 扫描指定的package获取所有entity class:</span></span><br><span class=\"line\">    entityManagerFactoryBean.set<span class=\"constructor\">PackagesToScan(<span class=\"string\">&quot;com.itranswarp.learnjava.entity&quot;</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 指定JPA的提供商是Hibernate:</span></span><br><span class=\"line\">    JpaVendorAdapter vendorAdapter = <span class=\"keyword\">new</span> <span class=\"constructor\">HibernateJpaVendorAdapter()</span>;</span><br><span class=\"line\">    entityManagerFactoryBean.set<span class=\"constructor\">JpaVendorAdapter(<span class=\"params\">vendorAdapter</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 设定特定提供商自己的配置:</span></span><br><span class=\"line\">    var props = <span class=\"keyword\">new</span> <span class=\"constructor\">Properties()</span>;</span><br><span class=\"line\">    props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class=\"string\">&quot;update&quot;</span>)</span>;</span><br><span class=\"line\">    props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;hibernate.dialect&quot;</span>, <span class=\"string\">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>)</span>;</span><br><span class=\"line\">    props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;hibernate.show_sql&quot;</span>, <span class=\"string\">&quot;true&quot;</span>)</span>;</span><br><span class=\"line\">    entityManagerFactoryBean.set<span class=\"constructor\">JpaProperties(<span class=\"params\">props</span>)</span>;</span><br><span class=\"line\">    return entityManagerFactoryBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察上述代码，除了需要注入<code>DataSource</code>和设定自动扫描的<code>package</code>外，还需要指定JPA的提供商，这里使用Spring提供的一个<code>HibernateJpaVendorAdapter</code>，最后，针对Hibernate自己需要的配置，以<code>Properties</code>的形式注入。</p>\n<p>最后，我们还需要实例化一个<code>JpaTransactionManager</code>，以实现声明式事务：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Bean</span></span><br><span class=\"line\">PlatformTransactionManager createTxManager(<span class=\"variable\">@Autowired</span> EntityManagerFactory entityManagerFactory) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就完成了JPA的全部初始化工作。有些童鞋可能从网上搜索得知JPA需要<code>persistence.xml</code>配置文件，以及复杂的<code>orm.xml</code>文件。这里我们负责地告诉大家，使用Spring+Hibernate作为JPA实现，无需任何配置文件。</p>\n<p>所有Entity Bean的配置和上一节完全相同，全部采用Annotation标注。我们现在只需关心具体的业务类如何通过JPA接口操作数据库。</p>\n<p>还是以<code>UserService</code>为例，除了标注<code>@Component</code>和<code>@Transactional</code>外，我们需要注入一个<code>EntityManager</code>，但是不要使用<code>Autowired</code>，而是<code>@PersistenceContext</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Component</span></span><br><span class=\"line\"><span class=\"variable\">@Transactional</span></span><br><span class=\"line\">public class UserService &#123;</span><br><span class=\"line\">    <span class=\"variable\">@PersistenceContext</span></span><br><span class=\"line\">    EntityManager em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们回顾一下JDBC、Hibernate和JPA提供的接口，实际上，它们的关系如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">JDBC</th>\n<th align=\"left\">Hibernate</th>\n<th align=\"left\">JPA</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DataSource</td>\n<td align=\"left\">SessionFactory</td>\n<td align=\"left\">EntityManagerFactory</td>\n</tr>\n<tr>\n<td align=\"left\">Connection</td>\n<td align=\"left\">Session</td>\n<td align=\"left\">EntityManager</td>\n</tr>\n</tbody></table>\n<p><code>SessionFactory</code>和<code>EntityManagerFactory</code>相当于<code>DataSource</code>，<code>Session</code>和<code>EntityManager</code>相当于<code>Connection</code>。每次需要访问数据库的时候，需要获取新的<code>Session</code>和<code>EntityManager</code>，用完后再关闭。</p>\n<p>但是，注意到<code>UserService</code>注入的不是<code>EntityManagerFactory</code>，而是<code>EntityManager</code>，并且标注了<code>@PersistenceContext</code>。难道使用JPA可以允许多线程操作同一个<code>EntityManager</code>？</p>\n<p>实际上这里注入的并不是真正的<code>EntityManager</code>，而是一个<code>EntityManager</code>的代理类，相当于：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">EntityManagerProxy</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">EntityManager</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> EntityManagerFactory emf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Spring遇到标注了<code>@PersistenceContext</code>的<code>EntityManager</code>会自动注入代理，该代理会在必要的时候自动打开<code>EntityManager</code>。换句话说，多线程引用的<code>EntityManager</code>虽然是同一个代理类，但该代理类内部针对不同线程会创建不同的<code>EntityManager</code>实例。</p>\n<p>简单总结一下，标注了<code>@PersistenceContext</code>的<code>EntityManager</code>可以被多线程安全地共享。</p>\n<p>因此，在<code>UserService</code>的每个业务方法里，直接使用<code>EntityManager</code>就很方便。以主键查询为例：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">User</span> getUserById(long id) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">User</span> <span class=\"keyword\">user</span> = this.em.find(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>, id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">user</span> == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        throw <span class=\"built_in\">new</span> RuntimeException(&quot;User not found by id: &quot; + id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">user</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JPA同样支持Criteria查询，比如我们需要的查询如下：</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> email = ?</span><br></pre></td></tr></table></figure>\n\n<p>使用Criteria查询的代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public User fetch<span class=\"constructor\">UserByEmail(String <span class=\"params\">email</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// CriteriaBuilder:</span></span><br><span class=\"line\">    var cb = em.get<span class=\"constructor\">CriteriaBuilder()</span>;</span><br><span class=\"line\">    CriteriaQuery&lt;User&gt; q = cb.create<span class=\"constructor\">Query(User.<span class=\"params\">class</span>)</span>;</span><br><span class=\"line\">    Root&lt;User&gt; r = q.from(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">User</span>.</span></span><span class=\"keyword\">class</span>);</span><br><span class=\"line\">    q.where(cb.equal(r.get(<span class=\"string\">&quot;email&quot;</span>), cb.parameter(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span><span class=\"keyword\">class</span>, <span class=\"string\">&quot;e&quot;</span>)));</span><br><span class=\"line\">    TypedQuery&lt;User&gt; query = em.create<span class=\"constructor\">Query(<span class=\"params\">q</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 绑定参数:</span></span><br><span class=\"line\">    query.set<span class=\"constructor\">Parameter(<span class=\"string\">&quot;e&quot;</span>, <span class=\"params\">email</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 执行查询:</span></span><br><span class=\"line\">    List&lt;User&gt; <span class=\"built_in\">list</span> = query.get<span class=\"constructor\">ResultList()</span>;</span><br><span class=\"line\">    return <span class=\"built_in\">list</span>.is<span class=\"constructor\">Empty()</span> ? null : <span class=\"built_in\">list</span>.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个简单的查询用Criteria写出来就像上面那样复杂，太恐怖了，如果条件多加几个，这种写法谁读得懂？</p>\n<p>所以，正常人还是建议写JPQL查询，它的语法和HQL基本差不多：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public User get<span class=\"constructor\">UserByEmail(String <span class=\"params\">email</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// JPQL查询:</span></span><br><span class=\"line\">    TypedQuery&lt;User&gt; query = em.create<span class=\"constructor\">Query(<span class=\"string\">&quot;SELECT u FROM User u WHERE u.email = :e&quot;</span>, User.<span class=\"params\">class</span>)</span>;</span><br><span class=\"line\">    query.set<span class=\"constructor\">Parameter(<span class=\"string\">&quot;e&quot;</span>, <span class=\"params\">email</span>)</span>;</span><br><span class=\"line\">    List&lt;User&gt; <span class=\"built_in\">list</span> = query.get<span class=\"constructor\">ResultList()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">list</span>.is<span class=\"constructor\">Empty()</span>) &#123;</span><br><span class=\"line\">        throw <span class=\"keyword\">new</span> <span class=\"constructor\">RuntimeException(<span class=\"string\">&quot;User not found by email.&quot;</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return <span class=\"built_in\">list</span>.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的，JPA也支持NamedQuery，即先给查询起个名字，再按名字创建查询：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">User</span> <span class=\"keyword\">login</span>(String email, String <span class=\"keyword\">password</span>) &#123;</span><br><span class=\"line\">    TypedQuery&lt;<span class=\"keyword\">User</span>&gt; query = em.createNamedQuery(&quot;login&quot;, <span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>);</span><br><span class=\"line\">    query.setParameter(&quot;e&quot;, email);</span><br><span class=\"line\">    query.setParameter(&quot;p&quot;, <span class=\"keyword\">password</span>);</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">User</span>&gt; list = query.getResultList();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.isEmpty() ? <span class=\"keyword\">null</span> : list.<span class=\"keyword\">get</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>NamedQuery通过注解标注在<code>User</code>类上，它的定义和上一节的<code>User</code>类一样：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@NamedQueries</span>(</span><br><span class=\"line\">    <span class=\"variable\">@NamedQuery</span>(</span><br><span class=\"line\">        name = <span class=\"string\">&quot;login&quot;</span>,</span><br><span class=\"line\">        query = <span class=\"string\">&quot;SELECT u FROM User u WHERE u.email=:e AND u.password=:p&quot;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"variable\">@Entity</span></span><br><span class=\"line\">public class User &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对数据库进行增删改的操作，可以分别使用<code>persist()</code>、<code>remove()</code>和<code>merge()</code>方法，参数均为Entity Bean本身，使用非常简单，这里不再多述。</p>\n<h2 id=\"4-6-集成MyBatis\"><a href=\"#4-6-集成MyBatis\" class=\"headerlink\" title=\"4.6 集成MyBatis\"></a>4.6 集成MyBatis</h2><p>使用Hibernate或JPA操作数据库时，这类ORM干的主要工作就是把ResultSet的每一行变成Java Bean，或者把Java Bean自动转换到INSERT或UPDATE语句的参数中，从而实现ORM。</p>\n<p>而ORM框架之所以知道如何把行数据映射到Java Bean，是因为我们在Java Bean的属性上给了足够的注解作为元数据，ORM框架获取Java Bean的注解后，就知道如何进行双向映射。</p>\n<p>那么，ORM框架是如何跟踪Java Bean的修改，以便在<code>update()</code>操作中更新必要的属性？</p>\n<p>答案是使用<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017\">Proxy模式</a>，从ORM框架读取的User实例实际上并不是User类，而是代理类，代理类继承自User类，但针对每个setter方法做了覆写：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    boolean _isNameChanged;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(<span class=\"type\">String</span> name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(name);</span><br><span class=\"line\">        _isNameChanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，代理类可以跟踪到每个属性的变化。</p>\n<p>针对一对多或多对一关系时，代理类可以直接通过getter方法查询数据库：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Session</span> _session;</span><br><span class=\"line\">    boolean _isNameChanged;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void setName(<span class=\"type\">String</span> name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(name);</span><br><span class=\"line\">        _isNameChanged = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取User对象关联的Address对象:</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    public <span class=\"type\">Address</span> getAddress() &#123;</span><br><span class=\"line\">        <span class=\"type\">Query</span> q = _session.createQuery(<span class=\"string\">&quot;from Address where userId = :userId&quot;</span>);</span><br><span class=\"line\">        q.setParameter(<span class=\"string\">&quot;userId&quot;</span>, <span class=\"keyword\">this</span>.getId());</span><br><span class=\"line\">        <span class=\"type\">List</span>&lt;<span class=\"type\">Address</span>&gt; list = query.list();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.isEmpty() ? <span class=\"literal\">null</span> : list(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了实现这样的查询，UserProxy必须保存Hibernate的当前Session。但是，当事务提交后，Session自动关闭，此时再获取<code>getAddress()</code>将无法访问数据库，或者获取的不是事务一致的数据。因此，ORM框架总是引入了Attached&#x2F;Detached状态，表示当前此Java Bean到底是在Session的范围内，还是脱离了Session变成了一个“游离”对象。很多初学者无法正确理解状态变化和事务边界，就会造成大量的<code>PersistentObjectException</code>异常。这种隐式状态使得普通Java Bean的生命周期变得复杂。</p>\n<p>此外，Hibernate和JPA为了实现兼容多种数据库，它使用HQL或JPQL查询，经过一道转换，变成特定数据库的SQL，理论上这样可以做到无缝切换数据库，但这一层自动转换除了少许的性能开销外，给SQL级别的优化带来了麻烦。</p>\n<p>最后，ORM框架通常提供了缓存，并且还分为一级缓存和二级缓存。一级缓存是指在一个Session范围内的缓存，常见的情景是根据主键查询时，两次查询可以返回同一实例：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">User</span> user1 = <span class=\"keyword\">session</span>.<span class=\"keyword\">load</span>(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\"><span class=\"keyword\">User</span> user2 = <span class=\"keyword\">session</span>.<span class=\"keyword\">load</span>(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>, <span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p>二级缓存是指跨Session的缓存，一般默认关闭，需要手动配置。二级缓存极大的增加了数据的不一致性，原因在于SQL非常灵活，常常会导致意外的更新。例如：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 线程1读取:</span></span><br><span class=\"line\">User user1 = session1.load(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">User</span>.</span></span><span class=\"keyword\">class</span>, <span class=\"number\">123</span>);<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">...</span></span><br><span class=\"line\"><span class=\"operator\"></span><span class=\"comment\">// 一段时间后，线程2读取:</span></span><br><span class=\"line\">User user2 = session2.load(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">User</span>.</span></span><span class=\"keyword\">class</span>, <span class=\"number\">123</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当二级缓存生效的时候，两个线程读取的User实例是一样的，但是，数据库对应的行记录完全可能被修改，例如：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 给老用户增加100积分:</span></span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> users <span class=\"keyword\">SET</span> bonus = bonus + <span class=\"number\">100</span> <span class=\"keyword\">WHERE</span> createdAt &lt;= ?</span><br></pre></td></tr></table></figure>\n\n<p>ORM无法判断<code>id=123</code>的用户是否受该<code>UPDATE</code>语句影响。考虑到数据库通常会支持多个应用程序，此UPDATE语句可能由其他进程执行，ORM框架就更不知道了。</p>\n<p>我们把这种ORM框架称之为全自动ORM框架。</p>\n<p>对比Spring提供的JdbcTemplate，它和ORM框架相比，主要有几点差别：</p>\n<ol>\n<li>查询后需要手动提供Mapper实例以便把ResultSet的每一行变为Java对象；</li>\n<li>增删改操作所需的参数列表，需要手动传入，即把User实例变为[user.id, user.name, user.email]这样的列表，比较麻烦。</li>\n</ol>\n<p>但是JdbcTemplate的优势在于它的确定性：即每次读取操作一定是数据库操作而不是缓存，所执行的SQL是完全确定的，缺点就是代码比较繁琐，构造<code>INSERT INTO users VALUES (?,?,?)</code>更是复杂。</p>\n<p>所以，介于全自动ORM如Hibernate和手写全部如JdbcTemplate之间，还有一种半自动的ORM，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。<a href=\"https://mybatis.org/\">MyBatis</a>就是这样一种半自动化ORM框架。</p>\n<p>我们来看看如何在Spring中集成MyBatis。</p>\n<p>首先，我们要引入MyBatis本身，其次，由于Spring并没有像Hibernate那样内置对MyBatis的集成，所以，我们需要再引入MyBatis官方自己开发的一个与Spring集成的库：</p>\n<ul>\n<li>org.mybatis:mybatis:3.5.4</li>\n<li>org.mybatis:mybatis-spring:2.0.4</li>\n</ul>\n<p>和前面一样，先创建<code>DataSource</code>是必不可少的：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(<span class=\"string\">&quot;jdbc.properties&quot;</span>)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    DataSource createDataSource() &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再回顾一下Hibernate和JPA的<code>SessionFactory</code>与<code>EntityManagerFactory</code>，MyBatis与之对应的是<code>SqlSessionFactory</code>和<code>SqlSession</code>：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">JDBC</th>\n<th align=\"left\">Hibernate</th>\n<th align=\"left\">JPA</th>\n<th align=\"left\">MyBatis</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">DataSource</td>\n<td align=\"left\">SessionFactory</td>\n<td align=\"left\">EntityManagerFactory</td>\n<td align=\"left\">SqlSessionFactory</td>\n</tr>\n<tr>\n<td align=\"left\">Connection</td>\n<td align=\"left\">Session</td>\n<td align=\"left\">EntityManager</td>\n<td align=\"left\">SqlSession</td>\n</tr>\n</tbody></table>\n<p>可见，ORM的设计套路都是类似的。使用MyBatis的核心就是创建<code>SqlSessionFactory</code>，这里我们需要创建的是<code>SqlSessionFactoryBean</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">SqlSessionFactoryBean <span class=\"function\"><span class=\"title\">createSqlSessionFactoryBean</span>(<span class=\"params\"><span class=\"meta\">@Autowired</span> DataSource dataSource</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sqlSessionFactoryBean = <span class=\"keyword\">new</span> SqlSessionFactoryBean();</span><br><span class=\"line\">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sqlSessionFactoryBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为MyBatis可以直接使用Spring管理的声明式事务，因此，创建事务管理器和使用JDBC是一样的：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Bean</span></span><br><span class=\"line\">PlatformTransactionManager createTxManager(<span class=\"variable\">@Autowired</span> DataSource dataSource) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">DataSourceTransactionManager</span>(dataSource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>和Hibernate不同的是，MyBatis使用Mapper来实现映射，而且Mapper必须是接口。我们以User类为例，在User类和users表之间映射的UserMapper编写如下：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">public</span> <span class=\"selector-tag\">interface</span> <span class=\"selector-tag\">UserMapper</span> &#123;</span><br><span class=\"line\">\t<span class=\"variable\">@Select</span>(<span class=\"string\">&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;</span>)</span><br><span class=\"line\">\tUser getById(<span class=\"variable\">@Param</span>(<span class=\"string\">&quot;id&quot;</span>) long id);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：这里的Mapper不是JdbcTemplate的RowMapper的概念，它是定义访问users表的接口方法。比如我们定义了一个<code>User getById(long)</code>的主键查询方法，不仅要定义接口方法本身，还要明确写出查询的SQL，这里用注解<code>@Select</code>标记。SQL语句的任何参数，都与方法参数按名称对应。例如，方法参数id的名字通过注解<code>@Param()</code>标记为<code>id</code>，则SQL语句里将来替换的占位符就是<code>#&#123;id&#125;</code>。</p>\n<p>如果有多个参数，那么每个参数命名后直接在SQL中写出对应的占位符即可：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Select</span>(<span class=\"string\">&quot;SELECT * FROM users LIMIT #&#123;offset&#125;, #&#123;maxResults&#125;&quot;</span>)</span><br><span class=\"line\">List&lt;User&gt; getAll(<span class=\"variable\">@Param</span>(<span class=\"string\">&quot;offset&quot;</span>) int offset, <span class=\"variable\">@Param</span>(<span class=\"string\">&quot;maxResults&quot;</span>) int maxResults);</span><br></pre></td></tr></table></figure>\n\n<p>注意：MyBatis执行查询后，将根据方法的返回类型自动把ResultSet的每一行转换为User实例，转换规则当然是按列名和属性名对应。如果列名和属性名不同，最简单的方式是编写SELECT语句的别名：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 列名是created_time，属性名是createdAt:</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> id, <span class=\"type\">name</span>, email, created_time <span class=\"keyword\">AS</span> createdAt <span class=\"keyword\">FROM</span> users</span><br></pre></td></tr></table></figure>\n\n<p>执行INSERT语句就稍微麻烦点，因为我们希望传入User实例，因此，定义的方法接口与<code>@Insert</code>注解如下：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Insert</span>(<span class=\"string\">&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;</span>)</span><br><span class=\"line\">void insert(<span class=\"variable\">@Param</span>(<span class=\"string\">&quot;user&quot;</span>) User user);</span><br></pre></td></tr></table></figure>\n\n<p>上述方法传入的参数名称是<code>user</code>，参数类型是User类，在SQL中引用的时候，以<code>#&#123;obj.property&#125;</code>的方式写占位符。和Hibernate这样的全自动化ORM相比，MyBatis必须写出完整的INSERT语句。</p>\n<p>如果<code>users</code>表的id是自增主键，那么，我们在SQL中不传入id，但希望获取插入后的主键，需要再加一个<code>@Options</code>注解：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Options</span>(useGeneratedKeys = true, keyProperty = <span class=\"string\">&quot;id&quot;</span>, keyColumn = <span class=\"string\">&quot;id&quot;</span>)</span><br><span class=\"line\"><span class=\"variable\">@Insert</span>(<span class=\"string\">&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;</span>)</span><br><span class=\"line\">void insert(<span class=\"variable\">@Param</span>(<span class=\"string\">&quot;user&quot;</span>) User user);</span><br></pre></td></tr></table></figure>\n\n<p><code>keyProperty</code>和<code>keyColumn</code>分别指出JavaBean的属性和数据库的主键列名。</p>\n<p>执行UPDATE和DELETE语句相对比较简单，我们定义方法如下：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Update</span>(<span class=\"string\">&quot;UPDATE users SET name = #&#123;user.name&#125;, createdAt = #&#123;user.createdAt&#125; WHERE id = #&#123;user.id&#125;&quot;</span>)</span><br><span class=\"line\">void update(<span class=\"variable\">@Param</span>(<span class=\"string\">&quot;user&quot;</span>) User user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">@Delete</span>(<span class=\"string\">&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;</span>)</span><br><span class=\"line\">void deleteById(<span class=\"variable\">@Param</span>(<span class=\"string\">&quot;id&quot;</span>) long id);</span><br></pre></td></tr></table></figure>\n\n<p>有了<code>UserMapper</code>接口，还需要对应的实现类才能真正执行这些数据库操作的方法。虽然可以自己写实现类，但我们除了编写<code>UserMapper</code>接口外，还有<code>BookMapper</code>、<code>BonusMapper</code>……一个一个写太麻烦，因此，MyBatis提供了一个<code>MapperFactoryBean</code>来自动创建所有Mapper的实现类。可以用一个简单的注解来启用它：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@MapperScan(&quot;com.itranswarp.learnjava.mapper&quot;)</span></span><br><span class=\"line\">...其他注解...</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppConfig</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了<code>@MapperScan</code>，就可以让MyBatis自动扫描指定包的所有Mapper并创建实现类。在真正的业务逻辑中，我们可以直接注入：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注入UserMapper:</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    UserMapper userMapper;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUserById</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 调用Mapper方法:</span></span><br><span class=\"line\">        User user = userMapper.getById(id);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (user == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;User not found by id.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，业务逻辑主要就是通过<code>XxxMapper</code>定义的数据库方法来访问数据库。</p>\n<h3 id=\"XML配置\"><a href=\"#XML配置\" class=\"headerlink\" title=\"XML配置\"></a>XML配置</h3><p>上述在Spring中集成MyBatis的方式，我们只需要用到注解，并没有任何XML配置文件。MyBatis也允许使用XML配置映射关系和SQL语句，例如，更新<code>User</code>时根据属性值构造动态SQL：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"keyword\">update</span> id=&quot;updateUser&quot;&gt;</span><br><span class=\"line\">  <span class=\"keyword\">UPDATE</span> users <span class=\"keyword\">SET</span></span><br><span class=\"line\">  &lt;<span class=\"keyword\">set</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">if</span> test=&quot;user.name != null&quot;&gt; <span class=\"type\">name</span> = #&#123;<span class=\"keyword\">user</span>.name&#125; &lt;/<span class=\"keyword\">if</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">if</span> test=&quot;user.hobby != null&quot;&gt; hobby = #&#123;<span class=\"keyword\">user</span>.hobby&#125; &lt;/<span class=\"keyword\">if</span>&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">if</span> test=&quot;user.summary != null&quot;&gt; <span class=\"keyword\">summary</span> = #&#123;<span class=\"keyword\">user</span>.<span class=\"keyword\">summary</span>&#125; &lt;/<span class=\"keyword\">if</span>&gt;</span><br><span class=\"line\">  &lt;/<span class=\"keyword\">set</span>&gt;</span><br><span class=\"line\">  <span class=\"keyword\">WHERE</span> id = #&#123;<span class=\"keyword\">user</span>.id&#125;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">update</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>编写XML配置的优点是可以组装出动态SQL，并且把所有SQL操作集中在一起。缺点是配置起来太繁琐，调用方法时如果想查看SQL还需要定位到XML配置中。这里我们不介绍XML的配置方式，需要了解的童鞋请自行阅读<a href=\"https://mybatis.org/mybatis-3/zh/configuration.html\">官方文档</a>。</p>\n<p>使用MyBatis最大的问题是所有SQL都需要全部手写，优点是执行的SQL就是我们自己写的SQL，对SQL进行优化非常简单，也可以编写任意复杂的SQL，或者使用数据库的特定语法，但切换数据库可能就不太容易。好消息是大部分项目并没有切换数据库的需求，完全可以针对某个数据库编写尽可能优化的SQL。</p>\n<h2 id=\"4-7-设计ORM\"><a href=\"#4-7-设计ORM\" class=\"headerlink\" title=\"4.7 设计ORM\"></a>4.7 设计ORM</h2><p>我们从前几节可以看到，所谓ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。</p>\n<p>而查询是涉及到数据库使用最广泛的操作，需要最大的灵活性。各种ORM解决方案各不相同，Hibernate和JPA自己实现了HQL和JPQL查询语法，用以生成最终的SQL，而MyBatis则完全手写，每增加一个查询都需要先编写SQL并增加接口方法。</p>\n<p>还有一种Hibernate和JPA支持的Criteria查询，用Hibernate写出来类似：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DetachedCriteria criteria = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DetachedCriteria</span>.</span></span><span class=\"keyword\">for</span><span class=\"constructor\">Class(User.<span class=\"params\">class</span>)</span>;</span><br><span class=\"line\">criteria.add(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Restrictions</span>.</span></span>eq(<span class=\"string\">&quot;email&quot;</span>, email))</span><br><span class=\"line\">        .add(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Restrictions</span>.</span></span>eq(<span class=\"string\">&quot;password&quot;</span>, password));</span><br><span class=\"line\">List&lt;User&gt; <span class=\"built_in\">list</span> = (List&lt;User&gt;) hibernateTemplate.find<span class=\"constructor\">ByCriteria(<span class=\"params\">criteria</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上述Criteria查询写法复杂，但和JPA相比，还是小巫见大巫了：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">var cb = em.get<span class=\"constructor\">CriteriaBuilder()</span>;</span><br><span class=\"line\">CriteriaQuery&lt;User&gt; q = cb.create<span class=\"constructor\">Query(User.<span class=\"params\">class</span>)</span>;</span><br><span class=\"line\">Root&lt;User&gt; r = q.from(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">User</span>.</span></span><span class=\"keyword\">class</span>);</span><br><span class=\"line\">q.where(cb.equal(r.get(<span class=\"string\">&quot;email&quot;</span>), cb.parameter(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span><span class=\"keyword\">class</span>, <span class=\"string\">&quot;e&quot;</span>)));</span><br><span class=\"line\">TypedQuery&lt;User&gt; query = em.create<span class=\"constructor\">Query(<span class=\"params\">q</span>)</span>;</span><br><span class=\"line\">query.set<span class=\"constructor\">Parameter(<span class=\"string\">&quot;e&quot;</span>, <span class=\"params\">email</span>)</span>;</span><br><span class=\"line\">List&lt;User&gt; <span class=\"built_in\">list</span> = query.get<span class=\"constructor\">ResultList()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>此外，是否支持自动读取一对多和多对一关系也是全自动化ORM框架的一个重要功能。</p>\n<p>如果我们自己来设计并实现一个ORM，应该吸取这些ORM的哪些特色，然后高效实现呢？</p>\n<h3 id=\"设计ORM接口\"><a href=\"#设计ORM接口\" class=\"headerlink\" title=\"设计ORM接口\"></a>设计ORM接口</h3><p>任何设计，都必须明确设计目标。这里我们准备实现的ORM并不想要全自动ORM那种自动读取一对多和多对一关系的功能，也不想给Entity加上复杂的状态，因此，对于Entity来说，它就是纯粹的JavaBean，没有任何Proxy。</p>\n<p>此外，ORM要兼顾易用性和适用性。易用性是指能覆盖95%的应用场景，但总有一些复杂的SQL，很难用ORM去自动生成，因此，也要给出原生的JDBC接口，能支持5%的特殊需求。</p>\n<p>最后，我们希望设计的接口要易于编写，并使用流式API便于阅读。为了配合编译器检查，还应该支持泛型，避免强制转型。</p>\n<p>以User类为例，我们设计的查询接口如下：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 按主键查询: <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> id = ?</span><br><span class=\"line\"><span class=\"keyword\">User</span> u = db.<span class=\"keyword\">get</span>(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>, <span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">// 条件查询唯一记录: <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> email = ? <span class=\"keyword\">AND</span> <span class=\"keyword\">password</span> = ?</span><br><span class=\"line\"><span class=\"keyword\">User</span> u = db.<span class=\"keyword\">from</span>(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>)</span><br><span class=\"line\">           .<span class=\"keyword\">where</span>(&quot;email=? AND password=?&quot;, &quot;bob@example.com&quot;, &quot;bob123&quot;)</span><br><span class=\"line\">           .<span class=\"keyword\">unique</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">// 条件查询多条记录: <span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> id &lt; ? <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> email <span class=\"keyword\">LIMIT</span> ?, ?</span><br><span class=\"line\">List&lt;<span class=\"keyword\">User</span>&gt; us = db.<span class=\"keyword\">from</span>(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>)</span><br><span class=\"line\">                  .<span class=\"keyword\">where</span>(&quot;id &lt; ?&quot;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">                  .orderBy(&quot;email&quot;)</span><br><span class=\"line\">                  .<span class=\"keyword\">limit</span>(<span class=\"number\">0</span>, <span class=\"number\">10</span>)</span><br><span class=\"line\">                  .list();</span><br><span class=\"line\"></span><br><span class=\"line\">// 查询特定列: <span class=\"keyword\">SELECT</span> id, <span class=\"type\">name</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> email = ?</span><br><span class=\"line\"><span class=\"keyword\">User</span> u = db.<span class=\"keyword\">select</span>(&quot;id&quot;, &quot;name&quot;)</span><br><span class=\"line\">           .<span class=\"keyword\">from</span>(<span class=\"keyword\">User</span>.<span class=\"keyword\">class</span>)</span><br><span class=\"line\">           .<span class=\"keyword\">where</span>(&quot;email = ?&quot;, &quot;bob@example.com&quot;)</span><br><span class=\"line\">           .<span class=\"keyword\">unique</span>();</span><br></pre></td></tr></table></figure>\n\n<p>这样的流式API便于阅读，也非常容易推导出最终生成的SQL。</p>\n<p>对于插入、更新和删除操作，就相对比较简单：</p>\n<figure class=\"highlight stata\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 插入User:</span></span><br><span class=\"line\"><span class=\"keyword\">db</span>.insert(user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按主键更新更新User:</span></span><br><span class=\"line\"><span class=\"keyword\">db</span>.<span class=\"keyword\">update</span>(user);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按主键删除User:</span></span><br><span class=\"line\"><span class=\"keyword\">db</span>.delete(User.<span class=\"keyword\">class</span>, 123);</span><br></pre></td></tr></table></figure>\n\n<p>对于Entity来说，通常一个表对应一个。手动列出所有Entity是非常麻烦的，一定要传入package自动扫描。</p>\n<p>最后，ORM总是需要元数据才能知道如何映射。我们不想编写复杂的XML配置，也没必要自己去定义一套规则，直接使用JPA的注解就行。</p>\n<h3 id=\"实现ORM\"><a href=\"#实现ORM\" class=\"headerlink\" title=\"实现ORM\"></a>实现ORM</h3><p>我们并不需要从JDBC底层开始编写，并且，还要考虑到事务，最好能直接使用Spring的声明式事务。实际上，我们可以设计一个全局<code>DbTemplate</code>，它注入了Spring的<code>JdbcTemplate</code>，涉及到数据库操作时，全部通过<code>JdbcTemplate</code>完成，自然天生支持Spring的声明式事务，因为这个ORM只是在<code>JdbcTemplate</code>的基础上做了一层封装。</p>\n<p>在<code>AppConfig</code>中，我们初始化所有Bean如下：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(<span class=\"string\">&quot;jdbc.properties&quot;</span>)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    DataSource createDataSource() &#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@Bean</span></span><br><span class=\"line\">    JdbcTemplate createJdbcTemplate(<span class=\"variable\">@Autowired</span> DataSource dataSource) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">JdbcTemplate</span>(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"selector-tag\">Bean</span></span><br><span class=\"line\">    <span class=\"selector-tag\">DbTemplate</span> <span class=\"selector-tag\">createDbTemplate</span>(<span class=\"variable\">@Autowired</span> JdbcTemplate jdbcTemplate) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">DbTemplate</span>(jdbcTemplate, <span class=\"string\">&quot;com.itranswarp.learnjava.entity&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"selector-tag\">Bean</span></span><br><span class=\"line\">    <span class=\"selector-tag\">PlatformTransactionManager</span> <span class=\"selector-tag\">createTxManager</span>(<span class=\"variable\">@Autowired</span> DataSource dataSource) &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">DataSourceTransactionManager</span>(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以上就是我们所需的所有配置。</p>\n<p>编写业务逻辑，例如<code>UserService</code>，写出来像这样：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public <span class=\"keyword\">class</span> UserService &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    DbTemplate db;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User get<span class=\"constructor\">UserById(<span class=\"params\">long</span> <span class=\"params\">id</span>)</span> &#123;</span><br><span class=\"line\">        return db.get(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">User</span>.</span></span><span class=\"keyword\">class</span>, id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User get<span class=\"constructor\">UserByEmail(String <span class=\"params\">email</span>)</span> &#123;</span><br><span class=\"line\">        return db.from(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">User</span>.</span></span><span class=\"keyword\">class</span>)</span><br><span class=\"line\">                 .where(<span class=\"string\">&quot;email = ?&quot;</span>, email)</span><br><span class=\"line\">                 .unique<span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public List&lt;User&gt; get<span class=\"constructor\">Users(<span class=\"params\">int</span> <span class=\"params\">pageIndex</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> pageSize = <span class=\"number\">100</span>;</span><br><span class=\"line\">        return db.from(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">User</span>.</span></span><span class=\"keyword\">class</span>)</span><br><span class=\"line\">                 .order<span class=\"constructor\">By(<span class=\"string\">&quot;id&quot;</span>)</span></span><br><span class=\"line\">                 .limit((pageIndex - <span class=\"number\">1</span>)<span class=\"operator\"> * </span>pageSize, pageSize)</span><br><span class=\"line\">                 .<span class=\"built_in\">list</span><span class=\"literal\">()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public User register(String email, String password, String name) &#123;</span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> <span class=\"constructor\">User()</span>;</span><br><span class=\"line\">        user.set<span class=\"constructor\">Email(<span class=\"params\">email</span>)</span>;</span><br><span class=\"line\">        user.set<span class=\"constructor\">Password(<span class=\"params\">password</span>)</span>;</span><br><span class=\"line\">        user.set<span class=\"constructor\">Name(<span class=\"params\">name</span>)</span>;</span><br><span class=\"line\">        user.set<span class=\"constructor\">CreatedAt(System.<span class=\"params\">currentTimeMillis</span>()</span>);</span><br><span class=\"line\">        db.insert(user);</span><br><span class=\"line\">        return user;</span><br><span class=\"line\">    &#125;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码给出了ORM的接口，以及如何在业务逻辑中使用ORM。下一步，就是如何实现这个<code>DbTemplate</code>。这里我们只给出框架代码，有兴趣的童鞋可以自己实现核心代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DbTemplate</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 保存Entity Class到Mapper的映射:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">Map</span>&lt;Class&lt;?&gt;, Mapper&lt;?&gt;&gt; classMapping;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"function\"><span class=\"title\">fetch</span>(<span class=\"params\">Class&lt;T&gt; clazz, <span class=\"built_in\">Object</span> id</span>)</span> &#123;</span><br><span class=\"line\">        Mapper&lt;T&gt; mapper = getMapper(clazz);</span><br><span class=\"line\">        List&lt;T&gt; list = (List&lt;T&gt;) jdbcTemplate.query(mapper.selectSQL, <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>[] &#123; id &#125;, mapper.rowMapper);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (list.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; T <span class=\"function\"><span class=\"title\">get</span>(<span class=\"params\">Class&lt;T&gt; clazz, <span class=\"built_in\">Object</span> id</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">insert</span>(<span class=\"params\">T bean</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">update</span>(<span class=\"params\">T bean</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">delete</span>(<span class=\"params\">Class&lt;T&gt; clazz, <span class=\"built_in\">Object</span> id</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现链式API的核心代码是第一步从<code>DbTemplate</code>调用<code>select()</code>或<code>from()</code>时实例化一个<code>CriteriaQuery</code>实例，并在后续的链式调用中设置它的字段：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DbTemplate</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Select select(<span class=\"keyword\">String</span>... selectFields) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">Select</span>(<span class=\"keyword\">new</span> <span class=\"type\">Criteria</span>(<span class=\"built_in\">this</span>), selectFields);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> &lt;T&gt; From&lt;T&gt; from(Class&lt;T&gt; entityClass) &#123;</span><br><span class=\"line\">        Mapper&lt;T&gt; mapper = getMapper(entityClass);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">From</span>&lt;&gt;(<span class=\"keyword\">new</span> <span class=\"type\">Criteria</span>&lt;&gt;(<span class=\"built_in\">this</span>), mapper);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后以此定义<code>Select</code>、<code>From</code>、<code>Where</code>、<code>OrderBy</code>、<code>Limit</code>等。在<code>From</code>中可以设置Class类型、表名等：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">From&lt;T&gt;</span> <span class=\"keyword\">extends</span> <span class=\"title\">CriteriaQuery&lt;T&gt;</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">From</span>(<span class=\"type\">Criteria</span>&lt;<span class=\"type\">T</span>&gt; criteria, <span class=\"type\">Mapper</span>&lt;<span class=\"type\">T</span>&gt; mapper) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(criteria);</span><br><span class=\"line\">        <span class=\"comment\">// from可以设置class、tableName:</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.criteria.mapper = mapper;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.criteria.clazz = mapper.entityClass;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.criteria.table = mapper.tableName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"type\">Where</span>&lt;<span class=\"type\">T</span>&gt; where(<span class=\"type\">String</span> clause, <span class=\"type\">Object</span>... args) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">Where</span>&lt;&gt;(<span class=\"keyword\">this</span>.criteria, clause, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>Where</code>中可以设置条件参数：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Where&lt;T&gt;</span> <span class=\"keyword\">extends</span> <span class=\"title\">CriteriaQuery&lt;T&gt;</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Where</span>(<span class=\"type\">Criteria</span>&lt;<span class=\"type\">T</span>&gt; criteria, <span class=\"type\">String</span> clause, <span class=\"type\">Object</span>... params) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(criteria);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.criteria.where = clause;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.criteria.whereParams = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// add:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">Object</span> param : params) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.criteria.whereParams.add(param);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，链式调用的尽头是调用<code>list()</code>返回一组结果，调用<code>unique()</code>返回唯一结果，调用<code>first()</code>返回首个结果。</p>\n<p>在IDE中，可以非常方便地实现链式调用：</p>\n<p>![warpdb](2.Spring 5.assets&#x2F;0.gif)</p>\n<p>需要复杂查询的时候，总是可以使用<code>JdbcTemplate</code>执行任意复杂的SQL。</p>\n<h1 id=\"5-开发Web应用\"><a href=\"#5-开发Web应用\" class=\"headerlink\" title=\"5. 开发Web应用\"></a>5. 开发Web应用</h1><h2 id=\"5-0-简介\"><a href=\"#5-0-简介\" class=\"headerlink\" title=\"5.0 简介\"></a>5.0 简介</h2><p>在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255945497738400\">Web开发</a>一章中，我们已经详细介绍了JavaEE中Web开发的基础：Servlet。具体地说，有以下几点：</p>\n<ol>\n<li>Servlet规范定义了几种标准组件：Servlet、JSP、Filter和Listener；</li>\n<li>Servlet的标准组件总是运行在Servlet容器中，如Tomcat、Jetty、WebLogic等。</li>\n</ol>\n<p>直接使用Servlet进行Web开发好比直接在JDBC上操作数据库，比较繁琐，更好的方法是在Servlet基础上封装MVC框架，基于MVC开发Web应用，大部分时候，不需要接触Servlet API，开发省时省力。</p>\n<p>我们在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266264917931808\">MVC开发</a>和<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009\">MVC高级开发</a>已经由浅入深地介绍了如何编写MVC框架。当然，自己写的MVC主要是理解原理，要实现一个功能全面的MVC需要大量的工作以及广泛的测试。</p>\n<p>因此，开发Web应用，首先要选择一个优秀的MVC框架。常用的MVC框架有：</p>\n<ul>\n<li><a href=\"https://struts.apache.org/\">Struts</a>：最古老的一个MVC框架，目前版本是2，和1.x有很大的区别；</li>\n<li>WebWork：一个比Struts设计更优秀的MVC框架，但不知道出于什么原因，从2.0开始把自己的代码全部塞给Struts 2了；</li>\n<li><a href=\"https://turbine.apache.org/\">Turbine</a>：一个重度使用Velocity，强调布局的MVC框架；</li>\n<li>其他100+MVC框架……（略）</li>\n</ul>\n<p>Spring虽然都可以集成任何Web框架，但是，Spring本身也开发了一个MVC框架，就叫<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\">Spring MVC</a>。这个MVC框架设计得足够优秀以至于我们已经不想再费劲去集成类似Struts这样的框架了。</p>\n<p>本章我们会详细介绍如何基于Spring MVC开发Web应用。</p>\n<h2 id=\"5-1-使用Spring-MVC\"><a href=\"#5-1-使用Spring-MVC\" class=\"headerlink\" title=\"5.1 使用Spring MVC\"></a>5.1 使用Spring MVC</h2><p>我们在前面介绍<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1255945497738400\">Web开发</a>时已经讲过了Java Web的基础：Servlet容器，以及标准的Servlet组件：</p>\n<ul>\n<li>Servlet：能处理HTTP请求并将HTTP响应返回；</li>\n<li>JSP：一种嵌套Java代码的HTML，将被编译为Servlet；</li>\n<li>Filter：能过滤指定的URL以实现拦截功能；</li>\n<li>Listener：监听指定的事件，如ServletContext、HttpSession的创建和销毁。</li>\n</ul>\n<p>此外，Servlet容器为每个Web应用程序自动创建一个唯一的<code>ServletContext</code>实例，这个实例就代表了Web应用程序本身。</p>\n<p>在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009\">MVC高级开发</a>中，我们手撸了一个MVC框架，接口和Spring MVC类似。如果直接使用Spring MVC，我们写出来的代码类似：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Controller</span></span><br><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\">    <span class=\"variable\">@GetMapping</span>(<span class=\"string\">&quot;/register&quot;</span>)</span><br><span class=\"line\">    public ModelAndView register() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">@PostMapping</span>(<span class=\"string\">&quot;/signin&quot;</span>)</span><br><span class=\"line\">    public ModelAndView signin(<span class=\"variable\">@RequestParam</span>(<span class=\"string\">&quot;email&quot;</span>) String email, <span class=\"variable\">@RequestParam</span>(<span class=\"string\">&quot;password&quot;</span>) String password) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，Spring提供的是一个IoC容器，所有的Bean，包括Controller，都在Spring IoC容器中被初始化，而Servlet容器由JavaEE服务器提供（如Tomcat），Servlet容器对Spring一无所知，他们之间到底依靠什么进行联系，又是以何种顺序初始化的？</p>\n<p>在理解上述问题之前，我们先把基于Spring MVC开发的项目结构搭建起来。首先创建基于Web的Maven工程，引入如下依赖：</p>\n<ul>\n<li>org.springframework:spring-context:5.2.0.RELEASE</li>\n<li>org.springframework:spring-webmvc:5.2.0.RELEASE</li>\n<li>org.springframework:spring-jdbc:5.2.0.RELEASE</li>\n<li>javax.annotation:javax.annotation-api:1.3.2</li>\n<li>io.pebbletemplates:pebble-spring5:3.1.2</li>\n<li>ch.qos.logback:logback-core:1.2.3</li>\n<li>ch.qos.logback:logback-classic:1.2.3</li>\n<li>com.zaxxer:HikariCP:3.4.2</li>\n<li>org.hsqldb:hsqldb:2.5.0</li>\n</ul>\n<p>以及<code>provided</code>依赖：</p>\n<ul>\n<li>org.apache.tomcat.embed:tomcat-embed-core:9.0.26</li>\n<li>org.apache.tomcat.embed:tomcat-embed-jasper:9.0.26</li>\n</ul>\n<p>这个标准的Maven Web工程目录结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring-web-mvc</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    └── main</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        │   └── com</span><br><span class=\"line\">        │       └── itranswarp</span><br><span class=\"line\">        │           └── learnjava</span><br><span class=\"line\">        │               ├── AppConfig.java</span><br><span class=\"line\">        │               ├── DatabaseInitializer.java</span><br><span class=\"line\">        │               ├── entity</span><br><span class=\"line\">        │               │   └── User.java</span><br><span class=\"line\">        │               ├── service</span><br><span class=\"line\">        │               │   └── UserService.java</span><br><span class=\"line\">        │               └── web</span><br><span class=\"line\">        │                   └── UserController.java</span><br><span class=\"line\">        ├── resources</span><br><span class=\"line\">        │   ├── jdbc.properties</span><br><span class=\"line\">        │   └── logback.xml</span><br><span class=\"line\">        └── webapp</span><br><span class=\"line\">            ├── WEB-INF</span><br><span class=\"line\">            │   ├── templates</span><br><span class=\"line\">            │   │   ├── _base.html</span><br><span class=\"line\">            │   │   ├── index.html</span><br><span class=\"line\">            │   │   ├── profile.html</span><br><span class=\"line\">            │   │   ├── register.html</span><br><span class=\"line\">            │   │   └── signin.html</span><br><span class=\"line\">            │   └── web.xml</span><br><span class=\"line\">            └── static</span><br><span class=\"line\">                ├── css</span><br><span class=\"line\">                │   └── bootstrap.css</span><br><span class=\"line\">                └── js</span><br><span class=\"line\">                    └── jquery.js</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>src/main/webapp</code>是标准web目录，<code>WEB-INF</code>存放<code>web.xml</code>，编译的class，第三方jar，以及不允许浏览器直接访问的View模版，<code>static</code>目录存放所有静态文件。</p>\n<p>在<code>src/main/resources</code>目录中存放的是Java程序读取的classpath资源文件，除了JDBC的配置文件<code>jdbc.properties</code>外，我们又新增了一个<code>logback.xml</code>，这是Logback的默认查找的配置文件：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">appender</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;STDOUT&quot;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"xml\">\t\t<span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">layout</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">Pattern</span>&gt;</span>%d</span><span class=\"template-variable\">&#123;yyyy-MM-dd HH:mm:ss&#125;</span><span class=\"xml\"> %-5level %logger</span><span class=\"template-variable\">&#123;36&#125;</span><span class=\"xml\"> - %msg%n<span class=\"tag\">&lt;/<span class=\"name\">Pattern</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">layout</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">appender</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">logger</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;com.itranswarp.learnjava&quot;</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span> <span class=\"attr\">additivity</span>=<span class=\"string\">&quot;false&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;STDOUT&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">logger</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;<span class=\"name\">root</span> <span class=\"attr\">level</span>=<span class=\"string\">&quot;info&quot;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t\t<span class=\"tag\">&lt;<span class=\"name\">appender-ref</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;STDOUT&quot;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">\t<span class=\"tag\">&lt;/<span class=\"name\">root</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>上面给出了一个写入到标准输出的Logback配置，可以基于上述配置添加写入到文件的配置。</p>\n<p>在<code>src/main/java</code>中就是我们编写的Java代码了。</p>\n<h3 id=\"配置Spring-MVC\"><a href=\"#配置Spring-MVC\" class=\"headerlink\" title=\"配置Spring MVC\"></a>配置Spring MVC</h3><p>和普通Spring配置一样，我们编写正常的<code>AppConfig</code>后，只需加上<code>@EnableWebMvc</code>注解，就“激活”了Spring MVC：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableWebMvc</span> <span class=\"comment\">// 启用Spring MVC</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(<span class=\"string\">&quot;classpath:/jdbc.properties&quot;</span>)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了创建<code>DataSource</code>、<code>JdbcTemplate</code>、<code>PlatformTransactionManager</code>外，<code>AppConfig</code>需要额外创建几个用于Spring MVC的Bean：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">WebMvcConfigurer <span class=\"function\"><span class=\"title\">createWebMvcConfigurer</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">WebMvcConfigurer</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">addResourceHandlers</span>(<span class=\"params\">ResourceHandlerRegistry registry</span>)</span> &#123;</span><br><span class=\"line\">            registry.addResourceHandler(<span class=\"string\">&quot;/static/**&quot;</span>).addResourceLocations(<span class=\"string\">&quot;/static/&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>WebMvcConfigurer</code>并不是必须的，但我们在这里创建一个默认的<code>WebMvcConfigurer</code>，只覆写<code>addResourceHandlers()</code>，目的是让Spring MVC自动处理静态文件，并且映射路径为<code>/static/**</code>。</p>\n<p>另一个必须要创建的Bean是<code>ViewResolver</code>，因为Spring MVC允许集成任何模板引擎，使用哪个模板引擎，就实例化一个对应的<code>ViewResolver</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">ViewResolver create<span class=\"constructor\">ViewResolver(@Autowired ServletContext <span class=\"params\">servletContext</span>)</span> &#123;</span><br><span class=\"line\">    PebbleEngine engine = <span class=\"keyword\">new</span> PebbleEngine.<span class=\"constructor\">Builder()</span>.auto<span class=\"constructor\">Escaping(<span class=\"params\">true</span>)</span></span><br><span class=\"line\">            .cache<span class=\"constructor\">Active(<span class=\"params\">false</span>)</span></span><br><span class=\"line\">            .loader(<span class=\"keyword\">new</span> <span class=\"constructor\">ServletLoader(<span class=\"params\">servletContext</span>)</span>)</span><br><span class=\"line\">            .extension(<span class=\"keyword\">new</span> <span class=\"constructor\">SpringExtension()</span>)</span><br><span class=\"line\">            .build<span class=\"literal\">()</span>;</span><br><span class=\"line\">    PebbleViewResolver viewResolver = <span class=\"keyword\">new</span> <span class=\"constructor\">PebbleViewResolver()</span>;</span><br><span class=\"line\">    viewResolver.set<span class=\"constructor\">Prefix(<span class=\"string\">&quot;/WEB-INF/templates/&quot;</span>)</span>;</span><br><span class=\"line\">    viewResolver.set<span class=\"constructor\">Suffix(<span class=\"string\">&quot;&quot;</span>)</span>;</span><br><span class=\"line\">    viewResolver.set<span class=\"constructor\">PebbleEngine(<span class=\"params\">engine</span>)</span>;</span><br><span class=\"line\">    return viewResolver;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>ViewResolver</code>通过指定prefix和suffix来确定如何查找View。上述配置使用Pebble引擎，指定模板文件存放在<code>/WEB-INF/templates/</code>目录下。</p>\n<p>剩下的Bean都是普通的<code>@Component</code>，但Controller必须标记为<code>@Controller</code>，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controller使用@Controller标记而不是@Component:</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 正常使用@Autowired注入:</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 处理一个URL映射:</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">index</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果是普通的Java应用程序，我们通过<code>main()</code>方法可以很简单地创建一个Spring容器的实例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">main</span>(<span class=\"params\"><span class=\"built_in\">String</span>[] args</span>)</span> &#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是问题来了，现在是Web应用程序，而Web应用程序总是由Servlet容器创建，那么，Spring容器应该由谁创建？在什么时候创建？Spring容器中的Controller又是如何通过Servlet调用的？</p>\n<p>在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，我们只介绍一种<em>最简单</em>的启动Spring容器的方式。</p>\n<p>第一步，我们在<code>web.xml</code>中配置Spring MVC提供的<code>DispatcherServlet</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">web-app</span> <span class=\"meta-keyword\">PUBLIC</span></span></span><br><span class=\"line\"><span class=\"meta\"> <span class=\"meta-string\">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\"> <span class=\"meta-string\">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextClass<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>com.itranswarp.learnjava.AppConfig<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">load-on-startup</span>&gt;</span>0<span class=\"tag\">&lt;/<span class=\"name\">load-on-startup</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>dispatcher<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servlet-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>初始化参数<code>contextClass</code>指定使用注解配置的<code>AnnotationConfigWebApplicationContext</code>，配置文件的位置参数<code>contextConfigLocation</code>指向<code>AppConfig</code>的完整类名，最后，把这个Servlet映射到<code>/*</code>，即处理所有URL。</p>\n<p>上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的<code>DispatcherServlet</code>，在<code>DispatcherServlet</code>启动时，它根据配置<code>AppConfig</code>创建了一个类型是WebApplicationContext的IoC容器，完成所有Bean的初始化，并将容器绑到ServletContext上。</p>\n<p>因为<code>DispatcherServlet</code>持有IoC容器，能从IoC容器中获取所有<code>@Controller</code>的Bean，因此，<code>DispatcherServlet</code>接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的<code>ModelAndView</code>决定如何渲染页面。</p>\n<p>最后，我们在<code>AppConfig</code>中通过<code>main()</code>方法启动嵌入式Tomcat：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> void main(<span class=\"keyword\">String</span>[] args) throws Exception &#123;</span><br><span class=\"line\">    Tomcat tomcat = <span class=\"keyword\">new</span> <span class=\"type\">Tomcat</span>();</span><br><span class=\"line\">    tomcat.setPort(Integer.getInteger(<span class=\"string\">&quot;port&quot;</span>, <span class=\"number\">8080</span>));</span><br><span class=\"line\">    tomcat.getConnector();</span><br><span class=\"line\">    Context ctx = tomcat.addWebapp(<span class=\"string\">&quot;&quot;</span>, <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">&quot;src/main/webapp&quot;</span>).getAbsolutePath());</span><br><span class=\"line\">    WebResourceRoot resources = <span class=\"keyword\">new</span> <span class=\"type\">StandardRoot</span>(ctx);</span><br><span class=\"line\">    resources.addPreResources(</span><br><span class=\"line\">            <span class=\"keyword\">new</span> <span class=\"type\">DirResourceSet</span>(resources, <span class=\"string\">&quot;/WEB-INF/classes&quot;</span>, <span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">&quot;target/classes&quot;</span>).getAbsolutePath(), <span class=\"string\">&quot;/&quot;</span>));</span><br><span class=\"line\">    ctx.setResources(resources);</span><br><span class=\"line\">    tomcat.start();</span><br><span class=\"line\">    tomcat.getServer().await();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述Web应用程序就是我们使用Spring MVC时的一个最小启动功能集。由于使用了JDBC和数据库，用户的注册、登录信息会被持久化：</p>\n<p>![spring-mvc](2.Spring 5.assets&#x2F;l.png)</p>\n<h3 id=\"编写Controller\"><a href=\"#编写Controller\" class=\"headerlink\" title=\"编写Controller\"></a>编写Controller</h3><p>有了Web应用程序的最基本的结构，我们的重点就可以放在如何编写Controller上。Spring MVC对Controller没有固定的要求，也不需要实现特定的接口。以UserController为例，编写Controller只需要遵循以下要点：</p>\n<p>总是标记<code>@Controller</code>而不是<code>@Component</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserController</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个方法对应一个HTTP请求路径，用<code>@GetMapping</code>或<code>@PostMapping</code>表示GET或POST请求：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@PostMapping</span>(<span class=\"string\">&quot;/signin&quot;</span>)</span><br><span class=\"line\">public ModelAndView doSignin(</span><br><span class=\"line\">        <span class=\"variable\">@RequestParam</span>(<span class=\"string\">&quot;email&quot;</span>) String email,</span><br><span class=\"line\">        <span class=\"variable\">@RequestParam</span>(<span class=\"string\">&quot;password&quot;</span>) String password,</span><br><span class=\"line\">        HttpSession session) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要接收的HTTP参数以<code>@RequestParam()</code>标注，可以设置默认值。如果方法参数需要传入<code>HttpServletRequest</code>、<code>HttpServletResponse</code>或者<code>HttpSession</code>，直接添加这个类型的参数即可，Spring MVC会自动按类型传入。</p>\n<p>返回的ModelAndView通常包含View的路径和一个Map作为Model，但也可以没有Model，例如：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">ModelAndView</span>(<span class=\"string\">&quot;signin.html&quot;</span>); <span class=\"comment\">// 仅View，没有Model</span></span><br></pre></td></tr></table></figure>\n\n<p>返回重定向时既可以写<code>new ModelAndView(&quot;redirect:/signin&quot;)</code>，也可以直接返回String：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">index</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (...) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;redirect:/signin&quot;</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;redirect:/profile&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果在方法内部直接操作<code>HttpServletResponse</code>发送响应，返回<code>null</code>表示无需进一步处理：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"code\"><pre><span class=\"line\">public ModelAndView download(HttpServletResponse response) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">byte</span>[] data = ...</span><br><span class=\"line\">    response.setContentType(<span class=\"string\">&quot;application/octet-stream&quot;</span>);</span><br><span class=\"line\">    OutputStream <span class=\"built_in\">output</span> = response.getOutputStream();</span><br><span class=\"line\">    <span class=\"built_in\">output</span>.<span class=\"built_in\">write</span>(data);</span><br><span class=\"line\">    <span class=\"built_in\">output</span>.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对URL进行分组，每组对应一个Controller是一种很好的组织形式，并可以在Controller的class定义出添加URL前缀，例如：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Controller</span></span><br><span class=\"line\"><span class=\"variable\">@RequestMapping</span>(<span class=\"string\">&quot;/user&quot;</span>)</span><br><span class=\"line\">public class UserController &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注意实际URL映射是/user/profile</span></span><br><span class=\"line\">    <span class=\"variable\">@GetMapping</span>(<span class=\"string\">&quot;/profile&quot;</span>)</span><br><span class=\"line\">    public ModelAndView profile() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意实际URL映射是/user/changePassword</span></span><br><span class=\"line\">    <span class=\"variable\">@GetMapping</span>(<span class=\"string\">&quot;/changePassword&quot;</span>)</span><br><span class=\"line\">    public ModelAndView changePassword() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际方法的URL映射总是前缀+路径，这种形式还可以有效避免不小心导致的重复的URL映射。</p>\n<p>可见，Spring MVC允许我们编写既简单又灵活的Controller实现。</p>\n<h2 id=\"5-2-使用REST\"><a href=\"#5-2-使用REST\" class=\"headerlink\" title=\"5.2 使用REST\"></a>5.2 使用REST</h2><p>使用Spring MVC开发Web应用程序的主要工作就是编写Controller逻辑。在Web应用中，除了需要使用MVC给用户显示页面外，还有一类API接口，我们称之为REST，通常输入输出都是JSON，便于第三方调用或者使用页面JavaScript与之交互。</p>\n<p>直接在Controller中处理JSON是可以的，因为Spring MVC的<code>@GetMapping</code>和<code>@PostMapping</code>都支持指定输入和输出的格式。如果我们想接收JSON，输出JSON，那么可以这样写：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping</span>(value = <span class=\"string\">&quot;/rest&quot;</span>,</span><br><span class=\"line\">             consumes = <span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class=\"line\">             produces = <span class=\"string\">&quot;application/json;charset=UTF-8&quot;</span>)</span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">rest</span>(<span class=\"params\"><span class=\"meta\">@RequestBody</span> User user</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&#123;\\&quot;restSupport\\&quot;:true&#125;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应的Maven工程需要加入Jackson这个依赖：<code>com.fasterxml.jackson.core:jackson-databind:2.11.0</code></p>\n<p>注意到<code>@PostMapping</code>使用<code>consumes</code>声明能接收的类型，使用<code>produces</code>声明输出的类型，并且额外加了<code>@ResponseBody</code>表示返回的<code>String</code>无需额外处理，直接作为输出内容写入<code>HttpServletResponse</code>。输入的JSON则根据注解<code>@RequestBody</code>直接被Spring反序列化为<code>User</code>这个JavaBean。</p>\n<p>使用curl命令测试一下：</p>\n<figure class=\"highlight node-repl\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -v -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;email&quot;:&quot;bob@example.com&quot;&#125;&#x27; http://localhost:8080/rest      </span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\">POST /rest HTTP/<span class=\"number\">1.1</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\">Host: localhost:<span class=\"number\">8080</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\">User-Agent: curl/<span class=\"number\">7.64</span><span class=\"number\">.1</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\">Accept: *<span class=\"comment\">/*</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\"><span class=\"comment\">Content-Type: application/json</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\"><span class=\"comment\">Content-Length: 27</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span> </span><br><span class=\"line\">&lt; HTTP/1.1 200 </span><br><span class=\"line\">&lt; Content-Type: application/json;charset=utf-8</span><br><span class=\"line\">&lt; Content-Length: 20</span><br><span class=\"line\">&lt; Date: Sun, 10 May 2020 09:56:01 GMT</span><br><span class=\"line\">&lt; </span><br><span class=\"line\">&#123;&quot;restSupport&quot;:true&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出正是我们写入的字符串。</p>\n<p>直接用Spring的Controller配合一大堆注解写REST太麻烦了，因此，Spring还额外提供了一个<code>@RestController</code>注解，使用<code>@RestController</code>替代<code>@Controller</code>后，每个方法自动变成API接口方法。我们还是以实际代码举例，编写<code>ApiController</code>如下：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">&quot;/api&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ApiController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">&quot;/users&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;User&gt; <span class=\"function\"><span class=\"title\">users</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.getUsers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping</span>(<span class=\"string\">&quot;/users/&#123;id&#125;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> User <span class=\"function\"><span class=\"title\">user</span>(<span class=\"params\"><span class=\"meta\">@PathVariable</span>(<span class=\"string\">&quot;id&quot;</span>) long id</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userService.getUserById(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostMapping</span>(<span class=\"string\">&quot;/signin&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt; <span class=\"function\"><span class=\"title\">signin</span>(<span class=\"params\"><span class=\"meta\">@RequestBody</span> SignInRequest signinRequest</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            User user = userService.signin(signinRequest.email, signinRequest.password);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Map</span>.of(<span class=\"string\">&quot;user&quot;</span>, user);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Map</span>.of(<span class=\"string\">&quot;error&quot;</span>, <span class=\"string\">&quot;SIGNIN_FAILED&quot;</span>, <span class=\"string\">&quot;message&quot;</span>, e.getMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SignInRequest</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> email;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写REST接口只需要定义<code>@RestController</code>，然后，每个方法都是一个API接口，输入和输出只要能被Jackson序列化或反序列化为JSON就没有问题。我们用浏览器测试GET请求，可直接显示JSON响应：</p>\n<p>![user-api](2.Spring 5.assets&#x2F;l-16419149374143.png)</p>\n<p>要测试POST请求，可以用curl命令：</p>\n<figure class=\"highlight ada\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -v -H <span class=\"string\">&quot;Content-Type: application/json&quot;</span> -d &#x27;&#123;<span class=\"string\">&quot;email&quot;</span>:<span class=\"string\">&quot;bob@example.com&quot;</span>,<span class=\"string\">&quot;password&quot;</span>:<span class=\"string\">&quot;bob123&quot;</span>&#125;&#x27; http://localhost:<span class=\"number\">8080</span>/api/signin</span><br><span class=\"line\">&gt; POST /api/signin HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">&gt; Host: localhost:<span class=\"number\">8080</span></span><br><span class=\"line\">&gt; User-Agent: curl/<span class=\"number\">7.64</span>.<span class=\"number\">1</span></span><br><span class=\"line\">&gt; <span class=\"keyword\">Accept</span>: */*</span><br><span class=\"line\">&gt; Content-<span class=\"keyword\">Type</span>: application/json</span><br><span class=\"line\">&gt; Content-Length: <span class=\"number\">47</span></span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&lt; HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> </span><br><span class=\"line\">&lt; Content-<span class=\"keyword\">Type</span>: application/json</span><br><span class=\"line\">&lt; Transfer-Encoding: chunked</span><br><span class=\"line\">&lt; Date: Sun, <span class=\"number\">10</span> May <span class=\"number\">2020</span> <span class=\"number\">08</span>:<span class=\"number\">14</span>:<span class=\"number\">13</span> GMT</span><br><span class=\"line\">&lt; </span><br><span class=\"line\">&#123;<span class=\"string\">&quot;user&quot;</span>:&#123;<span class=\"string\">&quot;id&quot;</span>:<span class=\"number\">1</span>,<span class=\"string\">&quot;email&quot;</span>:<span class=\"string\">&quot;bob@example.com&quot;</span>,<span class=\"string\">&quot;password&quot;</span>:<span class=\"string\">&quot;bob123&quot;</span>,<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;Bob&quot;</span>,...</span><br></pre></td></tr></table></figure>\n\n<p>注意观察上述JSON的输出，<code>User</code>能被正确地序列化为JSON，但暴露了<code>password</code>属性，这是我们不期望的。要避免输出<code>password</code>属性，可以把<code>User</code>复制到另一个<code>UserBean</code>对象，该对象只持有必要的属性，但这样做比较繁琐。另一种简单的方法是直接在<code>User</code>的<code>password</code>属性定义处加上<code>@JsonIgnore</code>表示完全忽略该属性：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@JsonIgnore</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getPassword</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是这样一来，如果写一个<code>register(User user)</code>方法，那么该方法的User对象也拿不到注册时用户传入的密码了。如果要允许输入<code>password</code>，但不允许输出<code>password</code>，即在JSON序列化和反序列化时，允许写属性，禁用读属性，可以更精细地控制如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@JsonProperty(access = Access.WRITE_ONLY)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getPassword</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样的，可以使用<code>@JsonProperty(access = Access.READ_ONLY)</code>允许输出，不允许输入。</p>\n<h2 id=\"5-3-集成Filter\"><a href=\"#5-3-集成Filter\" class=\"headerlink\" title=\"5.3 集成Filter\"></a>5.3 集成Filter</h2><p>在Spring MVC中，<code>DispatcherServlet</code>只需要固定配置到<code>web.xml</code>中，剩下的工作主要是专注于编写Controller。</p>\n<p>但是，在Servlet规范中，我们还可以<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1266264823560128\">使用Filter</a>。如果要在Spring MVC中使用<code>Filter</code>，应该怎么做？</p>\n<p>有的童鞋在上一节的Web应用中可能发现了，如果注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，我们可以简单地使用一个EncodingFilter，在全局范围类给<code>HttpServletRequest</code>和<code>HttpServletResponse</code>强制设置为UTF-8编码。</p>\n<p>可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个<code>CharacterEncodingFilter</code>。配置Filter时，只需在<code>web.xml</code>中声明即可：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">web-app</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>encoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>forceEncoding<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>encodingFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为这种Filter和我们业务关系不大，注意到<code>CharacterEncodingFilter</code>其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。</p>\n<p>我们再考虑这样一个问题：如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头<code>Authorization: Basic email:password</code>，这个需求如何实现？</p>\n<p>编写一个<code>AuthFilter</code>是最简单的实现方式：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public <span class=\"keyword\">class</span> AuthFilter implements Filter &#123;</span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void <span class=\"keyword\">do</span><span class=\"constructor\">Filter(ServletRequest <span class=\"params\">request</span>, ServletResponse <span class=\"params\">response</span>, FilterChain <span class=\"params\">chain</span>)</span></span><br><span class=\"line\">            throws IOException, ServletException &#123;</span><br><span class=\"line\">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class=\"line\">        <span class=\"comment\">// 获取Authorization头:</span></span><br><span class=\"line\">        String authHeader = req.get<span class=\"constructor\">Header(<span class=\"string\">&quot;Authorization&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (authHeader != null<span class=\"operator\"> &amp;&amp; </span>authHeader.starts<span class=\"constructor\">With(<span class=\"string\">&quot;Basic &quot;</span>)</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 从Header中提取email和password:</span></span><br><span class=\"line\">            String email = prefix<span class=\"constructor\">From(<span class=\"params\">authHeader</span>)</span>;</span><br><span class=\"line\">            String password = suffix<span class=\"constructor\">From(<span class=\"params\">authHeader</span>)</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 登录:</span></span><br><span class=\"line\">            User user = userService.signin(email, password);</span><br><span class=\"line\">            <span class=\"comment\">// 放入Session:</span></span><br><span class=\"line\">            req.get<span class=\"constructor\">Session()</span>.set<span class=\"constructor\">Attribute(UserController.KEY_USER, <span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 继续处理请求:</span></span><br><span class=\"line\">        chain.<span class=\"keyword\">do</span><span class=\"constructor\">Filter(<span class=\"params\">request</span>, <span class=\"params\">response</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在问题来了：在Spring中创建的这个<code>AuthFilter</code>是一个普通Bean，Servlet容器并不知道，所以它不会起作用。</p>\n<p>如果我们直接在<code>web.xml</code>中声明这个<code>AuthFilter</code>，注意到<code>AuthFilter</code>的实例将由Servlet容器而不是Spring容器初始化，因此，<code>@Autowire</code>根本不生效，用于登录的<code>UserService</code>成员变量永远是<code>null</code>。</p>\n<p>所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的<code>AuthFilter</code>。Spring MVC提供了一个<code>DelegatingFilterProxy</code>，专门来干这个事情：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;web-app&gt;</span><br><span class=\"line\">    &lt;<span class=\"keyword\">filter</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">filter</span>-<span class=\"type\">name</span>&gt;authFilter&lt;/<span class=\"keyword\">filter</span>-<span class=\"type\">name</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">filter</span>-<span class=\"keyword\">class</span>&gt;org.springframework.web.<span class=\"keyword\">filter</span>.DelegatingFilterProxy&lt;/<span class=\"keyword\">filter</span>-<span class=\"keyword\">class</span>&gt;</span><br><span class=\"line\">    &lt;/<span class=\"keyword\">filter</span>&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;<span class=\"keyword\">filter</span>-<span class=\"keyword\">mapping</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">filter</span>-<span class=\"type\">name</span>&gt;authFilter&lt;/<span class=\"keyword\">filter</span>-<span class=\"type\">name</span>&gt;</span><br><span class=\"line\">        &lt;url-pattern&gt;<span class=\"comment\">/*&lt;/url-pattern&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;/filter-mapping&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    ...</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/web-app&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>我们来看实现原理：</p>\n<ol>\n<li>Servlet容器从<code>web.xml</code>中读取配置，实例化<code>DelegatingFilterProxy</code>，注意命名是<code>authFilter</code>；</li>\n<li>Spring容器通过扫描<code>@Component</code>实例化<code>AuthFilter</code>。</li>\n</ol>\n<p>当<code>DelegatingFilterProxy</code>生效后，它会自动查找注册在<code>ServletContext</code>上的Spring容器，再试图从容器中查找名为<code>authFilter</code>的Bean，也就是我们用<code>@Component</code>声明的<code>AuthFilter</code>。</p>\n<p><code>DelegatingFilterProxy</code>将请求代理给<code>AuthFilter</code>，核心代码如下：</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DelegatingFilterProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Filter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Filter <span class=\"keyword\">delegate</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> doFilter(...) throws ... &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">delegate</span> == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delegate</span> = findBeanFromSpringContainer();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delegate</span>.doFilter(req, resp, chain);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这就是一个<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017\">代理模式</a>的简单应用。我们画个图表示它们之间的引用关系如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class=\"line\">  ┌─────────────────────┐        ┌───────────┐   │</span><br><span class=\"line\">│ │DelegatingFilterProxy│─│─│─ ─&gt;│AuthFilter │</span><br><span class=\"line\">  └─────────────────────┘        └───────────┘   │</span><br><span class=\"line\">│ ┌─────────────────────┐ │ │    ┌───────────┐</span><br><span class=\"line\">  │  DispatcherServlet  │─ ─ ─ ─&gt;│Controllers│   │</span><br><span class=\"line\">│ └─────────────────────┘ │ │    └───────────┘</span><br><span class=\"line\">                                                 │</span><br><span class=\"line\">│    Servlet Container    │ │  Spring Container</span><br><span class=\"line\"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>如果在<code>web.xml</code>中配置的Filter名字和Spring容器的Bean的名字不一致，那么需要指定Bean的名字：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>basicAuthFilter<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 指定Bean的名字 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>targetBeanName<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>authFilter<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">init-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>实际应用时，尽量保持名字一致，以减少不必要的配置。</p>\n<p>要使用Basic模式的用户认证，我们可以使用curl命令测试。例如，用户登录名是<code>tom@example.com</code>，口令是<code>tomcat</code>，那么先构造一个使用URL编码的<code>用户名:口令</code>的字符串：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">tom</span>%<span class=\"number\">40</span>example.com:tomcat</span><br></pre></td></tr></table></figure>\n\n<p>对其进行Base64编码，最终构造出的Header如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Authorization</span>: Basic dG<span class=\"number\">9</span>tJTQwZXhhbXBsZS<span class=\"number\">5</span>jb<span class=\"number\">206</span>dG<span class=\"number\">9</span>tY<span class=\"number\">2</span>F<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p>使用如下的<code>curl</code>命令并获得响应如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ curl -v -H &#x27;Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0&#x27; http://localhost:8080/profile</span><br><span class=\"line\">&gt; GET /profile HTTP/1.1</span><br><span class=\"line\">&gt; Host: localhost:8080</span><br><span class=\"line\">&gt; User-Agent: curl/7.64.1</span><br><span class=\"line\">&gt; Accept: */*</span><br><span class=\"line\">&gt; Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0</span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&lt; HTTP/1.1 200 </span><br><span class=\"line\">&lt; Set-Cookie: JSESSIONID=CE0F4BFC394816F717443397D4FEABBE; Path=/; HttpOnly</span><br><span class=\"line\">&lt; Content-Type: text/html;charset=UTF-8</span><br><span class=\"line\">&lt; Content-Language: en-CN</span><br><span class=\"line\">&lt; Transfer-Encoding: chunked</span><br><span class=\"line\">&lt; Date: Wed, 29 Apr 2020 00:15:50 GMT</span><br><span class=\"line\">&lt; </span><br><span class=\"line\"><span class=\"meta\">&lt;!doctype <span class=\"meta-keyword\">html</span>&gt;</span></span><br><span class=\"line\">...HTML输出...</span><br></pre></td></tr></table></figure>\n\n<p>上述响应说明<code>AuthFilter</code>已生效。</p>\n<p> 注意：Basic认证模式并不安全，本节只用来作为使用Filter的示例。</p>\n<h2 id=\"5-4-使用Interceptor\"><a href=\"#5-4-使用Interceptor\" class=\"headerlink\" title=\"5.4 使用Interceptor\"></a>5.4 使用Interceptor</h2><p>在Web程序中，注意到使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">         │   ▲</span><br><span class=\"line\">         ▼   │</span><br><span class=\"line\">       ┌───────┐</span><br><span class=\"line\">       │Filter1│</span><br><span class=\"line\">       └───────┘</span><br><span class=\"line\">         │   ▲</span><br><span class=\"line\">         ▼   │</span><br><span class=\"line\">       ┌───────┐</span><br><span class=\"line\">┌ ─ ─ ─│Filter2│─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">       └───────┘</span><br><span class=\"line\">│        │   ▲                  │</span><br><span class=\"line\">         ▼   │</span><br><span class=\"line\">│ ┌─────────────────┐           │</span><br><span class=\"line\">  │DispatcherServlet│&lt;───┐</span><br><span class=\"line\">│ └─────────────────┘    │      │</span><br><span class=\"line\">   │              ┌────────────┐</span><br><span class=\"line\">│  │              │ModelAndView││</span><br><span class=\"line\">   │              └────────────┘</span><br><span class=\"line\">│  │                     ▲      │</span><br><span class=\"line\">   │    ┌───────────┐    │</span><br><span class=\"line\">│  ├───&gt;│Controller1│────┤      │</span><br><span class=\"line\">   │    └───────────┘    │</span><br><span class=\"line\">│  │                     │      │</span><br><span class=\"line\">   │    ┌───────────┐    │</span><br><span class=\"line\">│  └───&gt;│Controller2│────┘      │</span><br><span class=\"line\">        └───────────┘</span><br><span class=\"line\">└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的<code>DispatcherServlet</code>还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。</p>\n<p>如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">       │   ▲</span><br><span class=\"line\">       ▼   │</span><br><span class=\"line\">     ┌───────┐</span><br><span class=\"line\">     │Filter1│</span><br><span class=\"line\">     └───────┘</span><br><span class=\"line\">       │   ▲</span><br><span class=\"line\">       ▼   │</span><br><span class=\"line\">     ┌───────┐</span><br><span class=\"line\">     │Filter2│</span><br><span class=\"line\">     └───────┘</span><br><span class=\"line\">       │   ▲</span><br><span class=\"line\">       ▼   │</span><br><span class=\"line\">┌─────────────────┐</span><br><span class=\"line\">│DispatcherServlet│&lt;───┐</span><br><span class=\"line\">└─────────────────┘    │</span><br><span class=\"line\"> │              ┌────────────┐</span><br><span class=\"line\"> │              │ModelAndView│</span><br><span class=\"line\"> │              └────────────┘</span><br><span class=\"line\"> │ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ▲</span><br><span class=\"line\"> │    ┌───────────┐    │</span><br><span class=\"line\"> ├─┼─&gt;│Controller1│──┼─┤</span><br><span class=\"line\"> │    └───────────┘    │</span><br><span class=\"line\"> │ │                 │ │</span><br><span class=\"line\"> │    ┌───────────┐    │</span><br><span class=\"line\"> └─┼─&gt;│Controller2│──┼─┘</span><br><span class=\"line\">      └───────────┘</span><br><span class=\"line\">   └ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>上图虚线框就是Interceptor的拦截范围，注意到Controller的处理方法一般都类似这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Controller1</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/path/to/hello&quot;)</span></span><br><span class=\"line\">    <span class=\"function\">ModelAndView <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回<code>ModelAndView</code>后，后续对View的渲染就脱离了Interceptor的拦截范围。</p>\n<p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的<code>@Order</code>指定顺序。我们先写一个<code>LoggerInterceptor</code>：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoggerInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object <span class=\"keyword\">handler</span>)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;preHandle &#123;&#125;...&quot;</span>, request.getRequestURI());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.getParameter(<span class=\"string\">&quot;debug&quot;</span>) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            PrintWriter pw = response.getWriter();</span><br><span class=\"line\">            pw.write(<span class=\"string\">&quot;&lt;p&gt;DEBUG MODE&lt;/p&gt;&quot;</span>);</span><br><span class=\"line\">            pw.flush();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object <span class=\"keyword\">handler</span>, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;postHandle &#123;&#125;.&quot;</span>, request.getRequestURI());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modelAndView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            modelAndView.addObject(<span class=\"string\">&quot;__time__&quot;</span>, LocalDateTime.now());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">afterCompletion</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object <span class=\"keyword\">handler</span>, Exception ex)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;afterCompletion &#123;&#125;: exception = &#123;&#125;&quot;</span>, request.getRequestURI(), ex);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>一个Interceptor必须实现<code>HandlerInterceptor</code>接口，可以选择实现<code>preHandle()</code>、<code>postHandle()</code>和<code>afterCompletion()</code>方法。<code>preHandle()</code>是Controller方法调用前执行，<code>postHandle()</code>是Controller方法正常返回后执行，而<code>afterCompletion()</code>无论Controller方法是否抛异常都会执行，参数<code>ex</code>就是Controller方法抛出的异常（未抛出异常是<code>null</code>）。</p>\n<p>在<code>preHandle()</code>中，也可以直接处理响应，然后返回<code>false</code>表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在<code>postHandle()</code>中，因为捕获了Controller方法返回的<code>ModelAndView</code>，所以可以继续往<code>ModelAndView</code>里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。</p>\n<p>我们再继续添加一个<code>AuthInterceptor</code>，用于替代上一节使用<code>AuthFilter</code>进行Basic认证的功能：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">Order(2)</span></span><br><span class=\"line\">@Component</span><br><span class=\"line\">public <span class=\"keyword\">class</span> AuthInterceptor implements HandlerInterceptor &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    final Logger logger = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LoggerFactory</span>.</span></span>get<span class=\"constructor\">Logger(<span class=\"params\">getClass</span>()</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    UserService userService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Override</span><br><span class=\"line\">    public boolean pre<span class=\"constructor\">Handle(HttpServletRequest <span class=\"params\">request</span>, HttpServletResponse <span class=\"params\">response</span>, Object <span class=\"params\">handler</span>)</span></span><br><span class=\"line\">            throws Exception &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;pre authenticate &#123;&#125;...&quot;</span>, request.get<span class=\"constructor\">RequestURI()</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            authenticate<span class=\"constructor\">ByHeader(<span class=\"params\">request</span>)</span>;</span><br><span class=\"line\">        &#125; catch (RuntimeException e) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">&quot;login by authorization header failed.&quot;</span>, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> void authenticate<span class=\"constructor\">ByHeader(HttpServletRequest <span class=\"params\">req</span>)</span> &#123;</span><br><span class=\"line\">        String authHeader = req.get<span class=\"constructor\">Header(<span class=\"string\">&quot;Authorization&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (authHeader != null<span class=\"operator\"> &amp;&amp; </span>authHeader.starts<span class=\"constructor\">With(<span class=\"string\">&quot;Basic &quot;</span>)</span>) &#123;</span><br><span class=\"line\">            logger.info(<span class=\"string\">&quot;try authenticate by authorization header...&quot;</span>);</span><br><span class=\"line\">            String up = <span class=\"keyword\">new</span> <span class=\"constructor\">String(Base64.<span class=\"params\">getDecoder</span>()</span>.decode(authHeader.substring(<span class=\"number\">6</span>)), StandardCharsets.UTF_8);</span><br><span class=\"line\">            <span class=\"built_in\">int</span> pos = up.index<span class=\"constructor\">Of(&#x27;:&#x27;)</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                String email = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">URLDecoder</span>.</span></span>decode(up.substring(<span class=\"number\">0</span>, pos), StandardCharsets.UTF_8);</span><br><span class=\"line\">                String password = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">URLDecoder</span>.</span></span>decode(up.substring(pos + <span class=\"number\">1</span>), StandardCharsets.UTF_8);</span><br><span class=\"line\">                User user = userService.signin(email, password);</span><br><span class=\"line\">                req.get<span class=\"constructor\">Session()</span>.set<span class=\"constructor\">Attribute(UserController.KEY_USER, <span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">                logger.info(<span class=\"string\">&quot;user &#123;&#125; login by authorization header ok.&quot;</span>, email);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>AuthInterceptor</code>是由Spring容器直接管理的，因此注入<code>UserService</code>非常方便。</p>\n<p>最后，要让拦截器生效，我们在<code>WebMvcConfigurer</code>中注册所有的Interceptor：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Bean</span></span><br><span class=\"line\">WebMvcConfigurer createWebMvcConfigurer(<span class=\"variable\">@Autowired</span> HandlerInterceptor[] interceptors) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">WebMvcConfigurer</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">public</span> <span class=\"selector-tag\">void</span> <span class=\"selector-tag\">addInterceptors</span>(InterceptorRegistry registry) &#123;</span><br><span class=\"line\">            <span class=\"selector-tag\">for</span> (var <span class=\"attribute\">interceptor </span>: interceptors) &#123;</span><br><span class=\"line\">                <span class=\"selector-tag\">registry</span><span class=\"selector-class\">.addInterceptor</span>(interceptor);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 如果拦截器没有生效，请检查是否忘了在WebMvcConfigurer中注册。</p>\n<h3 id=\"处理异常\"><a href=\"#处理异常\" class=\"headerlink\" title=\"处理异常\"></a>处理异常</h3><p>在Controller中，Spring MVC还允许定义基于<code>@ExceptionHandler</code>注解的异常处理方法。我们来看具体的示例代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\">public <span class=\"keyword\">class</span> UserController &#123;</span><br><span class=\"line\">    @<span class=\"constructor\">ExceptionHandler(RuntimeException.<span class=\"params\">class</span>)</span></span><br><span class=\"line\">    public ModelAndView handle<span class=\"constructor\">UnknowException(Exception <span class=\"params\">ex</span>)</span> &#123;</span><br><span class=\"line\">        return <span class=\"keyword\">new</span> <span class=\"constructor\">ModelAndView(<span class=\"string\">&quot;500.html&quot;</span>, Map.<span class=\"params\">of</span>(<span class=\"string\">&quot;error&quot;</span>, <span class=\"params\">ex</span>.<span class=\"params\">getClass</span>()</span>.get<span class=\"constructor\">SimpleName()</span>, <span class=\"string\">&quot;message&quot;</span>, ex.get<span class=\"constructor\">Message()</span>));</span><br><span class=\"line\">    &#125;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>异常处理方法没有固定的方法签名，可以传入<code>Exception</code>、<code>HttpServletRequest</code>等，返回值可以是<code>void</code>，也可以是<code>ModelAndView</code>，上述代码通过<code>@ExceptionHandler(RuntimeException.class)</code>表示当发生<code>RuntimeException</code>的时候，就自动调用此方法处理。</p>\n<p>注意到我们返回了一个新的<code>ModelAndView</code>，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。例如B站的错误页：</p>\n<p>![500](2.Spring 5.assets&#x2F;l-16419149632125.png)</p>\n<p>可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理<code>LoginException</code>使得页面可以自动跳转到登录页。</p>\n<p>使用<code>ExceptionHandler</code>时，要注意它仅作用于当前的Controller，即ControllerA中定义的一个<code>ExceptionHandler</code>方法对ControllerB不起作用。如果我们有很多Controller，每个Controller都需要处理一些通用的异常，例如<code>LoginException</code>，思考一下应该怎么避免重复代码？</p>\n<h2 id=\"5-5-处理CORS\"><a href=\"#5-5-处理CORS\" class=\"headerlink\" title=\"5.5 处理CORS\"></a>5.5 处理CORS</h2><p>在开发REST应用时，很多时候，是通过页面的JavaScript和后端的REST API交互。</p>\n<p>在JavaScript与REST交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行JavaScript调用API，即：</p>\n<ul>\n<li>如果A站在域名<code>a.com</code>页面的JavaScript调用A站自己的API时，没有问题；</li>\n<li>如果A站在域名<code>a.com</code>页面的JavaScript调用B站<code>b.com</code>的API时，将被浏览器拒绝访问，因为不满足同源策略。</li>\n</ul>\n<p>同源要求域名要完全相同（<code>a.com</code>和<code>www.a.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口要相同 。</p>\n<p>那么，在域名<code>a.com</code>页面的JavaScript要调用B站<code>b.com</code>的API时，还有没有办法？</p>\n<p>办法是有的，那就是CORS，全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。如果A站的JavaScript访问B站API的时候，B站能够返回响应头<code>Access-Control-Allow-Origin: http://a.com</code>，那么，浏览器就允许A站的JavaScript访问B站的API。</p>\n<p>注意到跨域访问能否成功，取决于B站是否愿意给A站返回一个正确的<code>Access-Control-Allow-Origin</code>响应头，所以决定权永远在提供API的服务方手中。</p>\n<p>关于CORS的详细信息可以参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\">MDN文档</a>，这里不再详述。</p>\n<p>使用Spring的<code>@RestController</code>开发REST应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面JavaScript访问这些REST API，就必须正确地设置CORS。</p>\n<p>有好几种方法设置CORS，我们来一一介绍。</p>\n<h3 id=\"使用-CrossOrigin\"><a href=\"#使用-CrossOrigin\" class=\"headerlink\" title=\"使用@CrossOrigin\"></a>使用@CrossOrigin</h3><p>第一种方法是使用<code>@CrossOrigin</code>注解，可以在<code>@RestController</code>的class级别或方法级别定义一个<code>@CrossOrigin</code>，例如：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@CrossOrigin</span>(origins = <span class=\"string\">&quot;http://local.liaoxuefeng.com:8080&quot;</span>)</span><br><span class=\"line\"><span class=\"variable\">@RestController</span></span><br><span class=\"line\"><span class=\"variable\">@RequestMapping</span>(<span class=\"string\">&quot;/api&quot;</span>)</span><br><span class=\"line\">public class ApiController &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述定义在<code>ApiController</code>处的<code>@CrossOrigin</code>指定了只允许来自<code>local.liaoxuefeng.com</code>跨域访问，允许多个域访问需要写成数组形式，例如<code>origins = &#123;&quot;http://a.com&quot;, &quot;https://www.b.com&quot;&#125;)</code>。如果要允许任何域访问，写成<code>origins = &quot;*&quot;</code>即可。</p>\n<p>如果有多个REST Controller都需要使用CORS，那么，每个Controller都必须标注<code>@CrossOrigin</code>注解。</p>\n<h3 id=\"使用CorsRegistry\"><a href=\"#使用CorsRegistry\" class=\"headerlink\" title=\"使用CorsRegistry\"></a>使用CorsRegistry</h3><p>第二种方法是在<code>WebMvcConfigurer</code>中定义一个全局CORS配置，下面是一个示例：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">WebMvcConfigurer <span class=\"function\"><span class=\"title\">createWebMvcConfigurer</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">WebMvcConfigurer</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">addCorsMappings</span>(<span class=\"params\">CorsRegistry registry</span>)</span> &#123;</span><br><span class=\"line\">            registry.addMapping(<span class=\"string\">&quot;/api/**&quot;</span>)</span><br><span class=\"line\">                    .allowedOrigins(<span class=\"string\">&quot;http://local.liaoxuefeng.com:8080&quot;</span>)</span><br><span class=\"line\">                    .allowedMethods(<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;POST&quot;</span>)</span><br><span class=\"line\">                    .maxAge(<span class=\"number\">3600</span>);</span><br><span class=\"line\">            <span class=\"comment\">// 可以继续添加其他URL规则:</span></span><br><span class=\"line\">            <span class=\"comment\">// registry.addMapping(&quot;/rest/v2/**&quot;)...</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种方式可以创建一个全局CORS配置，如果仔细地设计URL结构，那么可以一目了然地看到各个URL的CORS规则，推荐使用这种方式配置CORS。</p>\n<h3 id=\"使用CorsFilter\"><a href=\"#使用CorsFilter\" class=\"headerlink\" title=\"使用CorsFilter\"></a>使用CorsFilter</h3><p>第三种方法是使用Spring提供的<code>CorsFilter</code>，我们在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1282384114745378/\">集成Filter</a>中详细介绍了将Spring容器内置的Bean暴露为Servlet容器的Filter的方法，由于这种配置方式需要修改<code>web.xml</code>，也比较繁琐，所以推荐使用第二种方式。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>当我们配置好CORS后，可以在浏览器中测试一下规则是否生效。</p>\n<p>我们先用<code>http://localhost:8080</code>在Chrome浏览器中打开首页，然后打开Chrome的开发者工具，切换到Console，输入一个JavaScript语句来跨域访问API：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.getJSON( <span class=\"string\">&quot;http://local.liaoxuefeng.com:8080/api/users&quot;</span>, <span class=\"function\"><span class=\"params\">(data)</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data)));</span><br></pre></td></tr></table></figure>\n\n<p>上述源站的域是<code>http://localhost:8080</code>，跨域访问的是<code>http://local.liaoxuefeng.com:8080</code>，因为配置的CORS不允许<code>localhost</code>访问，所以不出意外地得到一个错误：</p>\n<p>![cors-deny](2.Spring 5.assets&#x2F;l-16419149778577.png)</p>\n<p>浏览题打印了错误原因就是<code>been blocked by CORS policy</code>。</p>\n<p>我们再用<code>http://local.liaoxuefeng.com:8080</code>在Chrome浏览器中打开首页，在Console中执行JavaScript访问<code>localhost</code>：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.getJSON( <span class=\"string\">&quot;http://localhost:8080/api/users&quot;</span>, <span class=\"function\"><span class=\"params\">(data)</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(data)));</span><br></pre></td></tr></table></figure>\n\n<p>因为CORS规则允许来自<code>http://local.liaoxuefeng.com:8080</code>的访问，因此访问成功，打印出API的返回值：</p>\n<p>![cors-ok](2.Spring 5.assets&#x2F;l-16419149778588.png)</p>\n<h2 id=\"5-6-国际化\"><a href=\"#5-6-国际化\" class=\"headerlink\" title=\"5.6 国际化\"></a>5.6 国际化</h2><p>在开发应用程序的时候，经常会遇到支持多语言的需求，这种支持多语言的功能称之为国际化，英文是internationalization，缩写为i18n（因为首字母i和末字母n中间有18个字母）。</p>\n<p>还有针对特定地区的本地化功能，英文是localization，缩写为L10n，本地化是指根据地区调整类似姓名、日期的显示等。</p>\n<p>也有把上面两者合称为全球化，英文是globalization，缩写为g11n。</p>\n<p>在Java中，支持多语言和本地化是通过<code>MessageFormat</code>配合<code>Locale</code>实现的：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> MessageFormat</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>对于Web应用程序，要实现国际化功能，主要是渲染View的时候，要把各种语言的资源文件提出来，这样，不同的用户访问同一个页面时，显示的语言就是不同的。</p>\n<p>我们来看看在Spring MVC应用程序中如何实现国际化。</p>\n<h3 id=\"获取Locale\"><a href=\"#获取Locale\" class=\"headerlink\" title=\"获取Locale\"></a>获取Locale</h3><p>实现国际化的第一步是获取到用户的<code>Locale</code>。在Web应用程序中，HTTP规范规定了浏览器会在请求中携带<code>Accept-Language</code>头，用来指示用户浏览器设定的语言顺序，如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Accept</span>-Language: zh-CN,zh;q=<span class=\"number\">0</span>.<span class=\"number\">8</span>,en;q=<span class=\"number\">0</span>.<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>上述HTTP请求头表示优先选择简体中文，其次选择中文，最后选择英文。<code>q</code>表示权重，解析后我们可获得一个根据优先级排序的语言列表，把它转换为Java的<code>Locale</code>，即获得了用户的<code>Locale</code>。大多数框架通常只返回权重最高的<code>Locale</code>。</p>\n<p>Spring MVC通过<code>LocaleResolver</code>来自动从<code>HttpServletRequest</code>中获取<code>Locale</code>。有多种<code>LocaleResolver</code>的实现类，其中最常用的是<code>CookieLocaleResolver</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">LocaleResolver create<span class=\"constructor\">LocaleResolver()</span> &#123;</span><br><span class=\"line\">    var clr = <span class=\"keyword\">new</span> <span class=\"constructor\">CookieLocaleResolver()</span>;</span><br><span class=\"line\">    clr.set<span class=\"constructor\">DefaultLocale(Locale.ENGLISH)</span>;</span><br><span class=\"line\">    clr.set<span class=\"constructor\">DefaultTimeZone(TimeZone.<span class=\"params\">getDefault</span>()</span>);</span><br><span class=\"line\">    return clr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CookieLocaleResolver</code>从<code>HttpServletRequest</code>中获取<code>Locale</code>时，首先根据一个特定的Cookie判断是否指定了<code>Locale</code>，如果没有，就从HTTP头获取，如果还没有，就返回默认的<code>Locale</code>。</p>\n<p>当用户第一次访问网站时，<code>CookieLocaleResolver</code>只能从HTTP头获取<code>Locale</code>，即使用浏览器的默认语言。通常网站也允许用户自己选择语言，此时，<code>CookieLocaleResolver</code>就会把用户选择的语言存放到Cookie中，下一次访问时，就会返回用户上次选择的语言而不是浏览器默认语言。</p>\n<h3 id=\"提取资源文件\"><a href=\"#提取资源文件\" class=\"headerlink\" title=\"提取资源文件\"></a>提取资源文件</h3><p>第二步是把写死在模板中的字符串以资源文件的方式存储在外部。对于多语言，主文件名如果命名为<code>messages</code>，那么资源文件必须按如下方式命名并放入classpath中：</p>\n<ul>\n<li>默认语言，文件名必须为<code>messages.properties</code>；</li>\n<li>简体中文，Locale是<code>zh_CN</code>，文件名必须为<code>messages_zh_CN.properties</code>；</li>\n<li>日文，Locale是<code>ja_JP</code>，文件名必须为<code>messages_ja_JP.properties</code>；</li>\n<li>其它更多语言……</li>\n</ul>\n<p>每个资源文件都有相同的key，例如，默认语言是英文，文件<code>messages.properties</code>内容如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language.select</span>=Language</span><br><span class=\"line\"><span class=\"attr\">home</span>=Home</span><br><span class=\"line\"><span class=\"attr\">signin</span>=Sign In</span><br><span class=\"line\"><span class=\"attr\">copyright</span>=Copyright©&#123;<span class=\"number\">0</span>,number,<span class=\"comment\">#&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>文件<code>messages_zh_CN.properties</code>内容如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language.select</span>=语言</span><br><span class=\"line\"><span class=\"attr\">home</span>=首页</span><br><span class=\"line\"><span class=\"attr\">signin</span>=登录</span><br><span class=\"line\"><span class=\"attr\">copyright</span>=版权所有©&#123;<span class=\"number\">0</span>,number,<span class=\"comment\">#&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建MessageSource\"><a href=\"#创建MessageSource\" class=\"headerlink\" title=\"创建MessageSource\"></a>创建MessageSource</h3><p>第三步是创建一个Spring提供的<code>MessageSource</code>实例，它自动读取所有的<code>.properties</code>文件，并提供一个统一接口来实现“翻译”：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// code, arguments, locale:</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> text = messageSource.getMessage(<span class=\"string\">&quot;signin&quot;</span>, <span class=\"built_in\">null</span>, <span class=\"built_in\">locale</span>);</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>signin</code>是我们在<code>.properties</code>文件中定义的key，第二个参数是<code>Object[]</code>数组作为格式化时传入的参数，最后一个参数就是获取的用户<code>Locale</code>实例。</p>\n<p>创建<code>MessageSource</code>如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">Bean(<span class=\"string\">&quot;i18n&quot;</span>)</span></span><br><span class=\"line\">MessageSource create<span class=\"constructor\">MessageSource()</span> &#123;</span><br><span class=\"line\">    var messageSource = <span class=\"keyword\">new</span> <span class=\"constructor\">ResourceBundleMessageSource()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 指定文件是UTF-8编码:</span></span><br><span class=\"line\">    messageSource.set<span class=\"constructor\">DefaultEncoding(<span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 指定主文件名:</span></span><br><span class=\"line\">    messageSource.set<span class=\"constructor\">Basename(<span class=\"string\">&quot;messages&quot;</span>)</span>;</span><br><span class=\"line\">    return messageSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>ResourceBundleMessageSource</code>会自动根据主文件名自动把所有相关语言的资源文件都读进来。</p>\n<p>再注意到Spring容器会创建不只一个<code>MessageSource</code>实例，我们自己创建的这个<code>MessageSource</code>是专门给页面国际化使用的，因此命名为<code>i18n</code>，不会与其它<code>MessageSource</code>实例冲突。</p>\n<h3 id=\"实现多语言\"><a href=\"#实现多语言\" class=\"headerlink\" title=\"实现多语言\"></a>实现多语言</h3><p>要在View中使用<code>MessageSource</code>加上<code>Locale</code>输出多语言，我们通过编写一个<code>MvcInterceptor</code>，把相关资源注入到<code>ModelAndView</code>中：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MvcInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    LocaleResolver localeResolver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意注入的MessageSource名称是i18n:</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier</span>(<span class=\"string\">&quot;i18n&quot;</span>)</span><br><span class=\"line\">    MessageSource messageSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object <span class=\"keyword\">handler</span>, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modelAndView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 解析用户的Locale:</span></span><br><span class=\"line\">            Locale locale = localeResolver.resolveLocale(request);</span><br><span class=\"line\">            <span class=\"comment\">// 放入Model:</span></span><br><span class=\"line\">            modelAndView.addObject(<span class=\"string\">&quot;__messageSource__&quot;</span>, messageSource);</span><br><span class=\"line\">            modelAndView.addObject(<span class=\"string\">&quot;__locale__&quot;</span>, locale);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不要忘了在<code>WebMvcConfigurer</code>中注册<code>MvcInterceptor</code>。现在，就可以在View中调用<code>MessageSource.getMessage()</code>方法来实现多语言：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/signin&quot;</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; <span class=\"name\">__messageSource__.getMessage</span>(<span class=\"name\">&#x27;signin&#x27;</span>, <span class=\"literal\">null</span>, __locale__) &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>上述这种写法虽然可行，但格式太复杂了。使用View时，要根据每个特定的View引擎定制国际化函数。在Pebble中，我们可以封装一个国际化函数，名称就是下划线<code>_</code>，改造一下创建<code>ViewResolver</code>的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">ViewResolver <span class=\"function\"><span class=\"title\">createViewResolver</span>(<span class=\"params\"><span class=\"meta\">@Autowired</span> ServletContext servletContext, <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">&quot;i18n&quot;</span>) MessageSource messageSource</span>)</span> &#123;</span><br><span class=\"line\">    PebbleEngine engine = <span class=\"keyword\">new</span> PebbleEngine.Builder()</span><br><span class=\"line\">            .autoEscaping(<span class=\"literal\">true</span>)</span><br><span class=\"line\">            .cacheActive(<span class=\"literal\">false</span>)</span><br><span class=\"line\">            .loader(<span class=\"keyword\">new</span> ServletLoader(servletContext))</span><br><span class=\"line\">            <span class=\"comment\">// 添加扩展:</span></span><br><span class=\"line\">            .extension(createExtension(messageSource))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    PebbleViewResolver viewResolver = <span class=\"keyword\">new</span> PebbleViewResolver();</span><br><span class=\"line\">    viewResolver.setPrefix(<span class=\"string\">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class=\"line\">    viewResolver.setSuffix(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    viewResolver.setPebbleEngine(engine);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> viewResolver;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Extension <span class=\"function\"><span class=\"title\">createExtension</span>(<span class=\"params\">MessageSource messageSource</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">AbstractExtension</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Function</span>&gt; <span class=\"function\"><span class=\"title\">getFunctions</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Map</span>.of(<span class=\"string\">&quot;_&quot;</span>, <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">Function</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"built_in\">Object</span> <span class=\"function\"><span class=\"title\">execute</span>(<span class=\"params\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt; args, PebbleTemplate self, EvaluationContext context, int lineNumber</span>)</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">String</span> key = (<span class=\"built_in\">String</span>) args.get(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">                    List&lt;<span class=\"built_in\">Object</span>&gt; <span class=\"built_in\">arguments</span> = <span class=\"built_in\">this</span>.extractArguments(args);</span><br><span class=\"line\">                    Locale locale = (Locale) context.getVariable(<span class=\"string\">&quot;__locale__&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> messageSource.getMessage(key, <span class=\"built_in\">arguments</span>.toArray(), <span class=\"string\">&quot;???&quot;</span> + key + <span class=\"string\">&quot;???&quot;</span>, locale);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">private</span> List&lt;<span class=\"built_in\">Object</span>&gt; <span class=\"function\"><span class=\"title\">extractArguments</span>(<span class=\"params\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt; args</span>)</span> &#123;</span><br><span class=\"line\">                    int i = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    List&lt;<span class=\"built_in\">Object</span>&gt; <span class=\"built_in\">arguments</span> = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (args.containsKey(<span class=\"built_in\">String</span>.valueOf(i))) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">Object</span> param = args.get(<span class=\"built_in\">String</span>.valueOf(i));</span><br><span class=\"line\">                        <span class=\"built_in\">arguments</span>.add(param);</span><br><span class=\"line\">                        i++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> List&lt;<span class=\"built_in\">String</span>&gt; <span class=\"function\"><span class=\"title\">getArgumentNames</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们可以把多语言页面改写为：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/signin&quot;</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; <span class=\"name\">_</span>(<span class=\"name\">&#x27;signin&#x27;</span>) &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>如果是带参数的多语言，需要把参数传进去：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; <span class=\"name\">_</span>(<span class=\"name\">&#x27;copyright&#x27;</span>, <span class=\"number\">2020</span>) &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>使用其它View引擎时，也应当根据引擎接口实现更方便的语法。</p>\n<h3 id=\"切换Locale\"><a href=\"#切换Locale\" class=\"headerlink\" title=\"切换Locale\"></a>切换Locale</h3><p>最后，我们需要允许用户手动切换<code>Locale</code>，编写一个<code>LocaleController</code>来实现该功能：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\"><span class=\"keyword\">public</span> class LocaleController &#123;</span><br><span class=\"line\">    final Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    LocaleResolver localeResolver;</span><br><span class=\"line\"></span><br><span class=\"line\">    @GetMapping(<span class=\"string\">&quot;/locale/&#123;lo&#125;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> setLocale(@PathVariable(<span class=\"string\">&quot;lo&quot;</span>) <span class=\"built_in\">String</span> lo, HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据传入的lo创建Locale实例:</span></span><br><span class=\"line\">        <span class=\"built_in\">Locale</span> <span class=\"built_in\">locale</span> = <span class=\"built_in\">null</span>;</span><br><span class=\"line\">        int pos = lo.indexOf(<span class=\"string\">&#x27;_&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">String</span> lang = lo.substring(<span class=\"number\">0</span>, pos);</span><br><span class=\"line\">            <span class=\"built_in\">String</span> country = lo.substring(pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">locale</span> = <span class=\"literal\">new</span> <span class=\"built_in\">Locale</span>(lang, country);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">locale</span> = <span class=\"literal\">new</span> <span class=\"built_in\">Locale</span>(lo);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 设定此Locale:</span></span><br><span class=\"line\">        localeResolver.setLocale(request, response, <span class=\"built_in\">locale</span>);</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;locale is set to &#123;&#125;.&quot;</span>, <span class=\"built_in\">locale</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 刷新页面:</span></span><br><span class=\"line\">        <span class=\"built_in\">String</span> <span class=\"keyword\">referer</span> = request.getHeader(<span class=\"string\">&quot;Referer&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;redirect:&quot;</span> + (<span class=\"keyword\">referer</span> == <span class=\"built_in\">null</span> ? <span class=\"string\">&quot;/&quot;</span> : <span class=\"keyword\">referer</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在页面设计中，通常在右上角给用户提供一个语言选择列表，来看看效果：</p>\n<p>![i18n-en](2.Spring 5.assets&#x2F;l-164191499871211.png)</p>\n<p>切换到中文：</p>\n<p>![i18n-zh-cn](2.Spring 5.assets&#x2F;l-164191499871312.png)</p>\n<h2 id=\"5-7-异步处理\"><a href=\"#5-7-异步处理\" class=\"headerlink\" title=\"5.7 异步处理\"></a>5.7 异步处理</h2><p>在开发应用程序的时候，经常会遇到支持多语言的需求，这种支持多语言的功能称之为国际化，英文是internationalization，缩写为i18n（因为首字母i和末字母n中间有18个字母）。</p>\n<p>还有针对特定地区的本地化功能，英文是localization，缩写为L10n，本地化是指根据地区调整类似姓名、日期的显示等。</p>\n<p>也有把上面两者合称为全球化，英文是globalization，缩写为g11n。</p>\n<p>在Java中，支持多语言和本地化是通过<code>MessageFormat</code>配合<code>Locale</code>实现的：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> MessageFormat</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>对于Web应用程序，要实现国际化功能，主要是渲染View的时候，要把各种语言的资源文件提出来，这样，不同的用户访问同一个页面时，显示的语言就是不同的。</p>\n<p>我们来看看在Spring MVC应用程序中如何实现国际化。</p>\n<h3 id=\"获取Locale-1\"><a href=\"#获取Locale-1\" class=\"headerlink\" title=\"获取Locale\"></a>获取Locale</h3><p>实现国际化的第一步是获取到用户的<code>Locale</code>。在Web应用程序中，HTTP规范规定了浏览器会在请求中携带<code>Accept-Language</code>头，用来指示用户浏览器设定的语言顺序，如：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Accept</span>-Language: zh-CN,zh;q=<span class=\"number\">0</span>.<span class=\"number\">8</span>,en;q=<span class=\"number\">0</span>.<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>上述HTTP请求头表示优先选择简体中文，其次选择中文，最后选择英文。<code>q</code>表示权重，解析后我们可获得一个根据优先级排序的语言列表，把它转换为Java的<code>Locale</code>，即获得了用户的<code>Locale</code>。大多数框架通常只返回权重最高的<code>Locale</code>。</p>\n<p>Spring MVC通过<code>LocaleResolver</code>来自动从<code>HttpServletRequest</code>中获取<code>Locale</code>。有多种<code>LocaleResolver</code>的实现类，其中最常用的是<code>CookieLocaleResolver</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Bean</span><br><span class=\"line\">LocaleResolver create<span class=\"constructor\">LocaleResolver()</span> &#123;</span><br><span class=\"line\">    var clr = <span class=\"keyword\">new</span> <span class=\"constructor\">CookieLocaleResolver()</span>;</span><br><span class=\"line\">    clr.set<span class=\"constructor\">DefaultLocale(Locale.ENGLISH)</span>;</span><br><span class=\"line\">    clr.set<span class=\"constructor\">DefaultTimeZone(TimeZone.<span class=\"params\">getDefault</span>()</span>);</span><br><span class=\"line\">    return clr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>CookieLocaleResolver</code>从<code>HttpServletRequest</code>中获取<code>Locale</code>时，首先根据一个特定的Cookie判断是否指定了<code>Locale</code>，如果没有，就从HTTP头获取，如果还没有，就返回默认的<code>Locale</code>。</p>\n<p>当用户第一次访问网站时，<code>CookieLocaleResolver</code>只能从HTTP头获取<code>Locale</code>，即使用浏览器的默认语言。通常网站也允许用户自己选择语言，此时，<code>CookieLocaleResolver</code>就会把用户选择的语言存放到Cookie中，下一次访问时，就会返回用户上次选择的语言而不是浏览器默认语言。</p>\n<h3 id=\"提取资源文件-1\"><a href=\"#提取资源文件-1\" class=\"headerlink\" title=\"提取资源文件\"></a>提取资源文件</h3><p>第二步是把写死在模板中的字符串以资源文件的方式存储在外部。对于多语言，主文件名如果命名为<code>messages</code>，那么资源文件必须按如下方式命名并放入classpath中：</p>\n<ul>\n<li>默认语言，文件名必须为<code>messages.properties</code>；</li>\n<li>简体中文，Locale是<code>zh_CN</code>，文件名必须为<code>messages_zh_CN.properties</code>；</li>\n<li>日文，Locale是<code>ja_JP</code>，文件名必须为<code>messages_ja_JP.properties</code>；</li>\n<li>其它更多语言……</li>\n</ul>\n<p>每个资源文件都有相同的key，例如，默认语言是英文，文件<code>messages.properties</code>内容如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language.select</span>=Language</span><br><span class=\"line\"><span class=\"attr\">home</span>=Home</span><br><span class=\"line\"><span class=\"attr\">signin</span>=Sign In</span><br><span class=\"line\"><span class=\"attr\">copyright</span>=Copyright©&#123;<span class=\"number\">0</span>,number,<span class=\"comment\">#&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>文件<code>messages_zh_CN.properties</code>内容如下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language.select</span>=语言</span><br><span class=\"line\"><span class=\"attr\">home</span>=首页</span><br><span class=\"line\"><span class=\"attr\">signin</span>=登录</span><br><span class=\"line\"><span class=\"attr\">copyright</span>=版权所有©&#123;<span class=\"number\">0</span>,number,<span class=\"comment\">#&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"创建MessageSource-1\"><a href=\"#创建MessageSource-1\" class=\"headerlink\" title=\"创建MessageSource\"></a>创建MessageSource</h3><p>第三步是创建一个Spring提供的<code>MessageSource</code>实例，它自动读取所有的<code>.properties</code>文件，并提供一个统一接口来实现“翻译”：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// code, arguments, locale:</span></span><br><span class=\"line\"><span class=\"built_in\">String</span> text = messageSource.getMessage(<span class=\"string\">&quot;signin&quot;</span>, <span class=\"built_in\">null</span>, <span class=\"built_in\">locale</span>);</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>signin</code>是我们在<code>.properties</code>文件中定义的key，第二个参数是<code>Object[]</code>数组作为格式化时传入的参数，最后一个参数就是获取的用户<code>Locale</code>实例。</p>\n<p>创建<code>MessageSource</code>如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@<span class=\"constructor\">Bean(<span class=\"string\">&quot;i18n&quot;</span>)</span></span><br><span class=\"line\">MessageSource create<span class=\"constructor\">MessageSource()</span> &#123;</span><br><span class=\"line\">    var messageSource = <span class=\"keyword\">new</span> <span class=\"constructor\">ResourceBundleMessageSource()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 指定文件是UTF-8编码:</span></span><br><span class=\"line\">    messageSource.set<span class=\"constructor\">DefaultEncoding(<span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 指定主文件名:</span></span><br><span class=\"line\">    messageSource.set<span class=\"constructor\">Basename(<span class=\"string\">&quot;messages&quot;</span>)</span>;</span><br><span class=\"line\">    return messageSource;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>ResourceBundleMessageSource</code>会自动根据主文件名自动把所有相关语言的资源文件都读进来。</p>\n<p>再注意到Spring容器会创建不只一个<code>MessageSource</code>实例，我们自己创建的这个<code>MessageSource</code>是专门给页面国际化使用的，因此命名为<code>i18n</code>，不会与其它<code>MessageSource</code>实例冲突。</p>\n<h3 id=\"实现多语言-1\"><a href=\"#实现多语言-1\" class=\"headerlink\" title=\"实现多语言\"></a>实现多语言</h3><p>要在View中使用<code>MessageSource</code>加上<code>Locale</code>输出多语言，我们通过编写一个<code>MvcInterceptor</code>，把相关资源注入到<code>ModelAndView</code>中：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MvcInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    LocaleResolver localeResolver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注意注入的MessageSource名称是i18n:</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"meta\">@Qualifier</span>(<span class=\"string\">&quot;i18n&quot;</span>)</span><br><span class=\"line\">    MessageSource messageSource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">postHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object <span class=\"keyword\">handler</span>, ModelAndView modelAndView)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modelAndView != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 解析用户的Locale:</span></span><br><span class=\"line\">            Locale locale = localeResolver.resolveLocale(request);</span><br><span class=\"line\">            <span class=\"comment\">// 放入Model:</span></span><br><span class=\"line\">            modelAndView.addObject(<span class=\"string\">&quot;__messageSource__&quot;</span>, messageSource);</span><br><span class=\"line\">            modelAndView.addObject(<span class=\"string\">&quot;__locale__&quot;</span>, locale);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>不要忘了在<code>WebMvcConfigurer</code>中注册<code>MvcInterceptor</code>。现在，就可以在View中调用<code>MessageSource.getMessage()</code>方法来实现多语言：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/signin&quot;</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; <span class=\"name\">__messageSource__.getMessage</span>(<span class=\"name\">&#x27;signin&#x27;</span>, <span class=\"literal\">null</span>, __locale__) &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>上述这种写法虽然可行，但格式太复杂了。使用View时，要根据每个特定的View引擎定制国际化函数。在Pebble中，我们可以封装一个国际化函数，名称就是下划线<code>_</code>，改造一下创建<code>ViewResolver</code>的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">ViewResolver <span class=\"function\"><span class=\"title\">createViewResolver</span>(<span class=\"params\"><span class=\"meta\">@Autowired</span> ServletContext servletContext, <span class=\"meta\">@Autowired</span> <span class=\"meta\">@Qualifier</span>(<span class=\"string\">&quot;i18n&quot;</span>) MessageSource messageSource</span>)</span> &#123;</span><br><span class=\"line\">    PebbleEngine engine = <span class=\"keyword\">new</span> PebbleEngine.Builder()</span><br><span class=\"line\">            .autoEscaping(<span class=\"literal\">true</span>)</span><br><span class=\"line\">            .cacheActive(<span class=\"literal\">false</span>)</span><br><span class=\"line\">            .loader(<span class=\"keyword\">new</span> ServletLoader(servletContext))</span><br><span class=\"line\">            <span class=\"comment\">// 添加扩展:</span></span><br><span class=\"line\">            .extension(createExtension(messageSource))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    PebbleViewResolver viewResolver = <span class=\"keyword\">new</span> PebbleViewResolver();</span><br><span class=\"line\">    viewResolver.setPrefix(<span class=\"string\">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class=\"line\">    viewResolver.setSuffix(<span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    viewResolver.setPebbleEngine(engine);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> viewResolver;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> Extension <span class=\"function\"><span class=\"title\">createExtension</span>(<span class=\"params\">MessageSource messageSource</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">AbstractExtension</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Function</span>&gt; <span class=\"function\"><span class=\"title\">getFunctions</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Map</span>.of(<span class=\"string\">&quot;_&quot;</span>, <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">Function</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> <span class=\"built_in\">Object</span> <span class=\"function\"><span class=\"title\">execute</span>(<span class=\"params\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt; args, PebbleTemplate self, EvaluationContext context, int lineNumber</span>)</span> &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">String</span> key = (<span class=\"built_in\">String</span>) args.get(<span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">                    List&lt;<span class=\"built_in\">Object</span>&gt; <span class=\"built_in\">arguments</span> = <span class=\"built_in\">this</span>.extractArguments(args);</span><br><span class=\"line\">                    Locale locale = (Locale) context.getVariable(<span class=\"string\">&quot;__locale__&quot;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> messageSource.getMessage(key, <span class=\"built_in\">arguments</span>.toArray(), <span class=\"string\">&quot;???&quot;</span> + key + <span class=\"string\">&quot;???&quot;</span>, locale);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">private</span> List&lt;<span class=\"built_in\">Object</span>&gt; <span class=\"function\"><span class=\"title\">extractArguments</span>(<span class=\"params\"><span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">Object</span>&gt; args</span>)</span> &#123;</span><br><span class=\"line\">                    int i = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    List&lt;<span class=\"built_in\">Object</span>&gt; <span class=\"built_in\">arguments</span> = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (args.containsKey(<span class=\"built_in\">String</span>.valueOf(i))) &#123;</span><br><span class=\"line\">                        <span class=\"built_in\">Object</span> param = args.get(<span class=\"built_in\">String</span>.valueOf(i));</span><br><span class=\"line\">                        <span class=\"built_in\">arguments</span>.add(param);</span><br><span class=\"line\">                        i++;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">public</span> List&lt;<span class=\"built_in\">String</span>&gt; <span class=\"function\"><span class=\"title\">getArgumentNames</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们可以把多语言页面改写为：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;/signin&quot;</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; <span class=\"name\">_</span>(<span class=\"name\">&#x27;signin&#x27;</span>) &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>如果是带参数的多语言，需要把参数传进去：</p>\n<figure class=\"highlight handlebars\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h5</span>&gt;</span></span><span class=\"template-variable\">&#123;&#123; <span class=\"name\">_</span>(<span class=\"name\">&#x27;copyright&#x27;</span>, <span class=\"number\">2020</span>) &#125;&#125;</span><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">h5</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>使用其它View引擎时，也应当根据引擎接口实现更方便的语法。</p>\n<h3 id=\"切换Locale-1\"><a href=\"#切换Locale-1\" class=\"headerlink\" title=\"切换Locale\"></a>切换Locale</h3><p>最后，我们需要允许用户手动切换<code>Locale</code>，编写一个<code>LocaleController</code>来实现该功能：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Controller</span><br><span class=\"line\"><span class=\"keyword\">public</span> class LocaleController &#123;</span><br><span class=\"line\">    final Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    LocaleResolver localeResolver;</span><br><span class=\"line\"></span><br><span class=\"line\">    @GetMapping(<span class=\"string\">&quot;/locale/&#123;lo&#125;&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> setLocale(@PathVariable(<span class=\"string\">&quot;lo&quot;</span>) <span class=\"built_in\">String</span> lo, HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据传入的lo创建Locale实例:</span></span><br><span class=\"line\">        <span class=\"built_in\">Locale</span> <span class=\"built_in\">locale</span> = <span class=\"built_in\">null</span>;</span><br><span class=\"line\">        int pos = lo.indexOf(<span class=\"string\">&#x27;_&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">String</span> lang = lo.substring(<span class=\"number\">0</span>, pos);</span><br><span class=\"line\">            <span class=\"built_in\">String</span> country = lo.substring(pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"built_in\">locale</span> = <span class=\"literal\">new</span> <span class=\"built_in\">Locale</span>(lang, country);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">locale</span> = <span class=\"literal\">new</span> <span class=\"built_in\">Locale</span>(lo);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 设定此Locale:</span></span><br><span class=\"line\">        localeResolver.setLocale(request, response, <span class=\"built_in\">locale</span>);</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;locale is set to &#123;&#125;.&quot;</span>, <span class=\"built_in\">locale</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 刷新页面:</span></span><br><span class=\"line\">        <span class=\"built_in\">String</span> <span class=\"keyword\">referer</span> = request.getHeader(<span class=\"string\">&quot;Referer&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;redirect:&quot;</span> + (<span class=\"keyword\">referer</span> == <span class=\"built_in\">null</span> ? <span class=\"string\">&quot;/&quot;</span> : <span class=\"keyword\">referer</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在页面设计中，通常在右上角给用户提供一个语言选择列表，来看看效果：</p>\n<p>![i18n-en](2.Spring 5.assets&#x2F;l-164191501404415.png)</p>\n<p>切换到中文：</p>\n<p>![i18n-zh-cn](2.Spring 5.assets&#x2F;l-164191501404516.png)</p>\n<h2 id=\"5-8-使用WebSocket\"><a href=\"#5-8-使用WebSocket\" class=\"headerlink\" title=\"5.8 使用WebSocket\"></a>5.8 使用WebSocket</h2><p>WebSocket是一种基于HTTP的长链接技术。传统的HTTP协议是一种请求-响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。</p>\n<p>因为HTTP本身是基于TCP连接的，所以，WebSocket在HTTP协议的基础上做了一个简单的升级，即建立TCP连接后，浏览器发送请求时，附带几个头：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/chat</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>www.example.com</span><br><span class=\"line\"><span class=\"attribute\">Upgrade</span><span class=\"punctuation\">: </span>websocket</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>Upgrade</span><br></pre></td></tr></table></figure>\n\n<p>就表示客户端希望升级连接，变成长连接的WebSocket，服务器返回升级成功的响应：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">101</span> Switching Protocols</span><br><span class=\"line\"><span class=\"attribute\">Upgrade</span><span class=\"punctuation\">: </span>websocket</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>Upgrade</span><br></pre></td></tr></table></figure>\n\n<p>收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。</p>\n<p>现代浏览器都已经支持WebSocket协议，服务器则需要底层框架支持。Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。</p>\n<p>我们以实际代码演示如何在Spring MVC中实现对WebSocket的支持。首先，我们需要在<code>pom.xml</code>中加入以下依赖：</p>\n<ul>\n<li>org.apache.tomcat.embed:tomcat-embed-websocket:9.0.26</li>\n<li>org.springframework:spring-websocket:5.2.0.RELEASE</li>\n</ul>\n<p>第一项是嵌入式Tomcat支持WebSocket的组件，第二项是Spring封装的支持WebSocket的接口。</p>\n<p>接下来，我们需要在AppConfig中加入Spring Web对WebSocket的配置，此处我们需要创建一个<code>WebSocketConfigurer</code>实例：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Bean</span></span><br><span class=\"line\">WebSocketConfigurer createWebSocketConfigurer(</span><br><span class=\"line\">        <span class=\"variable\">@Autowired</span> ChatHandler chatHandler,</span><br><span class=\"line\">        <span class=\"variable\">@Autowired</span> ChatHandshakeInterceptor chatInterceptor)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">WebSocketConfigurer</span>() &#123;</span><br><span class=\"line\">        <span class=\"selector-tag\">public</span> <span class=\"selector-tag\">void</span> <span class=\"selector-tag\">registerWebSocketHandlers</span>(WebSocketHandlerRegistry registry) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 把URL与指定的WebSocketHandler关联，可关联多个:</span></span><br><span class=\"line\">            <span class=\"selector-tag\">registry</span><span class=\"selector-class\">.addHandler</span>(chatHandler, <span class=\"string\">&quot;/chat&quot;</span>)<span class=\"selector-class\">.addInterceptors</span>(chatInterceptor);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此实例在内部通过<code>WebSocketHandlerRegistry</code>注册能处理WebSocket的<code>WebSocketHandler</code>，以及可选的WebSocket拦截器<code>HandshakeInterceptor</code>。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到WebSocket的URL是<code>/chat</code>。</p>\n<h3 id=\"处理WebSocket连接\"><a href=\"#处理WebSocket连接\" class=\"headerlink\" title=\"处理WebSocket连接\"></a>处理WebSocket连接</h3><p>和处理普通HTTP请求不同，没法用一个方法处理一个URL。Spring提供了<code>TextWebSocketHandler</code>和<code>BinaryWebSocketHandler</code>分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，<code>ChatHandler</code>需要继承自<code>TextWebSocketHandler</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChatHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">TextWebSocketHandler</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当浏览器请求一个WebSocket连接后，如果成功建立连接，Spring会自动调用<code>afterConnectionEstablished()</code>方法，任何原因导致WebSocket连接中断时，Spring会自动调用<code>afterConnectionClosed</code>方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChatHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">TextWebSocketHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 保存所有Client的WebSocket会话实例:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">Map</span>&lt;<span class=\"type\">String</span>, <span class=\"type\">WebSocketSession</span>&gt; clients = <span class=\"keyword\">new</span> <span class=\"type\">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public void afterConnectionEstablished(<span class=\"type\">WebSocketSession</span> session) <span class=\"keyword\">throws</span> <span class=\"type\">Exception</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 新会话根据ID放入Map:</span></span><br><span class=\"line\">        clients.put(session.getId(), session);</span><br><span class=\"line\">        session.getAttributes().put(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;Guest1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    public void afterConnectionClosed(<span class=\"type\">WebSocketSession</span> session, <span class=\"type\">CloseStatus</span> status) <span class=\"keyword\">throws</span> <span class=\"type\">Exception</span> &#123;</span><br><span class=\"line\">        clients.remove(session.getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每个WebSocket会话以<code>WebSocketSession</code>表示，且已分配唯一ID。和WebSocket相关的数据，例如用户名称等，均可放入关联的<code>getAttributes()</code>中。</p>\n<p>用实例变量<code>clients</code>持有当前所有的<code>WebSocketSession</code>是为了广播，即向所有用户推送同一消息时，可以这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String json =<span class=\"operator\"> ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>TextMessage message = <span class=\"keyword\">new</span> <span class=\"constructor\">TextMessage(<span class=\"params\">json</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String id : clients.key<span class=\"constructor\">Set()</span>) &#123;</span><br><span class=\"line\">    WebSocketSession session = clients.get(id);</span><br><span class=\"line\">    session.send<span class=\"constructor\">Message(<span class=\"params\">message</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们发送的消息是序列化后的JSON，可以用ChatMessage表示：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChatMessage</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">long</span> timestamp;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">String</span> text;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>每收到一个用户的消息后，我们就需要广播给所有用户：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChatHandler</span> <span class=\"keyword\">extends</span> <span class=\"title\">TextWebSocketHandler</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> void handleTextMessage(<span class=\"type\">WebSocketSession</span> session, <span class=\"type\">TextMessage</span> message) <span class=\"keyword\">throws</span> <span class=\"type\">Exception</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> s = message.getPayload();</span><br><span class=\"line\">        <span class=\"type\">String</span> r = ... <span class=\"comment\">// 根据输入消息构造待发送消息</span></span><br><span class=\"line\">        broadcastMessage(r); <span class=\"comment\">// 推送给所有用户</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要推送给指定的几个用户，那就需要在<code>clients</code>中根据条件查找出某些<code>WebSocketSession</code>，然后发送消息。</p>\n<p>注意到我们在注册WebSocket时还传入了一个<code>ChatHandshakeInterceptor</code>，这个类实际上可以从<code>HttpSessionHandshakeInterceptor</code>继承，它的主要作用是在WebSocket建立连接后，把HttpSession的一些属性复制到WebSocketSession，例如，用户的登录信息等：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ChatHandshakeInterceptor</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpSessionHandshakeInterceptor</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">ChatHandshakeInterceptor</span>() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 指定从HttpSession复制属性到WebSocketSession:</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>(<span class=\"type\">List</span>.of(<span class=\"type\">UserController</span>.<span class=\"type\">KEY_USER</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，在<code>ChatHandler</code>中，可以从<code>WebSocketSession.getAttributes()</code>中获取到复制过来的属性。</p>\n<h3 id=\"客户端开发\"><a href=\"#客户端开发\" class=\"headerlink\" title=\"客户端开发\"></a>客户端开发</h3><p>在完成了服务器端的开发后，我们还需要在页面编写一点JavaScript逻辑：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建WebSocket连接:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">&#x27;ws://&#x27;</span> + location.host + <span class=\"string\">&#x27;/chat&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 连接成功时:</span></span><br><span class=\"line\">ws.addEventListener(<span class=\"string\">&#x27;open&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;websocket connected.&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 收到消息时:</span></span><br><span class=\"line\">ws.addEventListener(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;message: &#x27;</span> + event.data);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> msgs = <span class=\"built_in\">JSON</span>.parse(event.data);</span><br><span class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span></span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 连接关闭时:</span></span><br><span class=\"line\">ws.addEventListener(<span class=\"string\">&#x27;close&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;websocket closed.&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 绑定到全局变量:</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.chatWs = ws;</span><br></pre></td></tr></table></figure>\n\n<p>用户可以在连接成功后任何时候给服务器发送消息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> inputText = <span class=\"string\">&#x27;Hello, WebSocket.&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.chatWs.send(<span class=\"built_in\">JSON</span>.stringify(&#123;<span class=\"attr\">text</span>: inputText&#125;));</span><br></pre></td></tr></table></figure>\n\n<p>最后，连调浏览器和服务器端，如果一切无误，可以开多个不同的浏览器测试WebSocket的推送和广播：</p>\n<p>![chat](2.Spring 5.assets&#x2F;l-164191502995819.png)</p>\n<p>和上一节我们介绍的异步处理类似，Servlet的线程模型并不适合大规模的长链接。基于NIO的Netty等框架更适合处理WebSocket长链接，我们将在后面介绍。</p>\n<h1 id=\"6-集成第三方组件\"><a href=\"#6-集成第三方组件\" class=\"headerlink\" title=\"6. 集成第三方组件\"></a>6. 集成第三方组件</h1><h2 id=\"6-0-简介\"><a href=\"#6-0-简介\" class=\"headerlink\" title=\"6.0 简介\"></a>6.0 简介</h2><p>Spring框架不仅提供了标准的IoC容器、AOP支持、数据库访问以及WebMVC等标准功能，还可以非常方便地集成许多常用的第三方组件：</p>\n<ul>\n<li>可以集成JavaMail发送邮件；</li>\n<li>可以集成JMS消息服务；</li>\n<li>可以集成Quartz实现定时任务；</li>\n<li>可以集成Redis等服务。</li>\n</ul>\n<p>本章我们介绍如何在Spring中简单快捷地集成这些第三方组件。</p>\n<h2 id=\"6-1-集成JavaMail\"><a href=\"#6-1-集成JavaMail\" class=\"headerlink\" title=\"6.1 集成JavaMail\"></a>6.1 集成JavaMail</h2><p>我们在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1319099923693601\">发送Email</a>和<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1319099948859426\">接收Email</a>中已经介绍了如何通过JavaMail来收发电子邮件。在Spring中，同样可以集成JavaMail。</p>\n<p>因为在服务器端，主要以发送邮件为主，例如在注册成功、登录时、购物付款后通知用户，基本上不会遇到接收用户邮件的情况，所以本节我们只讨论如何在Spring中发送邮件。</p>\n<p>在Spring中，发送邮件最终也是需要JavaMail，Spring只对JavaMail做了一点简单的封装，目的是简化代码。为了在Spring中集成JavaMail，我们在<code>pom.xml</code>中添加以下依赖：</p>\n<ul>\n<li>org.springframework:spring-context-support:5.2.0.RELEASE</li>\n<li>javax.mail:javax.mail-api:1.6.2</li>\n<li>com.sun.mail:javax.mail:1.6.2</li>\n</ul>\n<p>以及其他Web相关依赖。</p>\n<p>我们希望用户在注册成功后能收到注册邮件，为此，我们先定义一个<code>JavaMailSender</code>的Bean：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">JavaMailSender createJavaMailSender(</span><br><span class=\"line\">        <span class=\"comment\">// smtp.properties:</span></span><br><span class=\"line\">        <span class=\"meta\">@Value</span>(<span class=\"string\">&quot;<span class=\"subst\">$&#123;smtp.host&#125;</span>&quot;</span>) <span class=\"built_in\">String</span> host,</span><br><span class=\"line\">        <span class=\"meta\">@Value</span>(<span class=\"string\">&quot;<span class=\"subst\">$&#123;smtp.port&#125;</span>&quot;</span>) <span class=\"built_in\">int</span> port,</span><br><span class=\"line\">        <span class=\"meta\">@Value</span>(<span class=\"string\">&quot;<span class=\"subst\">$&#123;smtp.auth&#125;</span>&quot;</span>) <span class=\"built_in\">String</span> auth,</span><br><span class=\"line\">        <span class=\"meta\">@Value</span>(<span class=\"string\">&quot;<span class=\"subst\">$&#123;smtp.username&#125;</span>&quot;</span>) <span class=\"built_in\">String</span> username,</span><br><span class=\"line\">        <span class=\"meta\">@Value</span>(<span class=\"string\">&quot;<span class=\"subst\">$&#123;smtp.password&#125;</span>&quot;</span>) <span class=\"built_in\">String</span> password,</span><br><span class=\"line\">        <span class=\"meta\">@Value</span>(<span class=\"string\">&quot;<span class=\"subst\">$&#123;smtp.debug:<span class=\"keyword\">true</span>&#125;</span>&quot;</span>) <span class=\"built_in\">String</span> debug)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> mailSender = <span class=\"keyword\">new</span> JavaMailSenderImpl();</span><br><span class=\"line\">    mailSender.setHost(host);</span><br><span class=\"line\">    mailSender.setPort(port);</span><br><span class=\"line\">    mailSender.setUsername(username);</span><br><span class=\"line\">    mailSender.setPassword(password);</span><br><span class=\"line\">    Properties props = mailSender.getJavaMailProperties();</span><br><span class=\"line\">    props.put(<span class=\"string\">&quot;mail.transport.protocol&quot;</span>, <span class=\"string\">&quot;smtp&quot;</span>);</span><br><span class=\"line\">    props.put(<span class=\"string\">&quot;mail.smtp.auth&quot;</span>, auth);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (port == <span class=\"number\">587</span>) &#123;</span><br><span class=\"line\">        props.put(<span class=\"string\">&quot;mail.smtp.starttls.enable&quot;</span>, <span class=\"string\">&quot;true&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (port == <span class=\"number\">465</span>) &#123;</span><br><span class=\"line\">        props.put(<span class=\"string\">&quot;mail.smtp.socketFactory.port&quot;</span>, <span class=\"string\">&quot;465&quot;</span>);</span><br><span class=\"line\">        props.put(<span class=\"string\">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class=\"string\">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    props.put(<span class=\"string\">&quot;mail.debug&quot;</span>, debug);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mailSender;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>JavaMailSender</code>接口的实现类是<code>JavaMailSenderImpl</code>，初始化时，传入的参数与JavaMail是完全一致的。</p>\n<p>另外注意到需要注入的属性是从<code>smtp.properties</code>中读取的，因此，<code>AppConfig</code>导入的就不止一个<code>.properties</code>文件，可以导入多个：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(&#123; <span class=\"string\">&quot;classpath:/jdbc.properties&quot;</span>, <span class=\"string\">&quot;classpath:/smtp.properties&quot;</span> &#125;)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下一步是封装一个<code>MailService</code>，并定义<code>sendRegistrationMail()</code>方法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public <span class=\"keyword\">class</span> MailService &#123;</span><br><span class=\"line\">    @<span class=\"constructor\">Value(<span class=\"string\">&quot;$&#123;smtp.from&#125;&quot;</span>)</span></span><br><span class=\"line\">    String from;</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired</span><br><span class=\"line\">    JavaMailSender mailSender;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void send<span class=\"constructor\">RegistrationMail(User <span class=\"params\">user</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            MimeMessage mimeMessage = mailSender.create<span class=\"constructor\">MimeMessage()</span>;</span><br><span class=\"line\">            MimeMessageHelper helper = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeMessageHelper(<span class=\"params\">mimeMessage</span>, <span class=\"string\">&quot;utf-8&quot;</span>)</span>;</span><br><span class=\"line\">            helper.set<span class=\"constructor\">From(<span class=\"params\">from</span>)</span>;</span><br><span class=\"line\">            helper.set<span class=\"constructor\">To(<span class=\"params\">user</span>.<span class=\"params\">getEmail</span>()</span>);</span><br><span class=\"line\">            helper.set<span class=\"constructor\">Subject(<span class=\"string\">&quot;Welcome to Java course!&quot;</span>)</span>;</span><br><span class=\"line\">            String html = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>format(<span class=\"string\">&quot;&lt;p&gt;Hi, %s,&lt;/p&gt;&lt;p&gt;Welcome to Java course!&lt;/p&gt;&lt;p&gt;Sent at %s&lt;/p&gt;&quot;</span>, user.get<span class=\"constructor\">Name()</span>, <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocalDateTime</span>.</span></span>now<span class=\"literal\">()</span>);</span><br><span class=\"line\">            helper.set<span class=\"constructor\">Text(<span class=\"params\">html</span>, <span class=\"params\">true</span>)</span>;</span><br><span class=\"line\">            mailSender.send(mimeMessage);</span><br><span class=\"line\">        &#125; catch (MessagingException e) &#123;</span><br><span class=\"line\">            throw <span class=\"keyword\">new</span> <span class=\"constructor\">RuntimeException(<span class=\"params\">e</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察上述代码，<code>MimeMessage</code>是JavaMail的邮件对象，而<code>MimeMessageHelper</code>是Spring提供的用于简化设置MimeMessage的类，比如我们设置HTML邮件就可以直接调用<code>setText(String text, boolean html)</code>方法，而不必再调用比较繁琐的JavaMail接口方法。</p>\n<p>最后一步是调用<code>JavaMailSender.send()</code>方法把邮件发送出去。</p>\n<p>在MVC的某个Controller方法中，当用户注册成功后，我们就启动一个新线程来异步发送邮件：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">User user = userService.register(email, password, name);</span><br><span class=\"line\">logger.info(<span class=\"string\">&quot;user registered: &#123;&#125;&quot;</span>, user.get<span class=\"constructor\">Email()</span>);</span><br><span class=\"line\"><span class=\"comment\">// send registration mail:</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"constructor\">Thread(()</span> -&gt; &#123;</span><br><span class=\"line\">    mailService.send<span class=\"constructor\">RegistrationMail(<span class=\"params\">user</span>)</span>;</span><br><span class=\"line\">&#125;).start<span class=\"literal\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因为发送邮件是一种耗时的任务，从几秒到几分钟不等，因此，异步发送是保证页面能快速显示的必要措施。这里我们直接启动了一个新的线程，但实际上还有更优化的方法，我们在下一节讨论。</p>\n<h2 id=\"6-2-集成JMS\"><a href=\"#6-2-集成JMS\" class=\"headerlink\" title=\"6.2 集成JMS\"></a>6.2 集成JMS</h2><p>JMS即Java Message Service，是JavaEE的消息服务接口。JMS主要有两个版本：1.1和2.0。2.0和1.1相比，主要是简化了收发消息的代码。</p>\n<p>所谓消息服务，就是两个进程之间，通过消息服务器传递消息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌────────┐    ┌──────────────┐    ┌────────┐</span><br><span class=\"line\">│Producer│───&gt;│Message Server│───&gt;│Consumer│</span><br><span class=\"line\">└────────┘    └──────────────┘    └────────┘</span><br></pre></td></tr></table></figure>\n\n<p>使用消息服务，而不是直接调用对方的API，它的好处是：</p>\n<ul>\n<li>双方各自无需知晓对方的存在，消息可以异步处理，因为消息服务器会在Consumer离线的时候自动缓存消息；</li>\n<li>如果Producer发送的消息频率高于Consumer的处理能力，消息可以积压在消息服务器，不至于压垮Consumer；</li>\n<li>通过一个消息服务器，可以连接多个Producer和多个Consumer。</li>\n</ul>\n<p>因为消息服务在各类应用程序中非常有用，所以JavaEE专门定义了JMS规范。注意到JMS是一组接口定义，如果我们要使用JMS，还需要选择一个具体的JMS产品。常用的JMS服务器有开源的<a href=\"https://activemq.apache.org/\">ActiveMQ</a>，商业服务器如WebLogic、WebSphere等也内置了JMS支持。这里我们选择开源的ActiveMQ作为JMS服务器，因此，在开发JMS之前我们必须首先安装ActiveMQ。</p>\n<p>现在问题来了：从官网下载ActiveMQ时，蹦出一个页面，让我们选择ActiveMQ Classic或者ActiveMQ Artemis，这两个是什么关系，又有什么区别？</p>\n<p>实际上ActiveMQ Classic原来就叫ActiveMQ，是Apache开发的基于JMS 1.1的消息服务器，目前稳定版本号是5.x，而ActiveMQ Artemis是由RedHat捐赠的<a href=\"https://hornetq.jboss.org/\">HornetQ</a>服务器代码的基础上开发的，目前稳定版本号是2.x。和ActiveMQ Classic相比，Artemis版的代码与Classic完全不同，并且，它支持JMS 2.0，使用基于Netty的异步IO，大大提升了性能。此外，Artemis不仅提供了JMS接口，它还提供了AMQP接口，STOMP接口和物联网使用的MQTT接口。选择Artemis，相当于一鱼四吃。</p>\n<p>所以，我们这里直接选择ActiveMQ Artemis。从官网<a href=\"https://activemq.apache.org/components/artemis/download/\">下载</a>最新的2.x版本，解压后设置环境变量<code>ARTEMIS_HOME</code>，指向Artemis根目录，例如<code>C:\\Apps\\artemis</code>，然后，把<code>ARTEMIS_HOME/bin</code>加入PATH环境变量：</p>\n<ul>\n<li>Windows下添加<code>%ARTEMIS_HOME%\\bin</code>到Path路径；</li>\n<li>Mac和Linux下添加<code>$ARTEMIS_HOME/bin</code>到PATH路径。</li>\n</ul>\n<p>Artemis有个很好的设计，就是它把程序和数据完全分离了。我们解压后的<code>ARTEMIS_HOME</code>目录是程序目录，要启动一个Artemis服务，还需要创建一个数据目录。我们把数据目录直接设定在项目<code>spring-integration-jms</code>的<code>jms-data</code>目录下。执行命令<code>artemis create jms-data</code>：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ pwd</span><br><span class=\"line\">/Users/liaoxuefeng/workspace/spring-integration-jms</span><br><span class=\"line\"></span><br><span class=\"line\">$ artemis <span class=\"built_in\">create</span> jms-data</span><br><span class=\"line\">Creating ActiveMQ Artemis instance <span class=\"keyword\">at</span>: /Users/liaoxuefeng/workspace/spring-integration-jms/jms-data</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--user: is a mandatory property!</span></span><br><span class=\"line\">Please provide <span class=\"keyword\">the</span> default username:</span><br><span class=\"line\">admin</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--password: is mandatory with this configuration:</span></span><br><span class=\"line\">Please provide <span class=\"keyword\">the</span> default password:</span><br><span class=\"line\">********</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--allow-anonymous | --require-login: is a mandatory property!</span></span><br><span class=\"line\">Allow anonymous access?, valid values are Y,N,True,False</span><br><span class=\"line\">N</span><br><span class=\"line\"></span><br><span class=\"line\">Auto tuning journal ...</span><br><span class=\"line\">done! Your <span class=\"keyword\">system</span> can make <span class=\"number\">0.09</span> writes per <span class=\"built_in\">millisecond</span>, your journal-buffer-timeout will be <span class=\"number\">11392000</span></span><br><span class=\"line\"></span><br><span class=\"line\">You can now <span class=\"built_in\">start</span> <span class=\"keyword\">the</span> broker <span class=\"keyword\">by</span> executing:  </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"string\">&quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis&quot;</span> run</span><br><span class=\"line\"></span><br><span class=\"line\">Or you can run <span class=\"keyword\">the</span> broker <span class=\"keyword\">in</span> <span class=\"keyword\">the</span> background <span class=\"keyword\">using</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"string\">&quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis-service&quot;</span> <span class=\"built_in\">start</span></span><br></pre></td></tr></table></figure>\n\n<p>在创建过程中，会要求输入连接用户和口令，这里我们设定<code>admin</code>和<code>password</code>，以及是否允许匿名访问（这里选择<code>N</code>）。</p>\n<p>此数据目录<code>jms-data</code>不仅包含消息数据、日志，还自动创建了两个启动服务的命令<code>bin/artemis</code>和<code>bin/artemis-service</code>，前者在前台启动运行，按Ctrl+C结束，后者会一直在后台运行。</p>\n<p>我们把目录切换到<code>jms-data/bin</code>，直接运行<code>artemis run</code>即可启动Artemis服务：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ./artemis run</span><br><span class=\"line\">     <span class=\"symbol\">_</span>        <span class=\"symbol\">_</span>               <span class=\"symbol\">_</span></span><br><span class=\"line\">    / \\  ____| |<span class=\"symbol\">_</span>  ___ <span class=\"symbol\">__</span>  <span class=\"symbol\">__</span>(<span class=\"symbol\">_</span>) _____</span><br><span class=\"line\">   / <span class=\"symbol\">_</span> \\|  <span class=\"symbol\">_</span> \\ <span class=\"symbol\">__</span>|/ <span class=\"symbol\">_</span> \\  \\/  | |/  <span class=\"symbol\">__</span>/</span><br><span class=\"line\">  / ___ \\ | \\/ |<span class=\"symbol\">_</span>/  <span class=\"symbol\">__</span>/ |\\/| | |\\___ \\</span><br><span class=\"line\"> /<span class=\"symbol\">_</span>/   \\<span class=\"symbol\">_</span>\\|   \\<span class=\"symbol\">__</span>\\____|<span class=\"symbol\">_</span>|  |<span class=\"symbol\">_</span>|<span class=\"symbol\">_</span>|/___ /</span><br><span class=\"line\"> Apache ActiveMQ Artemis <span class=\"number\">2.13</span><span class=\"number\">.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">02</span> <span class=\"number\">07</span>:<span class=\"number\">50</span>:<span class=\"number\">21</span>,<span class=\"number\">718</span> INFO  [org.apache.activemq.artemis] AMQ241001: HTTP Server started <span class=\"built_in\">at</span> http://localhost:<span class=\"number\">8161</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">02</span> <span class=\"number\">07</span>:<span class=\"number\">50</span>:<span class=\"number\">21</span>,<span class=\"number\">718</span> INFO  [org.apache.activemq.artemis] AMQ241002: Artemis Jolokia REST API available <span class=\"built_in\">at</span> http://localhost:<span class=\"number\">8161</span>/console/jolokia</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">02</span> <span class=\"number\">07</span>:<span class=\"number\">50</span>:<span class=\"number\">21</span>,<span class=\"number\">719</span> INFO  [org.apache.activemq.artemis] AMQ241004: Artemis Console available <span class=\"built_in\">at</span> http://localhost:<span class=\"number\">8161</span>/console</span><br></pre></td></tr></table></figure>\n\n<p>启动成功后，Artemis提示可以通过URL<code>http://localhost:8161/console</code>访问管理后台。注意<em>不要关闭命令行窗口</em>。</p>\n<p>在编写JMS代码之前，我们首先得理解JMS的消息模型。JMS把生产消息的一方称为Producer，处理消息的一方称为Consumer。有两种类型的消息通道，一种是Queue：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌────────┐    ┌────────┐    ┌────────┐</span><br><span class=\"line\">│Producer│───&gt;│ Queue  │───&gt;│Consumer│</span><br><span class=\"line\">└────────┘    └────────┘    └────────┘</span><br></pre></td></tr></table></figure>\n\n<p>一种是Topic：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                            ┌────────┐</span><br><span class=\"line\">                         ┌─&gt;│Consumer│</span><br><span class=\"line\">                         │  └────────┘</span><br><span class=\"line\">┌────────┐    ┌────────┐ │  ┌────────┐</span><br><span class=\"line\">│Producer│───&gt;│ Topic  │─┼─&gt;│Consumer│</span><br><span class=\"line\">└────────┘    └────────┘ │  └────────┘</span><br><span class=\"line\">                         │  ┌────────┐</span><br><span class=\"line\">                         └─&gt;│Consumer│</span><br><span class=\"line\">                            └────────┘</span><br></pre></td></tr></table></figure>\n\n<p>它们的区别在于，Queue是一种一对一的通道，如果Consumer离线无法处理消息时，Queue会把消息存起来，等Consumer再次连接的时候发给它。设定了持久化机制的Queue不会丢失消息。如果有多个Consumer接入同一个Queue，那么它们等效于以集群方式处理消息，例如，发送方发送的消息是A，B，C，D，E，F，两个Consumer可能分别收到A，C，E和B，D，F，即每个消息只会交给其中一个Consumer处理。</p>\n<p>Topic则是一种一对多通道。一个Producer发出的消息，会被多个Consumer同时收到，即每个Consumer都会收到一份完整的消息流。那么问题来了：如果某个Consumer暂时离线，过一段时间后又上线了，那么在它离线期间产生的消息还能不能收到呢？</p>\n<p>这取决于消息服务器对Topic类型消息的持久化机制。如果消息服务器不存储Topic消息，那么离线的Consumer会丢失部分离线时期的消息，如果消息服务器存储了Topic消息，那么离线的Consumer可以收到自上次离线时刻开始后产生的所有消息。JMS规范通过Consumer指定一个持久化订阅可以在上线后收取所有离线期间的消息，如果指定的是非持久化订阅，那么离线期间的消息会全部丢失。</p>\n<p>细心的童鞋可以看出来，如果一个Topic的消息全部都持久化了，并且只有一个Consumer，那么它和Queue其实是一样的。实际上，很多消息服务器内部都只有Topic类型的消息架构，Queue可以通过Topic“模拟”出来。</p>\n<p>无论是Queue还是Topic，对Producer没有什么要求。多个Producer也可以写入同一个Queue或者Topic，此时消息服务器内部会自动排序确保消息总是有序的。</p>\n<p>以上是消息服务的基本模型。具体到某个消息服务器时，Producer和Consumer通常是通过TCP连接消息服务器，在编写JMS程序时，又会遇到<code>ConnectionFactory</code>、<code>Connection</code>、<code>Session</code>等概念，其实这和JDBC连接是类似的：</p>\n<ul>\n<li>ConnectionFactory：代表一个到消息服务器的连接池，类似JDBC的DataSource；</li>\n<li>Connection：代表一个到消息服务器的连接，类似JDBC的Connection；</li>\n<li>Session：代表一个经过认证后的连接会话；</li>\n<li>Message：代表一个消息对象。</li>\n</ul>\n<p>在JMS 1.1中，发送消息的典型代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    Connection connection = null;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 创建连接:</span></span><br><span class=\"line\">        connection = connectionFactory.create<span class=\"constructor\">Connection()</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 创建会话:</span></span><br><span class=\"line\">        Session session = connection.create<span class=\"constructor\">Session(<span class=\"params\">false</span>,Session.AUTO_ACKNOWLEDGE)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个Producer并关联到某个Queue:</span></span><br><span class=\"line\">        MessageProducer messageProducer = session.create<span class=\"constructor\">Producer(<span class=\"params\">queue</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 创建一个文本消息:</span></span><br><span class=\"line\">        TextMessage textMessage = session.create<span class=\"constructor\">TextMessage(<span class=\"params\">text</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 发送消息:</span></span><br><span class=\"line\">        messageProducer.send(textMessage);</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭连接:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (connection != null) &#123;</span><br><span class=\"line\">            connection.close<span class=\"literal\">()</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; catch (JMSException ex) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 处理JMS异常</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JMS 2.0改进了一些API接口，发送消息变得更简单：</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (JMSContext <span class=\"keyword\">context</span> = connectionFactory.createContext()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">context</span>.createProducer().send(queue, <span class=\"type\">text</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>JMSContext</code>实现了<code>AutoCloseable</code>接口，可以使用<code>try(resource)</code>语法，代码更简单。</p>\n<p>有了以上预备知识，我们就可以开始开发JMS应用了。</p>\n<p>首先，我们在<code>pom.xml</code>中添加如下依赖：</p>\n<ul>\n<li>org.springframework:spring-jms:5.2.0.RELEASE</li>\n<li>javax.jms:javax.jms-api:2.0.1</li>\n<li>org.apache.activemq:artemis-jms-client:2.13.0</li>\n<li>io.netty:netty-handler-proxy:4.1.45.Final</li>\n</ul>\n<p>在AppConfig中，通过<code>@EnableJms</code>让Spring自动扫描JMS相关的Bean，并加载JMS配置文件<code>jms.properties</code>：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"variable\">@EnableJms</span> <span class=\"comment\">// 启用JMS</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(&#123; <span class=\"string\">&quot;classpath:/jdbc.properties&quot;</span>, <span class=\"string\">&quot;classpath:/jms.properties&quot;</span> &#125;)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>首先要创建的Bean是ConnectionFactory，即连接消息服务器的连接池：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Bean</span></span><br><span class=\"line\">ConnectionFactory createJMSConnectionFactory(</span><br><span class=\"line\">    <span class=\"variable\">@Value</span>(<span class=\"string\">&quot;$&#123;jms.uri:tcp://localhost:61616&#125;&quot;</span>) String uri,</span><br><span class=\"line\">    <span class=\"variable\">@Value</span>(<span class=\"string\">&quot;$&#123;jms.username:admin&#125;&quot;</span>) String username,</span><br><span class=\"line\">    <span class=\"variable\">@Value</span>(<span class=\"string\">&quot;$&#123;jms.password:password&#125;&quot;</span>) String password)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">ActiveMQJMSConnectionFactory</span>(uri, username, password);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为我们使用的消息服务器是ActiveMQ Artemis，所以<code>ConnectionFactory</code>的实现类就是消息服务器提供的<code>ActiveMQJMSConnectionFactory</code>，它需要的参数均由配置文件读取后传入，并设置了默认值。</p>\n<p>我们再创建一个<code>JmsTemplate</code>，它是Spring提供的一个工具类，和<code>JdbcTemplate</code>类似，可以简化发送消息的代码：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Bean</span></span><br><span class=\"line\">JmsTemplate createJmsTemplate(<span class=\"variable\">@Autowired</span> ConnectionFactory connectionFactory) &#123;</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">new</span> <span class=\"selector-tag\">JmsTemplate</span>(connectionFactory);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下一步要创建的是<code>JmsListenerContainerFactory</code>，</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span>(<span class=\"string\">&quot;jmsListenerContainerFactory&quot;</span>)</span><br><span class=\"line\">DefaultJmsListenerContainerFactory createJmsListenerContainerFactory(<span class=\"meta\">@Autowired</span> ConnectionFactory connectionFactory) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> <span class=\"keyword\">factory</span> = <span class=\"keyword\">new</span> DefaultJmsListenerContainerFactory();</span><br><span class=\"line\">    <span class=\"keyword\">factory</span>.setConnectionFactory(connectionFactory);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">factory</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>除了必须指定Bean的名称为<code>jmsListenerContainerFactory</code>外，这个Bean的作用是处理和Consumer相关的Bean。我们先跳过它的原理，继续编写<code>MessagingService</code>来发送消息：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessagingService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> ObjectMapper objectMapper;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> JmsTemplate jmsTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sendMailMessage</span><span class=\"params\">(MailMessage msg)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String text = objectMapper.writeValueAsString(msg);</span><br><span class=\"line\">        jmsTemplate.send(<span class=\"string\">&quot;jms/queue/mail&quot;</span>, <span class=\"keyword\">new</span> MessageCreator() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"function\">Message <span class=\"title\">createMessage</span><span class=\"params\">(Session session)</span> <span class=\"keyword\">throws</span> JMSException </span>&#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">return</span> session.<span class=\"title\">createTextMessage</span><span class=\"params\">(text)</span></span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>JMS的消息类型支持以下几种：</p>\n<ul>\n<li>TextMessage：文本消息；</li>\n<li>BytesMessage：二进制消息；</li>\n<li>MapMessage：包含多个Key-Value对的消息；</li>\n<li>ObjectMessage：直接序列化Java对象的消息；</li>\n<li>StreamMessage：一个包含基本类型序列的消息。</li>\n</ul>\n<p>最常用的是发送基于JSON的文本消息，上述代码通过<code>JmsTemplate</code>创建一个<code>TextMessage</code>并发送到名称为<code>jms/queue/mail</code>的Queue。</p>\n<p>注意：Artemis消息服务器默认配置下会自动创建Queue，因此不必手动创建一个名为<code>jms/queue/mail</code>的Queue，但不是所有的消息服务器都会自动创建Queue，生产环境的消息服务器通常会关闭自动创建功能，需要手动创建Queue。</p>\n<p>再注意到<code>MailMessage</code>是我们自己定义的一个JavaBean，真正的JMS消息是创建的<code>TextMessage</code>，它的内容是JSON。</p>\n<p>当用户注册成功后，我们就调用<code>MessagingService.sendMailMessage()</code>发送一条JMS消息，此代码十分简单，这里不再贴出。</p>\n<p>下面我们要详细讨论的是如何处理消息，即编写Consumer。从理论上讲，可以创建另一个Java进程来处理消息，但对于我们这个简单的Web程序来说没有必要，直接在同一个Web应用中接收并处理消息即可。</p>\n<p>处理消息的核心代码是编写一个Bean，并在处理方法上标注<code>@JmsListener</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">@Component</span><br><span class=\"line\">public <span class=\"keyword\">class</span> MailMessageListener &#123;</span><br><span class=\"line\">    final Logger logger = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LoggerFactory</span>.</span></span>get<span class=\"constructor\">Logger(<span class=\"params\">getClass</span>()</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    @Autowired ObjectMapper objectMapper;</span><br><span class=\"line\">    @Autowired MailService mailService;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"constructor\">JmsListener(<span class=\"params\">destination</span> = <span class=\"string\">&quot;jms/queue/mail&quot;</span>, <span class=\"params\">concurrency</span> = <span class=\"string\">&quot;10&quot;</span>)</span></span><br><span class=\"line\">    public void on<span class=\"constructor\">MailMessageReceived(Message <span class=\"params\">message</span>)</span> throws Exception &#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;received message: &quot;</span> + message);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (message instanceof TextMessage) &#123;</span><br><span class=\"line\">            String text = ((TextMessage) message).get<span class=\"constructor\">Text()</span>;</span><br><span class=\"line\">            MailMessage mm = objectMapper.read<span class=\"constructor\">Value(<span class=\"params\">text</span>, MailMessage.<span class=\"params\">class</span>)</span>;</span><br><span class=\"line\">            mailService.send<span class=\"constructor\">RegistrationMail(<span class=\"params\">mm</span>)</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            logger.error(<span class=\"string\">&quot;unable to process non-text message!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>@JmsListener</code>指定了Queue的名称，因此，凡是发到此Queue的消息都会被这个<code>onMailMessageReceived()</code>方法处理，方法参数是JMS的<code>Message</code>接口，我们通过强制转型为<code>TextMessage</code>并提取JSON，反序列化后获得自定义的JavaBean，也就获得了发送邮件所需的所有信息。</p>\n<p>下面问题来了：Spring处理JMS消息的流程是什么？</p>\n<p>如果我们直接调用JMS的API来处理消息，那么编写的代码大致如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建JMS连接:</span></span><br><span class=\"line\">Connection connection = connectionFactory.create<span class=\"constructor\">Connection()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 创建会话:</span></span><br><span class=\"line\">Session session = connection.create<span class=\"constructor\">Session(<span class=\"params\">false</span>, Session.AUTO_ACKNOWLEDGE)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 创建一个Consumer:</span></span><br><span class=\"line\">MessageConsumer consumer = session.create<span class=\"constructor\">Consumer(<span class=\"params\">queue</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 为Consumer指定一个消息处理器:</span></span><br><span class=\"line\">consumer.set<span class=\"constructor\">MessageListener(<span class=\"params\">new</span> MessageListener()</span> &#123; </span><br><span class=\"line\">    public void on<span class=\"constructor\">Message(Message <span class=\"params\">message</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 在此处理消息... </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 启动接收消息的循环:</span></span><br><span class=\"line\">connection.start<span class=\"literal\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我们自己编写的<code>MailMessageListener.onMailMessageReceived()</code>相当于消息处理器：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">consumer.setMessageListener(<span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">MessageListener</span>(<span class=\"params\"></span>)</span> &#123; </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">onMessage</span>(<span class=\"params\">Message message</span>)</span> &#123;</span><br><span class=\"line\">        mailMessageListener.onMailMessageReceived(message); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>所以，Spring根据<code>AppConfig</code>的注解<code>@EnableJms</code>自动扫描带有<code>@JmsListener</code>的Bean方法，并为其创建一个<code>MessageListener</code>把它包装起来。</p>\n<p>注意到前面我们还创建了一个<code>JmsListenerContainerFactory</code>的Bean，它的作用就是为每个<code>MessageListener</code>创建<code>MessageConsumer</code>并启动消息接收循环。</p>\n<p>再注意到<code>@JmsListener</code>还有一个<code>concurrency</code>参数，10表示可以最多同时并发处理10个消息，<code>5-10</code>表示并发处理的线程可以在5~10之间调整。</p>\n<p>因此，Spring在通过<code>MessageListener</code>接收到消息后，并不是直接调用<code>mailMessageListener.onMailMessageReceived()</code>，而是用线程池调用，因此，要时刻牢记，<code>onMailMessageReceived()</code>方法可能被多线程并发执行，一定要保证线程安全。</p>\n<p>我们总结一下Spring接收消息的步骤：</p>\n<p>通过<code>JmsListenerContainerFactory</code>配合<code>@EnableJms</code>扫描所有<code>@JmsListener</code>方法，自动创建<code>MessageConsumer</code>、<code>MessageListener</code>以及线程池，启动消息循环接收处理消息，最终由我们自己编写的<code>@JmsListener</code>方法处理消息，可能会由多线程同时并发处理。</p>\n<p>要验证消息发送和处理，我们注册一个新用户，可以看到如下日志输出：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">02</span> <span class=\"number\">08</span>:<span class=\"number\">04</span>:<span class=\"number\">27</span> INFO  c<span class=\"selector-class\">.i</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.web</span><span class=\"selector-class\">.UserController</span> - user registered: bob@example<span class=\"selector-class\">.com</span></span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">02</span> <span class=\"number\">08</span>:<span class=\"number\">04</span>:<span class=\"number\">27</span> INFO  c<span class=\"selector-class\">.i</span><span class=\"selector-class\">.l</span><span class=\"selector-class\">.service</span><span class=\"selector-class\">.MailMessageListener</span> - received message: ActiveMQMessage<span class=\"selector-attr\">[ID:9fc5...]</span>:PERSISTENT/ClientMessageImpl<span class=\"selector-attr\">[messageID=983, durable=true, address=jms/queue/mail, ...]</span>]</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">02</span> <span class=\"number\">08</span>:<span class=\"number\">04</span>:<span class=\"number\">27</span> INFO  c<span class=\"selector-class\">.i</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.service</span><span class=\"selector-class\">.MailService</span> - <span class=\"selector-attr\">[send mail]</span> sending registration mail to bob@example<span class=\"selector-class\">.com</span>...</span><br><span class=\"line\"><span class=\"number\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">02</span> <span class=\"number\">08</span>:<span class=\"number\">04</span>:<span class=\"number\">30</span> INFO  c<span class=\"selector-class\">.i</span><span class=\"selector-class\">.learnjava</span><span class=\"selector-class\">.service</span><span class=\"selector-class\">.MailService</span> - <span class=\"selector-attr\">[send mail]</span> registration mail was sent to bob@example<span class=\"selector-class\">.com</span>.</span><br></pre></td></tr></table></figure>\n\n<p>可见，消息被成功发送到Artemis，然后在很短的时间内被接收处理了。</p>\n<p>使用消息服务对发送Email进行改造的好处是，发送Email的能力通常是有限的，通过JMS消息服务，如果短时间内需要给大量用户发送Email，可以先把消息堆积在JMS服务器上慢慢发送，对于批量发送邮件、短信等尤其有用。</p>\n<h2 id=\"6-3-使用Scheduler\"><a href=\"#6-3-使用Scheduler\" class=\"headerlink\" title=\"6.3 使用Scheduler\"></a>6.3 使用Scheduler</h2><p>在很多应用程序中，经常需要执行定时任务。例如，每天或每月给用户发送账户汇总报表，定期检查并发送系统状态报告，等等。</p>\n<p>定时任务我们在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849\">使用线程池</a>一节中已经讲到了，Java标准库本身就提供了定时执行任务的功能。在Spring中，使用定时任务更简单，不需要手写线程池相关代码，只需要两个注解即可。</p>\n<p>我们还是以实际代码为例，建立工程<code>spring-integration-schedule</code>，无需额外的依赖，我们可以直接在<code>AppConfig</code>中加上<code>@EnableScheduling</code>就开启了定时任务的支持：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"variable\">@EnableScheduling</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(&#123; <span class=\"string\">&quot;classpath:/jdbc.properties&quot;</span>, <span class=\"string\">&quot;classpath:/task.properties&quot;</span> &#125;)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，我们可以直接在一个Bean中编写一个<code>public void</code>无参数方法，然后加上<code>@Scheduled</code>注解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(initialDelay = 60_000, fixedRate = 60_000)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkSystemStatusEveryMinute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;Start check system status...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述注解指定了启动延迟60秒，并以60秒的间隔执行任务。现在，我们直接运行应用程序，就可以在控制台看到定时任务打印的日志：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">2020-06-03 18:47:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start<span class=\"built_in\"> check </span>system status...</span><br><span class=\"line\">2020-06-03 18:48:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start<span class=\"built_in\"> check </span>system status...</span><br><span class=\"line\">2020-06-03 18:49:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start<span class=\"built_in\"> check </span>system status...</span><br></pre></td></tr></table></figure>\n\n<p>如果没有看到定时任务的日志，需要检查：</p>\n<ul>\n<li>是否忘记了在<code>AppConfig</code>中标注<code>@EnableScheduling</code>；</li>\n<li>是否忘记了在定时任务的方法所在的class标注<code>@Component</code>。</li>\n</ul>\n<p>除了可以使用<code>fixedRate</code>外，还可以使用<code>fixedDelay</code>，两者的区别我们已经在<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849\">使用线程池</a>一节中讲过，这里不再重复。</p>\n<p>有的童鞋在实际开发中会遇到一个问题，因为Java的注解全部是常量，写死了<code>fixedDelay=30000</code>，如果根据实际情况要改成60秒怎么办，只能重新编译？</p>\n<p>我们可以把定时任务的配置放到配置文件中，例如<code>task.properties</code>：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">task.checkDiskSpace</span>=<span class=\"number\">30000</span></span><br></pre></td></tr></table></figure>\n\n<p>这样就可以随时修改配置文件而无需动代码。但是在代码中，我们需要用<code>fixedDelayString</code>取代<code>fixedDelay</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskService</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:30000&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">checkDiskSpaceEveryMinute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;Start check disk space...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到上述代码的注解参数<code>fixedDelayString</code>是一个属性占位符，并配有默认值30000，Spring在处理<code>@Scheduled</code>注解时，如果遇到<code>String</code>，会根据占位符自动用配置项替换，这样就可以灵活地修改定时任务的配置。</p>\n<p>此外，<code>fixedDelayString</code>还可以使用更易读的<code>Duration</code>，例如：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Scheduled(initialDelay = 30_000, fixedDelayString = <span class=\"meta-string\">&quot;<span class=\"subst\">$&#123;task.checkDiskSpace:PT2M30S&#125;</span>&quot;</span>)</span></span><br></pre></td></tr></table></figure>\n\n<p>以字符串<code>PT2M30S</code>表示的<code>Duration</code>就是2分30秒，请参考<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1303871087444002\">LocalDateTime</a>一节的Duration相关部分。</p>\n<p>多个<code>@Scheduled</code>方法完全可以放到一个Bean中，这样便于统一管理各类定时任务。</p>\n<h3 id=\"使用Cron任务\"><a href=\"#使用Cron任务\" class=\"headerlink\" title=\"使用Cron任务\"></a>使用Cron任务</h3><p>还有一类定时任务，它不是简单的重复执行，而是按时间触发，我们把这类任务称为Cron任务，例如：</p>\n<ul>\n<li>每天凌晨2:15执行报表任务；</li>\n<li>每个工作日12:00执行特定任务；</li>\n<li>……</li>\n</ul>\n<p>Cron源自Unix&#x2F;Linux系统自带的crond守护进程，以一个简洁的表达式定义任务触发时间。在Spring中，也可以使用Cron表达式来执行Cron任务，在Spring中，它的格式是：</p>\n<figure class=\"highlight\"><table><tr><td class=\"code\"><pre><span class=\"line\">秒 分 小时 天 月份 星期 年</span><br></pre></td></tr></table></figure>\n\n<p>年是可以忽略的，通常不写。每天凌晨2:15执行的Cron表达式就是：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">0 </span><span class=\"number\">15</span> <span class=\"number\">2</span> * * *</span><br></pre></td></tr></table></figure>\n\n<p>每个工作日12:00执行的Cron表达式就是：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">0 </span><span class=\"number\">0</span> <span class=\"number\">12</span> * * MON-FRI</span><br></pre></td></tr></table></figure>\n\n<p>每个月1号，2号，3号和10号12:00执行的Cron表达式就是：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">0 </span><span class=\"number\">0</span> <span class=\"number\">12</span> <span class=\"number\">1</span>-<span class=\"number\">3</span>,<span class=\"number\">10</span> * *</span><br></pre></td></tr></table></figure>\n\n<p>在Spring中，我们定义一个每天凌晨2:15执行的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskService</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(cron = &quot;$&#123;task.report:0 15 2 * * *&#125;&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">cronDailyReport</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;Start daily report task...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Cron任务同样可以使用属性占位符，这样修改起来更加方便。</p>\n<p>Cron表达式还可以表达每10分钟执行，例如：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">0 </span>*/<span class=\"number\">10</span> * * * *</span><br></pre></td></tr></table></figure>\n\n<p>这样，在每个小时的0:00，10:00，20:00，30:00，40:00，50:00均会执行任务，实际上它可以取代<code>fixedRate</code>类型的定时任务。</p>\n<h3 id=\"集成Quartz\"><a href=\"#集成Quartz\" class=\"headerlink\" title=\"集成Quartz\"></a>集成Quartz</h3><p>在Spring中使用定时任务和Cron任务都十分简单，但是要注意到，这些任务的调度都是在每个JVM进程中的。如果在本机启动两个进程，或者在多台机器上启动应用，这些进程的定时任务和Cron任务都是独立运行的，互不影响。</p>\n<p>如果一些定时任务要以集群的方式运行，例如每天23:00执行检查任务，只需要集群中的一台运行即可，这个时候，可以考虑使用<a href=\"https://www.quartz-scheduler.org/\">Quartz</a>。</p>\n<p>Quartz可以配置一个JDBC数据源，以便存储所有的任务调度计划以及任务执行状态。也可以使用内存来调度任务，但这样配置就和使用Spring的调度没啥区别了，额外集成Quartz的意义就不大。</p>\n<p>Quartz的JDBC配置比较复杂，Spring对其也有一定的支持。要详细了解Quartz的集成，请参考<a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-quartz\">Spring的文档</a>。</p>\n<p>思考：如果不使用Quartz的JDBC配置，多个Spring应用同时运行时，如何保证某个任务只在某一台机器执行？</p>\n<h2 id=\"6-4-集成JMX\"><a href=\"#6-4-集成JMX\" class=\"headerlink\" title=\"6.4 集成JMX\"></a>6.4 集成JMX</h2><p>在Spring中，可以方便地集成JMX。</p>\n<p>那么第一个问题来了：什么是JMX？</p>\n<p>JMX是Java Management Extensions，它是一个Java平台的管理和监控接口。为什么要搞JMX呢？因为在所有的应用程序中，对运行中的程序进行监控都是非常重要的，Java应用程序也不例外。我们肯定希望知道Java应用程序当前的状态，例如，占用了多少内存，分配了多少内存，当前有多少活动线程，有多少休眠线程等等。如何获取这些信息呢？</p>\n<p>为了标准化管理和监控，Java平台使用JMX作为管理和监控的标准接口，任何程序，只要按JMX规范访问这个接口，就可以获取所有管理与监控信息。</p>\n<p>实际上，常用的运维监控如Zabbix、Nagios等工具对JVM本身的监控都是通过JMX获取的信息。</p>\n<p>因为JMX是一个标准接口，不但可以用于管理JVM，还可以管理应用程序自身。下图是JMX的架构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    ┌─────────┐  ┌─────────┐</span><br><span class=\"line\">    │jconsole │  │   Web   │</span><br><span class=\"line\">    └─────────┘  └─────────┘</span><br><span class=\"line\">         │            │</span><br><span class=\"line\">┌ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─</span><br><span class=\"line\"> JVM     ▼            ▼        │</span><br><span class=\"line\">│   ┌─────────┐  ┌─────────┐</span><br><span class=\"line\">  ┌─┤Connector├──┤ Adaptor ├─┐ │</span><br><span class=\"line\">│ │ └─────────┘  └─────────┘ │</span><br><span class=\"line\">  │       MBeanServer        │ │</span><br><span class=\"line\">│ │ ┌──────┐┌──────┐┌──────┐ │</span><br><span class=\"line\">  └─┤MBean1├┤MBean2├┤MBean3├─┘ │</span><br><span class=\"line\">│   └──────┘└──────┘└──────┘</span><br><span class=\"line\"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>JMX把所有被管理的资源都称为MBean（Managed Bean），这些MBean全部由MBeanServer管理，如果要访问MBean，可以通过MBeanServer对外提供的访问接口，例如通过RMI或HTTP访问。</p>\n<p>注意到使用JMX不需要安装任何额外组件，也不需要第三方库，因为MBeanServer已经内置在JavaSE标准库中了。JavaSE还提供了一个<code>jconsole</code>程序，用于通过RMI连接到MBeanServer，这样就可以管理整个Java进程。</p>\n<p>除了JVM会把自身的各种资源以MBean注册到JMX中，我们自己的配置、监控信息也可以作为MBean注册到JMX，这样，管理程序就可以直接控制我们暴露的MBean。因此，应用程序使用JMX，只需要两步：</p>\n<ol>\n<li>编写MBean提供管理接口和监控数据；</li>\n<li>注册MBean。</li>\n</ol>\n<p>在Spring应用程序中，使用JMX只需要一步：</p>\n<ol>\n<li>编写MBean提供管理接口和监控数据。</li>\n</ol>\n<p>第二步注册的过程由Spring自动完成。我们以实际工程为例，首先在<code>AppConfig</code>中加上<code>@EnableMBeanExport</code>注解，告诉Spring自动注册MBean：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">@Configuration</span></span><br><span class=\"line\"><span class=\"variable\">@ComponentScan</span></span><br><span class=\"line\"><span class=\"variable\">@EnableWebMvc</span></span><br><span class=\"line\"><span class=\"variable\">@EnableMBeanExport</span> <span class=\"comment\">// 自动注册MBean</span></span><br><span class=\"line\"><span class=\"variable\">@EnableTransactionManagement</span></span><br><span class=\"line\"><span class=\"variable\">@PropertySource</span>(&#123; <span class=\"string\">&quot;classpath:/jdbc.properties&quot;</span> &#125;)</span><br><span class=\"line\">public class AppConfig &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>剩下的全部工作就是编写MBean。我们以实际问题为例，假设我们希望给应用程序添加一个IP黑名单功能，凡是在黑名单中的IP禁止访问，传统的做法是定义一个配置文件，启动的时候读取：</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"code\"><pre><span class=\"line\"># blacklist.txt</span><br><span class=\"line\"><span class=\"number\">1.2.3.4</span></span><br><span class=\"line\"><span class=\"number\">5.6.7.8</span></span><br><span class=\"line\"><span class=\"number\">2.2.3.4</span></span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>如果要修改黑名单怎么办？修改配置文件，然后重启应用程序。</p>\n<p>但是每次都重启应用程序实在是太麻烦了，能不能不重启应用程序？可以自己写一个定时读取配置文件的功能，检测到文件改动时自动重新读取。</p>\n<p>上述需求本质上是在应用程序运行期间对参数、配置等进行热更新并要求尽快生效。如果以JMX的方式实现，我们不必自己编写自动重新读取等任何代码，只需要提供一个符合JMX标准的MBean来存储配置即可。</p>\n<p>还是以IP黑名单为例，JMX的MBean通常以MBean结尾，因此我们遵循标准命名规范，首先编写一个<code>BlacklistMBean</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlacklistMBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt; ips = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span>[] <span class=\"function\"><span class=\"title\">getBlacklist</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ips.toArray(<span class=\"built_in\">String</span>[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">addBlacklist</span>(<span class=\"params\"><span class=\"built_in\">String</span> ip</span>)</span> &#123;</span><br><span class=\"line\">        ips.add(ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">removeBlacklist</span>(<span class=\"params\"><span class=\"built_in\">String</span> ip</span>)</span> &#123;</span><br><span class=\"line\">        ips.remove(ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">shouldBlock</span>(<span class=\"params\"><span class=\"built_in\">String</span> ip</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ips.contains(ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个MBean没什么特殊的，它的逻辑和普通Java类没有任何区别。</p>\n<p>下一步，我们要使用JMX的客户端来实时热更新这个MBean，所以要给它加上一些注解，让Spring能根据注解自动把相关方法注册到MBeanServer中：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@ManagedResource</span>(objectName = <span class=\"string\">&quot;sample:name=blacklist&quot;</span>, description = <span class=\"string\">&quot;Blacklist of IP addresses&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlacklistMBean</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt; ips = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManagedAttribute</span>(description = <span class=\"string\">&quot;Get IP addresses in blacklist&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span>[] <span class=\"function\"><span class=\"title\">getBlacklist</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ips.toArray(<span class=\"built_in\">String</span>[]::<span class=\"keyword\">new</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManagedOperation</span></span><br><span class=\"line\">    <span class=\"meta\">@ManagedOperationParameter</span>(name = <span class=\"string\">&quot;ip&quot;</span>, description = <span class=\"string\">&quot;Target IP address that will be added to blacklist&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">addBlacklist</span>(<span class=\"params\"><span class=\"built_in\">String</span> ip</span>)</span> &#123;</span><br><span class=\"line\">        ips.add(ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManagedOperation</span></span><br><span class=\"line\">    <span class=\"meta\">@ManagedOperationParameter</span>(name = <span class=\"string\">&quot;ip&quot;</span>, description = <span class=\"string\">&quot;Target IP address that will be removed from blacklist&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">removeBlacklist</span>(<span class=\"params\"><span class=\"built_in\">String</span> ip</span>)</span> &#123;</span><br><span class=\"line\">        ips.remove(ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">boolean</span> <span class=\"function\"><span class=\"title\">shouldBlock</span>(<span class=\"params\"><span class=\"built_in\">String</span> ip</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ips.contains(ip);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察上述代码，<code>BlacklistMBean</code>首先是一个标准的Spring管理的Bean，其次，添加了<code>@ManagedResource</code>表示这是一个MBean，将要被注册到JMX。objectName指定了这个MBean的名字，通常以<code>company:name=Xxx</code>来分类MBean。</p>\n<p>对于属性，使用<code>@ManagedAttribute</code>注解标注。上述MBean只有get属性，没有set属性，说明这是一个只读属性。</p>\n<p>对于操作，使用<code>@ManagedOperation</code>注解标准。上述MBean定义了两个操作：<code>addBlacklist()</code>和<code>removeBlacklist()</code>，其他方法如<code>shouldBlock()</code>不会被暴露给JMX。</p>\n<p>使用MBean和普通Bean是完全一样的。例如，我们在<code>BlacklistInterceptor</code>对IP进行黑名单拦截：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Order(1)</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BlacklistInterceptor</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    BlacklistMBean blacklistMBean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">preHandle</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        String ip = request.getRemoteAddr();</span><br><span class=\"line\">        logger.info(<span class=\"string\">&quot;check ip address &#123;&#125;...&quot;</span>, ip);</span><br><span class=\"line\">        <span class=\"comment\">// 是否在黑名单中:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (blacklistMBean.shouldBlock(ip)) &#123;</span><br><span class=\"line\">            logger.warn(<span class=\"string\">&quot;will block ip &#123;&#125; for it is in blacklist.&quot;</span>, ip);</span><br><span class=\"line\">            <span class=\"comment\">// 发送403错误响应:</span></span><br><span class=\"line\">            response.sendError(<span class=\"number\">403</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下一步就是正常启动Web应用程序，不要关闭它，我们打开另一个命令行窗口，输入<code>jconsole</code>启动JavaSE自带的一个JMX客户端程序：</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/1352171687772226/l\" alt=\"jconsole\"></p>\n<p>通过jconsole连接到一个Java进程最简单的方法是直接在Local Process中找到正在运行的<code>AppConfig</code>，点击Connect即可连接到我们当前正在运行的Web应用，在jconsole中可直接看到内存、CPU等资源的监控。</p>\n<p>我们点击MBean，左侧按分类列出所有MBean，可以在<code>java.lang</code>查看内存等信息：</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/1352171742298178/l\" alt=\"mbean\"></p>\n<p>细心的童鞋可以看到HikariCP连接池也是通过JMX监控的。</p>\n<p>在<code>sample</code>中可以看到我们自己的MBean，点击可查看属性<code>blacklist</code>：</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/1352172098814018/l\" alt=\"mbean-value\"></p>\n<p>点击<code>Operations</code>-<code>addBlacklist</code>，可以填入<code>127.0.0.1</code>并点击<code>addBlacklist</code>按钮，相当于jconsole通过JMX接口，调用了我们自己的<code>BlacklistMBean</code>的<code>addBlacklist()</code>方法，传入的参数就是填入的<code>127.0.0.1</code>：</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/1352172147048514/l\" alt=\"mbean-invoke-ok\"></p>\n<p>再次查看属性<code>blacklist</code>，可以看到结果已经更新了：</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/1352172193185858/l\" alt=\"mbean-modified\"></p>\n<p>我们可以在浏览器中测试一下黑名单功能是否已生效：</p>\n<p><img src=\"https://www.liaoxuefeng.com/files/attachments/1352172895731745/l\" alt=\"403\"></p>\n<p>可见，<code>127.0.0.1</code>确实被添加到了黑名单，后台日志打印如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">06</span> <span class=\"number\">20</span>:<span class=\"number\">22</span>:<span class=\"number\">12</span> INFO  c.i.l.web.BlacklistInterceptor - check ip address <span class=\"number\">127.0.0.1</span>...</span><br><span class=\"line\"><span class=\"attribute\">2020</span>-<span class=\"number\">06</span>-<span class=\"number\">06</span> <span class=\"number\">20</span>:<span class=\"number\">22</span>:<span class=\"number\">12</span> WARN  c.i.l.web.BlacklistInterceptor - will block ip <span class=\"number\">127.0.0.1</span> for it is in blacklist.</span><br></pre></td></tr></table></figure>\n\n<p>注意：如果使用IPv6，那么需要把<code>0:0:0:0:0:0:0:1</code>这个本机地址加到黑名单。</p>\n<p>如果从jconsole中调用<code>removeBlacklist</code>移除<code>127.0.0.1</code>，刷新浏览器可以看到又允许访问了。</p>\n<p>使用jconsole直接通过Local Process连接JVM有个限制，就是jconsole和正在运行的JVM必须在同一台机器。如果要远程连接，首先要打开JMX端口。我们在启动<code>AppConfig</code>时，需要传入以下JVM启动参数：</p>\n<ul>\n<li>-Dcom.sun.management.jmxremote.port&#x3D;19999</li>\n<li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false</li>\n<li>-Dcom.sun.management.jmxremote.ssl&#x3D;false</li>\n</ul>\n<p>第一个参数表示在19999端口监听JMX连接，第二个和第三个参数表示无需验证，不使用SSL连接，在开发测试阶段比较方便，生产环境必须指定验证方式并启用SSL。详细参数可参考Oracle<a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html#gdeum\">官方文档</a>。这样jconsole可以用<code>ip:19999</code>的远程方式连接JMX。连接后的操作是完全一样的。</p>\n<p>许多JavaEE服务器如JBoss的管理后台都是通过JMX提供管理接口，并由Web方式访问，对用户更加友好。</p>\n","categories":["Java","4.开发框架","2.Spring 5"],"tags":["写作"]},{"title":"6.SpringBoot 2","url":"/2022/02/04/4-Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_6.SpringBoot%202/","content":"<h1 id=\"描述：简化-Spring-应用的初始搭建以及开发过程，提高效率\"><a href=\"#描述：简化-Spring-应用的初始搭建以及开发过程，提高效率\" class=\"headerlink\" title=\"描述：简化. Spring. 应用的初始搭建以及开发过程，提高效率\"></a>描述：简化. Spring. 应用的初始搭建以及开发过程，提高效率</h1><h1 id=\"常用注解\"><a href=\"#常用注解\" class=\"headerlink\" title=\"常用注解\"></a>常用注解</h1><h1 id=\"资源整合\"><a href=\"#资源整合\" class=\"headerlink\" title=\"资源整合\"></a>资源整合</h1><h1 id=\"高级特性\"><a href=\"#高级特性\" class=\"headerlink\" title=\"高级特性\"></a>高级特性</h1><h1 id=\"本地热部署\"><a href=\"#本地热部署\" class=\"headerlink\" title=\"本地热部署\"></a>本地热部署</h1>","categories":["Java","4.开发框架","6.SpringBoot 2"],"tags":["写作"]},{"title":"7.Spring Security","url":"/2022/02/04/4-Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_7.Spring%20Security/","content":"<h1 id=\"描述：Spring-的安全管理框架\"><a href=\"#描述：Spring-的安全管理框架\" class=\"headerlink\" title=\"描述：Spring. 的安全管理框架\"></a>描述：Spring. 的安全管理框架</h1><h1 id=\"用户认证\"><a href=\"#用户认证\" class=\"headerlink\" title=\"用户认证\"></a>用户认证</h1><h1 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h1>","categories":["Java","4.开发框架","7.Spring Security"],"tags":["写作"]},{"title":"1.Maven、Gradle","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_1.Maven%E3%80%81Gradle/","content":"<h1 id=\"描述：项目管理工具\"><a href=\"#描述：项目管理工具\" class=\"headerlink\" title=\"描述：项目管理工具\"></a>描述：项目管理工具</h1><p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p>\n<p>在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到<a href=\"https://commons.apache.org/proper/commons-logging/\">commons logging</a>，我们就必须把commons logging的jar包放入classpath。如果我们还需要<a href=\"https://logging.apache.org/log4j/\">log4j</a>，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。</p>\n<p>其次，我们要确定项目的目录结构。例如，<code>src</code>目录存放Java源码，<code>resources</code>目录存放配置文件，<code>bin</code>目录存放编译生成的<code>.class</code>文件。</p>\n<p>此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。</p>\n<p>最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。</p>\n<p>这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。</p>\n<p>Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：</p>\n<ul>\n<li>提供了一套标准化的项目结构；</li>\n<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>\n<li>提供了一套依赖管理机制。</li>\n</ul>\n<h3 id=\"Maven项目结构\"><a href=\"#Maven项目结构\" class=\"headerlink\" title=\"Maven项目结构\"></a>Maven项目结构</h3><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a-maven-project</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── main</span><br><span class=\"line\">│   │   ├── java</span><br><span class=\"line\">│   │   └── resources</span><br><span class=\"line\">│   └── test</span><br><span class=\"line\">│       ├── java</span><br><span class=\"line\">│       └── resources</span><br><span class=\"line\">└── target</span><br></pre></td></tr></table></figure>\n\n<p>项目的根目录<code>a-maven-project</code>是项目名，它有一个项目描述文件<code>pom.xml</code>，存放Java源码的目录是<code>src/main/java</code>，存放资源文件的目录是<code>src/main/resources</code>，存放测试源码的目录是<code>src/test/java</code>，存放测试资源的目录是<code>src/test/resources</code>，最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p>\n<p>所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。</p>\n<p>我们再来看最关键的一个项目描述文件<code>pom.xml</code>，它的内容长得像下面：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>hello<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-logging<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-logging<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>groupId</code>类似于Java的包名，通常是公司或组织名称，<code>artifactId</code>类似于Java的类名，通常是项目名称，再加上<code>version</code>，一个Maven工程就是由<code>groupId</code>，<code>artifactId</code>和<code>version</code>作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖<code>commons-logging</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>commons-logging<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-logging<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>&lt;dependency&gt;</code>声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p>\n<h3 id=\"安装Maven\"><a href=\"#安装Maven\" class=\"headerlink\" title=\"安装Maven\"></a>安装Maven</h3><p>要安装Maven，可以从<a href=\"https://maven.apache.org/\">Maven官网</a>下载最新的Maven 3.6.x，然后在本地解压，设置几个环境变量：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">M2_HOME</span>=/path/to/maven-<span class=\"number\">3.6</span>.x</span><br><span class=\"line\"><span class=\"attr\">PATH</span>=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$M2_HOME</span>/bin</span><br></pre></td></tr></table></figure>\n\n<p>Windows可以把<code>%M2_HOME%\\bin</code>添加到系统Path变量中。</p>\n<p>然后，打开命令行窗口，输入<code>mvn -version</code>，应该看到Maven的版本信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌────────────────────────────────────────────────────────┐</span><br><span class=\"line\">│Command Prompt                                    - □ x │</span><br><span class=\"line\">├────────────────────────────────────────────────────────┤</span><br><span class=\"line\">│Microsoft Windows [Version 10.0.0]                      │</span><br><span class=\"line\">│(c) 2015 Microsoft Corporation. All rights reserved.    │</span><br><span class=\"line\">│                                                        │</span><br><span class=\"line\">│C:\\&gt; mvn -version                                       │</span><br><span class=\"line\">│Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918...) │</span><br><span class=\"line\">│Maven home: C:\\Users\\liaoxuefeng\\maven                  │</span><br><span class=\"line\">│Java version: ...                                       │</span><br><span class=\"line\">│...                                                     │</span><br><span class=\"line\">│C:\\&gt; _                                                  │</span><br><span class=\"line\">│                                                        │</span><br><span class=\"line\">│                                                        │</span><br><span class=\"line\">└────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>如果提示命令未找到，说明系统PATH路径有误，需要修复后再运行。</p>\n<h1 id=\"依赖管理\"><a href=\"#依赖管理\" class=\"headerlink\" title=\"依赖管理\"></a>依赖管理</h1><p>如果我们的项目依赖第三方的jar包，例如commons logging，那么问题来了：commons logging发布的jar包在哪下载？</p>\n<p>如果我们还希望依赖log4j，那么使用log4j需要哪些jar包？</p>\n<p>类似的依赖还包括：JUnit，JavaMail，MySQL驱动等等，一个可行的方法是通过搜索引擎搜索到项目的官网，然后手动下载zip包，解压，放入classpath。但是，这个过程非常繁琐。</p>\n<p>Maven解决了依赖管理问题。例如，我们的项目依赖<code>abc</code>这个jar包，而<code>abc</code>又依赖<code>xyz</code>这个jar包：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌──────────────┐</span><br><span class=\"line\">│Sample Project│</span><br><span class=\"line\">└──────────────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌──────────────┐</span><br><span class=\"line\">│     abc      │</span><br><span class=\"line\">└──────────────┘</span><br><span class=\"line\">        │</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌──────────────┐</span><br><span class=\"line\">│     xyz      │</span><br><span class=\"line\">└──────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>当我们声明了<code>abc</code>的依赖时，Maven自动把<code>abc</code>和<code>xyz</code>都加入了我们的项目依赖，不需要我们自己去研究<code>abc</code>是否需要依赖<code>xyz</code>。</p>\n<p>因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要<code>abc</code>，Maven会自动导入<code>abc</code>的jar包，再判断出<code>abc</code>需要<code>xyz</code>，又会自动导入<code>xyz</code>的jar包，这样，最终我们的项目会依赖<code>abc</code>和<code>xyz</code>两个jar包。</p>\n<p>我们来看一个复杂依赖示例：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.2.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当我们声明一个<code>spring-boot-starter-web</code>依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring-boot-starter-web</span><br><span class=\"line\">  spring-boot-starter</span><br><span class=\"line\">    spring-boot</span><br><span class=\"line\">    sprint-boot-autoconfigure</span><br><span class=\"line\">    spring-boot-starter-logging</span><br><span class=\"line\">      logback-classic</span><br><span class=\"line\">        logback-core</span><br><span class=\"line\">        slf4j-api</span><br><span class=\"line\">      jcl-over-slf4j</span><br><span class=\"line\">        slf4j-api</span><br><span class=\"line\">      jul-to-slf4j</span><br><span class=\"line\">        slf4j-api</span><br><span class=\"line\">      log4j-over-slf4j</span><br><span class=\"line\">        slf4j-api</span><br><span class=\"line\">    spring-core</span><br><span class=\"line\">    snakeyaml</span><br><span class=\"line\">  spring-boot-starter-tomcat</span><br><span class=\"line\">    tomcat-embed-core</span><br><span class=\"line\">    tomcat-embed-el</span><br><span class=\"line\">    tomcat-embed-websocket</span><br><span class=\"line\">      tomcat-embed-core</span><br><span class=\"line\">  jackson-databind</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n\n<p>如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。</p>\n<h3 id=\"依赖关系\"><a href=\"#依赖关系\" class=\"headerlink\" title=\"依赖关系\"></a>依赖关系</h3><p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">scope</th>\n<th align=\"left\">说明</th>\n<th align=\"left\">示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">compile</td>\n<td align=\"left\">编译时需要用到该jar包（默认）</td>\n<td align=\"left\">commons-logging</td>\n</tr>\n<tr>\n<td align=\"left\">test</td>\n<td align=\"left\">编译Test时需要用到该jar包</td>\n<td align=\"left\">junit</td>\n</tr>\n<tr>\n<td align=\"left\">runtime</td>\n<td align=\"left\">编译时不需要，但运行时需要用到</td>\n<td align=\"left\">mysql</td>\n</tr>\n<tr>\n<td align=\"left\">provided</td>\n<td align=\"left\">编译时需要用到，但运行时由JDK或某个服务器提供</td>\n<td align=\"left\">servlet-api</td>\n</tr>\n</tbody></table>\n<p>其中，默认的<code>compile</code>是最常用的，Maven会把这种类型的依赖直接放入classpath。</p>\n<p><code>test</code>依赖表示仅在测试时使用，正常运行时并不需要。最常用的<code>test</code>依赖就是JUnit：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.junit.jupiter<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit-jupiter-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.3.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>runtime</code>依赖表示编译时不需要，但运行时需要。最典型的<code>runtime</code>依赖是JDBC驱动，例如MySQL驱动：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.48<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>provided</code>依赖表示编译时需要，但运行时不需要。最典型的<code>provided</code>依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.servlet<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.servlet-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>provided<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（<a href=\"https://repo1.maven.org/\">repo1.maven.org</a>），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。</p>\n<p>Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的<code>.m2</code>目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p>\n<h3 id=\"唯一ID\"><a href=\"#唯一ID\" class=\"headerlink\" title=\"唯一ID\"></a>唯一ID</h3><p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p>\n<ul>\n<li>groupId：属于组织的名称，类似Java的包名；</li>\n<li>artifactId：该jar包自身的名称，类似Java的类名；</li>\n<li>version：该jar包的版本。</li>\n</ul>\n<p>通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。</p>\n<p>因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</p>\n<p>注：只有以<code>-SNAPSHOT</code>结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。</p>\n<h3 id=\"Maven镜像\"><a href=\"#Maven镜像\" class=\"headerlink\" title=\"Maven镜像\"></a>Maven镜像</h3><p>除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">           slow    ┌───────────────────┐</span><br><span class=\"line\">    ┌─────────────&gt;│Maven Central Repo.│</span><br><span class=\"line\">    │              └───────────────────┘</span><br><span class=\"line\">    │                        │</span><br><span class=\"line\">    │                        │sync</span><br><span class=\"line\">    │                        ▼</span><br><span class=\"line\">┌───────┐  fast    ┌───────────────────┐</span><br><span class=\"line\">│ User  │─────────&gt;│Maven Mirror Repo. │</span><br><span class=\"line\">└───────┘          └───────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入<code>.m2</code>目录，创建一个<code>settings.xml</code>配置文件，内容如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>aliyun<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>aliyun<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mirrorOf</span>&gt;</span>central<span class=\"tag\">&lt;/<span class=\"name\">mirrorOf</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://maven.aliyun.com/repository/central<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">mirror</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">mirrors</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>配置镜像仓库后，Maven的下载速度就会非常快。</p>\n<h3 id=\"搜索第三方组件\"><a href=\"#搜索第三方组件\" class=\"headerlink\" title=\"搜索第三方组件\"></a>搜索第三方组件</h3><p>最后一个问题：如果我们要引用一个第三方组件，比如<code>okhttp</code>，如何确切地获得它的<code>groupId</code>、<code>artifactId</code>和<code>version</code>？方法是通过<a href=\"https://search.maven.org/\">search.maven.org</a>搜索关键字，找到对应的组件后，直接复制：</p>\n<p><img src=\"/1.Maven%E3%80%81Gradle.assets/l.png\" alt=\"copy-maven\"></p>\n<h3 id=\"命令行编译\"><a href=\"#命令行编译\" class=\"headerlink\" title=\"命令行编译\"></a>命令行编译</h3><p>在命令中，进入到<code>pom.xml</code>所在目录，输入以下命令：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mvn clean <span class=\"class\"><span class=\"keyword\">package</span></span></span><br></pre></td></tr></table></figure>\n\n<p>如果一切顺利，即可在<code>target</code>目录下获得编译后自动打包的jar。</p>\n<h3 id=\"在IDE中使用Maven\"><a href=\"#在IDE中使用Maven\" class=\"headerlink\" title=\"在IDE中使用Maven\"></a>在IDE中使用Maven</h3><p>几乎所有的IDE都内置了对Maven的支持。在Eclipse中，可以直接创建或导入Maven项目。如果导入后的Maven项目有错误，可以尝试选择项目后点击右键，选择Maven - Update Project…更新：</p>\n<p><img src=\"/1.Maven%E3%80%81Gradle.assets/l-16418949320481.png\" alt=\"update-maven-project\"></p>\n<h1 id=\"构建流程\"><a href=\"#构建流程\" class=\"headerlink\" title=\"构建流程\"></a>构建流程</h1><h3 id=\"构建流程-1\"><a href=\"#构建流程-1\" class=\"headerlink\" title=\"构建流程\"></a>构建流程</h3><p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p>\n<h3 id=\"Lifecycle和Phase\"><a href=\"#Lifecycle和Phase\" class=\"headerlink\" title=\"Lifecycle和Phase\"></a>Lifecycle和Phase</h3><p>使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。</p>\n<p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期<code>default</code>为例，它包含以下phase：</p>\n<ul>\n<li>validate</li>\n<li>initialize</li>\n<li>generate-sources</li>\n<li>process-sources</li>\n<li>generate-resources</li>\n<li>process-resources</li>\n<li>compile</li>\n<li>process-classes</li>\n<li>generate-test-sources</li>\n<li>process-test-sources</li>\n<li>generate-test-resources</li>\n<li>process-test-resources</li>\n<li>test-compile</li>\n<li>process-test-classes</li>\n<li>test</li>\n<li>prepare-package</li>\n<li>package</li>\n<li>pre-integration-test</li>\n<li>integration-test</li>\n<li>post-integration-test</li>\n<li>verify</li>\n<li>install</li>\n<li>deploy</li>\n</ul>\n<p>如果我们运行<code>mvn package</code>，Maven就会执行<code>default</code>生命周期，它会从开始一直运行到<code>package</code>这个phase为止：</p>\n<ul>\n<li>validate</li>\n<li>…</li>\n<li>package</li>\n</ul>\n<p>如果我们运行<code>mvn compile</code>，Maven也会执行<code>default</code>生命周期，但这次它只会运行到<code>compile</code>，即以下几个phase：</p>\n<ul>\n<li>validate</li>\n<li>…</li>\n<li>compile</li>\n</ul>\n<p>Maven另一个常用的生命周期是<code>clean</code>，它会执行3个phase：</p>\n<ul>\n<li>pre-clean</li>\n<li>clean （注意这个clean不是lifecycle而是phase）</li>\n<li>post-clean</li>\n</ul>\n<p>所以，我们使用<code>mvn</code>这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。</p>\n<p>更复杂的例子是指定多个phase，例如，运行<code>mvn clean package</code>，Maven先执行<code>clean</code>生命周期并运行到<code>clean</code>这个phase，然后执行<code>default</code>生命周期并运行到<code>package</code>这个phase，实际执行的phase如下：</p>\n<ul>\n<li>pre-clean</li>\n<li>clean （注意这个clean是phase）</li>\n<li>validate</li>\n<li>…</li>\n<li>package</li>\n</ul>\n<p>在实际开发过程中，经常使用的命令有：</p>\n<p><code>mvn clean</code>：清理所有生成的class和jar；</p>\n<p><code>mvn clean compile</code>：先清理，再执行到<code>compile</code>；</p>\n<p><code>mvn clean test</code>：先清理，再执行到<code>test</code>，因为执行<code>test</code>前必须执行<code>compile</code>，所以这里不必指定<code>compile</code>；</p>\n<p><code>mvn clean package</code>：先清理，再执行到<code>package</code>。</p>\n<p>大多数phase在执行过程中，因为我们通常没有在<code>pom.xml</code>中配置相关的设置，所以这些phase什么事情都不做。</p>\n<p>经常用到的phase其实只有几个：</p>\n<ul>\n<li>clean：清理</li>\n<li>compile：编译</li>\n<li>test：运行测试</li>\n<li>package：打包</li>\n</ul>\n<h3 id=\"Goal\"><a href=\"#Goal\" class=\"headerlink\" title=\"Goal\"></a>Goal</h3><p>执行一个phase又会触发一个或多个goal：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">执行的Phase</th>\n<th align=\"left\">对应执行的Goal</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">compile</td>\n<td align=\"left\">compiler:compile</td>\n</tr>\n<tr>\n<td align=\"left\">test</td>\n<td align=\"left\">compiler:testCompile surefire:test</td>\n</tr>\n</tbody></table>\n<p>goal的命名总是<code>abc:xyz</code>这种形式。</p>\n<p>看到这里，相信大家对lifecycle、phase和goal已经明白了吧？</p>\n<p><img src=\"/1.Maven%E3%80%81Gradle.assets/l-16418949427424.jpeg\" alt=\"meng\"></p>\n<p>其实我们类比一下就明白了：</p>\n<ul>\n<li>lifecycle相当于Java的package，它包含一个或多个phase；</li>\n<li>phase相当于Java的class，它包含一个或多个goal；</li>\n<li>goal相当于class的method，它其实才是真正干活的。</li>\n</ul>\n<p>大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn tomcat:<span class=\"built_in\">run</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h1><p>我们在前面介绍了Maven的lifecycle，phase和goal：使用Maven构建项目就是执行lifecycle，执行到指定的phase为止。每个phase会执行自己默认的一个或多个goal。goal是最小任务单元。</p>\n<p>我们以<code>compile</code>这个phase为例，如果执行：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">mvn</span> compile</span><br></pre></td></tr></table></figure>\n\n<p>Maven将执行<code>compile</code>这个phase，这个phase会调用<code>compiler</code>插件执行关联的<code>compiler:compile</code>这个goal。</p>\n<p>实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行<code>compile</code>，它只是负责找到对应的<code>compiler</code>插件，然后执行默认的<code>compiler:compile</code>这个goal来完成编译。</p>\n<p>所以，使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们。</p>\n<p>Maven已经内置了一些常用的标准插件：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">插件名称</th>\n<th align=\"left\">对应执行的phase</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">clean</td>\n<td align=\"left\">clean</td>\n</tr>\n<tr>\n<td align=\"left\">compiler</td>\n<td align=\"left\">compile</td>\n</tr>\n<tr>\n<td align=\"left\">surefire</td>\n<td align=\"left\">test</td>\n</tr>\n<tr>\n<td align=\"left\">jar</td>\n<td align=\"left\">package</td>\n</tr>\n</tbody></table>\n<p>如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用<code>maven-shade-plugin</code>可以创建一个可执行的jar，要使用这个插件，需要在<code>pom.xml</code>中声明它：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-shade-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.2.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>shade<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                            ...</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">\t\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">\t\t\t<span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">\t\t<span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>自定义插件往往需要一些配置，例如，<code>maven-shade-plugin</code>需要指定Java程序的入口，它的配置是：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">transformers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">transformer</span> <span class=\"attr\">implementation</span>=<span class=\"string\">&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">mainClass</span>&gt;</span>com.itranswarp.learnjava.Main<span class=\"tag\">&lt;/<span class=\"name\">mainClass</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">transformer</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">transformers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，Maven自带的标准插件例如<code>compiler</code>是无需声明的，只有引入其它的插件才需要声明。</p>\n<p>下面列举了一些常用的插件：</p>\n<ul>\n<li>maven-shade-plugin：打包所有依赖包并生成可执行jar；</li>\n<li>cobertura-maven-plugin：生成单元测试覆盖率报告；</li>\n<li>findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。</li>\n</ul>\n<h1 id=\"模块管理\"><a href=\"#模块管理\" class=\"headerlink\" title=\"模块管理\"></a>模块管理</h1><p>在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                        ┌ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">                          ┌─────────┐</span><br><span class=\"line\">                        │ │Module A │ │</span><br><span class=\"line\">                          └─────────┘</span><br><span class=\"line\">┌──────────────┐ split  │ ┌─────────┐ │</span><br><span class=\"line\">│Single Project│───────&gt;  │Module B │</span><br><span class=\"line\">└──────────────┘        │ └─────────┘ │</span><br><span class=\"line\">                          ┌─────────┐</span><br><span class=\"line\">                        │ │Module C │ │</span><br><span class=\"line\">                          └─────────┘</span><br><span class=\"line\">                        └ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>对于Maven工程来说，原来是一个大项目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">single-project</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br></pre></td></tr></table></figure>\n\n<p>现在可以分拆成3个模块：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mutiple-project</span><br><span class=\"line\">├── module-a</span><br><span class=\"line\">│   ├── pom.xml</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── module-b</span><br><span class=\"line\">│   ├── pom.xml</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">└── module-c</span><br><span class=\"line\">    ├── pom.xml</span><br><span class=\"line\">    └── src</span><br></pre></td></tr></table></figure>\n\n<p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的<code>pom.xml</code>。例如，模块A的<code>pom.xml</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>module-a<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>module-a<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.28<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ch.qos.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logback-classic<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.junit.jupiter<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit-jupiter-engine<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.5.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>模块B的<code>pom.xml</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>module-b<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>module-b<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.28<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ch.qos.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logback-classic<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.junit.jupiter<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit-jupiter-engine<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.5.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看出来，模块A和模块B的<code>pom.xml</code>高度相似，因此，我们可以提取出共同部分作为<code>parent</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>parent<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.build.sourceEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class=\"tag\">&lt;/<span class=\"name\">project.reporting.outputEncoding</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.28<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>ch.qos.logback<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>logback-classic<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.junit.jupiter<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>junit-jupiter-engine<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.5.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意到parent的<code>&lt;packaging&gt;</code>是<code>pom</code>而不是<code>jar</code>，因为<code>parent</code>本身不含任何Java代码。编写<code>parent</code>的<code>pom.xml</code>只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">multiple-project</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">├── parent</span><br><span class=\"line\">│   └── pom.xml</span><br><span class=\"line\">├── module-a</span><br><span class=\"line\">│   ├── pom.xml</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">├── module-b</span><br><span class=\"line\">│   ├── pom.xml</span><br><span class=\"line\">│   └── src</span><br><span class=\"line\">└── module-c</span><br><span class=\"line\">    ├── pom.xml</span><br><span class=\"line\">    └── src</span><br></pre></td></tr></table></figure>\n\n<p>这样模块A就可以简化为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>&gt;</span>../parent/pom.xml<span class=\"tag\">&lt;/<span class=\"name\">relativePath</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>module-a<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>module-a<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>模块B、模块C都可以直接从<code>parent</code>继承，大幅简化了<code>pom.xml</code>的编写。</p>\n<p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>module-b<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>最后，在编译的时候，需要在根目录创建一个<code>pom.xml</code>统一编译：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.learnjava<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>build<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>build<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modules</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>parent<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>module-a<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>module-b<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">module</span>&gt;</span>module-c<span class=\"tag\">&lt;/<span class=\"name\">module</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">modules</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>这样，在根目录执行<code>mvn clean package</code>时，Maven根据根目录的<code>pom.xml</code>找到包括<code>parent</code>在内的共4个<code>&lt;module&gt;</code>，一次性全部编译。</p>\n<h3 id=\"中央仓库\"><a href=\"#中央仓库\" class=\"headerlink\" title=\"中央仓库\"></a>中央仓库</h3><p>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块，就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p>\n<h3 id=\"私有仓库\"><a href=\"#私有仓库\" class=\"headerlink\" title=\"私有仓库\"></a>私有仓库</h3><p>私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的<code>~/.m2/settings.xml</code>中配置好，使用方式和中央仓位没有任何区别。</p>\n<h3 id=\"本地仓库\"><a href=\"#本地仓库\" class=\"headerlink\" title=\"本地仓库\"></a>本地仓库</h3><p>本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。</p>\n<h1 id=\"使用mvnw\"><a href=\"#使用mvnw\" class=\"headerlink\" title=\"使用mvnw\"></a>使用mvnw</h1><p>我们使用Maven时，基本上只会用到<code>mvn</code>这一个命令。有些童鞋可能听说过<code>mvnw</code>，这个是啥？</p>\n<p><code>mvnw</code>是Maven Wrapper的缩写。因为我们安装Maven时，默认情况下，系统所有项目都会使用全局安装的这个Maven版本。但是，对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。</p>\n<p>简单地说，Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用。</p>\n<h3 id=\"安装Maven-Wrapper\"><a href=\"#安装Maven-Wrapper\" class=\"headerlink\" title=\"安装Maven Wrapper\"></a>安装Maven Wrapper</h3><p>安装Maven Wrapper最简单的方式是在项目的根目录（即<code>pom.xml</code>所在的目录）下运行安装命令：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -N io.takari:maven:<span class=\"number\">0.7</span><span class=\"number\">.6</span>:<span class=\"keyword\">wrapper</span></span><br></pre></td></tr></table></figure>\n\n<p>它会自动使用最新版本的Maven。注意<code>0.7.6</code>是Maven Wrapper的版本。最新的Maven Wrapper版本可以去<a href=\"https://github.com/takari/maven-wrapper\">官方网站</a>查看。</p>\n<p>如果要指定使用的Maven版本，使用下面的安装命令指定版本，例如<code>3.3.3</code>：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvn -N io.takari:maven:<span class=\"number\">0.7</span><span class=\"number\">.6</span>:<span class=\"keyword\">wrapper</span> -Dmaven=<span class=\"number\">3.3</span><span class=\"number\">.3</span></span><br></pre></td></tr></table></figure>\n\n<p>安装后，查看项目结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">my-project</span><br><span class=\"line\">├── .mvn</span><br><span class=\"line\">│   └── wrapper</span><br><span class=\"line\">│       ├── MavenWrapperDownloader.java</span><br><span class=\"line\">│       ├── maven-wrapper.jar</span><br><span class=\"line\">│       └── maven-wrapper.properties</span><br><span class=\"line\">├── mvnw</span><br><span class=\"line\">├── mvnw.cmd</span><br><span class=\"line\">├── pom.xml</span><br><span class=\"line\">└── src</span><br><span class=\"line\">    ├── main</span><br><span class=\"line\">    │   ├── java</span><br><span class=\"line\">    │   └── resources</span><br><span class=\"line\">    └── test</span><br><span class=\"line\">        ├── java</span><br><span class=\"line\">        └── resources</span><br></pre></td></tr></table></figure>\n\n<p>发现多了<code>mvnw</code>、<code>mvnw.cmd</code>和<code>.mvn</code>目录，我们只需要把<code>mvn</code>命令改成<code>mvnw</code>就可以使用跟项目关联的Maven。例如：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">mvnw clean <span class=\"class\"><span class=\"keyword\">package</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在Linux或macOS下运行时需要加上<code>./</code>：</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">./mvnw clean <span class=\"class\"><span class=\"keyword\">package</span></span></span><br></pre></td></tr></table></figure>\n\n<p>Maven Wrapper的另一个作用是把项目的<code>mvnw</code>、<code>mvnw.cmd</code>和<code>.mvn</code>提交到版本库中，可以使所有开发人员使用统一的Maven版本。</p>\n<h1 id=\"发布Artifact\"><a href=\"#发布Artifact\" class=\"headerlink\" title=\"发布Artifact\"></a>发布Artifact</h1><p>当我们使用<code>commons-logging</code>这些第三方开源库的时候，我们实际上是通过Maven自动下载它的jar包，并根据其<code>pom.xml</code>解析依赖，自动把相关依赖包都下载后加入到classpath。</p>\n<p>那么问题来了：当我们自己写了一个牛逼的开源库时，非常希望别人也能使用，总不能直接放个jar包的链接让别人下载吧？</p>\n<p>如果我们把自己的开源库放到Maven的repo中，那么，别人只需按标准引用<code>groupId:artifactId:version</code>，即可自动下载jar包以及相关依赖。因此，本节我们介绍如何发布一个库到Maven的repo中。</p>\n<p>把自己的库发布到Maven的repo中有好几种方法，我们介绍3种最常用的方法。</p>\n<h3 id=\"以静态文件发布\"><a href=\"#以静态文件发布\" class=\"headerlink\" title=\"以静态文件发布\"></a>以静态文件发布</h3><p>如果我们观察一个中央仓库的Artifact结构，例如<a href=\"https://commons.apache.org/proper/commons-math/\">Commons Math</a>，它的groupId是<code>org.apache.commons</code>，artifactId是<code>commons-math3</code>，以版本<code>3.6.1</code>为例，发布在中央仓库的文件夹路径就是<a href=\"https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/%EF%BC%8C%E5%9C%A8%E6%AD%A4%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%EF%BC%8C%60commons-math3-3.6.1.jar%60%E5%B0%B1%E6%98%AF%E5%8F%91%E5%B8%83%E7%9A%84jar%E5%8C%85%EF%BC%8C%60commons-math3-3.6.1.pom%60%E5%B0%B1%E6%98%AF%E5%AE%83%E7%9A%84%60pom.xml%60%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%EF%BC%8C%60commons-math3-3.6.1-sources.jar%60%E6%98%AF%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%8C%60commons-math3-3.6.1-javadoc.jar%60%E6%98%AF%E6%96%87%E6%A1%A3%E3%80%82%E5%85%B6%E5%AE%83%E4%BB%A5%60.asc%60%E3%80%81%60.md5%60%E3%80%81%60.sha1%60%E7%BB%93%E5%B0%BE%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%86%E5%88%AB%E6%98%AFGPG%E7%AD%BE%E5%90%8D%E3%80%81MD5%E6%91%98%E8%A6%81%E5%92%8CSHA-1%E6%91%98%E8%A6%81%E3%80%82\">https://repo1.maven.org/maven2/org/apache/commons/commons-math3/3.6.1/，在此文件夹下，`commons-math3-3.6.1.jar`就是发布的jar包，`commons-math3-3.6.1.pom`就是它的`pom.xml`描述文件，`commons-math3-3.6.1-sources.jar`是源代码，`commons-math3-3.6.1-javadoc.jar`是文档。其它以`.asc`、`.md5`、`.sha1`结尾的文件分别是GPG签名、MD5摘要和SHA-1摘要。</a></p>\n<p>我们只要按照这种目录结构组织文件，它就是一个有效的Maven仓库。</p>\n<p>我们以广受好评的开源项目<a href=\"https://github.com/michaelliao/how-to-become-rich\">how-to-become-rich</a>为例，先创建Maven工程目录结构如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">how-to-become-rich</span><br><span class=\"line\">├── maven-repo        &lt;-- Maven本地文件仓库</span><br><span class=\"line\">├── pom.xml           &lt;-- 项目文件</span><br><span class=\"line\">├── src</span><br><span class=\"line\">│   ├── main</span><br><span class=\"line\">│   │   ├── java      &lt;-- 源码目录</span><br><span class=\"line\">│   │   └── resources &lt;-- 资源目录</span><br><span class=\"line\">│   └── test</span><br><span class=\"line\">│       ├── java      &lt;-- 测试源码目录</span><br><span class=\"line\">│       └── resources &lt;-- 测试资源目录</span><br><span class=\"line\">└── target            &lt;-- 编译输出目录</span><br></pre></td></tr></table></figure>\n\n<p>在<code>pom.xml</code>中添加如下内容：</p>\n<figure class=\"highlight dust\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">...</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    ...</span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>local-repo-release<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>GitHub Release<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>file://$</span><span class=\"template-variable\">&#123;project.basedir&#125;</span><span class=\"xml\">/maven-repo<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-source-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>attach-sources<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                        <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar-no-fork<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-javadoc-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>attach-javadocs<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                        <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>package<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>&lt;distributionManagement&gt;</code>，它指示了发布的软件包的位置，这里的<code>&lt;url&gt;</code>是项目根目录下的<code>maven-repo</code>目录，在<code>&lt;build&gt;</code>中定义的两个插件<code>maven-source-plugin</code>和<code>maven-javadoc-plugin</code>分别用来创建源码和javadoc，如果不想发布源码，可以把对应的插件去掉。</p>\n<p>我们直接在项目根目录下运行Maven命令<code>mvn clean package deploy</code>，如果一切顺利，我们就可以在<code>maven-repo</code>目录下找到部署后的所有文件如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">maven-repo</span><br><span class=\"line\">└── com</span><br><span class=\"line\">    └── itranswarp</span><br><span class=\"line\">        └── rich</span><br><span class=\"line\">            └── how-to-become-rich</span><br><span class=\"line\">                ├── 1.0.0</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0-javadoc.jar</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0-javadoc.jar.md5</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0-javadoc.jar.sha1</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0-sources.jar</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0-sources.jar.md5</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0-sources.jar.sha1</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0.jar</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0.jar.md5</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0.jar.sha1</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0.pom</span><br><span class=\"line\">                │   ├── how-to-become-rich-1.0.0.pom.md5</span><br><span class=\"line\">                │   └── how-to-become-rich-1.0.0.pom.sha1</span><br><span class=\"line\">                ├── maven-metadata.xml</span><br><span class=\"line\">                ├── maven-metadata.xml.md5</span><br><span class=\"line\">                └── maven-metadata.xml.sha1</span><br></pre></td></tr></table></figure>\n\n<p>最后一步，是把这个工程推到GitHub上，并选择<code>Settings</code>-<code>GitHub Pages</code>，选择<code>master branch</code>启用Pages服务：</p>\n<p><img src=\"/1.Maven%E3%80%81Gradle.assets/l-16418949971816.png\" alt=\"enable-github-pages\"></p>\n<p>这样，把全部内容推送至GitHub后，即可作为静态网站访问Maven的repo，它的地址是<a href=\"https://michaelliao.github.io/how-to-become-rich/maven-repo/%E3%80%82%E7%89%88%E6%9C%AC%601.0.0%60%E5%AF%B9%E5%BA%94%E7%9A%84jar%E5%8C%85%E5%9C%B0%E5%9D%80%E6%98%AF%EF%BC%9A\">https://michaelliao.github.io/how-to-become-rich/maven-repo/。版本`1.0.0`对应的jar包地址是：</a></p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">https:<span class=\"regexp\">//mi</span>chaelliao.github.io<span class=\"regexp\">/how-to-become-rich/m</span>aven-repo<span class=\"regexp\">/com/i</span>transwarp<span class=\"regexp\">/rich/</span>how-to-become-rich<span class=\"regexp\">/1.0.0/</span>how-to-become-rich-<span class=\"number\">1.0</span>.<span class=\"number\">0</span>.jar</span><br></pre></td></tr></table></figure>\n\n<p>现在，如果其他人希望引用这个Maven包，我们可以告知如下依赖即可：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.rich<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>how-to-become-rich<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但是，除了正常导入依赖外，对方还需要再添加一个<code>&lt;repository&gt;</code>的声明，即使用方完整的<code>pom.xml</code>如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>example<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>how-to-become-rich-usage<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">packaging</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">packaging</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.source</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.source</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">maven.compiler.target</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">maven.compiler.target</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>github-rich-repo<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>The Maven Repository on Github<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://michaelliao.github.io/how-to-become-rich/maven-repo/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp.rich<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>how-to-become-rich<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在<code>&lt;repository&gt;</code>中，我们必须声明发布的Maven的repo地址，其中<code>&lt;id&gt;</code>和<code>&lt;name&gt;</code>可以任意填写，<code>&lt;url&gt;</code>填入GitHub Pages提供的地址+<code>/maven-repo/</code>后缀。现在，即可正常引用这个库并编写代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Millionaire millionaire = <span class=\"keyword\">new</span> <span class=\"constructor\">Millionaire()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(millionaire.how<span class=\"constructor\">ToBecomeRich()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>有的童鞋会问，为什么使用<code>commons-logging</code>等第三方库时，并不需要声明repo地址？这是因为这些库都是发布到Maven中央仓库的，发布到中央仓库后，不需要告诉Maven仓库地址，因为它知道中央仓库的地址默认是<a href=\"https://repo1.maven.org/maven2/%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%60~/.m2/settings.xml%60%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%90%86%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%E4%BB%A5%E6%9B%BF%E4%BB%A3%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93%E6%9D%A5%E6%8F%90%E9%AB%98%E9%80%9F%E5%BA%A6%EF%BC%88%E5%8F%82%E8%80%83[%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86](https://www.liaoxuefeng.com/wiki/1252599548343744/1309301178105890)%E7%9A%84Maven%E9%95%9C%E5%83%8F%EF%BC%89%E3%80%82\">https://repo1.maven.org/maven2/，也可以通过`~/.m2/settings.xml`指定一个代理仓库地址以替代中央仓库来提高速度（参考[依赖管理](https://www.liaoxuefeng.com/wiki/1252599548343744/1309301178105890)的Maven镜像）。</a></p>\n<p>因为GitHub Pages并不会把我们发布的Maven包同步到中央仓库，所以自然使用方必须手动添加一个我们提供的仓库地址。</p>\n<p>此外，通过GitHub Pages发布Maven repo时需要注意一点，即不要改动已发布的版本。因为Maven的仓库是不允许修改任何版本的，对一个库进行修改的唯一方法是发布一个新版本。但是通过静态文件的方式发布repo，实际上我们是可以修改jar文件的，但最好遵守规范，不要修改已发布版本。</p>\n<h3 id=\"通过Nexus发布到中央仓库\"><a href=\"#通过Nexus发布到中央仓库\" class=\"headerlink\" title=\"通过Nexus发布到中央仓库\"></a>通过Nexus发布到中央仓库</h3><p>有的童鞋会问，能不能把自己的开源库发布到Maven的中央仓库，这样用户就不需要声明repo地址，可以直接引用，显得更专业。</p>\n<p>当然可以，但我们不能直接发布到Maven中央仓库，而是通过曲线救国的方式，发布到<a href=\"https://central.sonatype.org/\">central.sonatype.org</a>，它会定期自动同步到Maven的中央仓库。<a href=\"https://www.sonatype.com/nexus-repository-oss\">Nexus</a>是一个支持Maven仓库的软件，由Sonatype开发，有免费版和专业版两个版本，很多大公司内部都使用Nexus作为自己的私有Maven仓库，而这个<a href=\"https://central.sonatype.org/\">central.sonatype.org</a>相当于面向开源的一个Nexus公共服务。</p>\n<p>所以，第一步是在<a href=\"https://central.sonatype.org/\">central.sonatype.org</a>上注册一个账号，注册链接非常隐蔽，可以自己先找找，找半小时没找到点<a href=\"javascript:showSonatypeSignUpLink()\">这里</a>查看攻略。</p>\n<p>如果注册顺利并审核通过，会得到一个登录账号，然后，通过<a href=\"https://central.sonatype.org/pages/apache-maven.html\">这个页面</a>一步一步操作就可以成功地将自己的Artifact发布到Nexus上，再耐心等待几个小时后，你的Artifact就会出现在Maven的中央仓库中。</p>\n<p>这里简单提一下发布重点与难点：</p>\n<ul>\n<li>必须正确创建GPG签名，Linux和Mac下推荐使用gnupg2；</li>\n<li>必须在<code>~/.m2/settings.xml</code>中配置好登录用户名和口令，以及GPG口令：</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>ossrh<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>OSSRH-USERNAME<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>OSSRH-PASSWORD<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servers</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">profiles</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">profile</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>ossrh<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">activation</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">activeByDefault</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">activeByDefault</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">activation</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">gpg.executable</span>&gt;</span>gpg2<span class=\"tag\">&lt;/<span class=\"name\">gpg.executable</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">gpg.passphrase</span>&gt;</span>GPG-PASSWORD<span class=\"tag\">&lt;/<span class=\"name\">gpg.passphrase</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">profile</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">profiles</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>在待发布的Artifact的<code>pom.xml</code>中添加OSS的Maven repo地址，以及<code>maven-jar-plugin</code>、<code>maven-source-plugin</code>、<code>maven-javadoc-plugin</code>、<code>maven-gpg-plugin</code>、<code>nexus-staging-maven-plugin</code>：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">snapshotRepository</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>ossrh<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">snapshotRepository</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>ossrh<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>Nexus Release Repository<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>http://oss.sonatype.org/service/local/staging/deploy/maven2/<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-jar-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>test-jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-source-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>attach-sources<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar-no-fork<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-javadoc-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>attach-javadocs<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>jar<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">additionalOption</span>&gt;</span></span><br><span class=\"line\">                                <span class=\"tag\">&lt;<span class=\"name\">additionalOption</span>&gt;</span>-Xdoclint:none<span class=\"tag\">&lt;/<span class=\"name\">additionalOption</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;/<span class=\"name\">additionalOption</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.maven.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>maven-gpg-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>sign-artifacts<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">phase</span>&gt;</span>verify<span class=\"tag\">&lt;/<span class=\"name\">phase</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                            <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>sign<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                        <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.sonatype.plugins<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>nexus-staging-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">extensions</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">extensions</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">serverId</span>&gt;</span>ossrh<span class=\"tag\">&lt;/<span class=\"name\">serverId</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">nexusUrl</span>&gt;</span>https://oss.sonatype.org/<span class=\"tag\">&lt;/<span class=\"name\">nexusUrl</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">autoReleaseAfterClose</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">autoReleaseAfterClose</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>最后执行命令<code>mvn clean package deploy</code>即可发布至<a href=\"https://central.sonatype.org/\">central.sonatype.org</a>。</p>\n<p>此方法前期需要复杂的申请账号和项目的流程，后期需要安装调试GPG，但只要跑通流程，后续发布都只需要一行命令。</p>\n<h3 id=\"发布到私有仓库\"><a href=\"#发布到私有仓库\" class=\"headerlink\" title=\"发布到私有仓库\"></a>发布到私有仓库</h3><p>通过<code>nexus-staging-maven-plugin</code>除了可以发布到<a href=\"https://central.sonatype.org/\">central.sonatype.org</a>外，也可以发布到私有仓库，例如，公司内部自己搭建的Nexus服务器。</p>\n<p>如果没有私有Nexus服务器，还可以发布到<a href=\"https://github.com/features/packages\">GitHub Packages</a>。GitHub Packages是GitHub提供的仓库服务，支持Maven、NPM、Docker等。使用GitHub Packages时，无论是发布Artifact，还是引用已发布的Artifact，都需要明确的授权Token，因此，GitHub Packages只能作为私有仓库使用。</p>\n<p>在发布前，我们必须首先登录后在用户的<code>Settings</code>-<code>Developer settings</code>-<code>Personal access tokens</code>中创建两个Token，一个用于发布，一个用于使用。发布Artifact的Token必须有<code>repo</code>、<code>write:packages</code>和<code>read:packages</code>权限：</p>\n<p><img src=\"/1.Maven%E3%80%81Gradle.assets/l-16418949971827.png\" alt=\"token-scopes\"></p>\n<p>使用Artifact的Token只需要<code>read:packages</code>权限。</p>\n<p>在发布端，把GitHub的用户名和发布Token写入<code>~/.m2/settings.xml</code>配置中：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">settings</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servers</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>github-release<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">username</span>&gt;</span>GITHUB-USERNAME<span class=\"tag\">&lt;/<span class=\"name\">username</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">password</span>&gt;</span>f052...c21f<span class=\"tag\">&lt;/<span class=\"name\">password</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">server</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">servers</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>然后，在需要发布的Artifact的<code>pom.xml</code>中，添加一个<code>&lt;repository&gt;</code>声明：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>github-release<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>GitHub Release<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://maven.pkg.github.com/michaelliao/complex<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">distributionManagement</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>&lt;id&gt;</code>和<code>~/.m2/settings.xml</code>配置中的<code>&lt;id&gt;</code>要保持一致，因为发布时Maven根据id找到用于登录的用户名和Token，才能成功上传文件到GitHub。我们直接通过命令<code>mvn clean package deploy</code>部署，成功后，在GitHub用户页面可以看到该Artifact：</p>\n<p><img src=\"/1.Maven%E3%80%81Gradle.assets/l-16418949971828.png\" alt=\"github-packages\"></p>\n<p>完整的配置请参考<a href=\"https://github.com/michaelliao/complex/\">complex</a>项目，这是一个非常简单的支持复数运算的库。</p>\n<p>使用该Artifact时，因为GitHub的Package只能作为私有仓库使用，所以除了在使用方的<code>pom.xml</code>中声明<code>&lt;repository&gt;</code>外：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">...</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">id</span>&gt;</span>github-release<span class=\"tag\">&lt;/<span class=\"name\">id</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>GitHub Release<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">url</span>&gt;</span>https://maven.pkg.github.com/michaelliao/complex<span class=\"tag\">&lt;/<span class=\"name\">url</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">repository</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">repositories</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.itranswarp<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>complex<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>还需要把有读权限的Token配置到<code>~/.m2/settings.xml</code>文件中。</p>\n","categories":["Java","5.JavaEE进阶","1.Maven、Gradle"],"tags":["写作"]},{"title":"2.网络编程","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"网络编程基础\"><a href=\"#网络编程基础\" class=\"headerlink\" title=\"网络编程基础\"></a>网络编程基础</h1><p>网络编程是Java最擅长的方向之一，使用Java进行网络编程时，由虚拟机实现了底层复杂的网络协议，Java程序只需要调用Java标准库提供的接口，就可以简单高效地编写网络程序。</p>\n<p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p>\n<p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>\n<p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>\n<p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP&#x2F;IP协议。</p>\n<p>TCP&#x2F;IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP&#x2F;IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p>\n<h3 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h3><p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p>\n<p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似<code>101.202.99.12</code>，而IPv6采用128位地址，类似<code>2001:0DA8:100A:0000:0000:1020:F2F3:1428</code>。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。</p>\n<p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p>\n<ul>\n<li>192.168.x.x</li>\n<li>10.x.x.x</li>\n</ul>\n<p>有一个特殊的IP地址，称之为本机地址，它总是<code>127.0.0.1</code>。</p>\n<p>IPv4地址实际上是一个32位整数。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1707762444 = 0x65ca630c</span><br><span class=\"line\">           = 65  ca  63 0c</span><br><span class=\"line\">           = 101.202.99.12</span><br></pre></td></tr></table></figure>\n\n<p>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<code>127.0.0.1</code>，还有一个IP地址，例如<code>101.202.99.12</code>，可以通过这个IP地址接入网络。</p>\n<p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p>\n<p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p>\n<p>某台计算机的IP是<code>101.202.99.2</code>，子网掩码是<code>255.255.255.0</code>，那么计算该计算机的网络号是：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">IP</span> = <span class=\"number\">101.202</span>.<span class=\"number\">99.2</span></span><br><span class=\"line\"><span class=\"attr\">Mask</span> = <span class=\"number\">255.255</span>.<span class=\"number\">255.0</span></span><br><span class=\"line\"><span class=\"attr\">Network</span> = IP &amp; Mask = <span class=\"number\">101.202</span>.<span class=\"number\">99.0</span></span><br></pre></td></tr></table></figure>\n\n<p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</p>\n<p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。</p>\n<p>所以，一台计算机的一个网卡会有3个关键配置：</p>\n<p><img src=\"/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l.png\" alt=\"network\"></p>\n<ul>\n<li>IP地址，例如：<code>10.0.2.15</code></li>\n<li>子网掩码，例如：<code>255.255.255.0</code></li>\n<li>网关的IP地址，例如：<code>10.0.2.2</code></li>\n</ul>\n<h3 id=\"域名\"><a href=\"#域名\" class=\"headerlink\" title=\"域名\"></a>域名</h3><p>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</p>\n<p>用<code>nslookup</code>可以查看域名对应的IP地址：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ nslookup www<span class=\"selector-class\">.liaoxuefeng</span><span class=\"selector-class\">.com</span></span><br><span class=\"line\">Server:  xxx<span class=\"selector-class\">.xxx</span><span class=\"selector-class\">.xxx</span><span class=\"selector-class\">.xxx</span></span><br><span class=\"line\">Address: xxx<span class=\"selector-class\">.xxx</span><span class=\"selector-class\">.xxx</span>.xxx#<span class=\"number\">53</span></span><br><span class=\"line\"></span><br><span class=\"line\">Non-authoritative answer:</span><br><span class=\"line\">Name:    www<span class=\"selector-class\">.liaoxuefeng</span><span class=\"selector-class\">.com</span></span><br><span class=\"line\">Address: <span class=\"number\">47.98</span>.<span class=\"number\">33.223</span></span><br></pre></td></tr></table></figure>\n\n<p>有一个特殊的本机域名<code>localhost</code>，它对应的IP地址总是本机地址<code>127.0.0.1</code>。</p>\n<h3 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h3><p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>\n<ul>\n<li>应用层，提供应用程序之间的通信；</li>\n<li>表示层：处理数据格式，加解密等等；</li>\n<li>会话层：负责建立和维护会话；</li>\n<li>传输层：负责提供端到端的可靠传输；</li>\n<li>网络层：负责根据目标地址选择路由来传输数据；</li>\n<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>\n</ul>\n<p>互联网实际使用的TCP&#x2F;IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">OSI</th>\n<th align=\"left\">TCP&#x2F;IP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">应用层</td>\n<td align=\"left\">应用层</td>\n</tr>\n<tr>\n<td align=\"left\">表示层</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">会话层</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">传输层</td>\n<td align=\"left\">传输层</td>\n</tr>\n<tr>\n<td align=\"left\">网络层</td>\n<td align=\"left\">IP层</td>\n</tr>\n<tr>\n<td align=\"left\">链路层</td>\n<td align=\"left\">网络接口层</td>\n</tr>\n<tr>\n<td align=\"left\">物理层</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"常用协议\"><a href=\"#常用协议\" class=\"headerlink\" title=\"常用协议\"></a>常用协议</h3><p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p>\n<p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p>\n<p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p>\n<p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p>\n<h1 id=\"TCP编程\"><a href=\"#TCP编程\" class=\"headerlink\" title=\"TCP编程\"></a>TCP编程</h1><p>在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP&#x2F;IP协议把数据传输到网络：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────┐                                   ┌───────────┐</span><br><span class=\"line\">│Application│                                   │Application│</span><br><span class=\"line\">├───────────┤                                   ├───────────┤</span><br><span class=\"line\">│  Socket   │                                   │  Socket   │</span><br><span class=\"line\">├───────────┤                                   ├───────────┤</span><br><span class=\"line\">│    TCP    │                                   │    TCP    │</span><br><span class=\"line\">├───────────┤      ┌──────┐       ┌──────┐      ├───────────┤</span><br><span class=\"line\">│    IP     │&lt;────&gt;│Router│&lt;─────&gt;│Router│&lt;────&gt;│    IP     │</span><br><span class=\"line\">└───────────┘      └──────┘       └──────┘      └───────────┘</span><br></pre></td></tr></table></figure>\n\n<p>Socket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单的封装。例如，Java提供的几个Socket相关的类就封装了操作系统提供的接口。</p>\n<p>为什么需要Socket进行网络通信？因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p>\n<p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<em>特权端口</em>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p>\n<ul>\n<li>101.202.99.2:1201</li>\n<li>101.202.99.2:1304</li>\n<li>101.202.99.2:15000</li>\n</ul>\n<p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p>\n<p>因此，当Socket连接成功地在服务器端和客户端之间建立后：</p>\n<ul>\n<li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li>\n<li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li>\n</ul>\n<h3 id=\"服务器端\"><a href=\"#服务器端\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h3><p>要使用Socket编程，我们首先要编写服务器端程序。Java标准库提供了<code>ServerSocket</code>来实现对指定IP和指定端口的监听。<code>ServerSocket</code>的典型实现代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Server</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class=\"line\">        ServerSocket ss = <span class=\"keyword\">new</span> <span class=\"built_in\">ServerSocket</span>(<span class=\"number\">6666</span>); <span class=\"comment\">// 监听指定端口</span></span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;server is running...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            Socket sock = ss.<span class=\"built_in\">accept</span>();</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;connected from &quot;</span> + sock.<span class=\"built_in\">getRemoteSocketAddress</span>());</span><br><span class=\"line\">            Thread t = <span class=\"keyword\">new</span> <span class=\"built_in\">Handler</span>(sock);</span><br><span class=\"line\">            t.<span class=\"built_in\">start</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Handler</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span></span><br><span class=\"line\">    Socket sock;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Handler</span><span class=\"params\">(Socket sock)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.sock = sock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    @<span class=\"function\">Override</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">try</span></span> (InputStream input = <span class=\"keyword\">this</span>.sock.<span class=\"built_in\">getInputStream</span>()) &#123;</span><br><span class=\"line\">            <span class=\"built_in\"><span class=\"keyword\">try</span></span> (OutputStream output = <span class=\"keyword\">this</span>.sock.<span class=\"built_in\">getOutputStream</span>()) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">handle</span>(input, output);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.sock.<span class=\"built_in\">close</span>();</span><br><span class=\"line\">            &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (IOException ioe) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;client disconnected.&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">handle</span><span class=\"params\">(InputStream input, OutputStream output)</span> throws IOException </span>&#123;</span><br><span class=\"line\">        var writer = <span class=\"keyword\">new</span> <span class=\"built_in\">BufferedWriter</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class=\"line\">        var reader = <span class=\"keyword\">new</span> <span class=\"built_in\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class=\"line\">        writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;hello\\n&quot;</span>);</span><br><span class=\"line\">        writer.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">String</span> s = reader.<span class=\"built_in\">readLine</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.<span class=\"built_in\">equals</span>(<span class=\"string\">&quot;bye&quot;</span>)) &#123;</span><br><span class=\"line\">                writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;bye\\n&quot;</span>);</span><br><span class=\"line\">                writer.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            writer.<span class=\"built_in\">write</span>(<span class=\"string\">&quot;ok: &quot;</span> + s + <span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">            writer.<span class=\"built_in\">flush</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务器端通过代码：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">ServerSocket ss</span> = new ServerSocket(6666);</span><br></pre></td></tr></table></figure>\n\n<p>在指定端口<code>6666</code>监听。这里我们没有指定IP地址，表示在计算机的所有网络接口上进行监听。</p>\n<p>如果<code>ServerSocket</code>监听成功，我们就使用一个无限循环来处理客户端的连接：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (<span class=\"comment\">;;) &#123;</span></span><br><span class=\"line\">    Socket sock = ss.accept()<span class=\"comment\">;</span></span><br><span class=\"line\">    Thread <span class=\"literal\">t</span> = new Handler(<span class=\"name\">sock</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">    <span class=\"literal\">t</span>.start()<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到代码<code>ss.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code>Socket</code>实例，这个<code>Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的<code>Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p>\n<p>我们在多线程编程的章节中介绍过线程池，这里也完全可以利用线程池来处理客户端连接，能大大提高运行效率。</p>\n<p>如果没有客户端连接进来，<code>accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code>ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code>accept()</code>就可以获取新的连接。</p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>相比服务器端，客户端程序就要简单很多。一个典型的客户端程序如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> Client &#123;</span><br><span class=\"line\">    public static void main(String<span class=\"literal\">[]</span> args) throws IOException &#123;</span><br><span class=\"line\">        Socket sock = <span class=\"keyword\">new</span> <span class=\"constructor\">Socket(<span class=\"string\">&quot;localhost&quot;</span>, 6666)</span>; <span class=\"comment\">// 连接指定服务器和端口</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> (InputStream input = sock.get<span class=\"constructor\">InputStream()</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> (OutputStream output = sock.get<span class=\"constructor\">OutputStream()</span>) &#123;</span><br><span class=\"line\">                handle(input, output);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sock.close<span class=\"literal\">()</span>;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;disconnected.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> static void handle(InputStream input, OutputStream output) throws IOException &#123;</span><br><span class=\"line\">        var writer = <span class=\"keyword\">new</span> <span class=\"constructor\">BufferedWriter(<span class=\"params\">new</span> OutputStreamWriter(<span class=\"params\">output</span>, StandardCharsets.UTF_8)</span>);</span><br><span class=\"line\">        var reader = <span class=\"keyword\">new</span> <span class=\"constructor\">BufferedReader(<span class=\"params\">new</span> InputStreamReader(<span class=\"params\">input</span>, StandardCharsets.UTF_8)</span>);</span><br><span class=\"line\">        Scanner scanner = <span class=\"keyword\">new</span> <span class=\"constructor\">Scanner(System.<span class=\"params\">in</span>)</span>;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;[server] &quot;</span> + reader.read<span class=\"constructor\">Line()</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.print(<span class=\"string\">&quot;&gt;&gt;&gt; &quot;</span>); <span class=\"comment\">// 打印提示</span></span><br><span class=\"line\">            String s = scanner.next<span class=\"constructor\">Line()</span>; <span class=\"comment\">// 读取一行输入</span></span><br><span class=\"line\">            writer.write(s);</span><br><span class=\"line\">            writer.<span class=\"keyword\">new</span><span class=\"constructor\">Line()</span>;</span><br><span class=\"line\">            writer.flush<span class=\"literal\">()</span>;</span><br><span class=\"line\">            String resp = reader.read<span class=\"constructor\">Line()</span>;</span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;&lt;&lt;&lt; &quot;</span> + resp);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (resp.equals(<span class=\"string\">&quot;bye&quot;</span>)) &#123;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端程序通过：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Socket sock</span> = new Socket(<span class=\"string\">&quot;localhost&quot;</span>, 6666);</span><br></pre></td></tr></table></figure>\n\n<p>连接到服务器端，注意上述代码的服务器地址是<code>&quot;localhost&quot;</code>，表示本机地址，端口号是<code>6666</code>。如果连接成功，将返回一个<code>Socket</code>实例，用于后续通信。</p>\n<h3 id=\"Socket流\"><a href=\"#Socket流\" class=\"headerlink\" title=\"Socket流\"></a>Socket流</h3><p>当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用<code>Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code>InputStream</code>和<code>OutputStream</code>来封装Socket的数据流，这样我们使用Socket的流，和普通IO流类似：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 用于读取网络数据:</span><br><span class=\"line\">InputStream <span class=\"keyword\">in</span> = sock.getInputStream();</span><br><span class=\"line\"><span class=\"regexp\">//</span> 用于写入网络数据:</span><br><span class=\"line\">OutputStream out = sock.getOutputStream();</span><br></pre></td></tr></table></figure>\n\n<p>最后我们重点来看看，为什么写入网络数据时，要调用<code>flush()</code>方法。</p>\n<p>如果不调用<code>flush()</code>，我们很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而我们又想强制把这些数据发送到网络，就必须调用<code>flush()</code>强制把缓冲区数据发送出去。</p>\n<h1 id=\"UDP编程\"><a href=\"#UDP编程\" class=\"headerlink\" title=\"UDP编程\"></a>UDP编程</h1><p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p>\n<p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p>\n<h3 id=\"服务器端-1\"><a href=\"#服务器端-1\" class=\"headerlink\" title=\"服务器端\"></a>服务器端</h3><p>在服务器端，使用UDP也需要监听指定的端口。Java提供了<code>DatagramSocket</code>来实现这个功能，代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DatagramSocket ds = <span class=\"keyword\">new</span> <span class=\"constructor\">DatagramSocket(6666)</span>; <span class=\"comment\">// 监听指定端口</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123; <span class=\"comment\">// 无限循环</span></span><br><span class=\"line\">    <span class=\"comment\">// 数据缓冲区:</span></span><br><span class=\"line\">    byte<span class=\"literal\">[]</span> buffer = <span class=\"keyword\">new</span> byte<span class=\"literal\">[<span class=\"number\">1024</span>]</span>;</span><br><span class=\"line\">    DatagramPacket packet = <span class=\"keyword\">new</span> <span class=\"constructor\">DatagramPacket(<span class=\"params\">buffer</span>, <span class=\"params\">buffer</span>.<span class=\"params\">length</span>)</span>;</span><br><span class=\"line\">    ds.receive(packet); <span class=\"comment\">// 收取一个UDP数据包</span></span><br><span class=\"line\">    <span class=\"comment\">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span></span><br><span class=\"line\">    <span class=\"comment\">// 将其按UTF-8编码转换为String:</span></span><br><span class=\"line\">    String s = <span class=\"keyword\">new</span> <span class=\"constructor\">String(<span class=\"params\">packet</span>.<span class=\"params\">getData</span>()</span>, packet.get<span class=\"constructor\">Offset()</span>, packet.get<span class=\"constructor\">Length()</span>, StandardCharsets.UTF_8);</span><br><span class=\"line\">    <span class=\"comment\">// 发送数据:</span></span><br><span class=\"line\">    byte<span class=\"literal\">[]</span> data = <span class=\"string\">&quot;ACK&quot;</span>.get<span class=\"constructor\">Bytes(StandardCharsets.UTF_8)</span>;</span><br><span class=\"line\">    packet.set<span class=\"constructor\">Data(<span class=\"params\">data</span>)</span>;</span><br><span class=\"line\">    ds.send(packet);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>服务器端首先使用如下语句在指定的端口监听UDP数据包：</p>\n<figure class=\"highlight ebnf\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">DatagramSocket ds</span> = new DatagramSocket(6666);</span><br></pre></td></tr></table></figure>\n\n<p>如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">for (<span class=\"comment\">;;) &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要接收一个UDP数据包，需要准备一个<code>byte[]</code>缓冲区，并通过<code>DatagramPacket</code>实现接收：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[<span class=\"number\">1024</span>];</span><br><span class=\"line\">DatagramPacket packet = <span class=\"keyword\">new</span> <span class=\"built_in\">DatagramPacket</span>(buffer, buffer.length);</span><br><span class=\"line\">ds.<span class=\"built_in\">receive</span>(packet);</span><br></pre></td></tr></table></figure>\n\n<p>假设我们收取到的是一个<code>String</code>，那么，通过<code>DatagramPacket</code>返回的<code>packet.getOffset()</code>和<code>packet.getLength()</code>确定数据在缓冲区的起止位置：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"keyword\">new</span> <span class=\"constructor\">String(<span class=\"params\">packet</span>.<span class=\"params\">getData</span>()</span>, packet.get<span class=\"constructor\">Offset()</span>, packet.get<span class=\"constructor\">Length()</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>\n\n<p>当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。</p>\n<p>发送UDP包也是通过<code>DatagramPacket</code>实现的，发送代码非常简单：</p>\n<figure class=\"highlight haskell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">byte</span>[] <span class=\"class\"><span class=\"keyword\">data</span> = ...</span></span><br><span class=\"line\"><span class=\"title\">packet</span>.setData(<span class=\"class\"><span class=\"keyword\">data</span>);</span></span><br><span class=\"line\"><span class=\"title\">ds</span>.send(packet);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"客户端-1\"><a href=\"#客户端-1\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>和服务器端相比，客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DatagramSocket ds = <span class=\"keyword\">new</span> <span class=\"constructor\">DatagramSocket()</span>;</span><br><span class=\"line\">ds.set<span class=\"constructor\">SoTimeout(1000)</span>;</span><br><span class=\"line\">ds.connect(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">InetAddress</span>.</span></span>get<span class=\"constructor\">ByName(<span class=\"string\">&quot;localhost&quot;</span>)</span>, <span class=\"number\">6666</span>); <span class=\"comment\">// 连接指定服务器和端口</span></span><br><span class=\"line\"><span class=\"comment\">// 发送:</span></span><br><span class=\"line\">byte<span class=\"literal\">[]</span> data = <span class=\"string\">&quot;Hello&quot;</span>.get<span class=\"constructor\">Bytes()</span>;</span><br><span class=\"line\">DatagramPacket packet = <span class=\"keyword\">new</span> <span class=\"constructor\">DatagramPacket(<span class=\"params\">data</span>, <span class=\"params\">data</span>.<span class=\"params\">length</span>)</span>;</span><br><span class=\"line\">ds.send(packet);</span><br><span class=\"line\"><span class=\"comment\">// 接收:</span></span><br><span class=\"line\">byte<span class=\"literal\">[]</span> buffer = <span class=\"keyword\">new</span> byte<span class=\"literal\">[<span class=\"number\">1024</span>]</span>;</span><br><span class=\"line\">packet = <span class=\"keyword\">new</span> <span class=\"constructor\">DatagramPacket(<span class=\"params\">buffer</span>, <span class=\"params\">buffer</span>.<span class=\"params\">length</span>)</span>;</span><br><span class=\"line\">ds.receive(packet);</span><br><span class=\"line\">String resp = <span class=\"keyword\">new</span> <span class=\"constructor\">String(<span class=\"params\">packet</span>.<span class=\"params\">getData</span>()</span>, packet.get<span class=\"constructor\">Offset()</span>, packet.get<span class=\"constructor\">Length()</span>);</span><br><span class=\"line\">ds.disconnect<span class=\"literal\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>客户端打开一个<code>DatagramSocket</code>使用以下代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DatagramSocket ds = <span class=\"keyword\">new</span> <span class=\"constructor\">DatagramSocket()</span>;</span><br><span class=\"line\">ds.set<span class=\"constructor\">SoTimeout(1000)</span>;</span><br><span class=\"line\">ds.connect(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">InetAddress</span>.</span></span>get<span class=\"constructor\">ByName(<span class=\"string\">&quot;localhost&quot;</span>)</span>, <span class=\"number\">6666</span>);</span><br></pre></td></tr></table></figure>\n\n<p>客户端创建<code>DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code>setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p>\n<p>注意到客户端的<code>DatagramSocket</code>还调用了一个<code>connect()</code>方法“连接”到指定的服务器端。不是说UDP是无连接的协议吗？为啥这里需要<code>connect()</code>？</p>\n<p>这个<code>connect()</code>方法不是真连接，它是为了在客户端的<code>DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code>DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p>\n<p>如果客户端希望向两个不同的服务器发送UDP包，那么它必须创建两个<code>DatagramSocket</code>实例。</p>\n<p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p>\n<p>如果客户端认为通信结束，就可以调用<code>disconnect()</code>断开连接：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">ds.disconnect()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code>DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code>DatagramSocket</code>实例就可以连接另一个服务器端。</p>\n<h1 id=\"发送Email\"><a href=\"#发送Email\" class=\"headerlink\" title=\"发送Email\"></a>发送Email</h1><p>Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如<code>abc@example.com</code>，邮件软件比如Outlook都是用来收发邮件的。</p>\n<p>使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。</p>\n<p>传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">           ┌──────────┐    ┌──────────┐</span><br><span class=\"line\">           │PostOffice│    │PostOffice│     .───.</span><br><span class=\"line\">┌─────┐    ├──────────┤    ├──────────┤    (   ( )</span><br><span class=\"line\">│═══ ░│───&gt;│ ┌─┐ ┌┐┌┐ │───&gt;│ ┌─┐ ┌┐┌┐ │───&gt; `─┬─&#x27;</span><br><span class=\"line\">└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │</span><br><span class=\"line\">           └─┴─┴──────┘    └─┴─┴──────┘       │</span><br></pre></td></tr></table></figure>\n\n<p>电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">             ┌─────────┐    ┌─────────┐    ┌─────────┐</span><br><span class=\"line\">             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│</span><br><span class=\"line\">┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐</span><br><span class=\"line\">│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│</span><br><span class=\"line\">├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤</span><br><span class=\"line\">│       │───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│&lt;───│       │</span><br><span class=\"line\">└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘</span><br><span class=\"line\">   MUA           MTA            MTA            MDA           MUA</span><br></pre></td></tr></table></figure>\n\n<p>我们把类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p>\n<p>MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p>\n<p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。</p>\n<p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。</p>\n<h3 id=\"准备SMTP登录信息\"><a href=\"#准备SMTP登录信息\" class=\"headerlink\" title=\"准备SMTP登录信息\"></a>准备SMTP登录信息</h3><p>假设我们准备使用自己的邮件地址<code>me@example.com</code>给小明发送邮件，已知小明的邮件地址是<code>xiaoming@somewhere.com</code>，发送邮件前，我们首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是<code>smtp.example.com</code>，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：</p>\n<ul>\n<li>QQ邮箱：SMTP服务器是smtp.qq.com，端口是465&#x2F;587；</li>\n<li>163邮箱：SMTP服务器是smtp.163.com，端口是465；</li>\n<li>Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465&#x2F;587。</li>\n</ul>\n<p>有了SMTP服务器的域名和端口号，我们还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p>\n<p>我们来看看如何使用JavaMail发送邮件。</p>\n<p>首先，我们需要创建一个Maven工程，并把JavaMail相关的两个依赖加入进来：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>javax.mail<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.mail-api<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.sun.mail<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>javax.mail<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们通过JavaMail API连接到SMTP服务器上：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 服务器地址:</span></span><br><span class=\"line\">String smtp = <span class=\"string\">&quot;smtp.office365.com&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 登录用户名:</span></span><br><span class=\"line\">String username = <span class=\"string\">&quot;jxsmtp101@outlook.com&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 登录口令:</span></span><br><span class=\"line\">String password = <span class=\"string\">&quot;********&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 连接到SMTP服务器587端口:</span></span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> <span class=\"constructor\">Properties()</span>;</span><br><span class=\"line\">props.put(<span class=\"string\">&quot;mail.smtp.host&quot;</span>, smtp); <span class=\"comment\">// SMTP主机名</span></span><br><span class=\"line\">props.put(<span class=\"string\">&quot;mail.smtp.port&quot;</span>, <span class=\"string\">&quot;587&quot;</span>); <span class=\"comment\">// 主机端口号</span></span><br><span class=\"line\">props.put(<span class=\"string\">&quot;mail.smtp.auth&quot;</span>, <span class=\"string\">&quot;true&quot;</span>); <span class=\"comment\">// 是否需要用户认证</span></span><br><span class=\"line\">props.put(<span class=\"string\">&quot;mail.smtp.starttls.enable&quot;</span>, <span class=\"string\">&quot;true&quot;</span>); <span class=\"comment\">// 启用TLS加密</span></span><br><span class=\"line\"><span class=\"comment\">// 获取Session实例:</span></span><br><span class=\"line\">Session session = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Session</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"params\">props</span>, <span class=\"params\">new</span> Authenticator()</span> &#123;</span><br><span class=\"line\">    protected PasswordAuthentication get<span class=\"constructor\">PasswordAuthentication()</span> &#123;</span><br><span class=\"line\">        return <span class=\"keyword\">new</span> <span class=\"constructor\">PasswordAuthentication(<span class=\"params\">username</span>, <span class=\"params\">password</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 设置debug模式便于调试:</span></span><br><span class=\"line\">session.set<span class=\"constructor\">Debug(<span class=\"params\">true</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>以587端口为例，连接SMTP服务器时，需要准备一个Properties对象，填入相关信息。最后获取Session实例时，如果服务器需要认证，还需要传入一个Authenticator对象，并返回指定的用户名和口令。</p>\n<p>当我们获取到Session实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p>\n<h3 id=\"发送邮件\"><a href=\"#发送邮件\" class=\"headerlink\" title=\"发送邮件\"></a>发送邮件</h3><p>发送邮件时，我们需要构造一个<code>Message</code>对象，然后调用<code>Transport.send(Message)</code>即可完成发送：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">MimeMessage message = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeMessage(<span class=\"params\">session</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置发送方地址:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">From(<span class=\"params\">new</span> InternetAddress(<span class=\"string\">&quot;me@example.com&quot;</span>)</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置接收方地址:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">Recipient(Message.RecipientType.TO, <span class=\"params\">new</span> InternetAddress(<span class=\"string\">&quot;xiaoming@somewhere.com&quot;</span>)</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置邮件主题:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">Subject(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置邮件正文:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">Text(<span class=\"string\">&quot;Hi Xiaoming...&quot;</span>, <span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 发送:</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Transport</span>.</span></span>send(message);</span><br></pre></td></tr></table></figure>\n\n<p>绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。</p>\n<p>填入真实的地址，运行上述代码，我们可以在控制台看到JavaMail打印的调试信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这是JavaMail打印的调试信息:</span><br><span class=\"line\">DEBUG: setDebug: JavaMail version 1.6.2</span><br><span class=\"line\">DEBUG: getProvider() returning javax.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]</span><br><span class=\"line\">DEBUG SMTP: need username and password for authentication</span><br><span class=\"line\">DEBUG SMTP: protocolConnect returning false, host=smtp.office365.com, ...</span><br><span class=\"line\">DEBUG SMTP: useEhlo true, useAuth true</span><br><span class=\"line\">开始尝试连接smtp.office365.com:</span><br><span class=\"line\">DEBUG SMTP: trying to connect to host &quot;smtp.office365.com&quot;, port 587, ...</span><br><span class=\"line\">DEBUG SMTP: connected to host &quot;smtp.office365.com&quot;, port: 587</span><br><span class=\"line\">发送命令EHLO:</span><br><span class=\"line\">EHLO localhost</span><br><span class=\"line\">SMTP服务器响应250:</span><br><span class=\"line\">250-SG3P274CA0024.outlook.office365.com Hello</span><br><span class=\"line\">250-SIZE 157286400</span><br><span class=\"line\">...</span><br><span class=\"line\">DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;</span><br><span class=\"line\">发送命令STARTTLS:</span><br><span class=\"line\">STARTTLS</span><br><span class=\"line\">SMTP服务器响应220:</span><br><span class=\"line\">220 2.0.0 SMTP server ready</span><br><span class=\"line\">EHLO localhost</span><br><span class=\"line\">250-SG3P274CA0024.outlook.office365.com Hello [111.196.164.63]</span><br><span class=\"line\">250-SIZE 157286400</span><br><span class=\"line\">250-PIPELINING</span><br><span class=\"line\">250-...</span><br><span class=\"line\">DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;</span><br><span class=\"line\">...</span><br><span class=\"line\">尝试登录:</span><br><span class=\"line\">DEBUG SMTP: protocolConnect login, host=smtp.office365.com, user=********, password=********</span><br><span class=\"line\">DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 </span><br><span class=\"line\">DEBUG SMTP: Using mechanism LOGIN</span><br><span class=\"line\">DEBUG SMTP: AUTH LOGIN command trace suppressed</span><br><span class=\"line\">登录成功:</span><br><span class=\"line\">DEBUG SMTP: AUTH LOGIN succeeded</span><br><span class=\"line\">DEBUG SMTP: use8bit false</span><br><span class=\"line\">开发发送邮件，设置FROM:</span><br><span class=\"line\">MAIL FROM:&lt;********@outlook.com&gt;</span><br><span class=\"line\">250 2.1.0 Sender OK</span><br><span class=\"line\">设置TO:</span><br><span class=\"line\">RCPT TO:&lt;********@sina.com&gt;</span><br><span class=\"line\">250 2.1.5 Recipient OK</span><br><span class=\"line\">发送邮件数据:</span><br><span class=\"line\">DATA</span><br><span class=\"line\">服务器响应354:</span><br><span class=\"line\">354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;</span><br><span class=\"line\">真正的邮件数据:</span><br><span class=\"line\">Date: Mon, 2 Dec 2019 09:37:52 +0800 (CST)</span><br><span class=\"line\">From: ********@outlook.com</span><br><span class=\"line\">To: ********001@sina.com</span><br><span class=\"line\">Message-ID: &lt;1617791695.0.1575250672483@localhost&gt;</span><br><span class=\"line\">邮件主题是编码后的文本:</span><br><span class=\"line\">Subject: =?UTF-8?Q?JavaMail=E9=82=AE=E4=BB=B6?=</span><br><span class=\"line\">MIME-Version: 1.0</span><br><span class=\"line\">Content-Type: text/plain; charset=UTF-8</span><br><span class=\"line\">Content-Transfer-Encoding: base64</span><br><span class=\"line\"></span><br><span class=\"line\">邮件正文是Base64编码的文本:</span><br><span class=\"line\">SGVsbG8sIOi/meaYr+S4gOWwgeadpeiHqmphdmFtYWls55qE6YKu5Lu277yB</span><br><span class=\"line\">.</span><br><span class=\"line\">邮件数据发送完成后，以\\r\\n.\\r\\n结束，服务器响应250表示发送成功:</span><br><span class=\"line\">250 2.0.0 OK &lt;HK0PR03MB4961.apcprd03.prod.outlook.com&gt; [Hostname=HK0PR03MB4961.apcprd03.prod.outlook.com]</span><br><span class=\"line\">DEBUG SMTP: message successfully delivered to mail server</span><br><span class=\"line\">发送QUIT命令:</span><br><span class=\"line\">QUIT</span><br><span class=\"line\">服务器响应221结束TCP连接:</span><br><span class=\"line\">221 2.0.0 Service closing transmission channel</span><br></pre></td></tr></table></figure>\n\n<p>从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在<a href=\"https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt\">SMTP协议</a>中了，查看具体的响应码就可以知道出错原因。</p>\n<p>如果一切顺利，对方将收到一封文本格式的电子邮件：</p>\n<p><img src=\"/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713672.png\" alt=\"javamail-text\"></p>\n<h3 id=\"发送HTML邮件\"><a href=\"#发送HTML邮件\" class=\"headerlink\" title=\"发送HTML邮件\"></a>发送HTML邮件</h3><p>发送HTML邮件和文本邮件是类似的，只需要把：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">message.set<span class=\"constructor\">Text(<span class=\"params\">body</span>, <span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>改为：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">message.set<span class=\"constructor\">Text(<span class=\"params\">body</span>, <span class=\"string\">&quot;UTF-8&quot;</span>, <span class=\"string\">&quot;html&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>传入的<code>body</code>是类似<code>&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hi, xxx&lt;/p&gt;</code>这样的HTML字符串即可。</p>\n<p>HTML邮件可以在邮件客户端直接显示为网页格式：</p>\n<p><img src=\"/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713683.png\" alt=\"javamail-html\"></p>\n<h3 id=\"发送附件\"><a href=\"#发送附件\" class=\"headerlink\" title=\"发送附件\"></a>发送附件</h3><p>要在电子邮件中携带附件，我们就不能直接调用<code>message.setText()</code>方法，而是要构造一个<code>Multipart</code>对象：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Multipart multipart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeMultipart()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 添加text:</span></span><br><span class=\"line\">BodyPart textpart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeBodyPart()</span>;</span><br><span class=\"line\">textpart.set<span class=\"constructor\">Content(<span class=\"params\">body</span>, <span class=\"string\">&quot;text/html;charset=utf-8&quot;</span>)</span>;</span><br><span class=\"line\">multipart.add<span class=\"constructor\">BodyPart(<span class=\"params\">textpart</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 添加image:</span></span><br><span class=\"line\">BodyPart imagepart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeBodyPart()</span>;</span><br><span class=\"line\">imagepart.set<span class=\"constructor\">FileName(<span class=\"params\">fileName</span>)</span>;</span><br><span class=\"line\">imagepart.set<span class=\"constructor\">DataHandler(<span class=\"params\">new</span> DataHandler(<span class=\"params\">new</span> ByteArrayDataSource(<span class=\"params\">input</span>, <span class=\"string\">&quot;application/octet-stream&quot;</span>)</span>));</span><br><span class=\"line\">multipart.add<span class=\"constructor\">BodyPart(<span class=\"params\">imagepart</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置邮件内容为multipart:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">Content(<span class=\"params\">multipart</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>一个<code>Multipart</code>对象可以添加若干个<code>BodyPart</code>，其中第一个<code>BodyPart</code>是文本，即邮件正文，后面的BodyPart是附件。<code>BodyPart</code>依靠<code>setContent()</code>决定添加的内容，如果添加文本，用<code>setContent(&quot;...&quot;, &quot;text/plain;charset=utf-8&quot;)</code>添加纯文本，或者用<code>setContent(&quot;...&quot;, &quot;text/html;charset=utf-8&quot;)</code>添加HTML文本。如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个<code>DataHandler()</code>，传入文件的MIME类型。二进制文件可以用<code>application/octet-stream</code>，Word文档则是<code>application/msword</code>。</p>\n<p>最后，通过<code>setContent()</code>把<code>Multipart</code>添加到<code>Message</code>中，即可发送。</p>\n<p>带附件的邮件在客户端会被提示下载：</p>\n<p><img src=\"/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713684.png\" alt=\"javamail-attachment\"></p>\n<h3 id=\"发送内嵌图片的HTML邮件\"><a href=\"#发送内嵌图片的HTML邮件\" class=\"headerlink\" title=\"发送内嵌图片的HTML邮件\"></a>发送内嵌图片的HTML邮件</h3><p>有些童鞋可能注意到，HTML邮件中可以内嵌图片，这是怎么做到的？</p>\n<p>如果给一个<code>&lt;img src=&quot;http://example.com/test.jpg&quot;&gt;</code>，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。</p>\n<p>内嵌图片实际上也是一个附件，即邮件本身也是<code>Multipart</code>，但需要做一点额外的处理：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Multipart multipart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeMultipart()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 添加text:</span></span><br><span class=\"line\">BodyPart textpart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeBodyPart()</span>;</span><br><span class=\"line\">textpart.set<span class=\"constructor\">Content(<span class=\"string\">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;&lt;img src=\\&quot;cid:img01\\&quot;&gt;&lt;/p&gt;&quot;</span>, <span class=\"string\">&quot;text/html;charset=utf-8&quot;</span>)</span>;</span><br><span class=\"line\">multipart.add<span class=\"constructor\">BodyPart(<span class=\"params\">textpart</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 添加image:</span></span><br><span class=\"line\">BodyPart imagepart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeBodyPart()</span>;</span><br><span class=\"line\">imagepart.set<span class=\"constructor\">FileName(<span class=\"params\">fileName</span>)</span>;</span><br><span class=\"line\">imagepart.set<span class=\"constructor\">DataHandler(<span class=\"params\">new</span> DataHandler(<span class=\"params\">new</span> ByteArrayDataSource(<span class=\"params\">input</span>, <span class=\"string\">&quot;image/jpeg&quot;</span>)</span>));</span><br><span class=\"line\"><span class=\"comment\">// 与HTML的&lt;img src=&quot;cid:img01&quot;&gt;关联:</span></span><br><span class=\"line\">imagepart.set<span class=\"constructor\">Header(<span class=\"string\">&quot;Content-ID&quot;</span>, <span class=\"string\">&quot;&lt;img01&gt;&quot;</span>)</span>;</span><br><span class=\"line\">multipart.add<span class=\"constructor\">BodyPart(<span class=\"params\">imagepart</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在HTML邮件中引用图片时，需要设定一个ID，用类似<code>&lt;img src=\\&quot;cid:img01\\&quot;&gt;</code>引用，然后，在添加图片作为BodyPart时，除了要正确设置MIME类型（根据图片类型使用<code>image/jpeg</code>或<code>image/png</code>），还需要设置一个Header：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">imagepart</span><span class=\"selector-class\">.setHeader</span>(<span class=\"string\">&quot;Content-ID&quot;</span>, <span class=\"string\">&quot;&lt;img01&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这个ID和HTML中引用的ID对应起来，邮件客户端就可以正常显示内嵌图片：</p>\n<p><img src=\"/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713685.png\" alt=\"javamail-inline\"></p>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><p>如果用户名或口令错误，会导致<code>535</code>登录失败：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">DEBUG</span> SMTP: AUTH LOGIN failed</span><br><span class=\"line\"><span class=\"attribute\">Exception</span> in thread <span class=\"string\">&quot;main&quot;</span> javax.mail.AuthenticationFailedException: <span class=\"number\">535</span> <span class=\"number\">5</span>.<span class=\"number\">7</span>.<span class=\"number\">3</span> Authentication unsuccessful<span class=\"meta\"> [HK0PR03CA0105.apcprd03.prod.outlook.com]</span></span><br></pre></td></tr></table></figure>\n\n<p>如果登录用户和发件人不一致，会导致<code>554</code>拒绝发送错误：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">DEBUG</span> SMTP: MessagingException while sending, THROW: </span><br><span class=\"line\"><span class=\"attribute\">com</span>.sun.mail.smtp.SMTPSendFailedException: <span class=\"number\">554</span> <span class=\"number\">5</span>.<span class=\"number\">2</span>.<span class=\"number\">0</span> STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;</span><br></pre></td></tr></table></figure>\n\n<p>有些时候，如果邮件主题和正文过于简单，会导致<code>554</code>被识别为垃圾邮件的错误：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"code\"><pre><span class=\"line\">DEBUG SMTP: MessagingException while sending, THROW: </span><br><span class=\"line\">com<span class=\"selector-class\">.sun</span><span class=\"selector-class\">.mail</span><span class=\"selector-class\">.smtp</span><span class=\"selector-class\">.SMTPSendFailedException</span>: <span class=\"number\">554</span> DT:SPM</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"接收Email\"><a href=\"#接收Email\" class=\"headerlink\" title=\"接收Email\"></a>接收Email</h1><p>发送Email的过程我们在上一节已经讲过了，客户端总是通过SMTP协议把邮件发送给MTA。</p>\n<p>接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p>\n<p>接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。</p>\n<p>另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口143和加密端口993。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p>\n<p>JavaMail也提供了IMAP协议的支持。因为POP3和IMAP的使用方式非常类似，因此我们只介绍POP3的用法。</p>\n<p>使用POP3收取Email时，我们无需关心POP3协议底层，因为JavaMail提供了高层接口。首先需要连接到Store对象：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 准备登录信息:</span></span><br><span class=\"line\">String host = <span class=\"string\">&quot;pop3.example.com&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">int</span> port = <span class=\"number\">995</span>;</span><br><span class=\"line\">String username = <span class=\"string\">&quot;bob@example.com&quot;</span>;</span><br><span class=\"line\">String password = <span class=\"string\">&quot;password&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Properties props = <span class=\"keyword\">new</span> <span class=\"constructor\">Properties()</span>;</span><br><span class=\"line\">props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;mail.store.protocol&quot;</span>, <span class=\"string\">&quot;pop3&quot;</span>)</span>; <span class=\"comment\">// 协议名称</span></span><br><span class=\"line\">props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;mail.pop3.host&quot;</span>, <span class=\"params\">host</span>)</span>;<span class=\"comment\">// POP3主机名</span></span><br><span class=\"line\">props.set<span class=\"constructor\">Property(<span class=\"string\">&quot;mail.pop3.port&quot;</span>, String.<span class=\"params\">valueOf</span>(<span class=\"params\">port</span>)</span>); <span class=\"comment\">// 端口号</span></span><br><span class=\"line\"><span class=\"comment\">// 启动SSL:</span></span><br><span class=\"line\">props.put(<span class=\"string\">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class=\"string\">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class=\"line\">props.put(<span class=\"string\">&quot;mail.smtp.socketFactory.port&quot;</span>, <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">String</span>.</span></span>value<span class=\"constructor\">Of(<span class=\"params\">port</span>)</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 连接到Store:</span></span><br><span class=\"line\">URLName url = <span class=\"keyword\">new</span> <span class=\"constructor\">URLName(<span class=\"string\">&quot;pop3&quot;</span>, <span class=\"params\">host</span>, <span class=\"params\">post</span>, <span class=\"string\">&quot;&quot;</span>, <span class=\"params\">username</span>, <span class=\"params\">password</span>)</span>;</span><br><span class=\"line\">Session session = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Session</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"params\">props</span>, <span class=\"params\">null</span>)</span>;</span><br><span class=\"line\">session.set<span class=\"constructor\">Debug(<span class=\"params\">true</span>)</span>; <span class=\"comment\">// 显示调试信息</span></span><br><span class=\"line\">Store store = <span class=\"keyword\">new</span> <span class=\"constructor\">POP3SSLStore(<span class=\"params\">session</span>, <span class=\"params\">url</span>)</span>;</span><br><span class=\"line\">store.connect<span class=\"literal\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>一个<code>Store</code>对象表示整个邮箱的存储，要收取邮件，我们需要通过<code>Store</code>访问指定的<code>Folder</code>（文件夹），通常是<code>INBOX</code>表示收件箱：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取收件箱:</span></span><br><span class=\"line\">Folder folder = store.get<span class=\"constructor\">Folder(<span class=\"string\">&quot;INBOX&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 以读写方式打开:</span></span><br><span class=\"line\">folder.<span class=\"keyword\">open</span>(Folder.READ_WRITE);</span><br><span class=\"line\"><span class=\"comment\">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Total messages: &quot;</span> + folder.get<span class=\"constructor\">MessageCount()</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;New messages: &quot;</span> + folder.get<span class=\"constructor\">NewMessageCount()</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Unread messages: &quot;</span> + folder.get<span class=\"constructor\">UnreadMessageCount()</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Deleted messages: &quot;</span> + folder.get<span class=\"constructor\">DeletedMessageCount()</span>);</span><br><span class=\"line\"><span class=\"comment\">// 获取每一封邮件:</span></span><br><span class=\"line\">Message<span class=\"literal\">[]</span> messages = folder.get<span class=\"constructor\">Messages()</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Message message : messages) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 打印每一封邮件:</span></span><br><span class=\"line\">    print<span class=\"constructor\">Message((MimeMessage)</span> message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当我们获取到一个<code>Message</code>对象时，可以强制转型为MimeMessage，然后打印出邮件主题、发件人、收件人等信息：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">void print<span class=\"constructor\">Message(MimeMessage <span class=\"params\">msg</span>)</span> throws IOException, MessagingException &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 邮件主题:</span></span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Subject: &quot;</span> + <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">MimeUtility</span>.</span></span>decode<span class=\"constructor\">Text(<span class=\"params\">msg</span>.<span class=\"params\">getSubject</span>()</span>));</span><br><span class=\"line\">    <span class=\"comment\">// 发件人:</span></span><br><span class=\"line\">    Address<span class=\"literal\">[]</span> froms = msg.get<span class=\"constructor\">From()</span>;</span><br><span class=\"line\">    InternetAddress address = (InternetAddress) froms<span class=\"literal\">[<span class=\"number\">0</span>]</span>;</span><br><span class=\"line\">    String personal = address.get<span class=\"constructor\">Personal()</span>;</span><br><span class=\"line\">    String from = personal<span class=\"operator\"> == </span>null ? address.get<span class=\"constructor\">Address()</span> : (<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">MimeUtility</span>.</span></span>decode<span class=\"constructor\">Text(<span class=\"params\">personal</span>)</span> + <span class=\"string\">&quot; &lt;&quot;</span> + address.get<span class=\"constructor\">Address()</span> + <span class=\"string\">&quot;&gt;&quot;</span>);</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;From: &quot;</span> + from);</span><br><span class=\"line\">    <span class=\"comment\">// 继续打印收件人:</span><span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>比较麻烦的是获取邮件的正文。一个<code>MimeMessage</code>对象也是一个<code>Part</code>对象，它可能只包含一个文本，也可能是一个<code>Multipart</code>对象，即由几个<code>Part</code>构成，因此，需要递归地解析出完整的正文：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String get<span class=\"constructor\">Body(Part <span class=\"params\">part</span>)</span> throws MessagingException, IOException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (part.is<span class=\"constructor\">MimeType(<span class=\"string\">&quot;text/*&quot;</span>)</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Part是文本:</span></span><br><span class=\"line\">        return part.get<span class=\"constructor\">Content()</span>.<span class=\"keyword\">to</span><span class=\"constructor\">String()</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (part.is<span class=\"constructor\">MimeType(<span class=\"string\">&quot;multipart/*&quot;</span>)</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Part是一个Multipart对象:</span></span><br><span class=\"line\">        Multipart multipart = (Multipart) part.get<span class=\"constructor\">Content()</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 循环解析每个子Part:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> i = <span class=\"number\">0</span>; i &lt; multipart.get<span class=\"constructor\">Count()</span>; i++) &#123;</span><br><span class=\"line\">            BodyPart bodyPart = multipart.get<span class=\"constructor\">BodyPart(<span class=\"params\">i</span>)</span>;</span><br><span class=\"line\">            String body = get<span class=\"constructor\">Body(<span class=\"params\">bodyPart</span>)</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!body.is<span class=\"constructor\">Empty()</span>) &#123;</span><br><span class=\"line\">                return body;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后记得关闭<code>Folder</code>和<code>Store</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\">folder.<span class=\"built_in\">close</span>(<span class=\"literal\">true</span>); <span class=\"comment\">// 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）</span></span><br><span class=\"line\">store.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"HTTP编程\"><a href=\"#HTTP编程\" class=\"headerlink\" title=\"HTTP编程\"></a>HTTP编程</h1><p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p>\n<p>HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p>\n<p>我们来看一下浏览器请求访问某个网站时发送的HTTP请求-响应。当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用<code>80</code>端口和加密端口<code>443</code>，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。一个完整的HTTP请求-响应如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">            GET / HTTP/1.1</span><br><span class=\"line\">            Host: www.sina.com.cn</span><br><span class=\"line\">            User-Agent: Mozilla/5 MSIE</span><br><span class=\"line\">            Accept: */*                ┌────────┐</span><br><span class=\"line\">┌─────────┐ Accept-Language: zh-CN,en  │░░░░░░░░│</span><br><span class=\"line\">│O ░░░░░░░│───────────────────────────&gt;├────────┤</span><br><span class=\"line\">├─────────┤&lt;───────────────────────────│░░░░░░░░│</span><br><span class=\"line\">│         │ HTTP/1.1 200 OK            ├────────┤</span><br><span class=\"line\">│         │ Content-Type: text/html    │░░░░░░░░│</span><br><span class=\"line\">└─────────┘ Content-Length: 133251     └────────┘</span><br><span class=\"line\">  Browser   &lt;!DOCTYPE html&gt;              Server</span><br><span class=\"line\">            &lt;html&gt;&lt;body&gt;</span><br><span class=\"line\">            &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class=\"line\">            ...</span><br></pre></td></tr></table></figure>\n\n<p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是<code>请求方法 路径 HTTP版本</code>，例如，<code>GET / HTTP/1.1</code>表示使用<code>GET</code>请求，路径是<code>/</code>，版本是<code>HTTP/1.1</code>。</p>\n<p>后续的每一行都是固定的<code>Header: Value</code>格式，我们称为HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p>\n<ul>\n<li>Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；</li>\n<li>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；</li>\n<li>Accept：表示客户端能处理的HTTP响应格式，<code>*/*</code>表示任意格式，<code>text/*</code>表示任意文本，<code>image/png</code>表示PNG格式的图片；</li>\n<li>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li>\n</ul>\n<p>如果是<code>GET</code>请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是<code>POST</code>请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">POST</span> <span class=\"string\">/login</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>www.example.com</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>application/x-www-form-urlencoded</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>30</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"ini\"><span class=\"attr\">username</span>=hello&amp;password=<span class=\"number\">123456</span></span></span><br></pre></td></tr></table></figure>\n\n<p><code>POST</code>请求通常要设置<code>Content-Type</code>表示Body的类型，<code>Content-Length</code>表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p>\n<p>此外，<code>GET</code>请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<code>http://www.example.com/?a=1&amp;b=K%26R</code>，参数分别是<code>a=1</code>和<code>b=K&amp;R</code>。因为URL的长度限制，<code>GET</code>请求的参数不能太多，而<code>POST</code>请求的参数就没有长度限制，因为<code>POST</code>请求的参数必须放到Body中。并且，<code>POST</code>请求的参数不一定是URL编码，可以按任意格式编码，只需要在<code>Content-Type</code>中正确设置即可。常见的发送JSON的<code>POST</code>请求如下：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">POST</span> <span class=\"string\">/login</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>application/json</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>38</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"json\">&#123;<span class=\"attr\">&quot;username&quot;</span>:<span class=\"string\">&quot;bob&quot;</span>,<span class=\"attr\">&quot;password&quot;</span>:<span class=\"string\">&quot;123456&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/html</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>133251</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"xml\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">html</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>Hello<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">...</span></span><br></pre></td></tr></table></figure>\n\n<p>响应的第一行总是<code>HTTP版本 响应代码 响应说明</code>，例如，<code>HTTP/1.1 200 OK</code>表示版本是<code>HTTP/1.1</code>，响应代码是<code>200</code>，响应说明是<code>OK</code>。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：</p>\n<ul>\n<li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接；</li>\n<li>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；</li>\n<li>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；</li>\n<li>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；</li>\n<li>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。</li>\n</ul>\n<p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，<code>GET /logo.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p>\n<figure class=\"highlight http\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>image/jpeg</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>18391</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"ruby\"><span class=\"string\">??</span><span class=\"string\">??</span>JFIFHH?<span class=\"string\">?X</span>ExifMM?i&amp;<span class=\"string\">??</span>X?...(二进制的JPEG图片)</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。</p>\n<p>对于最早期的HTTP&#x2F;1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP&#x2F;1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                       ┌─────────┐</span><br><span class=\"line\">┌─────────┐            │░░░░░░░░░│</span><br><span class=\"line\">│O ░░░░░░░│            ├─────────┤</span><br><span class=\"line\">├─────────┤            │░░░░░░░░░│</span><br><span class=\"line\">│         │            ├─────────┤</span><br><span class=\"line\">│         │            │░░░░░░░░░│</span><br><span class=\"line\">└─────────┘            └─────────┘</span><br><span class=\"line\">     │      request 1       │</span><br><span class=\"line\">     │─────────────────────&gt;│</span><br><span class=\"line\">     │      response 1      │</span><br><span class=\"line\">     │&lt;─────────────────────│</span><br><span class=\"line\">     │      request 2       │</span><br><span class=\"line\">     │─────────────────────&gt;│</span><br><span class=\"line\">     │      response 2      │</span><br><span class=\"line\">     │&lt;─────────────────────│</span><br><span class=\"line\">     │      request 3       │</span><br><span class=\"line\">     │─────────────────────&gt;│</span><br><span class=\"line\">     │      response 3      │</span><br><span class=\"line\">     │&lt;─────────────────────│</span><br><span class=\"line\">     ▼                      ▼</span><br></pre></td></tr></table></figure>\n\n<p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p>\n<p>所以，为了进一步提速，HTTP&#x2F;2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                       ┌─────────┐</span><br><span class=\"line\">┌─────────┐            │░░░░░░░░░│</span><br><span class=\"line\">│O ░░░░░░░│            ├─────────┤</span><br><span class=\"line\">├─────────┤            │░░░░░░░░░│</span><br><span class=\"line\">│         │            ├─────────┤</span><br><span class=\"line\">│         │            │░░░░░░░░░│</span><br><span class=\"line\">└─────────┘            └─────────┘</span><br><span class=\"line\">     │      request 1       │</span><br><span class=\"line\">     │─────────────────────&gt;│</span><br><span class=\"line\">     │      request 2       │</span><br><span class=\"line\">     │─────────────────────&gt;│</span><br><span class=\"line\">     │      response 1      │</span><br><span class=\"line\">     │&lt;─────────────────────│</span><br><span class=\"line\">     │      request 3       │</span><br><span class=\"line\">     │─────────────────────&gt;│</span><br><span class=\"line\">     │      response 3      │</span><br><span class=\"line\">     │&lt;─────────────────────│</span><br><span class=\"line\">     │      response 2      │</span><br><span class=\"line\">     │&lt;─────────────────────│</span><br><span class=\"line\">     ▼                      ▼</span><br></pre></td></tr></table></figure>\n\n<p>可见，HTTP&#x2F;2.0进一步提高了效率。</p>\n<h3 id=\"HTTP编程-1\"><a href=\"#HTTP编程-1\" class=\"headerlink\" title=\"HTTP编程\"></a>HTTP编程</h3><p>既然HTTP涉及到客户端和服务器端，和TCP类似，我们也需要针对客户端编程和针对服务器端编程。</p>\n<p>本节我们不讨论服务器端的HTTP编程，因为服务器端的HTTP编程本质上就是编写Web服务器，这是一个非常复杂的体系，也是JavaEE开发的核心内容，我们在后面的章节再仔细研究。</p>\n<p>本节我们只讨论作为客户端的HTTP编程。</p>\n<p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而我们使用Java进行HTTP客户端编程仅限于获得响应内容。</p>\n<p>我们来看一下Java如何使用HTTP客户端编程。</p>\n<p>Java标准库提供了基于HTTP的包，但是要注意，早期的JDK版本是通过<code>HttpURLConnection</code>访问HTTP，典型代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">URL url = <span class=\"keyword\">new</span> <span class=\"constructor\">URL(<span class=\"string\">&quot;http://www.example.com/path/to/target?a=1&amp;b=2&quot;</span>)</span>;</span><br><span class=\"line\">HttpURLConnection conn = (HttpURLConnection) url.<span class=\"keyword\">open</span><span class=\"constructor\">Connection()</span>;</span><br><span class=\"line\">conn.set<span class=\"constructor\">RequestMethod(<span class=\"string\">&quot;GET&quot;</span>)</span>;</span><br><span class=\"line\">conn.set<span class=\"constructor\">UseCaches(<span class=\"params\">false</span>)</span>;</span><br><span class=\"line\">conn.set<span class=\"constructor\">ConnectTimeout(5000)</span>; <span class=\"comment\">// 请求超时5秒</span></span><br><span class=\"line\"><span class=\"comment\">// 设置HTTP头:</span></span><br><span class=\"line\">conn.set<span class=\"constructor\">RequestProperty(<span class=\"string\">&quot;Accept&quot;</span>, <span class=\"string\">&quot;*/*&quot;</span>)</span>;</span><br><span class=\"line\">conn.set<span class=\"constructor\">RequestProperty(<span class=\"string\">&quot;User-Agent&quot;</span>, <span class=\"string\">&quot;Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 连接并发送HTTP请求:</span></span><br><span class=\"line\">conn.connect<span class=\"literal\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 判断HTTP响应是否200:</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (conn.get<span class=\"constructor\">ResponseCode()</span> != <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">    throw <span class=\"keyword\">new</span> <span class=\"constructor\">RuntimeException(<span class=\"string\">&quot;bad response&quot;</span>)</span>;</span><br><span class=\"line\">&#125;\t\t</span><br><span class=\"line\"><span class=\"comment\">// 获取所有响应Header:</span></span><br><span class=\"line\">Map&lt;String, List&lt;String&gt;&gt; map = conn.get<span class=\"constructor\">HeaderFields()</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (String key : map.key<span class=\"constructor\">Set()</span>) &#123;</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(key + <span class=\"string\">&quot;: &quot;</span> + map.get(key));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取响应内容:</span></span><br><span class=\"line\">InputStream input = conn.get<span class=\"constructor\">InputStream()</span>;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>上述代码编写比较繁琐，并且需要手动处理<code>InputStream</code>，所以用起来很麻烦。</p>\n<p>从Java 11开始，引入了新的<code>HttpClient</code>，它使用链式调用的API，能大大简化HTTP的处理。</p>\n<p>我们来看一下如何使用新版的<code>HttpClient</code>。首先需要创建一个全局<code>HttpClient</code>实例，因为<code>HttpClient</code>内部使用线程池优化多个HTTP连接，可以复用：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">static HttpClient httpClient = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpClient</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">Builder()</span>.build<span class=\"literal\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>GET</code>请求获取文本内容代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.net.URI;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.http.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.net.http.<span class=\"built_in\">HttpClient</span>.Version;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.time.Duration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 全局HttpClient:</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"built_in\">HttpClient</span> httpClient = <span class=\"built_in\">HttpClient</span>.<span class=\"built_in\">newBuilder</span>().<span class=\"built_in\">build</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> url = <span class=\"string\">&quot;https://www.sina.com.cn/&quot;</span>;</span><br><span class=\"line\">        HttpRequest request = HttpRequest.<span class=\"built_in\">newBuilder</span>(<span class=\"keyword\">new</span> <span class=\"built_in\">URI</span>(url))</span><br><span class=\"line\">            <span class=\"comment\">// 设置Header:</span></span><br><span class=\"line\">            .<span class=\"built_in\">header</span>(<span class=\"string\">&quot;User-Agent&quot;</span>, <span class=\"string\">&quot;Java HttpClient&quot;</span>).<span class=\"built_in\">header</span>(<span class=\"string\">&quot;Accept&quot;</span>, <span class=\"string\">&quot;*/*&quot;</span>)</span><br><span class=\"line\">            <span class=\"comment\">// 设置超时:</span></span><br><span class=\"line\">            .<span class=\"built_in\">timeout</span>(Duration.<span class=\"built_in\">ofSeconds</span>(<span class=\"number\">5</span>))</span><br><span class=\"line\">            <span class=\"comment\">// 设置版本:</span></span><br><span class=\"line\">            .<span class=\"built_in\">version</span>(Version.HTTP_2).<span class=\"built_in\">build</span>();</span><br><span class=\"line\">        HttpResponse&lt;<span class=\"keyword\">String</span>&gt; response = httpClient.<span class=\"built_in\">send</span>(request, HttpResponse.BodyHandlers.<span class=\"built_in\">ofString</span>());</span><br><span class=\"line\">        <span class=\"comment\">// HTTP允许重复的Header，因此一个Header可对应多个Value:</span></span><br><span class=\"line\">        Map&lt;<span class=\"keyword\">String</span>, List&lt;<span class=\"keyword\">String</span>&gt;&gt; headers = response.<span class=\"built_in\">headers</span>().<span class=\"built_in\">map</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> header : headers.<span class=\"built_in\">keySet</span>()) &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(header + <span class=\"string\">&quot;: &quot;</span> + headers.<span class=\"built_in\">get</span>(header).<span class=\"built_in\">get</span>(<span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"built_in\">println</span>(response.<span class=\"built_in\">body</span>().<span class=\"built_in\">substring</span>(<span class=\"number\">0</span>, <span class=\"number\">1024</span>) + <span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要获取图片这样的二进制内容，只需要把<code>HttpResponse.BodyHandlers.ofString()</code>换成<code>HttpResponse.BodyHandlers.ofByteArray()</code>，就可以获得一个<code>HttpResponse&lt;byte[]&gt;</code>对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用<code>HttpResponse.BodyHandlers.ofInputStream()</code>获取一个<code>InputStream</code>流。</p>\n<p>要使用<code>POST</code>请求，我们要准备好发送的Body数据并正确设置<code>Content-Type</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String url = <span class=\"string\">&quot;http://www.example.com/login&quot;</span>;</span><br><span class=\"line\">String body = <span class=\"string\">&quot;username=bob&amp;password=123456&quot;</span>;</span><br><span class=\"line\">HttpRequest request = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpRequest</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">Builder(<span class=\"params\">new</span> URI(<span class=\"params\">url</span>)</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 设置Header:</span></span><br><span class=\"line\">    .header(<span class=\"string\">&quot;Accept&quot;</span>, <span class=\"string\">&quot;*/*&quot;</span>)</span><br><span class=\"line\">    .header(<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 设置超时:</span></span><br><span class=\"line\">    .timeout(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Duration</span>.</span></span><span class=\"keyword\">of</span><span class=\"constructor\">Seconds(5)</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 设置版本:</span></span><br><span class=\"line\">    .version(Version.HTTP_2)</span><br><span class=\"line\">    <span class=\"comment\">// 使用POST并设置Body:</span></span><br><span class=\"line\">    .<span class=\"constructor\">POST(BodyPublishers.<span class=\"params\">ofString</span>(<span class=\"params\">body</span>, StandardCharsets.UTF_8)</span>).build<span class=\"literal\">()</span>;</span><br><span class=\"line\">HttpResponse&lt;String&gt; response = httpClient.send(request, <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">HttpResponse</span>.</span><span class=\"module\"><span class=\"identifier\">BodyHandlers</span>.</span></span><span class=\"keyword\">of</span><span class=\"constructor\">String()</span>);</span><br><span class=\"line\">String s = response.body<span class=\"literal\">()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>可见发送<code>POST</code>数据也十分简单。</p>\n<h1 id=\"RMI远程调用\"><a href=\"#RMI远程调用\" class=\"headerlink\" title=\"RMI远程调用\"></a>RMI远程调用</h1><p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p>\n<p>提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。</p>\n<p>我们先来实现一个最简单的RMI：服务器会提供一个<code>WorldClock</code>服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">LocalDateTime <span class=\"title\">getLocalDateTime</span><span class=\"params\">(<span class=\"keyword\">String</span> zoneId)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>要实现RMI，服务器和客户端必须共享同一个接口。我们定义一个<code>WorldClock</code>接口，代码如下：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WorldClock</span> <span class=\"keyword\"><span class=\"keyword\">extends</span> <span class=\"type\">Remote</span></span> </span>&#123;</span><br><span class=\"line\">    LocalDateTime getLocalDateTime(<span class=\"keyword\">String</span> zoneId) throws RemoteException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Java的RMI规定此接口必须派生自<code>java.rmi.Remote</code>，并在每个方法声明抛出<code>RemoteException</code>。</p>\n<p>下一步是编写服务器的实现类，因为客户端请求的调用方法<code>getLocalDateTime()</code>最终会通过这个实现类返回结果。实现类<code>WorldClockService</code>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorldClockService</span> <span class=\"keyword\">implements</span> <span class=\"title\">WorldClock</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> LocalDateTime <span class=\"title\">getLocalDateTime</span><span class=\"params\">(String zoneId)</span> <span class=\"keyword\">throws</span> RemoteException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> LocalDateTime.now(ZoneId.of(zoneId)).withNano(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，服务器端的服务相关代码就编写完毕。我们需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> Server &#123;</span><br><span class=\"line\">    public static void main(String<span class=\"literal\">[]</span> args) throws RemoteException &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;create World clock remote service...&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 实例化一个WorldClock:</span></span><br><span class=\"line\">        WorldClock worldClock = <span class=\"keyword\">new</span> <span class=\"constructor\">WorldClockService()</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将此服务转换为远程服务接口:</span></span><br><span class=\"line\">        WorldClock skeleton = (WorldClock) <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">UnicastRemoteObject</span>.</span></span>export<span class=\"constructor\">Object(<span class=\"params\">worldClock</span>, 0)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 将RMI服务注册到1099端口:</span></span><br><span class=\"line\">        Registry registry = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">LocateRegistry</span>.</span></span>create<span class=\"constructor\">Registry(1099)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 注册此服务，服务名为&quot;WorldClock&quot;:</span></span><br><span class=\"line\">        registry.rebind(<span class=\"string\">&quot;WorldClock&quot;</span>, skeleton);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码主要目的是通过RMI提供的相关类，将我们自己的<code>WorldClock</code>实例注册到RMI服务上。RMI的默认端口是<code>1099</code>，最后一步注册服务时通过<code>rebind()</code>指定服务名称为<code>&quot;WorldClock&quot;</code>。</p>\n<p>下一步我们就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此我们要把<code>WorldClock.java</code>这个接口文件复制到客户端，然后在客户端实现RMI调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> RemoteException, NotBoundException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 连接到服务器localhost，端口1099:</span></span><br><span class=\"line\">        Registry registry = LocateRegistry.getRegistry(<span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">1099</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 查找名称为&quot;WorldClock&quot;的服务并强制转型为WorldClock接口:</span></span><br><span class=\"line\">        WorldClock worldClock = (WorldClock) registry.lookup(<span class=\"string\">&quot;WorldClock&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 正常调用接口方法:</span></span><br><span class=\"line\">        LocalDateTime now = worldClock.getLocalDateTime(<span class=\"string\">&quot;Asia/Shanghai&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 打印调用结果:</span></span><br><span class=\"line\">        System.out.println(now);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。整个过程实际上非常简单，对客户端来说，客户端持有的<code>WorldClock</code>接口实际上对应了一个“实现类”，它是由<code>Registry</code>内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的<code>WorldClockService</code>，而是<code>Registry</code>自动生成的代码。我们把客户端的“实现类”称为<code>stub</code>，而服务器端的网络服务类称为<code>skeleton</code>，它会真正调用服务器端的<code>WorldClockService</code>，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">  ┌─────────────┐                                 ┌─────────────┐</span><br><span class=\"line\">│ │   Service   │ │         │                     │   Service   │ │</span><br><span class=\"line\">  └─────────────┘                                 └─────────────┘</span><br><span class=\"line\">│        ▲        │         │                            ▲        │</span><br><span class=\"line\">         │                                               │</span><br><span class=\"line\">│        │        │         │                            │        │</span><br><span class=\"line\">  ┌─────────────┐   Network   ┌───────────────┐   ┌─────────────┐</span><br><span class=\"line\">│ │ Client Stub ├─┼─────────┼&gt;│Server Skeleton│──&gt;│Service Impl │ │</span><br><span class=\"line\">  └─────────────┘             └───────────────┘   └─────────────┘</span><br><span class=\"line\">└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>\n<p>此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如<a href=\"https://grpc.io/\">gRPC</a>。</p>\n","categories":["Java","5.JavaEE进阶","2.网络编程"],"tags":["写作"]},{"title":"3.Netty网络编程","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_3.Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"IO模型（BIO-x2F-NIO）\"><a href=\"#IO模型（BIO-x2F-NIO）\" class=\"headerlink\" title=\"IO模型（BIO&#x2F;NIO）\"></a>IO模型（BIO&#x2F;NIO）</h1><h1 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h1><h1 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h1><h1 id=\"Seletor\"><a href=\"#Seletor\" class=\"headerlink\" title=\"Seletor\"></a>Seletor</h1><h1 id=\"Netty-模型\"><a href=\"#Netty-模型\" class=\"headerlink\" title=\"Netty. 模型\"></a>Netty. 模型</h1><h1 id=\"WebSocket-编程（动手做个聊天室）\"><a href=\"#WebSocket-编程（动手做个聊天室）\" class=\"headerlink\" title=\"WebSocket. 编程（动手做个聊天室）\"></a>WebSocket. 编程（动手做个聊天室）</h1>","categories":["Java","5.JavaEE进阶","3.Netty网络编程"],"tags":["写作"]},{"title":"5.函数式编程","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>本章我们介绍Java的函数式编程。</p>\n<p>我们先看看什么是函数。函数是一种最基本的任务，一个大型程序就是一个顶层函数调用若干底层函数，这些被调用的函数又可以调用其他函数，即大任务被一层层拆解并执行。所以函数就是面向过程的程序设计的基本单元。</p>\n<p>Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带<code>this</code>参数的函数。</p>\n<p>而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。</p>\n<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p>\n<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>\n<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。</p>\n<p>对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。</p>\n<p>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>\n<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>\n<p>函数式编程最早是数学家<a href=\"https://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87\">阿隆佐·邱奇</a>研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。</p>\n<p>Java平台从Java 8开始，支持函数式编程。</p>\n<h1 id=\"Lambda基础\"><a href=\"#Lambda基础\" class=\"headerlink\" title=\"Lambda基础\"></a>Lambda基础</h1><p>在了解Lambda之前，我们先回顾一下Java的方法。</p>\n<p>Java的方法分为实例方法，例如<code>Integer</code>定义的<code>equals()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Integer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>以及静态方法，例如<code>Integer</code>定义的<code>parseInt()</code>方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Integer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">parseInt</span><span class=\"params\">(<span class=\"keyword\">String</span> s)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无论是实例方法，还是静态方法，本质上都相当于过程式语言的函数。例如C函数：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">strcpy</span><span class=\"params\">(<span class=\"keyword\">char</span>* dest, <span class=\"keyword\">char</span>* src)</span></span></span><br></pre></td></tr></table></figure>\n\n<p>只不过Java的实例方法隐含地传入了一个<code>this</code>变量，即实例方法总是有一个隐含参数<code>this</code>。</p>\n<p>函数式编程（Functional Programming）是把函数作为基本运算单元，函数可以作为变量，可以接收函数，还可以返回函数。历史上研究函数式编程的理论是Lambda演算，所以我们经常把支持函数式编程的编码风格称为Lambda表达式。</p>\n<h3 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h3><p>在Java程序中，我们经常遇到一大堆单方法接口，即一个接口只定义了一个方法：</p>\n<ul>\n<li>Comparator</li>\n<li>Runnable</li>\n<li>Callable</li>\n</ul>\n<p>以<code>Comparator</code>为例，我们想要调用<code>Arrays.sort()</code>时，可以传入一个<code>Comparator</code>实例，以匿名类方式编写如下：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">String[]<span class=\"built_in\"> array </span>= ...</span><br><span class=\"line\">Arrays.sort(array,<span class=\"built_in\"> new </span>Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\">   <span class=\"keyword\"> public</span><span class=\"built_in\"> int </span>compare(String s1, String s2) &#123;</span><br><span class=\"line\">       <span class=\"built_in\"> return </span>s1.compareTo(s2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上述写法非常繁琐。从Java 8开始，我们可以用Lambda表达式替换单方法接口。改写上述代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lambda</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>观察Lambda表达式的写法，它只需要写出方法定义：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"code\"><pre><span class=\"line\">(<span class=\"built_in\">s1</span>, <span class=\"built_in\">s2</span>) -&gt; &#123;</span><br><span class=\"line\">    return <span class=\"built_in\">s1</span>.compareTo(<span class=\"built_in\">s2</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，参数是<code>(s1, s2)</code>，参数类型可以省略，因为编译器可以自动推断出<code>String</code>类型。<code>-&gt; &#123; ... &#125;</code>表示方法体，所有代码写在内部即可。Lambda表达式没有<code>class</code>定义，因此写法非常简洁。</p>\n<p>如果只有一行<code>return xxx</code>的代码，完全可以用更简单的写法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span>sort(<span class=\"built_in\">array</span>, (s1, s2) -&gt; s1.compare<span class=\"constructor\">To(<span class=\"params\">s2</span>)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>返回值的类型也是由编译器自动推断的，这里推断出的返回值是<code>int</code>，因此，只要返回<code>int</code>，编译器就不会报错。</p>\n<h3 id=\"FunctionalInterface\"><a href=\"#FunctionalInterface\" class=\"headerlink\" title=\"FunctionalInterface\"></a>FunctionalInterface</h3><p>我们把只定义了单方法的接口称之为<code>FunctionalInterface</code>，用注解<code>@FunctionalInterface</code>标记。例如，<code>Callable</code>接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再来看<code>Comparator</code>接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> Comparator&lt;T&gt; <span class=\"title\">reversed</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Collections.reverseOrder(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> Comparator&lt;T&gt; <span class=\"title\">thenComparing</span><span class=\"params\">(Comparator&lt;? <span class=\"keyword\">super</span> T&gt; other)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>虽然<code>Comparator</code>接口有很多方法，但只有一个抽象方法<code>int compare(T o1, T o2)</code>，其他的方法都是<code>default</code>方法或<code>static</code>方法。另外注意到<code>boolean equals(Object obj)</code>是<code>Object</code>定义的方法，不算在接口方法内。因此，<code>Comparator</code>也是一个<code>FunctionalInterface</code>。</p>\n<h1 id=\"方法引用\"><a href=\"#方法引用\" class=\"headerlink\" title=\"方法引用\"></a>方法引用</h1><p>使用Lambda表达式，我们就可以不必编写<code>FunctionalInterface</code>接口的实现类，从而简化代码：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Arrays.sort<span class=\"function\"><span class=\"params\">(array, (s1, s2) -&gt; &#123;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"keyword\">return</span> s1.compareTo(s2);</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">&#125;)</span>;</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，除了Lambda表达式，我们还可以直接传入方法引用。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码在<code>Arrays.sort()</code>中直接传入了静态方法<code>cmp</code>的引用，用<code>Main::cmp</code>表示。</p>\n<p>因此，所谓方法引用，是指如果某个方法签名和接口恰好一致，就可以直接传入方法引用。</p>\n<p>因为<code>Comparator&lt;String&gt;</code>接口定义的方法是<code>int compare(String, String)</code>，和静态方法<code>int cmp(String, String)</code>相比，除了方法名外，方法参数一致，返回类型相同，因此，我们说两者的方法签名一致，可以直接把方法名作为Lambda表达式传入：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span>sort(<span class=\"built_in\">array</span>, Main::cmp);</span><br></pre></td></tr></table></figure>\n\n<p>注意：在这里，方法签名只看参数类型和返回类型，不看方法名称，也不看类的继承关系。</p>\n<p>我们再看看如何引用实例方法。如果我们把代码改写如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>不但可以编译通过，而且运行结果也是一样的，这说明<code>String.compareTo()</code>方法也符合Lambda定义。</p>\n<p>观察<code>String.compareTo()</code>的方法定义：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(<span class=\"keyword\">String</span> o)</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个方法的签名只有一个参数，为什么和<code>int Comparator&lt;String&gt;.compare(String, String)</code>能匹配呢？</p>\n<p>因为实例方法有一个隐含的<code>this</code>参数，<code>String</code>类的<code>compareTo()</code>方法在实际调用的时候，第一个隐含参数总是传入<code>this</code>，相当于静态方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(<span class=\"keyword\">this</span>, <span class=\"keyword\">String</span> o)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>所以，<code>String.compareTo()</code>方法也可作为方法引用传入。</p>\n<h3 id=\"构造方法引用\"><a href=\"#构造方法引用\" class=\"headerlink\" title=\"构造方法引用\"></a>构造方法引用</h3><p>除了可以引用静态方法和实例方法，我们还可以引用构造方法。</p>\n<p>我们来看一个例子：如果要把一个<code>List&lt;String&gt;</code>转换为<code>List&lt;Person&gt;</code>，应该怎么办？</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Person</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;<span class=\"built_in\">String</span>&gt; names = List.of(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>);</span><br><span class=\"line\">List&lt;Person&gt; persons = ???</span><br></pre></td></tr></table></figure>\n\n<p>传统的做法是先定义一个<code>ArrayList&lt;Person&gt;</code>，然后用<code>for</code>循环填充这个<code>List</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;<span class=\"keyword\">String</span>&gt; names = List.of(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"string\">&quot;Tim&quot;</span>);</span><br><span class=\"line\">List&lt;Person&gt; persons = <span class=\"keyword\">new</span> <span class=\"type\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">String</span> name : <span class=\"type\">names</span>) &#123;</span><br><span class=\"line\">    persons.add(<span class=\"keyword\">new</span> <span class=\"type\">Person</span>(name));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要更简单地实现<code>String</code>到<code>Person</code>的转换，我们可以引用<code>Person</code>的构造方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引用构造方法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>后面我们会讲到<code>Stream</code>的<code>map()</code>方法。现在我们看到，这里的<code>map()</code>需要传入的FunctionalInterface的定义是：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"symbol\">Function</span>&lt;<span class=\"symbol\">T</span>, <span class=\"symbol\">R</span>&gt; &#123;</span><br><span class=\"line\">    R apply(T t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>把泛型对应上就是方法签名<code>Person apply(String)</code>，即传入参数<code>String</code>，返回类型<code>Person</code>。而<code>Person</code>类的构造方法恰好满足这个条件，因为构造方法的参数是<code>String</code>，而构造方法虽然没有<code>return</code>语句，但它会隐式地返回<code>this</code>实例，类型就是<code>Person</code>，因此，此处可以引用构造方法。构造方法的引用写法是<code>类名::new</code>，因此，此处传入<code>Person::new</code>。</p>\n<h1 id=\"使用Stream\"><a href=\"#使用Stream\" class=\"headerlink\" title=\"使用Stream\"></a>使用Stream</h1><h2 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>Java从8开始，不但引入了Lambda表达式，还引入了一个全新的流式API：Stream API。它位于<code>java.util.stream</code>包中。</p>\n<p><em>划重点</em>：这个<code>Stream</code>不同于<code>java.io</code>的<code>InputStream</code>和<code>OutputStream</code>，它代表的是任意Java对象的序列。两者对比如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">java.io</th>\n<th align=\"left\">java.util.stream</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">存储</td>\n<td align=\"left\">顺序读写的<code>byte</code>或<code>char</code></td>\n<td align=\"left\">顺序输出的任意Java对象实例</td>\n</tr>\n<tr>\n<td align=\"left\">用途</td>\n<td align=\"left\">序列化至文件或网络</td>\n<td align=\"left\">内存计算／业务逻辑</td>\n</tr>\n</tbody></table>\n<p>有同学会问：一个顺序输出的Java对象序列，不就是一个<code>List</code>容器吗？</p>\n<p><em>再次划重点</em>：这个<code>Stream</code>和<code>List</code>也不一样，<code>List</code>存储的每个元素都是已经存储在内存中的某个Java对象，而<code>Stream</code>输出的元素可能并没有预先存储在内存中，而是实时计算出来的。</p>\n<p>换句话说，<code>List</code>的用途是操作一组已存在的Java对象，而<code>Stream</code>实现的是惰性计算，两者对比如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\">java.util.List</th>\n<th align=\"left\">java.util.stream</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">元素</td>\n<td align=\"left\">已分配并存储在内存</td>\n<td align=\"left\">可能未分配，实时计算</td>\n</tr>\n<tr>\n<td align=\"left\">用途</td>\n<td align=\"left\">操作一组已存在的Java对象</td>\n<td align=\"left\">惰性计算</td>\n</tr>\n</tbody></table>\n<p><code>Stream</code>看上去有点不好理解，但我们举个例子就明白了。</p>\n<p>如果我们要表示一个全体自然数的集合，显然，用<code>List</code>是不可能写出来的，因为自然数是无限的，内存再大也没法放到<code>List</code>中：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;BigInteger&gt; list = ??? <span class=\"regexp\">//</span> 全体自然数?</span><br></pre></td></tr></table></figure>\n\n<p>但是，用<code>Stream</code>可以做到。写法如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Stream</span>&lt;BigInteger&gt; naturals = <span class=\"built_in\">createNaturalStream</span>(); <span class=\"comment\">// 全体自然数</span></span><br></pre></td></tr></table></figure>\n\n<p>我们先不考虑<code>createNaturalStream()</code>这个方法是如何实现的，我们看看如何使用这个<code>Stream</code>。</p>\n<p>首先，我们可以对每个自然数做一个平方，这样我们就把这个<code>Stream</code>转换成了另一个<code>Stream</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Stream</span>&lt;BigInteger&gt; naturals = <span class=\"built_in\">createNaturalStream</span>(); <span class=\"comment\">// 全体自然数</span></span><br><span class=\"line\"><span class=\"built_in\">Stream</span>&lt;BigInteger&gt; streamNxN = naturals.<span class=\"built_in\">map</span>(n -&gt; n.<span class=\"built_in\">multiply</span>(n)); <span class=\"comment\">// 全体自然数的平方</span></span><br></pre></td></tr></table></figure>\n\n<p>因为这个<code>streamNxN</code>也有无限多个元素，要打印它，必须首先把无限多个元素变成有限个元素，可以用<code>limit()</code>方法截取前100个元素，最后用<code>forEach()</code>处理每个元素，这样，我们就打印出了前100个自然数的平方：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;BigInteger&gt; naturals = create<span class=\"constructor\">NaturalStream()</span>;</span><br><span class=\"line\">naturals.map(n -&gt; n.multiply(n)) <span class=\"comment\">// 1, 4, 9, 16, 25...</span></span><br><span class=\"line\">        .limit(<span class=\"number\">100</span>)</span><br><span class=\"line\">        .<span class=\"keyword\">for</span><span class=\"constructor\">Each(System.<span class=\"params\">out</span>::<span class=\"params\">println</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>我们总结一下<code>Stream</code>的特点：它可以“存储”有限个或无限个元素。这里的存储打了个引号，是因为元素有可能已经全部存储在内存中，也有可能是根据需要实时计算出来的。</p>\n<p><code>Stream</code>的另一个特点是，一个<code>Stream</code>可以轻易地转换为另一个<code>Stream</code>，而不是修改原<code>Stream</code>本身。</p>\n<p>最后，真正的计算通常发生在最后结果的获取，也就是惰性计算。</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Stream</span>&lt;BigInteger&gt; naturals = <span class=\"built_in\">createNaturalStream</span>(); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\"><span class=\"built_in\">Stream</span>&lt;BigInteger&gt; s2 = naturals.<span class=\"built_in\">map</span>(BigInteger::multiply); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\"><span class=\"built_in\">Stream</span>&lt;BigInteger&gt; s3 = s2.<span class=\"built_in\">limit</span>(<span class=\"number\">100</span>); <span class=\"comment\">// 不计算</span></span><br><span class=\"line\">s3.forEach(System.out::println); <span class=\"comment\">// 计算</span></span><br></pre></td></tr></table></figure>\n\n<p>惰性计算的特点是：一个<code>Stream</code>转换为另一个<code>Stream</code>时，实际上只存储了转换规则，并没有任何计算发生。</p>\n<p>例如，创建一个全体自然数的<code>Stream</code>，不会进行计算，把它转换为上述<code>s2</code>这个<code>Stream</code>，也不会进行计算。再把<code>s2</code>这个无限<code>Stream</code>转换为<code>s3</code>这个有限的<code>Stream</code>，也不会进行计算。只有最后，调用<code>forEach</code>确实需要<code>Stream</code>输出的元素时，才进行计算。我们通常把<code>Stream</code>的操作写成链式操作，代码更简洁：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">createNaturalStream</span>()</span><br><span class=\"line\">    <span class=\"selector-class\">.map</span>(<span class=\"attribute\">BigInteger</span>::multiply)</span><br><span class=\"line\">    <span class=\"selector-class\">.limit</span>(<span class=\"number\">100</span>)</span><br><span class=\"line\">    <span class=\"selector-class\">.forEach</span>(System.<span class=\"attribute\">out</span>::println);</span><br></pre></td></tr></table></figure>\n\n<p>因此，Stream API的基本用法就是：创建一个<code>Stream</code>，然后做若干次转换，最后调用一个求值方法获取真正计算的结果：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">int result = createNaturalStream() <span class=\"regexp\">//</span> 创建Stream</span><br><span class=\"line\">             .filter(n -&gt; n % <span class=\"number\">2</span> == <span class=\"number\">0</span>) <span class=\"regexp\">//</span> 任意个转换</span><br><span class=\"line\">             .map(n -&gt; n * n) <span class=\"regexp\">//</span> 任意个转换</span><br><span class=\"line\">             .limit(<span class=\"number\">100</span>) <span class=\"regexp\">//</span> 任意个转换</span><br><span class=\"line\">             .sum(); <span class=\"regexp\">//</span> 最终计算结果</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"创建Stream\"><a href=\"#创建Stream\" class=\"headerlink\" title=\"创建Stream\"></a>创建Stream</h2><p>要使用<code>Stream</code>，就必须先创建它。创建<code>Stream</code>有很多种方法，我们来一一介绍。</p>\n<h3 id=\"Stream-of\"><a href=\"#Stream-of\" class=\"headerlink\" title=\"Stream.of()\"></a>Stream.of()</h3><p>创建<code>Stream</code>最简单的方式是直接用<code>Stream.of()</code>静态方法，传入可变参数即创建了一个能输出确定元素的<code>Stream</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>虽然这种方式基本上没啥实质性用途，但测试的时候很方便。</p>\n<h3 id=\"基于数组或Collection\"><a href=\"#基于数组或Collection\" class=\"headerlink\" title=\"基于数组或Collection\"></a>基于数组或Collection</h3><p>第二种创建<code>Stream</code>的方法是基于一个数组或者<code>Collection</code>，这样该<code>Stream</code>输出的元素就是数组或者<code>Collection</code>持有的元素：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>把数组变成<code>Stream</code>使用<code>Arrays.stream()</code>方法。对于<code>Collection</code>（<code>List</code>、<code>Set</code>、<code>Queue</code>等），直接调用<code>stream()</code>方法就可以获得<code>Stream</code>。</p>\n<p>上述创建<code>Stream</code>的方法都是把一个现有的序列变为<code>Stream</code>，它的元素是固定的。</p>\n<h3 id=\"基于Supplier\"><a href=\"#基于Supplier\" class=\"headerlink\" title=\"基于Supplier\"></a>基于Supplier</h3><p>创建<code>Stream</code>还可以通过<code>Stream.generate()</code>方法，它需要传入一个<code>Supplier</code>对象：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Stream</span>&lt;<span class=\"keyword\">String</span>&gt; s = <span class=\"built_in\">Stream</span>.<span class=\"built_in\">generate</span>(Supplier&lt;<span class=\"keyword\">String</span>&gt; sp);</span><br></pre></td></tr></table></figure>\n\n<p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素，这种<code>Stream</code>保存的不是元素，而是算法，它可以用来表示无限序列。</p>\n<p>例如，我们编写一个能不断生成自然数的<code>Supplier</code>，它的代码非常简单，每次调用<code>get()</code>方法，就生成下一个自然数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>上述代码我们用一个<code>Supplier&lt;Integer&gt;</code>模拟了一个无限序列（当然受<code>int</code>范围限制不是真的无限大）。如果用<code>List</code>表示，即便在<code>int</code>范围内，也会占用巨大的内存，而<code>Stream</code>几乎不占用空间，因为每个元素都是实时计算出来的，用的时候再算。</p>\n<p>对于无限序列，如果直接调用<code>forEach()</code>或者<code>count()</code>这些最终求值操作，会进入死循环，因为永远无法计算完这个序列，所以正确的方法是先把无限序列变成有限序列，例如，用<code>limit()</code>方法可以截取前面若干个元素，这样就变成了一个有限序列，对这个有限序列调用<code>forEach()</code>或者<code>count()</code>操作就没有问题。</p>\n<h3 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h3><p>创建<code>Stream</code>的第三种方法是通过一些API提供的接口，直接获得<code>Stream</code>。</p>\n<p>例如，<code>Files</code>类的<code>lines()</code>方法可以把一个文件变成一个<code>Stream</code>，每个元素代表文件的一行内容：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Stream&lt;String&gt; lines = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span>lines(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Paths</span>.</span></span>get(<span class=\"string\">&quot;/path/to/file.txt&quot;</span>))) &#123;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此方法对于按行遍历文本文件十分有用。</p>\n<p>另外，正则表达式的<code>Pattern</code>对象有一个<code>splitAsStream()</code>方法，可以直接把一个长字符串分割成<code>Stream</code>序列而不是数组：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Pattern p = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Pattern</span>.</span></span>compile(<span class=\"string\">&quot;\\\\s+&quot;</span>);</span><br><span class=\"line\">Stream&lt;String&gt; s = p.split<span class=\"constructor\">AsStream(<span class=\"string\">&quot;The quick brown fox jumps over the lazy dog&quot;</span>)</span>;</span><br><span class=\"line\">s.<span class=\"keyword\">for</span><span class=\"constructor\">Each(System.<span class=\"params\">out</span>::<span class=\"params\">println</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h3><p>因为Java的范型不支持基本类型，所以我们无法用<code>Stream&lt;int&gt;</code>这样的类型，会发生编译错误。为了保存<code>int</code>，只能使用<code>Stream&lt;Integer&gt;</code>，但这样会产生频繁的装箱、拆箱操作。为了提高效率，Java标准库提供了<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>这三种使用基本类型的<code>Stream</code>，它们的使用方法和范型<code>Stream</code>没有大的区别，设计这三个<code>Stream</code>的目的是提高运行效率：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将int[]数组变为IntStream:</span></span><br><span class=\"line\">IntStream is = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span>stream(<span class=\"keyword\">new</span> <span class=\"built_in\">int</span><span class=\"literal\">[]</span> &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;);</span><br><span class=\"line\"><span class=\"comment\">// 将Stream&lt;String&gt;转换为LongStream:</span></span><br><span class=\"line\">LongStream ls = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">List</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"string\">&quot;1&quot;</span>, <span class=\"string\">&quot;2&quot;</span>, <span class=\"string\">&quot;3&quot;</span>).stream<span class=\"literal\">()</span>.map<span class=\"constructor\">ToLong(Long::<span class=\"params\">parseLong</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"使用map\"><a href=\"#使用map\" class=\"headerlink\" title=\"使用map\"></a>使用map</h2><p><code>Stream.map()</code>是<code>Stream</code>最常用的一个转换方法，它把一个<code>Stream</code>转换为另一个<code>Stream</code>。</p>\n<p>所谓<code>map</code>操作，就是把一种操作运算，映射到一个序列的每一个元素上。例如，对<code>x</code>计算它的平方，可以使用函数<code>f(x) = x * x</code>。我们把这个函数映射到一个序列1，2，3，4，5上，就得到了另一个序列1，4，9，16，25：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">            f(x) = x * x</span><br><span class=\"line\"></span><br><span class=\"line\">                  │</span><br><span class=\"line\">                  │</span><br><span class=\"line\">  ┌───┬───┬───┬───┼───┬───┬───┬───┐</span><br><span class=\"line\">  │   │   │   │   │   │   │   │   │</span><br><span class=\"line\">  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class=\"line\"></span><br><span class=\"line\">[ 1   2   3   4   5   6   7   8   9 ]</span><br><span class=\"line\"></span><br><span class=\"line\">  │   │   │   │   │   │   │   │   │</span><br><span class=\"line\">  │   │   │   │   │   │   │   │   │</span><br><span class=\"line\">  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class=\"line\"></span><br><span class=\"line\">[ 1   4   9  16  25  36  49  64  81 ]</span><br></pre></td></tr></table></figure>\n\n<p>可见，<code>map</code>操作，把一个<code>Stream</code>的每个元素一一对应到应用了目标函数的结果上。</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Stream</span>&lt;Integer&gt; s = Stream.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"attribute\">Stream</span>&lt;Integer&gt; s<span class=\"number\">2</span> = s.map(n -&gt; n * n);</span><br></pre></td></tr></table></figure>\n\n<p>如果我们查看<code>Stream</code>的源码，会发现<code>map()</code>方法接收的对象是<code>Function</code>接口对象，它定义了一个<code>apply()</code>方法，负责把一个<code>T</code>类型转换成<code>R</code>类型：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;R&gt; Stream&lt;R&gt; <span class=\"keyword\">map</span>(<span class=\"built_in\">Function</span>&lt;? <span class=\"built_in\">super</span> T, ? <span class=\"keyword\">extends</span> R&gt; mapper);</span><br></pre></td></tr></table></figure>\n\n<p>其中，<code>Function</code>的定义是：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\">@FunctionalInterface</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"symbol\">Function</span>&lt;<span class=\"symbol\">T</span>, <span class=\"symbol\">R</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将T类型转换为R:</span></span><br><span class=\"line\">    R apply(T t);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>map()</code>，不但能完成数学计算，对于字符串操作，以及任何Java对象都是非常有用的。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>通过若干步<code>map</code>转换，可以写出逻辑简单、清晰的代码。</p>\n<h2 id=\"使用filter\"><a href=\"#使用filter\" class=\"headerlink\" title=\"使用filter\"></a>使用filter</h2><p><code>Stream.filter()</code>是<code>Stream</code>的另一个常用转换方法。</p>\n<p>所谓<code>filter()</code>操作，就是对一个<code>Stream</code>的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的<code>Stream</code>。</p>\n<p>例如，我们对1，2，3，4，5这个<code>Stream</code>调用<code>filter()</code>，传入的测试函数<code>f(x) = x % 2 != 0</code>用来判断元素是否是奇数，这样就过滤掉偶数，只剩下奇数，因此我们得到了另一个序列1，3，5：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">            f(x) = x % 2 != 0</span><br><span class=\"line\"></span><br><span class=\"line\">                  │</span><br><span class=\"line\">                  │</span><br><span class=\"line\">  ┌───┬───┬───┬───┼───┬───┬───┬───┐</span><br><span class=\"line\">  │   │   │   │   │   │   │   │   │</span><br><span class=\"line\">  ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼   ▼</span><br><span class=\"line\"></span><br><span class=\"line\">[ 1   2   3   4   5   6   7   8   9 ]</span><br><span class=\"line\"></span><br><span class=\"line\">  │   X   │   X   │   X   │   X   │</span><br><span class=\"line\">  │       │       │       │       │</span><br><span class=\"line\">  ▼       ▼       ▼       ▼       ▼</span><br><span class=\"line\"></span><br><span class=\"line\">[ 1       3       5       7       9 ]</span><br></pre></td></tr></table></figure>\n\n<p>用IntStream写出上述逻辑，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.IntStream;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>从结果可知，经过<code>filter()</code>后生成的<code>Stream</code>元素可能变少。</p>\n<p><code>filter()</code>方法接收的对象是<code>Predicate</code>接口对象，它定义了一个<code>test()</code>方法，负责判断元素是否符合条件：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Predicate</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断元素t是否符合条件:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">test</span><span class=\"params\">(T t)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>filter()</code>除了常用于数值外，也可应用于任何Java对象。例如，从一组给定的<code>LocalDate</code>中过滤掉工作日，以便得到休息日：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.time.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h2 id=\"使用reduce\"><a href=\"#使用reduce\" class=\"headerlink\" title=\"使用reduce\"></a>使用reduce</h2><p><code>map()</code>和<code>filter()</code>都是<code>Stream</code>的转换方法，而<code>Stream.reduce()</code>则是<code>Stream</code>的一个聚合方法，它可以把一个<code>Stream</code>的所有元素按照聚合函数聚合成一个结果。</p>\n<p>我们来看一个简单的聚合方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>reduce()</code>方法传入的对象是<code>BinaryOperator</code>接口，它定义了一个<code>apply()</code>方法，负责把上次累加的结果和本次的元素 进行运算，并返回累加的结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">BinaryOperator</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Bi操作：两个输入，一个输出</span></span><br><span class=\"line\">    <span class=\"function\">T <span class=\"title\">apply</span><span class=\"params\">(T t, T u)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码看上去不好理解，但我们用<code>for</code>循环改写一下，就容易理解了：</p>\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; stream = ...</span><br><span class=\"line\"><span class=\"built_in\">int</span> <span class=\"built_in\">sum</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">for (<span class=\"built_in\">n</span> <span class=\"symbol\">:</span> stream) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = (<span class=\"built_in\">sum</span>, <span class=\"built_in\">n</span>) -&gt; <span class=\"built_in\">sum</span> + <span class=\"built_in\">n</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，<code>reduce()</code>操作首先初始化结果为指定值（这里是0），紧接着，<code>reduce()</code>对每个元素依次调用<code>(acc, n) -&gt; acc + n</code>，其中，<code>acc</code>是上次计算的结果：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 计算过程:</span><br><span class=\"line\"><span class=\"attr\">acc</span> = <span class=\"number\">0</span> // 初始化为指定值</span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">0</span> + <span class=\"number\">1</span> = <span class=\"number\">1</span> // <span class=\"attr\">n</span> = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">1</span> + <span class=\"number\">2</span> = <span class=\"number\">3</span> // <span class=\"attr\">n</span> = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">3</span> + <span class=\"number\">3</span> = <span class=\"number\">6</span> // <span class=\"attr\">n</span> = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">6</span> + <span class=\"number\">4</span> = <span class=\"number\">10</span> // <span class=\"attr\">n</span> = <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">10</span> + <span class=\"number\">5</span> = <span class=\"number\">15</span> // <span class=\"attr\">n</span> = <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">15</span> + <span class=\"number\">6</span> = <span class=\"number\">21</span> // <span class=\"attr\">n</span> = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">21</span> + <span class=\"number\">7</span> = <span class=\"number\">28</span> // <span class=\"attr\">n</span> = <span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">28</span> + <span class=\"number\">8</span> = <span class=\"number\">36</span> // <span class=\"attr\">n</span> = <span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"attr\">acc</span> = acc + <span class=\"attr\">n</span> = <span class=\"number\">36</span> + <span class=\"number\">9</span> = <span class=\"number\">45</span> // <span class=\"attr\">n</span> = <span class=\"number\">9</span></span><br></pre></td></tr></table></figure>\n\n<p>因此，实际上这个<code>reduce()</code>操作是一个求和。</p>\n<p>如果去掉初始值，我们会得到一个<code>Optional&lt;Integer&gt;</code>：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">Optional&lt;Integer&gt; opt = stream.reduce<span class=\"function\"><span class=\"params\">((acc, n) -&gt; acc + n)</span>;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">if</span> <span class=\"params\">(opt.isPresent())</span> &#123;</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">System</span>.<span class=\"title\">out</span>.<span class=\"title\">println</span><span class=\"params\">(opt.get())</span>;</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为<code>Stream</code>的元素有可能是0个，这样就没法调用<code>reduce()</code>的聚合函数了，因此返回<code>Optional</code>对象，需要进一步判断结果是否存在。</p>\n<p>利用reduce()，我们可以把求和改成求积，代码也十分简单：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>注意：计算求积时，初始值必须设置为<code>1</code>。</p>\n<p>除了可以对数值进行累积计算外，灵活运用<code>reduce()</code>也可以对Java对象进行操作。下面的代码演示了如何将配置文件的每一行配置通过<code>map()</code>和<code>reduce()</code>操作聚合成一个<code>Map&lt;String, String&gt;</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h2 id=\"输出集合\"><a href=\"#输出集合\" class=\"headerlink\" title=\"输出集合\"></a>输出集合</h2><p>我们介绍了<code>Stream</code>的几个常见操作：<code>map()</code>、<code>filter()</code>、<code>reduce()</code>。这些操作对<code>Stream</code>来说可以分为两类，一类是转换操作，即把一个<code>Stream</code>转换为另一个<code>Stream</code>，例如<code>map()</code>和<code>filter()</code>，另一类是聚合操作，即对<code>Stream</code>的每个元素进行计算，得到一个确定的结果，例如<code>reduce()</code>。</p>\n<p>区分这两种操作是非常重要的，因为对于<code>Stream</code>来说，对其进行转换操作<em>并不会触发任何计算</em>！我们可以做个实验：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.function.Supplier; </span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.Stream;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>因为<code>s1</code>是一个<code>Long</code>类型的序列，它的元素高达922亿亿个，但执行上述代码，既不会有任何内存增长，也不会有任何计算，因为转换操作只是保存了转换规则，无论我们对一个<code>Stream</code>转换多少次，都不会有任何实际计算发生。</p>\n<p>而聚合操作则不一样，聚合操作会立刻促使<code>Stream</code>输出它的每一个元素，并依次纳入计算，以获得最终结果。所以，对一个<code>Stream</code>进行聚合操作，会触发一系列连锁反应：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Stream</span>&lt;Long&gt; s<span class=\"number\">1</span> = Stream.generate(new NatualSupplier());</span><br><span class=\"line\"><span class=\"attribute\">Stream</span>&lt;Long&gt; s<span class=\"number\">2</span> = s<span class=\"number\">1</span>.map(n -&gt; n * n);</span><br><span class=\"line\"><span class=\"attribute\">Stream</span>&lt;Long&gt; s<span class=\"number\">3</span> = s<span class=\"number\">2</span>.map(n -&gt; n - <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"attribute\">Stream</span>&lt;Long&gt; s<span class=\"number\">4</span> = s<span class=\"number\">3</span>.limit(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"attribute\">s4</span>.reduce(<span class=\"number\">0</span>, (acc, n) -&gt; acc + n);</span><br></pre></td></tr></table></figure>\n\n<p>我们对<code>s4</code>进行<code>reduce()</code>聚合计算，会不断请求<code>s4</code>输出它的每一个元素。因为<code>s4</code>的上游是<code>s3</code>，它又会向<code>s3</code>请求元素，导致<code>s3</code>向<code>s2</code>请求元素，<code>s2</code>向<code>s1</code>请求元素，最终，<code>s1</code>从<code>Supplier</code>实例中请求到真正的元素，并经过一系列转换，最终被<code>reduce()</code>聚合出结果。</p>\n<p>可见，聚合操作是真正需要从<code>Stream</code>请求数据的，对一个<code>Stream</code>做聚合计算后，结果就不是一个<code>Stream</code>，而是一个其他的Java对象。</p>\n<h3 id=\"输出为List\"><a href=\"#输出为List\" class=\"headerlink\" title=\"输出为List\"></a>输出为List</h3><p><code>reduce()</code>只是一种聚合操作，如果我们希望把<code>Stream</code>的元素保存到集合，例如<code>List</code>，因为<code>List</code>的元素是确定的Java对象，因此，把<code>Stream</code>变为<code>List</code>不是一个转换操作，而是一个聚合操作，它会强制<code>Stream</code>输出每个元素。</p>\n<p>下面的代码演示了如何将一组<code>String</code>先过滤掉空字符串，然后把非空字符串保存到<code>List</code>中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>把<code>Stream</code>的每个元素收集到<code>List</code>的方法是调用<code>collect()</code>并传入<code>Collectors.toList()</code>对象，它实际上是一个<code>Collector</code>实例，通过类似<code>reduce()</code>的操作，把每个元素添加到一个收集器中（实际上是<code>ArrayList</code>）。</p>\n<p>类似的，<code>collect(Collectors.toSet())</code>可以把<code>Stream</code>的每个元素收集到<code>Set</code>中。</p>\n<h3 id=\"输出为数组\"><a href=\"#输出为数组\" class=\"headerlink\" title=\"输出为数组\"></a>输出为数组</h3><p>把Stream的元素输出为数组和输出为List类似，我们只需要调用<code>toArray()</code>方法，并传入数组的“构造方法”：</p>\n<figure class=\"highlight smali\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = List.of(<span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>, <span class=\"string\">&quot;Orange&quot;</span>);</span><br><span class=\"line\">String[]<span class=\"built_in\"> array </span>= list.stream().toArray(String[]::new);</span><br></pre></td></tr></table></figure>\n\n<p>注意到传入的“构造方法”是<code>String[]::new</code>，它的签名实际上是<code>IntFunction&lt;String[]&gt;</code>定义的<code>String[] apply(int)</code>，即传入<code>int</code>参数，获得<code>String[]</code>数组的返回值。</p>\n<h3 id=\"输出为Map\"><a href=\"#输出为Map\" class=\"headerlink\" title=\"输出为Map\"></a>输出为Map</h3><p>如果我们要把Stream的元素收集到Map中，就稍微麻烦一点。因为对于每个元素，添加到Map时需要key和value，因此，我们要指定两个映射函数，分别把元素映射为key和value：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<h3 id=\"分组输出\"><a href=\"#分组输出\" class=\"headerlink\" title=\"分组输出\"></a>分组输出</h3><p><code>Stream</code>还有一个强大的分组功能，可以按组输出。我们看下面的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>分组输出使用<code>Collectors.groupingBy()</code>，它需要提供两个函数：一个是分组的key，这里使用<code>s -&gt; s.substring(0, 1)</code>，表示只要首字母相同的<code>String</code>分到一组，第二个是分组的value，这里直接使用<code>Collectors.toList()</code>，表示输出为<code>List</code>，上述代码运行结果如下：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    A=[Apple, Avocado, Apricots],</span><br><span class=\"line\">    B=[Banana, Blackberry],</span><br><span class=\"line\">    C=[Coconut, Cherry]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，结果一共有3组，按<code>&quot;A&quot;</code>，<code>&quot;B&quot;</code>，<code>&quot;C&quot;</code>分组，每一组都是一个<code>List</code>。</p>\n<p>假设有这样一个<code>Student</code>类，包含学生姓名、班级和成绩：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"symbol\">Student</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">int</span> gradeId; <span class=\"comment\">// 年级</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> classId; <span class=\"comment\">// 班级</span></span><br><span class=\"line\">    String name; <span class=\"comment\">// 名字</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span> score; <span class=\"comment\">// 分数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们有一个<code>Stream&lt;Student&gt;</code>，利用分组输出，可以非常简单地按年级或班级把<code>Student</code>归类。</p>\n<h2 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h2><p>我们把<code>Stream</code>提供的操作分为两类：转换操作和聚合操作。除了前面介绍的常用操作外，<code>Stream</code>还提供了一系列非常有用的方法。</p>\n<h3 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h3><p>对<code>Stream</code>的元素进行排序十分简单，只需调用<code>sorted()</code>方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.stream.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>此方法要求<code>Stream</code>的每个元素必须实现<code>Comparable</code>接口。如果要自定义排序，传入指定的<code>Comparator</code>即可：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; <span class=\"built_in\">list</span> = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">List</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"string\">&quot;Orange&quot;</span>, <span class=\"string\">&quot;apple&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span>)</span><br><span class=\"line\">    .stream<span class=\"literal\">()</span></span><br><span class=\"line\">    .sorted(String::compareToIgnoreCase)</span><br><span class=\"line\">    .collect(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Collectors</span>.</span></span><span class=\"keyword\">to</span><span class=\"constructor\">List()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意<code>sorted()</code>只是一个转换操作，它会返回一个新的<code>Stream</code>。</p>\n<h3 id=\"去重\"><a href=\"#去重\" class=\"headerlink\" title=\"去重\"></a>去重</h3><p>对一个<code>Stream</code>的元素进行去重，没必要先转换为<code>Set</code>，可以直接用<code>distinct()</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">List</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;D&quot;</span>)</span><br><span class=\"line\">    .stream<span class=\"literal\">()</span></span><br><span class=\"line\">    .distinct<span class=\"literal\">()</span></span><br><span class=\"line\">    .collect(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Collectors</span>.</span></span><span class=\"keyword\">to</span><span class=\"constructor\">List()</span>); <span class=\"comment\">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"截取\"><a href=\"#截取\" class=\"headerlink\" title=\"截取\"></a>截取</h3><p>截取操作常用于把一个无限的<code>Stream</code>转换成有限的<code>Stream</code>，<code>skip()</code>用于跳过当前<code>Stream</code>的前N个元素，<code>limit()</code>用于截取当前<code>Stream</code>最多前N个元素：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">List</span><span class=\"selector-class\">.of</span>(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>, <span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>, <span class=\"string\">&quot;F&quot;</span>)</span><br><span class=\"line\">    <span class=\"selector-class\">.stream</span>()</span><br><span class=\"line\">    <span class=\"selector-class\">.skip</span>(<span class=\"number\">2</span>) <span class=\"comment\">// 跳过A, B</span></span><br><span class=\"line\">    <span class=\"selector-class\">.limit</span>(<span class=\"number\">3</span>) <span class=\"comment\">// 截取C, D, E</span></span><br><span class=\"line\">    <span class=\"selector-class\">.collect</span>(Collectors.toList()); <span class=\"comment\">// [C, D, E]</span></span><br></pre></td></tr></table></figure>\n\n<p>截取操作也是一个转换操作，将返回新的<code>Stream</code>。</p>\n<h3 id=\"合并\"><a href=\"#合并\" class=\"headerlink\" title=\"合并\"></a>合并</h3><p>将两个<code>Stream</code>合并为一个<code>Stream</code>可以使用<code>Stream</code>的静态方法<code>concat()</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;String&gt; s1 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">List</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"string\">&quot;A&quot;</span>, <span class=\"string\">&quot;B&quot;</span>, <span class=\"string\">&quot;C&quot;</span>).stream<span class=\"literal\">()</span>;</span><br><span class=\"line\">Stream&lt;String&gt; s2 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">List</span>.</span></span><span class=\"keyword\">of</span>(<span class=\"string\">&quot;D&quot;</span>, <span class=\"string\">&quot;E&quot;</span>).stream<span class=\"literal\">()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 合并:</span></span><br><span class=\"line\">Stream&lt;String&gt; s = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Stream</span>.</span></span>concat(s1, s2);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(s.collect(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Collectors</span>.</span></span><span class=\"keyword\">to</span><span class=\"constructor\">List()</span>)); <span class=\"comment\">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"flatMap\"><a href=\"#flatMap\" class=\"headerlink\" title=\"flatMap\"></a>flatMap</h3><p>如果<code>Stream</code>的元素是集合：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;List&lt;Integer&gt;&gt; s = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Stream</span>.</span></span><span class=\"keyword\">of</span>(</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span><span class=\"keyword\">as</span><span class=\"constructor\">List(1, 2, 3)</span>,</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span><span class=\"keyword\">as</span><span class=\"constructor\">List(4, 5, 6)</span>,</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span><span class=\"keyword\">as</span><span class=\"constructor\">List(7, 8, 9)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>而我们希望把上述<code>Stream</code>转换为<code>Stream&lt;Integer&gt;</code>，就可以使用<code>flatMap()</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;Integer&gt; i = s.flat<span class=\"constructor\">Map(<span class=\"params\">list</span> -&gt; <span class=\"params\">list</span>.<span class=\"params\">stream</span>()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>因此，所谓<code>flatMap()</code>，是指把<code>Stream</code>的每个元素（这里是<code>List</code>）映射为<code>Stream</code>，然后合并成一个新的<code>Stream</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────┬─────────────┬─────────────┐</span><br><span class=\"line\">│┌───┬───┬───┐│┌───┬───┬───┐│┌───┬───┬───┐│</span><br><span class=\"line\">││ 1 │ 2 │ 3 │││ 4 │ 5 │ 6 │││ 7 │ 8 │ 9 ││</span><br><span class=\"line\">│└───┴───┴───┘│└───┴───┴───┘│└───┴───┴───┘│</span><br><span class=\"line\">└─────────────┴─────────────┴─────────────┘</span><br><span class=\"line\">                     │</span><br><span class=\"line\">                     │flatMap(List -&gt; Stream)</span><br><span class=\"line\">                     │</span><br><span class=\"line\">                     │</span><br><span class=\"line\">                     ▼</span><br><span class=\"line\">   ┌───┬───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class=\"line\">   │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ 8 │ 9 │</span><br><span class=\"line\">   └───┴───┴───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"并行\"><a href=\"#并行\" class=\"headerlink\" title=\"并行\"></a>并行</h3><p>通常情况下，对<code>Stream</code>的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理<code>Stream</code>的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p>\n<p>把一个普通<code>Stream</code>转换为可以并行处理的<code>Stream</code>非常简单，只需要用<code>parallel()</code>进行转换：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Stream</span>&lt;<span class=\"keyword\">String</span>&gt; s = ...</span><br><span class=\"line\"><span class=\"keyword\">String</span>[] result = s.<span class=\"built_in\">parallel</span>() <span class=\"comment\">// 变成一个可以并行处理的Stream</span></span><br><span class=\"line\">                   .<span class=\"built_in\">sorted</span>() <span class=\"comment\">// 可以进行并行排序</span></span><br><span class=\"line\">                   .<span class=\"built_in\">toArray</span>(<span class=\"keyword\">String</span>[]::<span class=\"keyword\">new</span>);</span><br></pre></td></tr></table></figure>\n\n<p>经过<code>parallel()</code>转换后的<code>Stream</code>只要可能，就会对后续操作进行并行处理。我们不需要编写任何多线程代码就可以享受到并行处理带来的执行效率的提升。</p>\n<h3 id=\"其他聚合方法\"><a href=\"#其他聚合方法\" class=\"headerlink\" title=\"其他聚合方法\"></a>其他聚合方法</h3><p>除了<code>reduce()</code>和<code>collect()</code>外，<code>Stream</code>还有一些常用的聚合方法：</p>\n<ul>\n<li><code>count()</code>：用于返回元素个数；</li>\n<li><code>max(Comparator&lt;? super T&gt; cp)</code>：找出最大元素；</li>\n<li><code>min(Comparator&lt;? super T&gt; cp)</code>：找出最小元素。</li>\n</ul>\n<p>针对<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>，还额外提供了以下聚合方法：</p>\n<ul>\n<li><code>sum()</code>：对所有元素求和；</li>\n<li><code>average()</code>：对所有元素求平均数。</li>\n</ul>\n<p>还有一些方法，用来测试<code>Stream</code>的元素是否满足以下条件：</p>\n<ul>\n<li><code>boolean allMatch(Predicate&lt;? super T&gt;)</code>：测试是否所有元素均满足测试条件；</li>\n<li><code>boolean anyMatch(Predicate&lt;? super T&gt;)</code>：测试是否至少有一个元素满足测试条件。</li>\n</ul>\n<p>最后一个常用的方法是<code>forEach()</code>，它可以循环处理<code>Stream</code>的每个元素，我们经常传入<code>System.out::println</code>来打印<code>Stream</code>的元素：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stream&lt;<span class=\"keyword\">String</span>&gt; s = ...</span><br><span class=\"line\">s.forEach(<span class=\"built_in\">str</span> -&gt; &#123;</span><br><span class=\"line\">    System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;Hello, &quot;</span> + <span class=\"built_in\">str</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>","categories":["Java","5.JavaEE进阶","5.函数式编程"],"tags":["写作"]},{"title":"4.JDBC编程","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_4.JDBC%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"JDBC编程简介\"><a href=\"#JDBC编程简介\" class=\"headerlink\" title=\"JDBC编程简介\"></a>JDBC编程简介</h1><p>程序运行的时候，往往需要存取数据。现代应用程序最基本，也是使用最广泛的数据存储就是关系数据库。</p>\n<p>Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity），本章我们介绍如何在Java程序中使用JDBC。</p>\n<p>在介绍JDBC之前，我们先简单介绍一下关系数据库。</p>\n<p>程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。</p>\n<p>而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">名字</th>\n<th align=\"left\">成绩</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Michael</td>\n<td align=\"left\">99</td>\n</tr>\n<tr>\n<td align=\"left\">Bob</td>\n<td align=\"left\">85</td>\n</tr>\n<tr>\n<td align=\"left\">Bart</td>\n<td align=\"left\">59</td>\n</tr>\n<tr>\n<td align=\"left\">Lisa</td>\n<td align=\"left\">87</td>\n</tr>\n</tbody></table>\n<p>你可以用一个文本文件保存，一行保存一个学生，用<code>,</code>隔开：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Michael</span>,<span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"attribute\">Bob</span>,<span class=\"number\">85</span></span><br><span class=\"line\"><span class=\"attribute\">Bart</span>,<span class=\"number\">59</span></span><br><span class=\"line\"><span class=\"attribute\">Lisa</span>,<span class=\"number\">87</span></span><br></pre></td></tr></table></figure>\n\n<p>你还可以用JSON格式保存，也是文本文件：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"attr\">&quot;name&quot;</span>:<span class=\"string\">&quot;Michael&quot;</span>,<span class=\"attr\">&quot;score&quot;</span>:<span class=\"number\">99</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">&quot;name&quot;</span>:<span class=\"string\">&quot;Bob&quot;</span>,<span class=\"attr\">&quot;score&quot;</span>:<span class=\"number\">85</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">&quot;name&quot;</span>:<span class=\"string\">&quot;Bart&quot;</span>,<span class=\"attr\">&quot;score&quot;</span>:<span class=\"number\">59</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">&quot;name&quot;</span>:<span class=\"string\">&quot;Lisa&quot;</span>,<span class=\"attr\">&quot;score&quot;</span>:<span class=\"number\">87</span>&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n\n<p>你还可以定义各种保存格式，但是问题来了：</p>\n<p>存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；</p>\n<p>不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存（比如蓝光电影，40GB的数据），根本无法全部读入内存。</p>\n<p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p>\n<p>数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。</p>\n<p>关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：</p>\n<p>假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来：</p>\n<p><img src=\"/4.JDBC%E7%BC%96%E7%A8%8B.assets/0.jpeg\" alt=\"grade\"></p>\n<p>每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格：</p>\n<p><img src=\"/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063210.jpeg\" alt=\"class\"></p>\n<p>这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级：</p>\n<p><img src=\"/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063211.jpeg\" alt=\"grade-classes\"></p>\n<p>也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p>\n<p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> classes <span class=\"keyword\">WHERE</span> grade_id = <span class=\"string\">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>结果也是一个表：</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"code\"><pre><span class=\"line\">---------<span class=\"code\">+----------+</span>----------</span><br><span class=\"line\"><span class=\"section\">grade_id | class_id | name</span></span><br><span class=\"line\"><span class=\"section\">---------+----------+----------</span></span><br><span class=\"line\"><span class=\"section\">1        | 11       | 一年级一班</span></span><br><span class=\"line\"><span class=\"section\">---------+----------+----------</span></span><br><span class=\"line\"><span class=\"section\">1        | 12       | 一年级二班</span></span><br><span class=\"line\"><span class=\"section\">---------+----------+----------</span></span><br><span class=\"line\"><span class=\"section\">1        | 13       | 一年级三班</span></span><br><span class=\"line\"><span class=\"section\">---------+----------+----------</span></span><br></pre></td></tr></table></figure>\n\n<p>类似的，Class表的一行记录又可以关联到Student表的多行记录：</p>\n<p><img src=\"/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063212.png\" alt=\"class-students\"></p>\n<p>由于本教程不涉及到关系数据库的详细内容，如果你想从零学习关系数据库和基本的SQL语句，请参考<a href=\"https://www.liaoxuefeng.com/wiki/1177760294764384\">SQL课程</a>。</p>\n<h3 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h3><p>你也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被他们忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？</p>\n<h3 id=\"数据库类别\"><a href=\"#数据库类别\" class=\"headerlink\" title=\"数据库类别\"></a>数据库类别</h3><p>既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：</p>\n<p>付费的商用数据库：</p>\n<ul>\n<li>Oracle，典型的高富帅；</li>\n<li>SQL Server，微软自家产品，Windows定制专款；</li>\n<li>DB2，IBM的产品，听起来挺高端；</li>\n<li>Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。</li>\n</ul>\n<p>这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：</p>\n<ul>\n<li>MySQL，大家都在用，一般错不了；</li>\n<li>PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；</li>\n<li>sqlite，嵌入式数据库，适合桌面和移动应用。</li>\n</ul>\n<p>作为一个Java工程师，选择哪个免费数据库呢？当然是MySQL。因为MySQL普及率最高，出了错，可以很容易找到解决方法。而且，围绕MySQL有一大堆监控和运维的工具，安装和使用很方便。</p>\n<h3 id=\"安装MySQL\"><a href=\"#安装MySQL\" class=\"headerlink\" title=\"安装MySQL\"></a>安装MySQL</h3><p>为了能继续后面的学习，你需要从MySQL官方网站下载并安装<a href=\"http://dev.mysql.com/downloads/mysql/\">MySQL Community Server 5.6</a>，这个版本是免费的，其他高级版本是要收钱的（请放心，收钱的功能我们用不上）。MySQL是跨平台的，选择对应的平台下载安装文件，安装即可。</p>\n<p>安装时，MySQL会提示输入<code>root</code>用户的口令，请务必记清楚。如果怕记不住，就把口令设置为<code>password</code>。</p>\n<p>在Windows上，安装时请选择<code>UTF-8</code>编码，以便正确地处理中文。</p>\n<p>在Mac或Linux上，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。MySQL的配置文件默认存放在<code>/etc/my.cnf</code>或者<code>/etc/mysql/my.cnf</code>：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">[client]</span></span><br><span class=\"line\"><span class=\"attr\">default-character-set</span> = utf8</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">[mysqld]</span></span><br><span class=\"line\"><span class=\"attr\">default-storage-engine</span> = INNODB</span><br><span class=\"line\"><span class=\"attr\">character-set-server</span> = utf8</span><br><span class=\"line\"><span class=\"attr\">collation-server</span> = utf8_general_ci</span><br></pre></td></tr></table></figure>\n\n<p>重启MySQL后，可以通过MySQL的客户端命令行检查编码：</p>\n<figure class=\"highlight gherkin\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mysql -u root -p</span><br><span class=\"line\">Enter password: </span><br><span class=\"line\">Welcome to the MySQL monitor...</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; show variables like &#x27;%char%&#x27;;</span><br><span class=\"line\">+--------------------------+--------------------------------------------------------+</span><br><span class=\"line\">|<span class=\"string\"> Variable_name            </span>|<span class=\"string\"> Value                                                  </span>|</span><br><span class=\"line\">+--------------------------+--------------------------------------------------------+</span><br><span class=\"line\">|<span class=\"string\"> character_set_client     </span>|<span class=\"string\"> utf8                                                   </span>|</span><br><span class=\"line\">|<span class=\"string\"> character_set_connection </span>|<span class=\"string\"> utf8                                                   </span>|</span><br><span class=\"line\">|<span class=\"string\"> character_set_database   </span>|<span class=\"string\"> utf8                                                   </span>|</span><br><span class=\"line\">|<span class=\"string\"> character_set_filesystem </span>|<span class=\"string\"> binary                                                 </span>|</span><br><span class=\"line\">|<span class=\"string\"> character_set_results    </span>|<span class=\"string\"> utf8                                                   </span>|</span><br><span class=\"line\">|<span class=\"string\"> character_set_server     </span>|<span class=\"string\"> utf8                                                   </span>|</span><br><span class=\"line\">|<span class=\"string\"> character_set_system     </span>|<span class=\"string\"> utf8                                                   </span>|</span><br><span class=\"line\">|<span class=\"string\"> character_sets_dir       </span>|<span class=\"string\"> /usr/local/mysql-5.1.65-osx10.6-x86_64/share/charsets/ </span>|</span><br><span class=\"line\">+--------------------------+--------------------------------------------------------+</span><br><span class=\"line\">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n\n<p>看到<code>utf8</code>字样就表示编码设置正确。</p>\n<p><em>注</em>：如果MySQL的版本≥5.5.3，可以把编码设置为<code>utf8mb4</code>，<code>utf8mb4</code>和<code>utf8</code>完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。</p>\n<h3 id=\"JDBC\"><a href=\"#JDBC\" class=\"headerlink\" title=\"JDBC\"></a>JDBC</h3><p>什么是JDBC？JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。</p>\n<p>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。</p>\n<p>例如，我们在Java代码中如果要访问MySQL，那么必须编写代码操作JDBC接口。注意到JDBC接口是Java标准库自带的，所以可以直接编译。而具体的JDBC驱动是由数据库厂商提供的，例如，MySQL的JDBC驱动由Oracle提供。因此，访问某个具体的数据库，我们只需要引入该厂商提供的JDBC驱动，就可以通过JDBC接口来访问，这样保证了Java程序编写的是一套数据库访问代码，却可以访问各种不同的数据库，因为他们都提供了标准的JDBC驱动：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\"></span><br><span class=\"line\">│  ┌───────────────┐  │</span><br><span class=\"line\">   │   Java App    │</span><br><span class=\"line\">│  └───────────────┘  │</span><br><span class=\"line\">           │</span><br><span class=\"line\">│          ▼          │</span><br><span class=\"line\">   ┌───────────────┐</span><br><span class=\"line\">│  │JDBC Interface │&lt;─┼─── JDK</span><br><span class=\"line\">   └───────────────┘</span><br><span class=\"line\">│          │          │</span><br><span class=\"line\">           ▼</span><br><span class=\"line\">│  ┌───────────────┐  │</span><br><span class=\"line\">   │  JDBC Driver  │&lt;───── Vendor</span><br><span class=\"line\">│  └───────────────┘  │</span><br><span class=\"line\">           │</span><br><span class=\"line\">└ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ┘</span><br><span class=\"line\">           ▼</span><br><span class=\"line\">   ┌───────────────┐</span><br><span class=\"line\">   │   Database    │</span><br><span class=\"line\">   └───────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>从代码来看，Java标准库自带的JDBC接口其实就是定义了一组接口，而某个具体的JDBC驱动其实就是实现了这些接口的类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\"></span><br><span class=\"line\">│  ┌───────────────┐  │</span><br><span class=\"line\">   │   Java App    │</span><br><span class=\"line\">│  └───────────────┘  │</span><br><span class=\"line\">           │</span><br><span class=\"line\">│          ▼          │</span><br><span class=\"line\">   ┌───────────────┐</span><br><span class=\"line\">│  │JDBC Interface │&lt;─┼─── JDK</span><br><span class=\"line\">   └───────────────┘</span><br><span class=\"line\">│          │          │</span><br><span class=\"line\">           ▼</span><br><span class=\"line\">│  ┌───────────────┐  │</span><br><span class=\"line\">   │ MySQL Driver  │&lt;───── Oracle</span><br><span class=\"line\">│  └───────────────┘  │</span><br><span class=\"line\">           │</span><br><span class=\"line\">└ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ┘</span><br><span class=\"line\">           ▼</span><br><span class=\"line\">   ┌───────────────┐</span><br><span class=\"line\">   │     MySQL     │</span><br><span class=\"line\">   └───────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>实际上，一个MySQL的JDBC的驱动就是一个jar包，它本身也是纯Java编写的。我们自己编写的代码只需要引用Java标准库提供的java.sql包下面的相关接口，由此再间接地通过MySQL驱动的jar包通过网络访问MySQL服务器，所有复杂的网络通讯都被封装到JDBC驱动中，因此，Java程序本身只需要引入一个MySQL驱动的jar包就可以正常访问MySQL服务器：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">   ┌───────────────┐</span><br><span class=\"line\">│  │   App.class   │  │</span><br><span class=\"line\">   └───────────────┘</span><br><span class=\"line\">│          │          │</span><br><span class=\"line\">           ▼</span><br><span class=\"line\">│  ┌───────────────┐  │</span><br><span class=\"line\">   │  java.sql.*   │</span><br><span class=\"line\">│  └───────────────┘  │</span><br><span class=\"line\">           │</span><br><span class=\"line\">│          ▼          │</span><br><span class=\"line\">   ┌───────────────┐     TCP    ┌───────────────┐</span><br><span class=\"line\">│  │ mysql-xxx.jar │──┼────────&gt;│     MySQL     │</span><br><span class=\"line\">   └───────────────┘            └───────────────┘</span><br><span class=\"line\">└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br><span class=\"line\">          JVM</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"JDBC查询\"><a href=\"#JDBC查询\" class=\"headerlink\" title=\"JDBC查询\"></a>JDBC查询</h1><p>前面我们讲了Java程序要通过JDBC接口来查询数据库。JDBC是一套接口规范，它在哪呢？就在Java的标准库<code>java.sql</code>里放着，不过这里面大部分都是接口。接口并不能直接实例化，而是必须实例化对应的实现类，然后通过接口引用这个实例。那么问题来了：JDBC接口的实现类在哪？</p>\n<p>因为JDBC接口并不知道我们要使用哪个数据库，所以，用哪个数据库，我们就去使用哪个数据库的“实现类”，我们把某个数据库实现了JDBC接口的jar包称为JDBC驱动。</p>\n<p>因为我们选择了MySQL 5.x作为数据库，所以我们首先得找一个MySQL的JDBC驱动。所谓JDBC驱动，其实就是一个第三方jar包，我们直接添加一个Maven依赖就可以了：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.47<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>runtime<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>注意到这里添加依赖的<code>scope</code>是<code>runtime</code>，因为编译Java程序并不需要MySQL的这个jar包，只有在运行期才需要使用。如果把<code>runtime</code>改成<code>compile</code>，虽然也能正常编译，但是在IDE里写程序的时候，会多出来一大堆类似<code>com.mysql.jdbc.Connection</code>这样的类，非常容易与Java标准库的JDBC接口混淆，所以坚决不要设置为<code>compile</code>。</p>\n<p>有了驱动，我们还要确保MySQL在本机正常运行，并且还需要准备一点数据。这里我们用一个脚本创建数据库和表，然后插入一些数据：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建数据库learjdbc:</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">DATABASE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> learnjdbc;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">DATABASE</span> learnjdbc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建登录用户learn/口令learnpassword</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span> learn@<span class=\"string\">&#x27;%&#x27;</span> IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;learnpassword&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">GRANT</span> <span class=\"keyword\">ALL</span> <span class=\"keyword\">PRIVILEGES</span> <span class=\"keyword\">ON</span> learnjdbc.* <span class=\"keyword\">TO</span> learn@<span class=\"string\">&#x27;%&#x27;</span> <span class=\"keyword\">WITH</span> <span class=\"keyword\">GRANT</span> <span class=\"keyword\">OPTION</span>;</span><br><span class=\"line\">FLUSH <span class=\"keyword\">PRIVILEGES</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 创建表students:</span></span><br><span class=\"line\">USE learnjdbc;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> students (</span><br><span class=\"line\">  id <span class=\"type\">BIGINT</span> AUTO_INCREMENT <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  <span class=\"type\">name</span> <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  gender TINYINT(<span class=\"number\">1</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  grade <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  score <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY KEY</span>(id)</span><br><span class=\"line\">) Engine=INNODB <span class=\"keyword\">DEFAULT</span> CHARSET=UTF8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入初始数据:</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小明&#x27;</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">88</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小红&#x27;</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">95</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小军&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">93</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小白&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小牛&#x27;</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">96</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小兵&#x27;</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">99</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小强&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">86</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小乔&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">2</span>, <span class=\"number\">79</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小青&#x27;</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">85</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小王&#x27;</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">90</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小林&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">91</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> students (<span class=\"type\">name</span>, gender, grade, score) <span class=\"keyword\">VALUES</span> (<span class=\"string\">&#x27;小贝&#x27;</span>, <span class=\"number\">0</span>, <span class=\"number\">3</span>, <span class=\"number\">77</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在控制台输入<code>mysql -u root -p</code>，输入<code>root</code>口令后以<code>root</code>身份，把上述SQL贴到控制台执行一遍就行。如果你运行的是最新版MySQL 8.x，需要调整一下<code>CREATE USER</code>语句。</p>\n<h3 id=\"JDBC连接\"><a href=\"#JDBC连接\" class=\"headerlink\" title=\"JDBC连接\"></a>JDBC连接</h3><p>使用JDBC时，我们先了解什么是Connection。Connection代表一个JDBC连接，它相当于Java程序到数据库的连接（通常是TCP连接）。打开一个Connection时，需要准备URL、用户名和口令，才能成功连接到数据库。</p>\n<p>URL是由数据库厂商指定的格式，例如，MySQL的URL是：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">jdbc</span>:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;db&gt;?key<span class=\"number\">1</span>=value<span class=\"number\">1</span>&amp;key<span class=\"number\">2</span>=value<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>假设数据库运行在本机<code>localhost</code>，端口使用标准的<code>3306</code>，数据库名称是<code>learnjdbc</code>，那么URL如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">jdbc</span>:mysql://localhost:<span class=\"number\">3306</span>/learnjdbc?useSSL=false&amp;characterEncoding=utf<span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n\n<p>后面的两个参数表示不使用SSL加密，使用UTF-8作为字符编码（注意MySQL的UTF-8是<code>utf8</code>）。</p>\n<p>要获取数据库连接，使用如下代码：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// JDBC连接的URL, 不同数据库有不同的格式:</span></span><br><span class=\"line\"><span class=\"keyword\">String</span> JDBC_URL = <span class=\"string\">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">String</span> JDBC_USER = <span class=\"string\">&quot;root&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">String</span> JDBC_PASSWORD = <span class=\"string\">&quot;password&quot;</span>;</span><br><span class=\"line\"><span class=\"comment\">// 获取连接:</span></span><br><span class=\"line\">Connection conn = DriverManager.<span class=\"built_in\">getConnection</span>(JDBC_URL, JDBC_USER, JDBC_PASSWORD);</span><br><span class=\"line\"><span class=\"comment\">// <span class=\"doctag\">TODO:</span> 访问数据库...</span></span><br><span class=\"line\"><span class=\"comment\">// 关闭连接:</span></span><br><span class=\"line\">conn.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure>\n\n<p>核心代码是<code>DriverManager</code>提供的静态方法<code>getConnection()</code>。<code>DriverManager</code>会自动扫描classpath，找到所有的JDBC驱动，然后根据我们传入的URL自动挑选一个合适的驱动。</p>\n<p>因为JDBC连接是一种昂贵的资源，所以使用后要及时释放。使用<code>try (resource)</code>来自动释放JDBC连接是一个好方法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DriverManager</span>.</span></span>get<span class=\"constructor\">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JDBC查询-1\"><a href=\"#JDBC查询-1\" class=\"headerlink\" title=\"JDBC查询\"></a>JDBC查询</h3><p>获取到JDBC连接后，下一步我们就可以查询数据库了。查询数据库分以下几步：</p>\n<p>第一步，通过<code>Connection</code>提供的<code>createStatement()</code>方法创建一个<code>Statement</code>对象，用于执行一个查询；</p>\n<p>第二步，执行<code>Statement</code>对象提供的<code>executeQuery(&quot;SELECT * FROM students&quot;)</code>并传入SQL语句，执行查询并获得返回的结果集，使用<code>ResultSet</code>来引用这个结果集；</p>\n<p>第三步，反复调用<code>ResultSet</code>的<code>next()</code>方法并读取每一行结果。</p>\n<p>完整查询代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DriverManager</span>.</span></span>get<span class=\"constructor\">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (Statement stmt = conn.create<span class=\"constructor\">Statement()</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (ResultSet rs = stmt.execute<span class=\"constructor\">Query(<span class=\"string\">&quot;SELECT id, grade, name, gender FROM students WHERE gender=1&quot;</span>)</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rs.next<span class=\"literal\">()</span>) &#123;</span><br><span class=\"line\">                long id = rs.get<span class=\"constructor\">Long(1)</span>; <span class=\"comment\">// 注意：索引从1开始</span></span><br><span class=\"line\">                long grade = rs.get<span class=\"constructor\">Long(2)</span>;</span><br><span class=\"line\">                String name = rs.get<span class=\"constructor\">String(3)</span>;</span><br><span class=\"line\">                <span class=\"built_in\">int</span> gender = rs.get<span class=\"constructor\">Int(4)</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意要点：</p>\n<p><code>Statment</code>和<code>ResultSet</code>都是需要关闭的资源，因此嵌套使用<code>try (resource)</code>确保及时关闭；</p>\n<p><code>rs.next()</code>用于判断是否有下一行记录，如果有，将自动把当前行移动到下一行（一开始获得<code>ResultSet</code>时当前行不是第一行）；</p>\n<p><code>ResultSet</code>获取列时，索引从<code>1</code>开始而不是<code>0</code>；</p>\n<p>必须根据<code>SELECT</code>的列的对应位置来调用<code>getLong(1)</code>，<code>getString(2)</code>这些方法，否则对应位置的数据类型不对，将报错。</p>\n<h3 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h3><p>使用<code>Statement</code>拼字符串非常容易引发SQL注入的问题，这是因为SQL参数往往是从方法参数传入的。</p>\n<p>我们来看一个例子：假设用户登录的验证方法如下：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">User</span> <span class=\"title\">login</span>(<span class=\"keyword\">String</span> name, <span class=\"keyword\">String</span> pass) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    stmt.executeQuery(<span class=\"string\">&quot;SELECT * FROM user WHERE login=&#x27;&quot;</span> + name + <span class=\"string\">&quot;&#x27; AND pass=&#x27;&quot;</span> + pass + <span class=\"string\">&quot;&#x27;&quot;</span>);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，参数<code>name</code>和<code>pass</code>通常都是Web页面输入后由程序接收到的。</p>\n<p>如果用户的输入是程序期待的值，就可以拼出正确的SQL。例如：name &#x3D; <code>&quot;bob&quot;</code>，pass &#x3D; <code>&quot;1234&quot;</code>：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">login</span>=<span class=\"string\">&#x27;bob&#x27;</span> <span class=\"keyword\">AND</span> pass=<span class=\"string\">&#x27;1234&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>但是，如果用户的输入是一个精心构造的字符串，就可以拼出意想不到的SQL，这个SQL也是正确的，但它查询的条件不是程序设计的意图。例如：name &#x3D; <code>&quot;bob&#39; OR pass=&quot;</code>, pass &#x3D; <code>&quot; OR pass=&#39;&quot;</code>：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> <span class=\"keyword\">user</span> <span class=\"keyword\">WHERE</span> <span class=\"keyword\">login</span>=<span class=\"string\">&#x27;bob&#x27;</span> <span class=\"keyword\">OR</span> pass=<span class=\"string\">&#x27; AND pass=&#x27;</span> <span class=\"keyword\">OR</span> pass=<span class=\"string\">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个SQL语句执行的时候，根本不用判断口令是否正确，这样一来，登录就形同虚设。</p>\n<p>要避免SQL注入攻击，一个办法是针对所有字符串参数进行转义，但是转义很麻烦，而且需要在任何使用SQL的地方增加转义代码。</p>\n<p>还有一个办法就是使用<code>PreparedStatement</code>。使用<code>PreparedStatement</code>可以<em>完全避免SQL注入</em>的问题，因为<code>PreparedStatement</code>始终使用<code>?</code>作为占位符，并且把数据连同SQL本身传给数据库，这样可以保证每次传给数据库的SQL语句是相同的，只是占位符的数据不同，还能高效利用数据库本身对查询的缓存。上述登录SQL如果用<code>PreparedStatement</code>可以改写如下：</p>\n<figure class=\"highlight crmsh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">User</span> <span class=\"title\">login</span>(<span class=\"keyword\">String</span> name, <span class=\"keyword\">String</span> pass) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">String</span> sql = <span class=\"string\">&quot;SELECT * FROM user WHERE login=? AND pass=?&quot;</span>;</span><br><span class=\"line\">    PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class=\"line\">    ps.setObject(<span class=\"number\">1</span>, name);</span><br><span class=\"line\">    ps.setObject(<span class=\"number\">2</span>, pass);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，<code>PreparedStatement</code>比<code>Statement</code>更安全，而且更快。</p>\n<p> 使用Java对数据库进行操作时，必须使用PreparedStatement，严禁任何通过参数拼字符串的代码！</p>\n<p>我们把上面使用<code>Statement</code>的代码改为使用<code>PreparedStatement</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DriverManager</span>.</span></span>get<span class=\"constructor\">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (PreparedStatement ps = conn.prepare<span class=\"constructor\">Statement(<span class=\"string\">&quot;SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?&quot;</span>)</span>) &#123;</span><br><span class=\"line\">        ps.set<span class=\"constructor\">Object(1, <span class=\"string\">&quot;M&quot;</span>)</span>; <span class=\"comment\">// 注意：索引从1开始</span></span><br><span class=\"line\">        ps.set<span class=\"constructor\">Object(2, 3)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> (ResultSet rs = ps.execute<span class=\"constructor\">Query()</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rs.next<span class=\"literal\">()</span>) &#123;</span><br><span class=\"line\">                long id = rs.get<span class=\"constructor\">Long(<span class=\"string\">&quot;id&quot;</span>)</span>;</span><br><span class=\"line\">                long grade = rs.get<span class=\"constructor\">Long(<span class=\"string\">&quot;grade&quot;</span>)</span>;</span><br><span class=\"line\">                String name = rs.get<span class=\"constructor\">String(<span class=\"string\">&quot;name&quot;</span>)</span>;</span><br><span class=\"line\">                String gender = rs.get<span class=\"constructor\">String(<span class=\"string\">&quot;gender&quot;</span>)</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用<code>PreparedStatement</code>和<code>Statement</code>稍有不同，必须首先调用<code>setObject()</code>设置每个占位符<code>?</code>的值，最后获取的仍然是<code>ResultSet</code>对象。</p>\n<p>另外注意到从结果集读取列时，使用<code>String</code>类型的列名比索引要易读，而且不易出错。</p>\n<p>注意到JDBC查询的返回值总是<code>ResultSet</code>，即使我们写这样的聚合查询<code>SELECT SUM(score) FROM ...</code>，也需要按结果集读取：</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"code\"><pre><span class=\"line\">ResultSet rs = ...</span><br><span class=\"line\"><span class=\"keyword\">if</span> (rs.<span class=\"keyword\">next</span>()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">double</span> <span class=\"keyword\">sum</span> = rs.getDouble(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>有的童鞋可能注意到了，使用JDBC的时候，我们需要在Java数据类型和SQL数据类型之间进行转换。JDBC在<code>java.sql.Types</code>定义了一组常量来表示如何映射SQL数据类型，但是平时我们使用的类型通常也就以下几种：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">SQL数据类型</th>\n<th align=\"left\">Java数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">BIT, BOOL</td>\n<td align=\"left\">boolean</td>\n</tr>\n<tr>\n<td align=\"left\">INTEGER</td>\n<td align=\"left\">int</td>\n</tr>\n<tr>\n<td align=\"left\">BIGINT</td>\n<td align=\"left\">long</td>\n</tr>\n<tr>\n<td align=\"left\">REAL</td>\n<td align=\"left\">float</td>\n</tr>\n<tr>\n<td align=\"left\">FLOAT, DOUBLE</td>\n<td align=\"left\">double</td>\n</tr>\n<tr>\n<td align=\"left\">CHAR, VARCHAR</td>\n<td align=\"left\">String</td>\n</tr>\n<tr>\n<td align=\"left\">DECIMAL</td>\n<td align=\"left\">BigDecimal</td>\n</tr>\n<tr>\n<td align=\"left\">DATE</td>\n<td align=\"left\">java.sql.Date, LocalDate</td>\n</tr>\n<tr>\n<td align=\"left\">TIME</td>\n<td align=\"left\">java.sql.Time, LocalTime</td>\n</tr>\n</tbody></table>\n<p>注意：只有最新的JDBC驱动才支持<code>LocalDate</code>和<code>LocalTime</code>。</p>\n<h1 id=\"JDBC更新\"><a href=\"#JDBC更新\" class=\"headerlink\" title=\"JDBC更新\"></a>JDBC更新</h1><p>数据库操作总结起来就四个字：增删改查，行话叫CRUD：Create，Retrieve，Update和Delete。</p>\n<p>查就是查询，我们已经讲过了，就是使用<code>PreparedStatement</code>进行各种<code>SELECT</code>，然后处理结果集。现在我们来看看如何使用JDBC进行增删改。</p>\n<h3 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h3><p>插入操作是<code>INSERT</code>，即插入一条新记录。通过JDBC进行插入，本质上也是用<code>PreparedStatement</code>执行一条SQL语句，不过最后执行的不是<code>executeQuery()</code>，而是<code>executeUpdate()</code>。示例代码如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class=\"line\">    try (PreparedStatement ps = conn.prepareStatement(</span><br><span class=\"line\">            <span class=\"string\">&quot;INSERT INTO students (id, grade, name, gender) VALUES (?,?,?,?)&quot;</span>)) &#123;</span><br><span class=\"line\">        ps.setObject(<span class=\"number\">1</span>, <span class=\"number\">999</span>); <span class=\"regexp\">//</span> 注意：索引从<span class=\"number\">1</span>开始</span><br><span class=\"line\">        ps.setObject(<span class=\"number\">2</span>, <span class=\"number\">1</span>); <span class=\"regexp\">//</span> grade</span><br><span class=\"line\">        ps.setObject(<span class=\"number\">3</span>, <span class=\"string\">&quot;Bob&quot;</span>); <span class=\"regexp\">//</span> name</span><br><span class=\"line\">        ps.setObject(<span class=\"number\">4</span>, <span class=\"string\">&quot;M&quot;</span>); <span class=\"regexp\">//</span> gender</span><br><span class=\"line\">        int n = ps.executeUpdate(); <span class=\"regexp\">//</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设置参数与查询是一样的，有几个<code>?</code>占位符就必须设置对应的参数。虽然<code>Statement</code>也可以执行插入操作，但我们仍然要严格遵循<em>绝不能手动拼SQL字符串</em>的原则，以避免安全漏洞。</p>\n<p>当成功执行<code>executeUpdate()</code>后，返回值是<code>int</code>，表示插入的记录数量。此处总是<code>1</code>，因为只插入了一条记录。</p>\n<h3 id=\"插入并获取主键\"><a href=\"#插入并获取主键\" class=\"headerlink\" title=\"插入并获取主键\"></a>插入并获取主键</h3><p>如果数据库的表设置了自增主键，那么在执行<code>INSERT</code>语句时，并不需要指定主键，数据库会自动分配主键。对于使用自增主键的程序，有个额外的步骤，就是如何获取插入后的自增主键的值。</p>\n<p>要获取自增主键，不能先插入，再查询。因为两条SQL执行期间可能有别的程序也插入了同一个表。获取自增主键的正确写法是在创建<code>PreparedStatement</code>的时候，指定一个<code>RETURN_GENERATED_KEYS</code>标志位，表示JDBC驱动必须返回插入的自增主键。示例代码如下：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\">try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class=\"line\">    try (PreparedStatement ps = conn.prepareStatement(</span><br><span class=\"line\">            <span class=\"string\">&quot;INSERT INTO students (grade, name, gender) VALUES (?,?,?)&quot;</span>,</span><br><span class=\"line\">            Statement.RETURN_GENERATED_KEYS)) &#123;</span><br><span class=\"line\">        ps.setObject(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"regexp\">//</span> grade</span><br><span class=\"line\">        ps.setObject(<span class=\"number\">2</span>, <span class=\"string\">&quot;Bob&quot;</span>); <span class=\"regexp\">//</span> name</span><br><span class=\"line\">        ps.setObject(<span class=\"number\">3</span>, <span class=\"string\">&quot;M&quot;</span>); <span class=\"regexp\">//</span> gender</span><br><span class=\"line\">        int n = ps.executeUpdate(); <span class=\"regexp\">//</span> <span class=\"number\">1</span></span><br><span class=\"line\">        try (ResultSet rs = ps.getGeneratedKeys()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rs.<span class=\"keyword\">next</span>()) &#123;</span><br><span class=\"line\">                long id = rs.getLong(<span class=\"number\">1</span>); <span class=\"regexp\">//</span> 注意：索引从<span class=\"number\">1</span>开始</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>观察上述代码，有两点注意事项：</p>\n<p>一是调用<code>prepareStatement()</code>时，第二个参数必须传入常量<code>Statement.RETURN_GENERATED_KEYS</code>，否则JDBC驱动不会返回自增主键；</p>\n<p>二是执行<code>executeUpdate()</code>方法后，必须调用<code>getGeneratedKeys()</code>获取一个<code>ResultSet</code>对象，这个对象包含了数据库自动生成的主键的值，读取该对象的每一行来获取自增主键的值。如果一次插入多条记录，那么这个<code>ResultSet</code>对象就会有多行返回值。如果插入时有多列自增，那么<code>ResultSet</code>对象的每一行都会对应多个自增值（自增列不一定必须是主键）。</p>\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><p>更新操作是<code>UPDATE</code>语句，它可以一次更新若干列的记录。更新操作和插入操作在JDBC代码的层面上实际上没有区别，除了SQL语句不同：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DriverManager</span>.</span></span>get<span class=\"constructor\">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (PreparedStatement ps = conn.prepare<span class=\"constructor\">Statement(<span class=\"string\">&quot;UPDATE students SET name=? WHERE id=?&quot;</span>)</span>) &#123;</span><br><span class=\"line\">        ps.set<span class=\"constructor\">Object(1, <span class=\"string\">&quot;Bob&quot;</span>)</span>; <span class=\"comment\">// 注意：索引从1开始</span></span><br><span class=\"line\">        ps.set<span class=\"constructor\">Object(2, 999)</span>;</span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = ps.execute<span class=\"constructor\">Update()</span>; <span class=\"comment\">// 返回更新的行数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>executeUpdate()</code>返回数据库实际更新的行数。返回结果可能是正数，也可能是0（表示没有任何记录更新）。</p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>删除操作是<code>DELETE</code>语句，它可以一次删除若干列。和更新一样，除了SQL语句不同外，JDBC代码都是相同的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DriverManager</span>.</span></span>get<span class=\"constructor\">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (PreparedStatement ps = conn.prepare<span class=\"constructor\">Statement(<span class=\"string\">&quot;DELETE FROM students WHERE id=?&quot;</span>)</span>) &#123;</span><br><span class=\"line\">        ps.set<span class=\"constructor\">Object(1, 999)</span>; <span class=\"comment\">// 注意：索引从1开始</span></span><br><span class=\"line\">        <span class=\"built_in\">int</span> n = ps.execute<span class=\"constructor\">Update()</span>; <span class=\"comment\">// 删除的行数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"JDBC事务\"><a href=\"#JDBC事务\" class=\"headerlink\" title=\"JDBC事务\"></a>JDBC事务</h1><p>数据库事务（Transaction）是由若干个SQL语句构成的一个操作序列，有点类似于Java的<code>synchronized</code>同步。数据库系统保证在一个事务中的所有SQL要么全部执行成功，要么全部不执行，即数据库事务具有ACID特性：</p>\n<ul>\n<li>Atomicity：原子性</li>\n<li>Consistency：一致性</li>\n<li>Isolation：隔离性</li>\n<li>Durability：持久性</li>\n</ul>\n<p>数据库事务可以并发执行，而数据库系统从效率考虑，对事务定义了不同的隔离级别。SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Isolation Level</th>\n<th align=\"left\">脏读（Dirty Read）</th>\n<th align=\"left\">不可重复读（Non Repeatable Read）</th>\n<th align=\"left\">幻读（Phantom Read）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Read Uncommitted</td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Read Committed</td>\n<td align=\"left\">-</td>\n<td align=\"left\">Yes</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Repeatable Read</td>\n<td align=\"left\">-</td>\n<td align=\"left\">-</td>\n<td align=\"left\">Yes</td>\n</tr>\n<tr>\n<td align=\"left\">Serializable</td>\n<td align=\"left\">-</td>\n<td align=\"left\">-</td>\n<td align=\"left\">-</td>\n</tr>\n</tbody></table>\n<p>对应用程序来说，数据库事务非常重要，很多运行着关键任务的应用程序，都必须依赖数据库事务保证程序的结果正常。</p>\n<p>举个例子：假设小明准备给小红支付100，两人在数据库中的记录主键分别是<code>123</code>和<code>456</code>，那么用两条SQL语句操作如下：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"code\"><pre><span class=\"line\">UPDATE accounts <span class=\"builtin-name\">SET</span> balance = balance - 100 WHERE <span class=\"attribute\">id</span>=123 <span class=\"keyword\">AND</span> balance &gt;= 100;</span><br><span class=\"line\">UPDATE accounts <span class=\"builtin-name\">SET</span> balance = balance + 100 WHERE <span class=\"attribute\">id</span>=456;</span><br></pre></td></tr></table></figure>\n\n<p>这两条语句必须以事务方式执行才能保证业务的正确性，因为一旦第一条SQL执行成功而第二条SQL失败的话，系统的钱就会凭空减少100，而有了事务，要么这笔转账成功，要么转账失败，双方账户的钱都不变。</p>\n<p>这里我们不讨论详细的SQL事务，如果对SQL事务不熟悉，请参考<a href=\"https://www.liaoxuefeng.com/wiki/1177760294764384/1179611198786848\">SQL事务</a>。</p>\n<p>要在JDBC中执行事务，本质上就是如何把多条SQL包裹在一个数据库事务中执行。我们来看JDBC的事务代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Connection conn = <span class=\"keyword\">open</span><span class=\"constructor\">Connection()</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 关闭自动提交:</span></span><br><span class=\"line\">    conn.set<span class=\"constructor\">AutoCommit(<span class=\"params\">false</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 执行多条SQL语句:</span></span><br><span class=\"line\">    insert<span class=\"literal\">()</span>; update<span class=\"literal\">()</span>; delete<span class=\"literal\">()</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 提交事务:</span></span><br><span class=\"line\">    conn.commit<span class=\"literal\">()</span>;</span><br><span class=\"line\">&#125; catch (SQLException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 回滚事务:</span></span><br><span class=\"line\">    conn.rollback<span class=\"literal\">()</span>;</span><br><span class=\"line\">&#125; finally &#123;</span><br><span class=\"line\">    conn.set<span class=\"constructor\">AutoCommit(<span class=\"params\">true</span>)</span>;</span><br><span class=\"line\">    conn.close<span class=\"literal\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中，开启事务的关键代码是<code>conn.setAutoCommit(false)</code>，表示关闭自动提交。提交事务的代码在执行完指定的若干条SQL语句后，调用<code>conn.commit()</code>。要注意事务不是总能成功，如果事务提交失败，会抛出SQL异常（也可能在执行SQL语句的时候就抛出了），此时我们必须捕获并调用<code>conn.rollback()</code>回滚事务。最后，在<code>finally</code>中通过<code>conn.setAutoCommit(true)</code>把<code>Connection</code>对象的状态恢复到初始值。</p>\n<p>实际上，默认情况下，我们获取到<code>Connection</code>连接后，总是处于“自动提交”模式，也就是每执行一条SQL都是作为事务自动执行的，这也是为什么前面几节我们的更新操作总能成功的原因：因为默认有这种“隐式事务”。只要关闭了<code>Connection</code>的<code>autoCommit</code>，那么就可以在一个事务中执行多条语句，事务以<code>commit()</code>方法结束。</p>\n<p>如果要设定事务的隔离级别，可以使用如下代码：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 设定隔离级别为READ COMMITTED:</span><br><span class=\"line\">conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br></pre></td></tr></table></figure>\n\n<p>如果没有调用上述方法，那么会使用数据库的默认隔离级别。MySQL的默认隔离级别是<code>REPEATABLE READ</code>。</p>\n<h1 id=\"JDBC-Batch\"><a href=\"#JDBC-Batch\" class=\"headerlink\" title=\"JDBC Batch\"></a>JDBC Batch</h1><p>使用JDBC操作数据库的时候，经常会执行一些批量操作。</p>\n<p>例如，一次性给会员增加可用优惠券若干，我们可以执行以下SQL代码：</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> coupons (user_id, <span class=\"built_in\">type</span>, expires) <span class=\"keyword\">VALUES</span> (<span class=\"number\">123</span>, <span class=\"string\">&#x27;DISCOUNT&#x27;</span>, <span class=\"string\">&#x27;2030-12-31&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> coupons (user_id, <span class=\"built_in\">type</span>, expires) <span class=\"keyword\">VALUES</span> (<span class=\"number\">234</span>, <span class=\"string\">&#x27;DISCOUNT&#x27;</span>, <span class=\"string\">&#x27;2030-12-31&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> coupons (user_id, <span class=\"built_in\">type</span>, expires) <span class=\"keyword\">VALUES</span> (<span class=\"number\">345</span>, <span class=\"string\">&#x27;DISCOUNT&#x27;</span>, <span class=\"string\">&#x27;2030-12-31&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> coupons (user_id, <span class=\"built_in\">type</span>, expires) <span class=\"keyword\">VALUES</span> (<span class=\"number\">456</span>, <span class=\"string\">&#x27;DISCOUNT&#x27;</span>, <span class=\"string\">&#x27;2030-12-31&#x27;</span>);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>实际上执行JDBC时，因为只有占位符参数不同，所以SQL实际上是一样的：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (var params : paramsList) &#123;</span><br><span class=\"line\">    PreparedStatement ps = conn.prepared<span class=\"constructor\">Statement(<span class=\"string\">&quot;INSERT INTO coupons (user_id, type, expires) VALUES (?,?,?)&quot;</span>)</span>;</span><br><span class=\"line\">    ps.set<span class=\"constructor\">Long(<span class=\"params\">params</span>.<span class=\"params\">get</span>(0)</span>);</span><br><span class=\"line\">    ps.set<span class=\"constructor\">String(<span class=\"params\">params</span>.<span class=\"params\">get</span>(1)</span>);</span><br><span class=\"line\">    ps.set<span class=\"constructor\">String(<span class=\"params\">params</span>.<span class=\"params\">get</span>(2)</span>);</span><br><span class=\"line\">    ps.execute<span class=\"constructor\">Update()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似的还有，给每个员工薪水增加10%～30%：</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> employees <span class=\"keyword\">SET</span> salary = salary * ? <span class=\"keyword\">WHERE</span> id = ?</span><br></pre></td></tr></table></figure>\n\n<p>通过一个循环来执行每个<code>PreparedStatement</code>虽然可行，但是性能很低。SQL数据库对SQL语句相同，但只有参数不同的若干语句可以作为batch执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个SQL。</p>\n<p>在JDBC代码中，我们可以利用SQL数据库的这一特性，把同一个SQL但参数不同的若干次操作合并为一个batch执行。我们以批量插入为例，示例代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (PreparedStatement ps = conn.prepare<span class=\"constructor\">Statement(<span class=\"string\">&quot;INSERT INTO students (name, gender, grade, score) VALUES (?, ?, ?, ?)&quot;</span>)</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 对同一个PreparedStatement反复设置参数并调用addBatch():</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Student s : students) &#123;</span><br><span class=\"line\">        ps.set<span class=\"constructor\">String(1, <span class=\"params\">s</span>.<span class=\"params\">name</span>)</span>;</span><br><span class=\"line\">        ps.set<span class=\"constructor\">Boolean(2, <span class=\"params\">s</span>.<span class=\"params\">gender</span>)</span>;</span><br><span class=\"line\">        ps.set<span class=\"constructor\">Int(3, <span class=\"params\">s</span>.<span class=\"params\">grade</span>)</span>;</span><br><span class=\"line\">        ps.set<span class=\"constructor\">Int(4, <span class=\"params\">s</span>.<span class=\"params\">score</span>)</span>;</span><br><span class=\"line\">        ps.add<span class=\"constructor\">Batch()</span>; <span class=\"comment\">// 添加到batch</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 执行batch:</span></span><br><span class=\"line\">    <span class=\"built_in\">int</span><span class=\"literal\">[]</span> ns = ps.execute<span class=\"constructor\">Batch()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"built_in\">int</span> n : ns) &#123;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(n + <span class=\"string\">&quot; inserted.&quot;</span>); <span class=\"comment\">// batch中每个SQL执行的结果数量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行batch和执行一个SQL不同点在于，需要对同一个<code>PreparedStatement</code>反复设置参数并调用<code>addBatch()</code>，这样就相当于给一个SQL加上了多组参数，相当于变成了“多行”SQL。</p>\n<p>第二个不同点是调用的不是<code>executeUpdate()</code>，而是<code>executeBatch()</code>，因为我们设置了多组参数，相应地，返回结果也是多个<code>int</code>值，因此返回类型是<code>int[]</code>，循环<code>int[]</code>数组即可获取每组参数执行后影响的结果数量。</p>\n<h1 id=\"JDBC连接池\"><a href=\"#JDBC连接池\" class=\"headerlink\" title=\"JDBC连接池\"></a>JDBC连接池</h1><p>我们在讲多线程的时候说过，创建线程是一个昂贵的操作，如果有大量的小任务需要执行，并且频繁地创建和销毁线程，实际上会消耗大量的系统资源，往往创建和消耗线程所耗费的时间比执行任务的时间还长，所以，为了提高效率，可以用线程池。</p>\n<p>类似的，在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。</p>\n<p>JDBC连接池有一个标准的接口<code>javax.sql.DataSource</code>，注意这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，我们必须选择一个JDBC连接池的实现。常用的JDBC连接池有：</p>\n<ul>\n<li>HikariCP</li>\n<li>C3P0</li>\n<li>BoneCP</li>\n<li>Druid</li>\n</ul>\n<p>目前使用最广泛的是HikariCP。我们以HikariCP为例，要使用JDBC连接池，先添加HikariCP的依赖如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.zaxxer<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>HikariCP<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>紧接着，我们需要创建一个<code>DataSource</code>实例，这个实例就是连接池：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">HikariConfig config = <span class=\"keyword\">new</span> <span class=\"constructor\">HikariConfig()</span>;</span><br><span class=\"line\">config.set<span class=\"constructor\">JdbcUrl(<span class=\"string\">&quot;jdbc:mysql://localhost:3306/test&quot;</span>)</span>;</span><br><span class=\"line\">config.set<span class=\"constructor\">Username(<span class=\"string\">&quot;root&quot;</span>)</span>;</span><br><span class=\"line\">config.set<span class=\"constructor\">Password(<span class=\"string\">&quot;password&quot;</span>)</span>;</span><br><span class=\"line\">config.add<span class=\"constructor\">DataSourceProperty(<span class=\"string\">&quot;connectionTimeout&quot;</span>, <span class=\"string\">&quot;1000&quot;</span>)</span>; <span class=\"comment\">// 连接超时：1秒</span></span><br><span class=\"line\">config.add<span class=\"constructor\">DataSourceProperty(<span class=\"string\">&quot;idleTimeout&quot;</span>, <span class=\"string\">&quot;60000&quot;</span>)</span>; <span class=\"comment\">// 空闲超时：60秒</span></span><br><span class=\"line\">config.add<span class=\"constructor\">DataSourceProperty(<span class=\"string\">&quot;maximumPoolSize&quot;</span>, <span class=\"string\">&quot;10&quot;</span>)</span>; <span class=\"comment\">// 最大连接数：10</span></span><br><span class=\"line\">DataSource ds = <span class=\"keyword\">new</span> <span class=\"constructor\">HikariDataSource(<span class=\"params\">config</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>注意创建<code>DataSource</code>也是一个非常昂贵的操作，所以通常<code>DataSource</code>实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期。</p>\n<p>有了连接池以后，我们如何使用它呢？和前面的代码类似，只是获取<code>Connection</code>时，把<code>DriverManage.getConnection()</code>改为<code>ds.getConnection()</code>：</p>\n<figure class=\"highlight jboss-cli\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> <span class=\"params\">(Connection <span class=\"attr\">conn</span> = ds.getConnection()</span>) &#123; <span class=\"string\">//</span> 在此获取连接</span><br><span class=\"line\">    <span class=\"string\">...</span></span><br><span class=\"line\">&#125; <span class=\"string\">//</span> 在此“关闭”连接</span><br></pre></td></tr></table></figure>\n\n<p>通过连接池获取连接时，并不需要指定JDBC的相关URL、用户名、口令等信息，因为这些信息已经存储在连接池内部了（创建<code>HikariDataSource</code>时传入的<code>HikariConfig</code>持有这些信息）。一开始，连接池内部并没有连接，所以，第一次调用<code>ds.getConnection()</code>，会迫使连接池内部先创建一个<code>Connection</code>，再返回给客户端使用。当我们调用<code>conn.close()</code>方法时（<code>在try(resource)&#123;...&#125;</code>结束处），不是真正“关闭”连接，而是释放到连接池中，以便下次获取连接时能直接返回。</p>\n<p>因此，连接池内部维护了若干个<code>Connection</code>实例，如果调用<code>ds.getConnection()</code>，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对<code>Connection</code>调用<code>close()</code>，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，我们就通过连接池维护了少量连接，但可以频繁地执行大量的SQL语句。</p>\n<p>通常连接池提供了大量的参数可以配置，例如，维护的最小、最大活动连接数，指定一个连接在空闲一段时间后自动关闭等，需要根据应用程序的负载合理地配置这些参数。此外，大多数连接池都提供了详细的实时状态以便进行监控。</p>\n","categories":["Java","5.JavaEE进阶","4.JDBC编程"],"tags":["写作"]},{"title":"7.中间件","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_7.%E4%B8%AD%E9%97%B4%E4%BB%B6/","content":"<h1 id=\"Redis-缓存\"><a href=\"#Redis-缓存\" class=\"headerlink\" title=\"Redis 缓存\"></a>Redis 缓存</h1><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h2 id=\"常用操作\"><a href=\"#常用操作\" class=\"headerlink\" title=\"常用操作\"></a>常用操作</h2><h2 id=\"Java-操作-Redis\"><a href=\"#Java-操作-Redis\" class=\"headerlink\" title=\"Java 操作 Redis\"></a>Java 操作 Redis</h2><h2 id=\"主从模型搭建\"><a href=\"#主从模型搭建\" class=\"headerlink\" title=\"主从模型搭建\"></a>主从模型搭建</h2><h2 id=\"哨兵集群搭建\"><a href=\"#哨兵集群搭建\" class=\"headerlink\" title=\"哨兵集群搭建\"></a>哨兵集群搭建</h2><h2 id=\"日志持久化\"><a href=\"#日志持久化\" class=\"headerlink\" title=\"日志持久化\"></a>日志持久化</h2><h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><h1 id=\"RabbitMQ-消息队列\"><a href=\"#RabbitMQ-消息队列\" class=\"headerlink\" title=\"RabbitMQ 消息队列\"></a>RabbitMQ 消息队列</h1><h2 id=\"消息队列的作用\"><a href=\"#消息队列的作用\" class=\"headerlink\" title=\"消息队列的作用\"></a>消息队列的作用</h2><h2 id=\"生产消费模型\"><a href=\"#生产消费模型\" class=\"headerlink\" title=\"生产消费模型\"></a>生产消费模型</h2><h2 id=\"交换机模型\"><a href=\"#交换机模型\" class=\"headerlink\" title=\"交换机模型\"></a>交换机模型</h2><h2 id=\"死信队列\"><a href=\"#死信队列\" class=\"headerlink\" title=\"死信队列\"></a>死信队列</h2><h2 id=\"延迟队列\"><a href=\"#延迟队列\" class=\"headerlink\" title=\"延迟队列\"></a>延迟队列</h2><h2 id=\"消息持久化\"><a href=\"#消息持久化\" class=\"headerlink\" title=\"消息持久化\"></a>消息持久化</h2><h2 id=\"Java-操作\"><a href=\"#Java-操作\" class=\"headerlink\" title=\"Java 操作\"></a>Java 操作</h2><h2 id=\"集群搭建\"><a href=\"#集群搭建\" class=\"headerlink\" title=\"集群搭建\"></a>集群搭建</h2><h1 id=\"Nginx-网关\"><a href=\"#Nginx-网关\" class=\"headerlink\" title=\"Nginx 网关\"></a>Nginx 网关</h1><h2 id=\"Nginx-作用\"><a href=\"#Nginx-作用\" class=\"headerlink\" title=\"Nginx 作用\"></a>Nginx 作用</h2><h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><h2 id=\"反向代理（负载均衡）\"><a href=\"#反向代理（负载均衡）\" class=\"headerlink\" title=\"反向代理（负载均衡）\"></a>反向代理（负载均衡）</h2><h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><h2 id=\"动静分离（网站部署）\"><a href=\"#动静分离（网站部署）\" class=\"headerlink\" title=\"动静分离（网站部署）\"></a>动静分离（网站部署）</h2><h2 id=\"集群搭建-1\"><a href=\"#集群搭建-1\" class=\"headerlink\" title=\"集群搭建\"></a>集群搭建</h2>","categories":["Java","5.JavaEE进阶","7.中间件"],"tags":["写作"]},{"title":"8.容器","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_8.%E5%AE%B9%E5%99%A8/","content":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"容器概念\"><a href=\"#容器概念\" class=\"headerlink\" title=\"容器概念\"></a>容器概念</h2><h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><h2 id=\"部署服务\"><a href=\"#部署服务\" class=\"headerlink\" title=\"部署服务\"></a>部署服务</h2><h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><h1 id=\"K8S（Kubernetes）\"><a href=\"#K8S（Kubernetes）\" class=\"headerlink\" title=\"K8S（Kubernetes）\"></a>K8S（Kubernetes）</h1><h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><h2 id=\"部署应用\"><a href=\"#部署应用\" class=\"headerlink\" title=\"部署应用\"></a>部署应用</h2><h2 id=\"暴露服务\"><a href=\"#暴露服务\" class=\"headerlink\" title=\"暴露服务\"></a>暴露服务</h2><h2 id=\"动态扩缩容器\"><a href=\"#动态扩缩容器\" class=\"headerlink\" title=\"动态扩缩容器\"></a>动态扩缩容器</h2><h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","categories":["Java","5.JavaEE进阶","8.容器"],"tags":["写作"]},{"title":"9.CI、CD","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_9.CI%E3%80%81CD/","content":"<h1 id=\"什么是CI-x2F-CD\"><a href=\"#什么是CI-x2F-CD\" class=\"headerlink\" title=\"什么是CI&#x2F;CD\"></a>什么是CI&#x2F;CD</h1><h1 id=\"CI-x2F-CD有什么好处\"><a href=\"#CI-x2F-CD有什么好处\" class=\"headerlink\" title=\"CI&#x2F;CD有什么好处\"></a>CI&#x2F;CD有什么好处</h1><h1 id=\"使用任一CI-x2F-CD平台\"><a href=\"#使用任一CI-x2F-CD平台\" class=\"headerlink\" title=\"使用任一CI&#x2F;CD平台\"></a>使用任一CI&#x2F;CD平台</h1>","categories":["Java","5.JavaEE进阶","9.CI、CD"],"tags":["写作"]},{"title":"1.Dubbo","url":"/2022/02/04/4-Java_6.%E5%BE%AE%E6%9C%8D%E5%8A%A1_1.Dubbo/","content":"<h1 id=\"架构演进\"><a href=\"#架构演进\" class=\"headerlink\" title=\"架构演进\"></a>架构演进</h1><h1 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h1><h1 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h1><h1 id=\"服务提供者\"><a href=\"#服务提供者\" class=\"headerlink\" title=\"服务提供者\"></a>服务提供者</h1><h1 id=\"服务消费者\"><a href=\"#服务消费者\" class=\"headerlink\" title=\"服务消费者\"></a>服务消费者</h1><h1 id=\"项目搭建\"><a href=\"#项目搭建\" class=\"headerlink\" title=\"项目搭建\"></a>项目搭建</h1>","categories":["Java","6.微服务","1.Dubbo"],"tags":["写作"]},{"title":"2.微服务","url":"/2022/02/04/4-Java_6.%E5%BE%AE%E6%9C%8D%E5%8A%A1_2.%E5%BE%AE%E6%9C%8D%E5%8A%A1/","content":"<h1 id=\"微服务概念\"><a href=\"#微服务概念\" class=\"headerlink\" title=\"微服务概念\"></a>微服务概念</h1><h1 id=\"Spring-Cloud-框架\"><a href=\"#Spring-Cloud-框架\" class=\"headerlink\" title=\"Spring Cloud 框架\"></a>Spring Cloud 框架</h1><h2 id=\"子父工程\"><a href=\"#子父工程\" class=\"headerlink\" title=\"子父工程\"></a>子父工程</h2><h2 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h2><h2 id=\"注册中心-Eureka、Zookeeper、Consul\"><a href=\"#注册中心-Eureka、Zookeeper、Consul\" class=\"headerlink\" title=\"注册中心 Eureka、Zookeeper、Consul\"></a>注册中心 Eureka、Zookeeper、Consul</h2><h2 id=\"Ribbon-负载均衡\"><a href=\"#Ribbon-负载均衡\" class=\"headerlink\" title=\"Ribbon 负载均衡\"></a>Ribbon 负载均衡</h2><h2 id=\"Feign-服务调用\"><a href=\"#Feign-服务调用\" class=\"headerlink\" title=\"Feign 服务调用\"></a>Feign 服务调用</h2><h2 id=\"Hystrix-服务限流、降级、熔断\"><a href=\"#Hystrix-服务限流、降级、熔断\" class=\"headerlink\" title=\"Hystrix 服务限流、降级、熔断\"></a>Hystrix 服务限流、降级、熔断</h2><h2 id=\"Resilience4j-服务容错\"><a href=\"#Resilience4j-服务容错\" class=\"headerlink\" title=\"Resilience4j 服务容错\"></a>Resilience4j 服务容错</h2><h2 id=\"Gateway（Zuul）微服务网关\"><a href=\"#Gateway（Zuul）微服务网关\" class=\"headerlink\" title=\"Gateway（Zuul）微服务网关\"></a>Gateway（Zuul）微服务网关</h2><h2 id=\"Config-分布式配置中心\"><a href=\"#Config-分布式配置中心\" class=\"headerlink\" title=\"Config 分布式配置中心\"></a>Config 分布式配置中心</h2><h2 id=\"分布式服务总线\"><a href=\"#分布式服务总线\" class=\"headerlink\" title=\"分布式服务总线\"></a>分布式服务总线</h2><h2 id=\"分布式链路追踪\"><a href=\"#分布式链路追踪\" class=\"headerlink\" title=\"分布式链路追踪\"></a>分布式链路追踪</h2><h1 id=\"Spring-Cloud-Alibaba\"><a href=\"#Spring-Cloud-Alibaba\" class=\"headerlink\" title=\"Spring Cloud Alibaba\"></a>Spring Cloud Alibaba</h1><h2 id=\"Nacos-注册、配置中心\"><a href=\"#Nacos-注册、配置中心\" class=\"headerlink\" title=\"Nacos 注册、配置中心\"></a>Nacos 注册、配置中心</h2><h2 id=\"OpenFeign-服务调用\"><a href=\"#OpenFeign-服务调用\" class=\"headerlink\" title=\"OpenFeign 服务调用\"></a>OpenFeign 服务调用</h2><h2 id=\"Sentinel-流控\"><a href=\"#Sentinel-流控\" class=\"headerlink\" title=\"Sentinel 流控\"></a>Sentinel 流控</h2><h2 id=\"Seata-分布式事务\"><a href=\"#Seata-分布式事务\" class=\"headerlink\" title=\"Seata 分布式事务\"></a>Seata 分布式事务</h2>","categories":["Java","6.微服务","2.微服务"],"tags":["写作"]},{"title":"6.设计模式","url":"/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p>\n<p>设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本<a href=\"https://en.wikipedia.org/wiki/Design_Patterns\">Design Patterns</a>的书。这四人也被称为四人帮（GoF）。</p>\n<p>为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：</p>\n<h3 id=\"开闭原则\"><a href=\"#开闭原则\" class=\"headerlink\" title=\"开闭原则\"></a>开闭原则</h3><p>由Bertrand Meyer提出的开闭原则（Open Closed Principle）是指，软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p>\n<h3 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h3><p>里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p>\n<p>设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为创建型模式、结构型模式和行为型模式三类，我们后续会一一讲解。</p>\n<p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性，并意识到设计模式也并不是万能的。</p>\n<p><img src=\"/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l.jpeg\" alt=\"designpatterns\"></p>\n<h1 id=\"创建型模式\"><a href=\"#创建型模式\" class=\"headerlink\" title=\"创建型模式\"></a>创建型模式</h1><p>对象实例化的模式，创建型模式用于解耦对象的实例化过程</p>\n<p>创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>\n<p>创建型模式包括：</p>\n<ul>\n<li>工厂方法：Factory Method</li>\n<li>抽象工厂：Abstract Factory</li>\n<li>建造者：Builder</li>\n<li>原型：Prototype</li>\n<li>单例：Singleton</li>\n</ul>\n<h2 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h2><blockquote>\n<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>\n</blockquote>\n<p>工厂方法即Factory Method，是一种对象创建型模式。</p>\n<p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────┐      ┌─────────────┐</span><br><span class=\"line\">│   Product   │      │   Factory   │</span><br><span class=\"line\">└─────────────┘      └─────────────┘</span><br><span class=\"line\">       ▲                    ▲</span><br><span class=\"line\">       │                    │</span><br><span class=\"line\">┌─────────────┐      ┌─────────────┐</span><br><span class=\"line\">│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │</span><br><span class=\"line\">└─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>我们以具体的例子来说：假设我们希望实现一个解析字符串到<code>Number</code>的<code>Factory</code>，可以定义如下：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">NumberFactory</span> </span>&#123;</span><br><span class=\"line\">    Number parse(<span class=\"keyword\">String</span> s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了工厂接口，再编写一个工厂的实现类：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumberFactoryImpl</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">NumberFactory</span></span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Number parse(<span class=\"keyword\">String</span> s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">BigDecimal</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而产品接口是<code>Number</code>，<code>NumberFactoryImpl</code>返回的实际产品是<code>BigDecimal</code>。</p>\n<p>那么客户端如何创建<code>NumberFactoryImpl</code>呢？通常我们会在接口<code>Factory</code>中定义一个静态方法<code>getFactory()</code>来返回真正的子类：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> NumberFactory &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建方法:</span></span><br><span class=\"line\">    <span class=\"built_in\">Number</span> parse(<span class=\"built_in\">String</span> s);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取工厂实例:</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> NumberFactory <span class=\"function\"><span class=\"title\">getFactory</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> impl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> NumberFactory impl = <span class=\"keyword\">new</span> NumberFactoryImpl();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在客户端中，我们只需要和工厂接口<code>NumberFactory</code>以及抽象产品<code>Number</code>打交道：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">NumberFactory factory = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">NumberFactory</span>.</span></span>get<span class=\"constructor\">Factory()</span>;</span><br><span class=\"line\">Number result = factory.parse(<span class=\"string\">&quot;123.456&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>调用方可以完全忽略真正的工厂<code>NumberFactoryImpl</code>和实际的产品<code>BigDecimal</code>，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。</p>\n<p>有的童鞋会问：一个简单的<code>parse()</code>需要写这么复杂的工厂吗？实际上大多数情况下我们并不需要抽象工厂，而是通过静态方法直接返回产品，即：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NumberFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"built_in\">Number</span> <span class=\"function\"><span class=\"title\">parse</span>(<span class=\"params\"><span class=\"built_in\">String</span> s</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> BigDecimal(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。例如：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Integer n = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Integer</span>.</span></span>value<span class=\"constructor\">Of(100)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>Integer</code>既是产品又是静态工厂。它提供了静态方法<code>valueOf()</code>来创建<code>Integer</code>。那么这种方式和直接写<code>new Integer(100)</code>有何区别呢？我们观察<code>valueOf()</code>方法：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public final <span class=\"keyword\">class</span> Integer &#123;</span><br><span class=\"line\">    public static Integer value<span class=\"constructor\">Of(<span class=\"params\">int</span> <span class=\"params\">i</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &gt;= <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">IntegerCache</span>.</span></span>low<span class=\"operator\"> &amp;&amp; </span>i &lt;= <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">IntegerCache</span>.</span></span>high)</span><br><span class=\"line\">            return <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">IntegerCache</span>.</span></span>cache<span class=\"literal\">[<span class=\"identifier\">i</span> + (-I<span class=\"identifier\">ntegerCache</span>.<span class=\"identifier\">low</span>)]</span>;</span><br><span class=\"line\">        return <span class=\"keyword\">new</span> <span class=\"constructor\">Integer(<span class=\"params\">i</span>)</span>;</span><br><span class=\"line\">    &#125;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它的好处在于，<code>valueOf()</code>内部可能会使用<code>new</code>创建一个新的<code>Integer</code>实例，但也可能直接返回一个缓存的<code>Integer</code>实例。对于调用方来说，没必要知道<code>Integer</code>创建的细节。</p>\n<p> 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p>\n<p>如果调用方直接使用<code>Integer n = new Integer(100)</code>，那么就失去了使用缓存优化的可能性。</p>\n<p>我们经常使用的另一个静态工厂方法是<code>List.of()</code>：</p>\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span><span class=\"operator\">&lt;</span><span class=\"built_in\">String</span><span class=\"operator\">&gt;</span> <span class=\"variable\">list</span> <span class=\"operator\">=</span> <span class=\"built_in\">List</span><span class=\"operator\">.</span><span class=\"variable\">of</span><span class=\"punctuation\">(</span><span class=\"string\">&quot;A&quot;</span><span class=\"operator\">,</span> <span class=\"string\">&quot;B&quot;</span><span class=\"operator\">,</span> <span class=\"string\">&quot;C&quot;</span><span class=\"punctuation\">)</span><span class=\"operator\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个静态工厂方法接收可变参数，然后返回<code>List</code>接口。需要注意的是，调用方获取的产品总是<code>List</code>接口，而且并不关心它的实际类型。即使调用方知道<code>List</code>产品的实际类型是<code>java.util.ImmutableCollections$ListN</code>，也不要去强制转型为子类，因为静态工厂方法<code>List.of()</code>保证返回<code>List</code>，但也完全可以修改为返回<code>java.util.ArrayList</code>。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。</p>\n<p> 总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。</p>\n<p>和<code>List.of()</code>类似，我们使用<code>MessageDigest</code>时，为了创建某个摘要算法，总是使用静态工厂方法<code>getInstance(String)</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">MessageDigest md5 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">MessageDigest</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;MD5&quot;</span>)</span>;</span><br><span class=\"line\">MessageDigest sha1 = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">MessageDigest</span>.</span></span>get<span class=\"constructor\">Instance(<span class=\"string\">&quot;SHA-1&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是<code>MessageDigest</code>这个抽象类。</p>\n<h2 id=\"抽象工厂\"><a href=\"#抽象工厂\" class=\"headerlink\" title=\"抽象工厂\"></a>抽象工厂</h2><blockquote>\n<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>\n</blockquote>\n<p>抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。</p>\n<p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                                ┌────────┐</span><br><span class=\"line\">                             ─ &gt;│ProductA│</span><br><span class=\"line\">┌────────┐    ┌─────────┐   │   └────────┘</span><br><span class=\"line\">│ Client │─ ─&gt;│ Factory │─ ─</span><br><span class=\"line\">└────────┘    └─────────┘   │   ┌────────┐</span><br><span class=\"line\">                   ▲         ─ &gt;│ProductB│</span><br><span class=\"line\">           ┌───────┴───────┐    └────────┘</span><br><span class=\"line\">           │               │</span><br><span class=\"line\">      ┌─────────┐     ┌─────────┐</span><br><span class=\"line\">      │Factory1 │     │Factory2 │</span><br><span class=\"line\">      └─────────┘     └─────────┘</span><br><span class=\"line\">           │   ┌─────────┐ │   ┌─────────┐</span><br><span class=\"line\">            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│</span><br><span class=\"line\">           │   └─────────┘ │   └─────────┘</span><br><span class=\"line\">               ┌─────────┐     ┌─────────┐</span><br><span class=\"line\">           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│</span><br><span class=\"line\">               └─────────┘     └─────────┘</span><br></pre></td></tr></table></figure>\n\n<p>这种模式有点类似于多个供应商负责提供一系列类型的产品。我们举个例子：</p>\n<p>假设我们希望为用户提供一个<a href=\"https://baike.baidu.com/item/MarkDown\">Markdown</a>文本转换为HTML和Word的服务，它的接口定义如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> interface AbstractFactory &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建Html文档:</span></span><br><span class=\"line\">    <span class=\"function\">HtmlDocument <span class=\"title\">createHtml</span><span class=\"params\">(<span class=\"keyword\">String</span> md)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 创建Word文档:</span></span><br><span class=\"line\">    <span class=\"function\">WordDocument <span class=\"title\">createWord</span><span class=\"params\">(<span class=\"keyword\">String</span> md)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意到上面的抽象工厂仅仅是一个接口，没有任何代码。同样的，因为<code>HtmlDocument</code>和<code>WordDocument</code>都比较复杂，现在我们并不知道如何实现它们，所以只有接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Html文档接口:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">HtmlDocument</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">toHtml</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">(Path path)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Word文档接口:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">WordDocument</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">(Path path)</span> <span class=\"keyword\">throws</span> IOException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就定义好了抽象工厂（<code>AbstractFactory</code>）以及两个抽象产品（<code>HtmlDocument</code>和<code>WordDocument</code>）。因为实现它们比较困难，我们决定让供应商来完成。</p>\n<p>现在市场上有两家供应商：FastDoc Soft的产品便宜，并且转换速度快，而GoodDoc Soft的产品贵，但转换效果好。我们决定同时使用这两家供应商的产品，以便给免费用户和付费用户提供不同的服务。</p>\n<p>我们先看看FastDoc Soft的产品是如何实现的。首先，FastDoc Soft必须要有实际的产品，即<code>FastHtmlDocument</code>和<code>FastWordDocument</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FastHtmlDocument</span> <span class=\"keyword\">implements</span> <span class=\"title\">HtmlDocument</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toHtml</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">(Path path)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FastWordDocument</span> <span class=\"keyword\">implements</span> <span class=\"title\">WordDocument</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">save</span><span class=\"params\">(Path path)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，FastDoc Soft必须提供一个实际的工厂来生产这两种产品，即<code>FastFactory</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FastFactory</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">AbstractFactory</span></span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> HtmlDocument createHtml(<span class=\"keyword\">String</span> md) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">FastHtmlDocument</span>(md);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> WordDocument createWord(<span class=\"keyword\">String</span> md) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">FastWordDocument</span>(md);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就可以使用FastDoc Soft的服务了。客户端编写代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建AbstractFactory，实际类型是FastFactory:</span></span><br><span class=\"line\">AbstractFactory factory = <span class=\"keyword\">new</span> <span class=\"constructor\">FastFactory()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 生成Html文档:</span></span><br><span class=\"line\">HtmlDocument html = factory.create<span class=\"constructor\">Html(<span class=\"string\">&quot;#Hello\\nHello, world!&quot;</span>)</span>;</span><br><span class=\"line\">html.save(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Paths</span>.</span></span>get(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;fast.html&quot;</span>));</span><br><span class=\"line\"><span class=\"comment\">// 生成Word文档:</span></span><br><span class=\"line\">WordDocument word = factory.create<span class=\"constructor\">Word(<span class=\"string\">&quot;#Hello\\nHello, world!&quot;</span>)</span>;</span><br><span class=\"line\">word.save(<span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Paths</span>.</span></span>get(<span class=\"string\">&quot;.&quot;</span>, <span class=\"string\">&quot;fast.doc&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要同时使用GoodDoc Soft的服务怎么办？因为用了抽象工厂模式，GoodDoc Soft只需要根据我们定义的抽象工厂和抽象产品接口，实现自己的实际工厂和实际产品即可：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实际工厂:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GoodFactory</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">AbstractFactory</span></span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> HtmlDocument createHtml(<span class=\"keyword\">String</span> md) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">GoodHtmlDocument</span>(md);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> WordDocument createWord(<span class=\"keyword\">String</span> md) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">GoodWordDocument</span>(md);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际产品:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GoodHtmlDocument</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">HtmlDocument</span></span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GoodWordDocument</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">HtmlDocument</span></span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端要使用GoodDoc Soft的服务，只需要把原来的<code>new FastFactory()</code>切换为<code>new GoodFactory()</code>即可。</p>\n<p>注意到客户端代码除了通过<code>new</code>创建了<code>FastFactory</code>或<code>GoodFactory</code>外，其余代码只引用了产品接口，并未引用任何实际产品（例如，<code>FastHtmlDocument</code>），如果把创建工厂的代码放到<code>AbstractFactory</code>中，就可以连实际工厂也屏蔽了：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">AbstractFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> AbstractFactory createFactory(<span class=\"keyword\">String</span> name) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (name.equalsIgnoreCase(<span class=\"string\">&quot;fast&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">FastFactory</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (name.equalsIgnoreCase(<span class=\"string\">&quot;good&quot;</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">GoodFactory</span>();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">IllegalArgumentException</span>(<span class=\"string\">&quot;Invalid factory name&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们来看看<code>FastFactory</code>和<code>GoodFactory</code>创建的<code>WordDocument</code>的实际效果：</p>\n<p><img src=\"/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189618389718.png\" alt=\"worddoc\"></p>\n<p>注意：出于简化代码的目的，我们只支持两种Markdown语法：以<code>#</code>开头的标题以及普通正文。</p>\n<h2 id=\"生成器-x2F-建造者模式\"><a href=\"#生成器-x2F-建造者模式\" class=\"headerlink\" title=\"生成器&#x2F;建造者模式\"></a>生成器&#x2F;建造者模式</h2><blockquote>\n<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>\n</blockquote>\n<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>\n<p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>\n<p>我们仍然以Markdown转HTML为例，因为直接编写一个完整的转换器比较困难，但如果针对类似下面的一行文本：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"code\"><pre><span class=\"line\"># <span class=\"keyword\">this</span> <span class=\"keyword\">is</span> a heading</span><br></pre></td></tr></table></figure>\n\n<p>转换成HTML就很简单：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">h1</span>&gt;this is <span class=\"selector-tag\">a</span> heading&lt;/<span class=\"selector-tag\">h1</span>&gt;</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：</p>\n<ul>\n<li>如果以<code>#</code>开头，使用<code>HeadingBuilder</code>转换；</li>\n<li>如果以<code>&gt;</code>开头，使用<code>QuoteBuilder</code>转换；</li>\n<li>如果以<code>---</code>开头，使用<code>HrBuilder</code>转换；</li>\n<li>其余使用<code>ParagraphBuilder</code>转换。</li>\n</ul>\n<p>这个<code>HtmlBuilder</code>写出来如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HtmlBuilder</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HeadingBuilder headingBuilder = <span class=\"keyword\">new</span> <span class=\"built_in\">HeadingBuilder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> HrBuilder hrBuilder = <span class=\"keyword\">new</span> <span class=\"built_in\">HrBuilder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ParagraphBuilder paragraphBuilder = <span class=\"keyword\">new</span> <span class=\"built_in\">ParagraphBuilder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">private</span> QuoteBuilder quoteBuilder = <span class=\"keyword\">new</span> <span class=\"built_in\">QuoteBuilder</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">String</span> <span class=\"title\">toHtml</span><span class=\"params\">(<span class=\"keyword\">String</span> markdown)</span> </span>&#123;</span><br><span class=\"line\">        StringBuilder buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">StringBuilder</span>();</span><br><span class=\"line\">        markdown.<span class=\"built_in\">lines</span>().forEach(line -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (line.<span class=\"built_in\">startsWith</span>(<span class=\"string\">&quot;#&quot;</span>)) &#123;</span><br><span class=\"line\">                buffer.<span class=\"built_in\">append</span>(headingBuilder.<span class=\"built_in\">buildHeading</span>(line)).<span class=\"built_in\">append</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (line.<span class=\"built_in\">startsWith</span>(<span class=\"string\">&quot;&gt;&quot;</span>)) &#123;</span><br><span class=\"line\">                buffer.<span class=\"built_in\">append</span>(quoteBuilder.<span class=\"built_in\">buildQuote</span>(line)).<span class=\"built_in\">append</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (line.<span class=\"built_in\">startsWith</span>(<span class=\"string\">&quot;---&quot;</span>)) &#123;</span><br><span class=\"line\">                buffer.<span class=\"built_in\">append</span>(hrBuilder.<span class=\"built_in\">buildHr</span>(line)).<span class=\"built_in\">append</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                buffer.<span class=\"built_in\">append</span>(paragraphBuilder.<span class=\"built_in\">buildParagraph</span>(line)).<span class=\"built_in\">append</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buffer.<span class=\"built_in\">toString</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意观察上述代码，<code>HtmlBuilder</code>并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个<code>XxxBuilder</code>去转换，最后，把所有转换的结果组合起来，返回给客户端。</p>\n<p>这样一来，我们只需要针对每一种类型编写不同的Builder。例如，针对以<code>#</code>开头的行，需要<code>HeadingBuilder</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HeadingBuilder</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">String</span> <span class=\"title\">buildHeading</span><span class=\"params\">(<span class=\"keyword\">String</span> line)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (line.<span class=\"built_in\">charAt</span>(<span class=\"number\">0</span>) == <span class=\"string\">&#x27;#&#x27;</span>) &#123;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">            line = line.<span class=\"built_in\">substring</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">String</span>.format(<span class=\"string\">&quot;&lt;h%d&gt;%s&lt;/h%d&gt;&quot;</span>, n, line.<span class=\"built_in\">strip</span>(), n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 注意：实际解析Markdown是带有状态的，即下一行的语义可能与上一行相关。这里我们简化了语法，把每一行视为可以独立转换。</p>\n<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>\n<p>JavaMail的<code>MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code>MimeMessage</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Multipart multipart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeMultipart()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 添加text:</span></span><br><span class=\"line\">BodyPart textpart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeBodyPart()</span>;</span><br><span class=\"line\">textpart.set<span class=\"constructor\">Content(<span class=\"params\">body</span>, <span class=\"string\">&quot;text/html;charset=utf-8&quot;</span>)</span>;</span><br><span class=\"line\">multipart.add<span class=\"constructor\">BodyPart(<span class=\"params\">textpart</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 添加image:</span></span><br><span class=\"line\">BodyPart imagepart = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeBodyPart()</span>;</span><br><span class=\"line\">imagepart.set<span class=\"constructor\">FileName(<span class=\"params\">fileName</span>)</span>;</span><br><span class=\"line\">imagepart.set<span class=\"constructor\">DataHandler(<span class=\"params\">new</span> DataHandler(<span class=\"params\">new</span> ByteArrayDataSource(<span class=\"params\">input</span>, <span class=\"string\">&quot;application/octet-stream&quot;</span>)</span>));</span><br><span class=\"line\">multipart.add<span class=\"constructor\">BodyPart(<span class=\"params\">imagepart</span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">MimeMessage message = <span class=\"keyword\">new</span> <span class=\"constructor\">MimeMessage(<span class=\"params\">session</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置发送方地址:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">From(<span class=\"params\">new</span> InternetAddress(<span class=\"string\">&quot;me@example.com&quot;</span>)</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置接收方地址:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">Recipient(Message.RecipientType.TO, <span class=\"params\">new</span> InternetAddress(<span class=\"string\">&quot;xiaoming@somewhere.com&quot;</span>)</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置邮件主题:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">Subject(<span class=\"string\">&quot;Hello&quot;</span>, <span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 设置邮件内容为multipart:</span></span><br><span class=\"line\">message.set<span class=\"constructor\">Content(<span class=\"params\">multipart</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常编写这样的代码：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\">StringBuilder builder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">builder.<span class=\"built_in\">append</span>(secure ? <span class=\"string\">&quot;https://&quot;</span> : <span class=\"string\">&quot;http://&quot;</span>)</span><br><span class=\"line\">       .<span class=\"built_in\">append</span>(<span class=\"string\">&quot;www.liaoxuefeng.com&quot;</span>)</span><br><span class=\"line\">       .<span class=\"built_in\">append</span>(<span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">       .<span class=\"built_in\">append</span>(<span class=\"string\">&quot;?t=0&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">String</span> url = builder.toString();</span><br></pre></td></tr></table></figure>\n\n<p>由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String url = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">URLBuilder</span>.</span></span>builder<span class=\"literal\">()</span> <span class=\"comment\">// 创建Builder</span></span><br><span class=\"line\">        .set<span class=\"constructor\">Domain(<span class=\"string\">&quot;www.liaoxuefeng.com&quot;</span>)</span> <span class=\"comment\">// 设置domain</span></span><br><span class=\"line\">        .set<span class=\"constructor\">Scheme(<span class=\"string\">&quot;https&quot;</span>)</span> <span class=\"comment\">// 设置scheme</span></span><br><span class=\"line\">        .set<span class=\"constructor\">Path(<span class=\"string\">&quot;/&quot;</span>)</span> <span class=\"comment\">// 设置路径</span></span><br><span class=\"line\">        .set<span class=\"constructor\">Query(Map.<span class=\"params\">of</span>(<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;123&quot;</span>, <span class=\"string\">&quot;q&quot;</span>, <span class=\"string\">&quot;K&amp;R&quot;</span>)</span>) <span class=\"comment\">// 设置query</span></span><br><span class=\"line\">        .build<span class=\"literal\">()</span>; <span class=\"comment\">// 完成build</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h2><blockquote>\n<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>\n</blockquote>\n<p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p>\n<p>我们举个例子：如果我们已经有了一个<code>String[]</code>数组，想再创建一个一模一样的<code>String[]</code>数组，怎么写？</p>\n<p>实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 原型:</span></span><br><span class=\"line\">String<span class=\"literal\">[]</span> original = &#123; <span class=\"string\">&quot;Apple&quot;</span>, <span class=\"string\">&quot;Pear&quot;</span>, <span class=\"string\">&quot;Banana&quot;</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">// 新对象:</span></span><br><span class=\"line\">String<span class=\"literal\">[]</span> copy = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Arrays</span>.</span></span>copy<span class=\"constructor\">Of(<span class=\"params\">original</span>, <span class=\"params\">original</span>.<span class=\"params\">length</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>对于普通类，我们如何实现原型拷贝？Java的<code>Object</code>提供了一个<code>clone()</code>方法，它的意图就是复制一个新的对象出来，我们需要实现一个<code>Cloneable</code>接口来标识一个对象是“可复制”的：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"title\">implements</span> <span class=\"title\">Cloneable</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 复制新对象并返回:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">clone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Student std = <span class=\"keyword\">new</span> <span class=\"built_in\">Student</span>();</span><br><span class=\"line\">        std.id = <span class=\"keyword\">this</span>.id;</span><br><span class=\"line\">        std.name = <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">        std.score = <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用的时候，因为<code>clone()</code>的方法签名是定义在<code>Object</code>中，返回类型也是<code>Object</code>，所以要强制转型，比较麻烦：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Student std1 = <span class=\"keyword\">new</span> <span class=\"constructor\">Student()</span>;</span><br><span class=\"line\">std1.set<span class=\"constructor\">Id(123)</span>;</span><br><span class=\"line\">std1.set<span class=\"constructor\">Name(<span class=\"string\">&quot;Bob&quot;</span>)</span>;</span><br><span class=\"line\">std1.set<span class=\"constructor\">Score(88)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 复制新对象:</span></span><br><span class=\"line\">Student std2 = (Student) std1.clone<span class=\"literal\">()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(std1);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(std2);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(std1<span class=\"operator\"> == </span>std2); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，使用原型模式更好的方式是定义一个<code>copy()</code>方法，返回明确的类型：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> score;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Student <span class=\"title\">copy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Student std = <span class=\"keyword\">new</span> <span class=\"built_in\">Student</span>();</span><br><span class=\"line\">        std.id = <span class=\"keyword\">this</span>.id;</span><br><span class=\"line\">        std.name = <span class=\"keyword\">this</span>.name;</span><br><span class=\"line\">        std.score = <span class=\"keyword\">this</span>.score;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><blockquote>\n<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n</blockquote>\n<p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p>\n<p>因为这个类只有一个实例，因此，自然不能让调用方使用<code>new Xyz()</code>来创建实例了。所以，单例的构造方法必须是<code>private</code>，这样就防止了调用方自己创建实例，但是在类的内部，是可以用一个静态字段来引用唯一创建的实例的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态字段引用唯一实例:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// private构造方法保证外部无法实例化:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么问题来了，外部调用方如何获得这个唯一实例？</p>\n<p>答案是提供一个静态方法，直接返回实例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态字段引用唯一实例:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 通过静态方法返回实例:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// private构造方法保证外部无法实例化:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>或者直接把<code>static</code>变量暴露给外部：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 静态字段引用唯一实例:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// private构造方法保证外部无法实例化:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>所以，单例模式的实现方式很简单：</p>\n<ol>\n<li>只有<code>private</code>构造方法，确保外部无法实例化；</li>\n<li>通过<code>private static</code>变量持有唯一实例，保证全局唯一性；</li>\n<li>通过<code>public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li>\n</ol>\n<p>Java标准库有一些类就是单例，例如<code>Runtime</code>这个类：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Runtime</span> <span class=\"keyword\">runtime</span> = <span class=\"keyword\">Runtime</span>.getRuntime();</span><br></pre></td></tr></table></figure>\n\n<p>有些童鞋可能听说过延迟加载，即在调用方第一次调用<code>getInstance()</code>时才初始化全局唯一实例，类似这样：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton INSTANCE = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"function\"><span class=\"title\">getInstance</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (INSTANCE == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"title\">Singleton</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>遗憾的是，这种写法在多线程中是错误的，在竞争条件下会创建出多个实例。必须对整个方法进行加锁：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> <span class=\"function\">Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但加锁会严重影响并发性能。还有些童鞋听说过双重检查，类似这样：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\">Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (INSTANCE == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然而，由于Java的内存模型，双重检查在这里不成立。要真正实现延迟加载，只能通过Java的ClassLoader机制完成。如果没有特殊的需求，使用Singleton模式的时候，最好不要延迟加载，这样会使代码更简单。</p>\n<p>另一种实现Singleton的方式是利用Java的<code>enum</code>，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">enum</span> World &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 唯一枚举:</span></span><br><span class=\"line\">\tINSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name = <span class=\"string\">&quot;world&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getName</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setName</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个<code>World</code>类在调用方看来就可以这么用：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">String name = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">World</span>.</span><span class=\"module\"><span class=\"identifier\">INSTANCE</span>.</span></span>get<span class=\"constructor\">Name()</span>;</span><br></pre></td></tr></table></figure>\n\n<p>使用枚举实现Singleton还避免了第一种方式实现Singleton的一个潜在问题：即序列化和反序列化会绕过普通类的<code>private</code>构造方法从而创建出多个实例，而枚举类就没有这个问题。</p>\n<p>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">// 表示一个单例组件</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyService</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p>\n<h1 id=\"结构型模式\"><a href=\"#结构型模式\" class=\"headerlink\" title=\"结构型模式\"></a>结构型模式</h1><p>把类或对象结合在一起形成一个更大的结构</p>\n<p>结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p>\n<p>结构型模式有：</p>\n<ul>\n<li>适配器</li>\n<li>桥接</li>\n<li>组合</li>\n<li>装饰器</li>\n<li>外观</li>\n<li>享元</li>\n<li>代理</li>\n</ul>\n<h2 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h2><blockquote>\n<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>\n</blockquote>\n<p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？</p>\n<p>我们举个例子。如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器：</p>\n<p><img src=\"/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189632185020.jpeg\" alt=\"adapter\"></p>\n<p>在程序设计中，适配器也是类似的。我们已经有一个<code>Task</code>类，实现了<code>Callable</code>接口：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"keyword\">Task</span> <span class=\"keyword\">implements</span> Callable&lt;<span class=\"keyword\">Long</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> num;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">Task</span>(<span class=\"keyword\">long</span> num) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">Long</span> <span class=\"keyword\">call</span>() <span class=\"keyword\">throws</span> Exception &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> r = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">long</span> n = <span class=\"number\">1</span>; n &lt;= <span class=\"keyword\">this</span>.num; n++) &#123;</span><br><span class=\"line\">            r = r + n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">&quot;Result: &quot;</span> + r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们想通过一个线程去执行它：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\">Callable&lt;Long&gt; callable = <span class=\"literal\">new</span> Task(<span class=\"number\">123450000</span>L);</span><br><span class=\"line\"><span class=\"keyword\">Thread</span> <span class=\"keyword\">thread</span> = <span class=\"literal\">new</span> <span class=\"keyword\">Thread</span>(callable); <span class=\"comment\">// compile error!</span></span><br><span class=\"line\"><span class=\"keyword\">thread</span>.start();</span><br></pre></td></tr></table></figure>\n\n<p>发现编译不过！因为<code>Thread</code>接收<code>Runnable</code>接口，但不接收<code>Callable</code>接口，肿么办？</p>\n<p>一个办法是改写<code>Task</code>类，把实现的<code>Callable</code>改为<code>Runnable</code>，但这样做不好，因为<code>Task</code>很可能在其他地方作为<code>Callable</code>被引用，改写<code>Task</code>的接口，会导致其他正常工作的代码无法编译。</p>\n<p>另一个办法不用改写<code>Task</code>类，而是用一个Adapter，把这个<code>Callable</code>接口“变成”<code>Runnable</code>接口，这样，就可以正常编译：</p>\n<figure class=\"highlight autohotkey\"><table><tr><td class=\"code\"><pre><span class=\"line\">Callable&lt;Long&gt; callable = <span class=\"keyword\">new</span> Task(<span class=\"number\">123450000</span>L)<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span> <span class=\"keyword\">thread</span> = <span class=\"keyword\">new</span> <span class=\"keyword\">Thread</span>(<span class=\"keyword\">new</span> RunnableAdapter(callable))<span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">thread</span>.start()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>这个<code>RunnableAdapter</code>类就是Adapter，它接收一个<code>Callable</code>，输出一个<code>Runnable</code>。怎么实现这个<code>RunnableAdapter</code>呢？我们先看完整的代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RunnableAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 引用待转换接口:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">Callable</span><span class=\"meta\">&lt;?</span>&gt; <span class=\"keyword\">callable</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RunnableAdapter(<span class=\"keyword\">Callable</span><span class=\"meta\">&lt;?</span>&gt; <span class=\"keyword\">callable</span>) &#123;</span><br><span class=\"line\">        this.<span class=\"keyword\">callable</span> = <span class=\"keyword\">callable</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现指定接口:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> run() &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将指定接口调用委托给转换接口调用:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">callable</span>.call();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (<span class=\"built_in\">Exception</span> e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编写一个Adapter的步骤如下：</p>\n<ol>\n<li>实现目标接口，这里是<code>Runnable</code>；</li>\n<li>内部持有一个待转换接口的引用，这里是通过字段持有<code>Callable</code>接口；</li>\n<li>在目标接口的实现方法内部，调用待转换接口的方法。</li>\n</ol>\n<p>这样一来，Thread就可以接收这个<code>RunnableAdapter</code>，因为它实现了<code>Runnable</code>接口。<code>Thread</code>作为调用方，它会调用<code>RunnableAdapter</code>的<code>run()</code>方法，在这个<code>run()</code>方法内部，又调用了<code>Callable</code>的<code>call()</code>方法，相当于<code>Thread</code>通过一层转换，间接调用了<code>Callable</code>的<code>call()</code>方法。</p>\n<p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是<code>String[]</code>，但是需要<code>List</code>接口时，可以用一个Adapter：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>[] exist = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>[] &#123;<span class=\"string\">&quot;Good&quot;</span>, <span class=\"string\">&quot;morning&quot;</span>, <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"string\">&quot;and&quot;</span>, <span class=\"string\">&quot;Alice&quot;</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Set</span>&lt;<span class=\"built_in\">String</span>&gt; <span class=\"keyword\">set</span> = <span class=\"keyword\">new</span> HashSet&lt;&gt;(Arrays.asList(exist));</span><br></pre></td></tr></table></figure>\n\n<p>注意到<code>List&lt;T&gt; Arrays.asList(T[])</code>就相当于一个转换器，它可以把数组转换为<code>List</code>。</p>\n<p>我们再看一个例子：假设我们持有一个<code>InputStream</code>，希望调用<code>readText(Reader)</code>方法，但它的参数类型是<code>Reader</code>而不是<code>InputStream</code>，怎么办？</p>\n<p>当然是使用适配器，把<code>InputStream</code>“变成”<code>Reader</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputStream input = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Files</span>.</span></span><span class=\"keyword\">new</span><span class=\"constructor\">InputStream(Paths.<span class=\"params\">get</span>(<span class=\"string\">&quot;/path/to/file&quot;</span>)</span>);</span><br><span class=\"line\">Reader reader = <span class=\"keyword\">new</span> <span class=\"constructor\">InputStreamReader(<span class=\"params\">input</span>, <span class=\"string\">&quot;UTF-8&quot;</span>)</span>;</span><br><span class=\"line\">read<span class=\"constructor\">Text(<span class=\"params\">reader</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p><code>InputStreamReader</code>就是Java标准库提供的<code>Adapter</code>，它负责把一个<code>InputStream</code>适配为<code>Reader</code>。类似的还有<code>OutputStreamWriter</code>。</p>\n<p>如果我们把<code>readText(Reader)</code>方法参数从<code>Reader</code>改为<code>FileReader</code>，会有什么问题？这个时候，因为我们需要一个<code>FileReader</code>类型，就必须把<code>InputStream</code>适配为<code>FileReader</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">FileReader reader = <span class=\"keyword\">new</span> <span class=\"constructor\">InputStreamReader(<span class=\"params\">input</span>, <span class=\"string\">&quot;UTF-8&quot;</span>)</span>; <span class=\"comment\">// compile error!</span></span><br></pre></td></tr></table></figure>\n\n<p>直接使用<code>InputStreamReader</code>这个Adapter是不行的，因为它只能转换出<code>Reader</code>接口。事实上，要把<code>InputStream</code>转换为<code>FileReader</code>也不是不可能，但需要花费十倍以上的功夫。这时，面向抽象编程这一原则就体现出了威力：持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类类型，要想做一些改动就非常困难。</p>\n<h2 id=\"桥接模式\"><a href=\"#桥接模式\" class=\"headerlink\" title=\"桥接模式\"></a>桥接模式</h2><blockquote>\n<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>\n</blockquote>\n<p>桥接模式的定义非常玄乎，直接理解不太容易，所以我们还是举例子。</p>\n<p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                   ┌───────┐</span><br><span class=\"line\">                   │  Car  │</span><br><span class=\"line\">                   └───────┘</span><br><span class=\"line\">                       ▲</span><br><span class=\"line\">    ┌──────────────────┼───────────────────┐</span><br><span class=\"line\">    │                  │                   │</span><br><span class=\"line\">┌───────┐          ┌───────┐          ┌───────┐</span><br><span class=\"line\">│BigCar │          │TinyCar│          │BossCar│</span><br><span class=\"line\">└───────┘          └───────┘          └───────┘</span><br><span class=\"line\">    ▲                  ▲                  ▲</span><br><span class=\"line\">    │                  │                  │</span><br><span class=\"line\">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class=\"line\">    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │</span><br><span class=\"line\">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class=\"line\">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class=\"line\">    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│</span><br><span class=\"line\">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class=\"line\">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class=\"line\">    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │</span><br><span class=\"line\">      └───────────────┘  └───────────────┘  └───────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。</p>\n<p>所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p>\n<p>我们来看看桥接模式如何解决上述问题。</p>\n<p>在桥接模式中，首先把<code>Car</code>按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。我们来看看具体的实现。</p>\n<p>首先定义抽象类<code>Car</code>，它引用一个<code>Engine</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 引用Engine:</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Engine engine;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Car</span><span class=\"params\">(Engine engine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.engine = engine;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">drive</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Engine</code>的定义如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Engine</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>紧接着，在一个“修正”的抽象类<code>RefinedCar</code>中定义一些额外操作：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RefinedCar</span> <span class=\"keyword\">extends</span> <span class=\"title\">Car</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">RefinedCar</span>(<span class=\"type\">Engine</span> engine) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(engine);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void drive() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.engine.start();</span><br><span class=\"line\">        <span class=\"type\">System</span>.out.println(<span class=\"string\">&quot;Drive &quot;</span> + getBrand() + <span class=\"string\">&quot; car...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"keyword\">abstract</span> <span class=\"type\">String</span> getBrand();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，最终的不同品牌继承自<code>RefinedCar</code>，例如<code>BossCar</code>：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BossCar</span> <span class=\"keyword\">extends</span> <span class=\"title\">RefinedCar</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">BossCar</span>(<span class=\"type\">Engine</span> engine) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(engine);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"type\">String</span> getBrand() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Boss&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而针对每一种引擎，继承自<code>Engine</code>，例如<code>HybridEngine</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">HybridEngine</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">Engine</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> start() &#123;</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">&quot;Start Hybrid Engine...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">RefinedCar car = <span class=\"keyword\">new</span> <span class=\"type\">BossCar</span>(<span class=\"keyword\">new</span> <span class=\"type\">HybridEngine</span>());</span><br><span class=\"line\">car.drive();</span><br></pre></td></tr></table></figure>\n\n<p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对<code>Engine</code>派生一个新的子类，如果要增加一个品牌，只需要针对<code>RefinedCar</code>派生一个子类，任何<code>RefinedCar</code>的子类都可以和任何一种<code>Engine</code>自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">       ┌───────────┐</span><br><span class=\"line\">       │    Car    │</span><br><span class=\"line\">       └───────────┘</span><br><span class=\"line\">             ▲</span><br><span class=\"line\">             │</span><br><span class=\"line\">       ┌───────────┐       ┌─────────┐</span><br><span class=\"line\">       │RefinedCar │ ─ ─ ─&gt;│ Engine  │</span><br><span class=\"line\">       └───────────┘       └─────────┘</span><br><span class=\"line\">             ▲                  ▲</span><br><span class=\"line\">    ┌────────┼────────┐         │ ┌──────────────┐</span><br><span class=\"line\">    │        │        │         ├─│  FuelEngine  │</span><br><span class=\"line\">┌───────┐┌───────┐┌───────┐     │ └──────────────┘</span><br><span class=\"line\">│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐</span><br><span class=\"line\">└───────┘└───────┘└───────┘     ├─│ElectricEngine│</span><br><span class=\"line\">                                │ └──────────────┘</span><br><span class=\"line\">                                │ ┌──────────────┐</span><br><span class=\"line\">                                └─│ HybridEngine │</span><br><span class=\"line\">                                  └──────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p>\n<h2 id=\"组合模式\"><a href=\"#组合模式\" class=\"headerlink\" title=\"组合模式\"></a>组合模式</h2><blockquote>\n<p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>\n</blockquote>\n<p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p>\n<p>我们来看一个具体的例子。在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。</p>\n<p>要以树的结构表示XML，我们可以先抽象出节点类型<code>Node</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 添加一个节点为子节点:</span></span><br><span class=\"line\">    <span class=\"function\">Node <span class=\"title\">add</span><span class=\"params\">(Node node)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取子节点:</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;Node&gt; <span class=\"title\">children</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 输出为XML:</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">toXml</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于一个<code>&lt;abc&gt;</code>这样的节点，我们称之为<code>ElementNode</code>，它可以作为容器包含多个子节点：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ElementNode</span> <span class=\"title\">implements</span> <span class=\"title\">Node</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Node&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">ElementNode</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Node <span class=\"function\"><span class=\"title\">add</span>(<span class=\"params\">Node node</span>)</span> &#123;</span><br><span class=\"line\">        list.add(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Node&gt; <span class=\"function\"><span class=\"title\">children</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">toXml</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">String</span> start = <span class=\"string\">&quot;&lt;&quot;</span> + name + <span class=\"string\">&quot;&gt;\\n&quot;</span>;</span><br><span class=\"line\">        <span class=\"built_in\">String</span> end = <span class=\"string\">&quot;&lt;/&quot;</span> + name + <span class=\"string\">&quot;&gt;\\n&quot;</span>;</span><br><span class=\"line\">        StringJoiner sj = <span class=\"keyword\">new</span> StringJoiner(<span class=\"string\">&quot;&quot;</span>, start, end);</span><br><span class=\"line\">        list.forEach(node -&gt; &#123;</span><br><span class=\"line\">            sj.add(node.toXml() + <span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sj.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于普通文本，我们把它看作<code>TextNode</code>，它没有子节点：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextNode</span> <span class=\"title\">implements</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">String</span> text;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TextNode</span><span class=\"params\">(<span class=\"keyword\">String</span> text)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.text = text;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">add</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">UnsupportedOperationException</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;Node&gt; <span class=\"title\">children</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> List.<span class=\"built_in\">of</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">String</span> <span class=\"title\">toXml</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> text;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此外，还可以有注释节点：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CommentNode</span> <span class=\"title\">implements</span> <span class=\"title\">Node</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">String</span> text;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CommentNode</span><span class=\"params\">(<span class=\"keyword\">String</span> text)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.text = text;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Node <span class=\"title\">add</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">UnsupportedOperationException</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> List&lt;Node&gt; <span class=\"title\">children</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> List.<span class=\"built_in\">of</span>();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">String</span> <span class=\"title\">toXml</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">&quot;&lt;!-- &quot;</span> + text + <span class=\"string\">&quot; --&gt;&quot;</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过<code>ElementNode</code>、<code>TextNode</code>和<code>CommentNode</code>，我们就可以构造出一颗树：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Node root = <span class=\"keyword\">new</span> <span class=\"constructor\">ElementNode(<span class=\"string\">&quot;school&quot;</span>)</span>;</span><br><span class=\"line\">root.add(<span class=\"keyword\">new</span> <span class=\"constructor\">ElementNode(<span class=\"string\">&quot;classA&quot;</span>)</span></span><br><span class=\"line\">        .add(<span class=\"keyword\">new</span> <span class=\"constructor\">TextNode(<span class=\"string\">&quot;Tom&quot;</span>)</span>)</span><br><span class=\"line\">        .add(<span class=\"keyword\">new</span> <span class=\"constructor\">TextNode(<span class=\"string\">&quot;Alice&quot;</span>)</span>));</span><br><span class=\"line\">root.add(<span class=\"keyword\">new</span> <span class=\"constructor\">ElementNode(<span class=\"string\">&quot;classB&quot;</span>)</span></span><br><span class=\"line\">        .add(<span class=\"keyword\">new</span> <span class=\"constructor\">TextNode(<span class=\"string\">&quot;Bob&quot;</span>)</span>)</span><br><span class=\"line\">        .add(<span class=\"keyword\">new</span> <span class=\"constructor\">TextNode(<span class=\"string\">&quot;Grace&quot;</span>)</span>)</span><br><span class=\"line\">        .add(<span class=\"keyword\">new</span> <span class=\"constructor\">CommentNode(<span class=\"string\">&quot;comment...&quot;</span>)</span>));</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(root.<span class=\"keyword\">to</span><span class=\"constructor\">Xml()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>最后通过<code>root</code>节点输出的XML如下：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">school</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">classA</span>&gt;</span></span><br><span class=\"line\">Tom</span><br><span class=\"line\">Alice</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">classA</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">classB</span>&gt;</span></span><br><span class=\"line\">Bob</span><br><span class=\"line\">Grace</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- comment... --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">classB</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">school</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">             ┌───────────┐</span><br><span class=\"line\">             │   Node    │</span><br><span class=\"line\">             └───────────┘</span><br><span class=\"line\">                   ▲</span><br><span class=\"line\">      ┌────────────┼────────────┐</span><br><span class=\"line\">      │            │            │</span><br><span class=\"line\">┌───────────┐┌───────────┐┌───────────┐</span><br><span class=\"line\">│ElementNode││ TextNode  ││CommentNode│</span><br><span class=\"line\">└───────────┘└───────────┘└───────────┘</span><br></pre></td></tr></table></figure>\n\n<p>作为容器节点的<code>ElementNode</code>又可以添加任意个<code>Node</code>，这样就可以构成层级结构。</p>\n<p>类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p>\n<h2 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h2><blockquote>\n<p>动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。</p>\n</blockquote>\n<p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</p>\n<p>我们在IO的<a href=\"https://www.liaoxuefeng.com/wiki/1252599548343744/1298364142452770\">Filter模式</a>一节中其实已经讲过装饰器模式了。在Java标准库中，<code>InputStream</code>是抽象类，<code>FileInputStream</code>、<code>ServletInputStream</code>、<code>Socket.getInputStream()</code>这些<code>InputStream</code>都是最终数据源。</p>\n<p>现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。</p>\n<p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。</p>\n<p>例如：给<code>FileInputStream</code>增加缓冲和解压缩功能，用Decorator模式写出来如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建原始的数据源:</span></span><br><span class=\"line\">InputStream fis = <span class=\"keyword\">new</span> <span class=\"constructor\">FileInputStream(<span class=\"string\">&quot;test.gz&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 增加缓冲功能:</span></span><br><span class=\"line\">InputStream bis = <span class=\"keyword\">new</span> <span class=\"constructor\">BufferedInputStream(<span class=\"params\">fis</span>)</span>;</span><br><span class=\"line\"><span class=\"comment\">// 增加解压缩功能:</span></span><br><span class=\"line\">InputStream gis = <span class=\"keyword\">new</span> <span class=\"constructor\">GZIPInputStream(<span class=\"params\">bis</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>或者一次性写成这样：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">InputStream input = <span class=\"keyword\">new</span> <span class=\"type\">GZIPInputStream</span>( <span class=\"comment\">// 第二层装饰</span></span><br><span class=\"line\">                        <span class=\"keyword\">new</span> <span class=\"type\">BufferedInputStream</span>( <span class=\"comment\">// 第一层装饰</span></span><br><span class=\"line\">                            <span class=\"keyword\">new</span> <span class=\"type\">FileInputStream</span>(<span class=\"string\">&quot;test.gz&quot;</span>) <span class=\"comment\">// 核心功能</span></span><br><span class=\"line\">                        ));</span><br></pre></td></tr></table></figure>\n\n<p>观察<code>BufferedInputStream</code>和<code>GZIPInputStream</code>，它们实际上都是从<code>FilterInputStream</code>继承的，这个<code>FilterInputStream</code>就是一个抽象的Decorator。我们用图把Decorator模式画出来如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">             ┌───────────┐</span><br><span class=\"line\">             │ Component │</span><br><span class=\"line\">             └───────────┘</span><br><span class=\"line\">                   ▲</span><br><span class=\"line\">      ┌────────────┼─────────────────┐</span><br><span class=\"line\">      │            │                 │</span><br><span class=\"line\">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class=\"line\">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class=\"line\">└───────────┘└───────────┘     └───────────┘</span><br><span class=\"line\">                                     ▲</span><br><span class=\"line\">                              ┌──────┴──────┐</span><br><span class=\"line\">                              │             │</span><br><span class=\"line\">                        ┌───────────┐ ┌───────────┐</span><br><span class=\"line\">                        │DecoratorA │ │DecoratorB │...</span><br><span class=\"line\">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>\n\n<p>最顶层的Component是接口，对应到IO的就是<code>InputStream</code>这个抽象类。ComponentA、ComponentB是实际的子类，对应到IO的就是<code>FileInputStream</code>、<code>ServletInputStream</code>这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是<code>FilterInputStream</code>。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是<code>BufferedInputStream</code>、<code>GZIPInputStream</code>等。</p>\n<p>Decorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。如果我们要增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>\n<p>如果我们要自己设计完整的Decorator模式，应该如何设计？</p>\n<p>我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。</p>\n<p>首先，仍然需要定义顶层接口<code>TextNode</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> interface TextNode &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置text:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(<span class=\"keyword\">String</span> text)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取text:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">String</span> <span class=\"title\">getText</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于核心节点，例如<code>&lt;span&gt;</code>，它需要从<code>TextNode</code>直接继承：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpanNode</span> <span class=\"title\">implements</span> <span class=\"title\">TextNode</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> text;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(<span class=\"keyword\">String</span> text)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.text = text;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">String</span> <span class=\"title\">getText</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&lt;span&gt;&quot;</span> + text + <span class=\"string\">&quot;&lt;/span&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>紧接着，为了实现Decorator模式，需要有一个抽象的Decorator类：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NodeDecorator</span> <span class=\"keyword\">implements</span> <span class=\"title\">TextNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> TextNode <span class=\"keyword\">target</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">NodeDecorator</span><span class=\"params\">(TextNode <span class=\"keyword\">target</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">target</span> = <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setText</span><span class=\"params\">(String text)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">target</span>.setText(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>NodeDecorator</code>类的核心是持有一个<code>TextNode</code>，即将要把功能附加到的<code>TextNode</code>实例。接下来就可以写一个加粗功能：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoldDecorator</span> <span class=\"keyword\">extends</span> <span class=\"title\">NodeDecorator</span> </span>&#123;</span><br><span class=\"line\">    public <span class=\"type\">BoldDecorator</span>(<span class=\"type\">TextNode</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"type\">String</span> getText() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&lt;b&gt;&quot;</span> + target.getText() + <span class=\"string\">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似的，可以继续加<code>ItalicDecorator</code>、<code>UnderlineDecorator</code>等。客户端可以自由组合这些Decorator：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">TextNode n1 = <span class=\"keyword\">new</span> <span class=\"constructor\">SpanNode()</span>;</span><br><span class=\"line\">TextNode n2 = <span class=\"keyword\">new</span> <span class=\"constructor\">BoldDecorator(<span class=\"params\">new</span> UnderlineDecorator(<span class=\"params\">new</span> SpanNode()</span>));</span><br><span class=\"line\">TextNode n3 = <span class=\"keyword\">new</span> <span class=\"constructor\">ItalicDecorator(<span class=\"params\">new</span> BoldDecorator(<span class=\"params\">new</span> SpanNode()</span>));</span><br><span class=\"line\">n1.set<span class=\"constructor\">Text(<span class=\"string\">&quot;Hello&quot;</span>)</span>;</span><br><span class=\"line\">n2.set<span class=\"constructor\">Text(<span class=\"string\">&quot;Decorated&quot;</span>)</span>;</span><br><span class=\"line\">n3.set<span class=\"constructor\">Text(<span class=\"string\">&quot;World&quot;</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(n1.get<span class=\"constructor\">Text()</span>);</span><br><span class=\"line\"><span class=\"comment\">// 输出&lt;span&gt;Hello&lt;/span&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(n2.get<span class=\"constructor\">Text()</span>);</span><br><span class=\"line\"><span class=\"comment\">// 输出&lt;b&gt;&lt;u&gt;&lt;span&gt;Decorated&lt;/span&gt;&lt;/u&gt;&lt;/b&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(n3.get<span class=\"constructor\">Text()</span>);</span><br><span class=\"line\"><span class=\"comment\">// 输出&lt;i&gt;&lt;b&gt;&lt;span&gt;World&lt;/span&gt;&lt;/b&gt;&lt;/i&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"外观模式\"><a href=\"#外观模式\" class=\"headerlink\" title=\"外观模式\"></a>外观模式</h2><blockquote>\n<p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>\n</blockquote>\n<p>外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：</p>\n<p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p>\n<p>我们以注册公司为例，假设注册公司需要三步：</p>\n<ol>\n<li>向工商局申请公司营业执照；</li>\n<li>在银行开设账户；</li>\n<li>在税务局开设纳税号。</li>\n</ol>\n<p>以下是三个系统的接口：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工商注册:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AdminOfIndustry</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Company <span class=\"function\"><span class=\"title\">register</span>(<span class=\"params\"><span class=\"built_in\">String</span> name</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 银行开户:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">openAccount</span>(<span class=\"params\"><span class=\"built_in\">String</span> companyId</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 纳税登记:</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Taxation</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">applyTaxCode</span>(<span class=\"params\"><span class=\"built_in\">String</span> companyId</span>)</span> &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> Facade &#123;</span><br><span class=\"line\">    public Company <span class=\"keyword\">open</span><span class=\"constructor\">Company(String <span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">        Company c = this.admin.register(name);</span><br><span class=\"line\">        String bankAccount = this.bank.<span class=\"keyword\">open</span><span class=\"constructor\">Account(<span class=\"params\">c</span>.<span class=\"params\">getId</span>()</span>);</span><br><span class=\"line\">        c.set<span class=\"constructor\">BankAccount(<span class=\"params\">bankAccount</span>)</span>;</span><br><span class=\"line\">        String taxCode = this.taxation.apply<span class=\"constructor\">TaxCode(<span class=\"params\">c</span>.<span class=\"params\">getId</span>()</span>);</span><br><span class=\"line\">        c.set<span class=\"constructor\">TaxCode(<span class=\"params\">taxCode</span>)</span>;</span><br><span class=\"line\">        return c;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Company c = facade.<span class=\"keyword\">open</span><span class=\"constructor\">Company(<span class=\"string\">&quot;Facade Software Ltd.&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code>RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p>\n<p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p>\n<h2 id=\"享元模式\"><a href=\"#享元模式\" class=\"headerlink\" title=\"享元模式\"></a>享元模式</h2><blockquote>\n<p>运用共享技术有效地支持大量细粒度的对象。</p>\n</blockquote>\n<p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>\n<p>享元模式在Java标准库中有很多应用。我们知道，包装类型如<code>Byte</code>、<code>Integer</code>都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以<code>Integer</code>为例，如果我们通过<code>Integer.valueOf()</code>这个静态工厂方法创建<code>Integer</code>实例，当传入的<code>int</code>范围在<code>-128</code>~&#96;+127<code>之间时，会直接返回缓存的</code>Integer&#96;实例：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> 享元模式</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>对于<code>Byte</code>来说，因为它一共只有256个状态，所以，通过<code>Byte.valueOf()</code>创建的<code>Byte</code>实例，全部都是缓存对象。</p>\n<p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。</p>\n<p> 总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。</p>\n<p>在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。</p>\n<p>我们以<code>Student</code>为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 持有缓存:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;<span class=\"keyword\">String</span>, Student&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 静态工厂方法:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Student <span class=\"title\">create</span><span class=\"params\">(<span class=\"keyword\">int</span> id, <span class=\"keyword\">String</span> name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> key = id + <span class=\"string\">&quot;\\n&quot;</span> + name;</span><br><span class=\"line\">        <span class=\"comment\">// 先查找缓存:</span></span><br><span class=\"line\">        Student std = cache.<span class=\"built_in\">get</span>(key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (std == null) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 未找到,创建新对象:</span></span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"keyword\">String</span>.format(<span class=\"string\">&quot;create new Student(%s, %s)&quot;</span>, id, name));</span><br><span class=\"line\">            std = <span class=\"keyword\">new</span> <span class=\"built_in\">Student</span>(id, name);</span><br><span class=\"line\">            <span class=\"comment\">// 放入缓存:</span></span><br><span class=\"line\">            cache.<span class=\"built_in\">put</span>(key, std);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 缓存中存在:</span></span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"keyword\">String</span>.format(<span class=\"string\">&quot;return cached Student(%s, %s)&quot;</span>, std.id, std.name));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Student</span><span class=\"params\">(<span class=\"keyword\">int</span> id, <span class=\"keyword\">String</span> name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在实际应用中，我们经常使用成熟的缓存库，例如<a href=\"https://github.com/google/guava\">Guava</a>的<a href=\"https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java\">Cache</a>，因为它提供了最大缓存数量限制、定时过期等实用功能。</p>\n<h2 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h2><blockquote>\n<p>为其他对象提供一种代理以控制对这个对象的访问。</p>\n</blockquote>\n<p>代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口：</p>\n<figure class=\"highlight delphi\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> BAdapter <span class=\"keyword\">implements</span> B <span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">    private A a;</span></span><br><span class=\"line\"><span class=\"comment\">    public BAdapter(A a) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        this.a = a;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> void b() <span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        a.a();</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> AProxy <span class=\"keyword\">implements</span> A &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> A a;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">AProxy</span>(<span class=\"params\">A a</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a = a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">a</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a.a();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>合着Proxy就是为了给A接口再包一层，这不是脱了裤子放屁吗？</p>\n<p>当然不是。我们观察Proxy的实现A接口的方法：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">a</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.a.a();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样写当然没啥卵用。但是，如果我们在调用<code>a.a()</code>的前后，加一些额外的代码：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">a</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (getCurrentUser().isRoot()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.a.a();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SecurityException(<span class=\"string\">&quot;Forbidden&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样一来，我们就实现了权限检查，只有符合要求的用户，才会真正调用目标方法，否则，会直接抛出异常。</p>\n<p>有的童鞋会问，为啥不把权限检查的功能直接写到目标实例A的内部？</p>\n<p>因为我们编写代码的原则有：</p>\n<ul>\n<li>职责清晰：一个类只负责一件事；</li>\n<li>易于测试：一次只测一个功能。</li>\n</ul>\n<p>用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：</p>\n<ul>\n<li>A接口：只定义接口；</li>\n<li>ABusiness类：只实现A接口的业务逻辑；</li>\n<li>APermissionProxy类：只实现A接口的权限检查代理。</li>\n</ul>\n<p>如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。</p>\n<p>实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：</p>\n<h3 id=\"远程代理\"><a href=\"#远程代理\" class=\"headerlink\" title=\"远程代理\"></a>远程代理</h3><p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p>\n<h3 id=\"虚代理\"><a href=\"#虚代理\" class=\"headerlink\" title=\"虚代理\"></a>虚代理</h3><p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>\n<h3 id=\"保护代理\"><a href=\"#保护代理\" class=\"headerlink\" title=\"保护代理\"></a>保护代理</h3><p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p>\n<h3 id=\"智能引用\"><a href=\"#智能引用\" class=\"headerlink\" title=\"智能引用\"></a>智能引用</h3><p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>\n<p>我们来看一下如何应用代理模式编写一个JDBC连接池（<code>DataSource</code>）。我们首先来编写一个虚代理，即如果调用者获取到<code>Connection</code>后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DataSource lazyDataSource = <span class=\"keyword\">new</span> <span class=\"constructor\">LazyDataSource(<span class=\"params\">jdbcUrl</span>, <span class=\"params\">jdbcUsername</span>, <span class=\"params\">jdbcPassword</span>)</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;get lazy connection...&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn1 = lazyDataSource.get<span class=\"constructor\">Connection()</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 并没有实际打开真正的Connection</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;get lazy connection...&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn2 = lazyDataSource.get<span class=\"constructor\">Connection()</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> (PreparedStatement ps = conn2.prepare<span class=\"constructor\">Statement(<span class=\"string\">&quot;SELECT * FROM students&quot;</span>)</span>) &#123; <span class=\"comment\">// 打开了真正的Connection</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> (ResultSet rs = ps.execute<span class=\"constructor\">Query()</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (rs.next<span class=\"literal\">()</span>) &#123;</span><br><span class=\"line\">                <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(rs.get<span class=\"constructor\">String(<span class=\"string\">&quot;name&quot;</span>)</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们来思考如何实现这个<code>LazyConnectionProxy</code>。为了简化代码，我们首先针对<code>Connection</code>接口做一个抽象的代理类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractConnectionProxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Connection</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 抽象方法获取实际的Connection:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Connection <span class=\"title\">getRealConnection</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 实现Connection接口的每一个方法:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Statement <span class=\"title\">createStatement</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getRealConnection().createStatement();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> PreparedStatement <span class=\"title\">prepareStatement</span><span class=\"params\">(String sql)</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getRealConnection().prepareStatement(sql);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...其他代理方法...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>AbstractConnectionProxy</code>代理类的作用是把<code>Connection</code>接口定义的方法全部实现一遍，因为<code>Connection</code>接口定义的方法太多了，后面我们要编写的<code>LazyConnectionProxy</code>只需要继承<code>AbstractConnectionProxy</code>，就不必再把<code>Connection</code>接口方法挨个实现一遍。</p>\n<p><code>LazyConnectionProxy</code>实现如下：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyConnectionProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractConnectionProxy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Supplier&lt;Connection&gt; supplier;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Connection <span class=\"keyword\">target</span> = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">LazyConnectionProxy</span><span class=\"params\">(Supplier&lt;Connection&gt; supplier)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.supplier = supplier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 覆写close方法：只有target不为null时才需要关闭:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;Close connection: &quot;</span> + <span class=\"keyword\">target</span>);</span><br><span class=\"line\">            <span class=\"keyword\">super</span>.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\">Connection <span class=\"title\">getRealConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">target</span> == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">target</span> = supplier.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果调用者没有执行任何SQL语句，那么<code>target</code>字段始终为<code>null</code>。只有第一次执行SQL语句时（即调用任何类似<code>prepareStatement()</code>方法时，触发<code>getRealConnection()</code>调用），才会真正打开实际的JDBC Connection。</p>\n<p>最后，我们还需要编写一个<code>LazyDataSource</code>来支持这个<code>LazyConnecitonProxy</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LazyDataSource</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">DataSource</span></span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> url;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> username;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">String</span> password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> LazyDataSource(<span class=\"keyword\">String</span> url, <span class=\"keyword\">String</span> username, <span class=\"keyword\">String</span> password) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.url = url;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.username = username;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.password = password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Connection getConnection(<span class=\"keyword\">String</span> username, <span class=\"keyword\">String</span> password) throws SQLException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"type\">LazyConnectionProxy</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;Open connection: &quot;</span> + conn);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"type\">RuntimeException</span>(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们执行代码，输出如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">get</span> lazy connection...</span><br><span class=\"line\"><span class=\"keyword\">get</span> lazy connection...</span><br><span class=\"line\"><span class=\"keyword\">Open</span> connection: com.mysql.jdbc.JDBC4Connection<span class=\"variable\">@7a36aefa</span></span><br><span class=\"line\">小明</span><br><span class=\"line\">小红</span><br><span class=\"line\">小军</span><br><span class=\"line\">小白</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">Close</span> connection: com.mysql.jdbc.JDBC4Connection<span class=\"variable\">@7a36aefa</span></span><br></pre></td></tr></table></figure>\n\n<p>可见第一个<code>getConnection()</code>调用获取到的<code>LazyConnectionProxy</code>并没有实际打开真正的JDBC Connection。</p>\n<p>使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DataSource pooledDataSource = <span class=\"keyword\">new</span> <span class=\"constructor\">PooledDataSource(<span class=\"params\">jdbcUrl</span>, <span class=\"params\">jdbcUsername</span>, <span class=\"params\">jdbcPassword</span>)</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn = pooledDataSource.get<span class=\"constructor\">Connection()</span>) &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn = pooledDataSource.get<span class=\"constructor\">Connection()</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到的是同一个Connection</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> (Connection conn = pooledDataSource.get<span class=\"constructor\">Connection()</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取到的是同一个Connection</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用方并不关心是否复用了<code>Connection</code>，但从<code>PooledDataSource</code>获取的<code>Connection</code>确实自带这个优化功能。如何实现可复用<code>Connection</code>的连接池？答案仍然是使用代理模式。</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PooledConnectionProxy</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractConnectionProxy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 实际的Connection:</span></span><br><span class=\"line\">    Connection <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 空闲队列:</span></span><br><span class=\"line\">    Queue&lt;PooledConnectionProxy&gt; idleQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PooledConnectionProxy</span><span class=\"params\">(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection <span class=\"keyword\">target</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.idleQueue = idleQueue;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"keyword\">target</span> = <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">close</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Fake close and released to idle queue for future reuse: &quot;</span> + <span class=\"keyword\">target</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 并没有调用实际Connection的close()方法,</span></span><br><span class=\"line\">        <span class=\"comment\">// 而是把自己放入空闲队列:</span></span><br><span class=\"line\">        idleQueue.offer(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"function\">Connection <span class=\"title\">getRealConnection</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">target</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复用连接的关键在于覆写<code>close()</code>方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。</p>\n<p>空闲队列由<code>PooledDataSource</code>负责维护：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> PooledDataSource implements DataSource &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String url;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 维护一个空闲队列:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Queue&lt;PooledConnectionProxy&gt; idleQueue = <span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    public <span class=\"constructor\">PooledDataSource(String <span class=\"params\">url</span>, String <span class=\"params\">username</span>, String <span class=\"params\">password</span>)</span> &#123;</span><br><span class=\"line\">        this.url = url;</span><br><span class=\"line\">        this.username = username;</span><br><span class=\"line\">        this.password = password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public Connection get<span class=\"constructor\">Connection(String <span class=\"params\">username</span>, String <span class=\"params\">password</span>)</span> throws SQLException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 首先试图获取一个空闲连接:</span></span><br><span class=\"line\">        PooledConnectionProxy conn = idleQueue.poll<span class=\"literal\">()</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (conn<span class=\"operator\"> == </span>null) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 没有空闲连接时，打开一个新连接:</span></span><br><span class=\"line\">            conn = <span class=\"keyword\">open</span><span class=\"constructor\">NewConnection()</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Return pooled connection: &quot;</span> + conn.target);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return conn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> PooledConnectionProxy <span class=\"keyword\">open</span><span class=\"constructor\">NewConnection()</span> throws SQLException &#123;</span><br><span class=\"line\">        Connection conn = <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">DriverManager</span>.</span></span>get<span class=\"constructor\">Connection(<span class=\"params\">url</span>, <span class=\"params\">username</span>, <span class=\"params\">password</span>)</span>;</span><br><span class=\"line\">        <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;Open new connection: &quot;</span> + conn);</span><br><span class=\"line\">        return <span class=\"keyword\">new</span> <span class=\"constructor\">PooledConnectionProxy(<span class=\"params\">idleQueue</span>, <span class=\"params\">conn</span>)</span>;</span><br><span class=\"line\">    &#125;<span class=\"operator\"></span></span><br><span class=\"line\"><span class=\"operator\">    ...</span></span><br><span class=\"line\"><span class=\"operator\"></span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们执行调用方代码，输出如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Open</span> new connection: com.mysql.jdbc.JDBC<span class=\"number\">4</span>Connection@<span class=\"number\">61</span>ca<span class=\"number\">2</span>dfa</span><br><span class=\"line\"><span class=\"attribute\">Fake</span> close and released to idle queue for future reuse: com.mysql.jdbc.JDBC<span class=\"number\">4</span>Connection@<span class=\"number\">61</span>ca<span class=\"number\">2</span>dfa</span><br><span class=\"line\"><span class=\"attribute\">Return</span> pooled connection: com.mysql.jdbc.JDBC<span class=\"number\">4</span>Connection@<span class=\"number\">61</span>ca<span class=\"number\">2</span>dfa</span><br><span class=\"line\"><span class=\"attribute\">Fake</span> close and released to idle queue for future reuse: com.mysql.jdbc.JDBC<span class=\"number\">4</span>Connection@<span class=\"number\">61</span>ca<span class=\"number\">2</span>dfa</span><br><span class=\"line\"><span class=\"attribute\">Return</span> pooled connection: com.mysql.jdbc.JDBC<span class=\"number\">4</span>Connection@<span class=\"number\">61</span>ca<span class=\"number\">2</span>dfa</span><br><span class=\"line\"><span class=\"attribute\">Fake</span> close and released to idle queue for future reuse: com.mysql.jdbc.JDBC<span class=\"number\">4</span>Connection@<span class=\"number\">61</span>ca<span class=\"number\">2</span>dfa</span><br></pre></td></tr></table></figure>\n\n<p>除了第一次打开了一个真正的JDBC Connection，后续获取的<code>Connection</code>实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。</p>\n<p>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</p>\n<p>有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p>\n<h1 id=\"行为型模式\"><a href=\"#行为型模式\" class=\"headerlink\" title=\"行为型模式\"></a>行为型模式</h1><p>类和对象如何交互，及划分责任和算法</p>\n<p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p>\n<p>行为型模式有：</p>\n<ul>\n<li>责任链</li>\n<li>命令</li>\n<li>解释器</li>\n<li>迭代器</li>\n<li>中介</li>\n<li>备忘录</li>\n<li>观察者</li>\n<li>状态</li>\n<li>策略</li>\n<li>模板方法</li>\n<li>访问者</li>\n</ul>\n<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><blockquote>\n<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>\n</blockquote>\n<p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">     ┌─────────┐</span><br><span class=\"line\">     │ Request │</span><br><span class=\"line\">     └─────────┘</span><br><span class=\"line\">          │</span><br><span class=\"line\">┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐</span><br><span class=\"line\">          ▼</span><br><span class=\"line\">│  ┌─────────────┐  │</span><br><span class=\"line\">   │ ProcessorA  │</span><br><span class=\"line\">│  └─────────────┘  │</span><br><span class=\"line\">          │</span><br><span class=\"line\">│         ▼         │</span><br><span class=\"line\">   ┌─────────────┐</span><br><span class=\"line\">│  │ ProcessorB  │  │</span><br><span class=\"line\">   └─────────────┘</span><br><span class=\"line\">│         │         │</span><br><span class=\"line\">          ▼</span><br><span class=\"line\">│  ┌─────────────┐  │</span><br><span class=\"line\">   │ ProcessorC  │</span><br><span class=\"line\">│  └─────────────┘  │</span><br><span class=\"line\">          │</span><br><span class=\"line\">└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘</span><br><span class=\"line\">          │</span><br><span class=\"line\">          ▼</span><br></pre></td></tr></table></figure>\n\n<p>在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：</p>\n<ul>\n<li>Manager：只能审核1000元以下的报销；</li>\n<li>Director：只能审核10000元以下的报销；</li>\n<li>CEO：可以审核任意额度。</li>\n</ul>\n<p>用责任链模式设计此报销流程时，每个审核者只关心自己责任范围内的请求，并且处理它。对于超出自己责任范围的，扔给下一个审核者处理，这样，将来继续添加审核者的时候，不用改动现有逻辑。</p>\n<p>我们来看看如何实现责任链模式。</p>\n<p>首先，我们要抽象出请求对象，它将在责任链上传递：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Request</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">String</span> name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> BigDecimal amount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Request</span>(<span class=\"params\"><span class=\"built_in\">String</span> name, BigDecimal amount</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.amount = amount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getName</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> BigDecimal <span class=\"function\"><span class=\"title\">getAmount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> amount;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其次，我们要抽象出处理器：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> interface <span class=\"keyword\">Handler</span> &#123;</span><br><span class=\"line\">    // 返回<span class=\"type\">Boolean</span>.<span class=\"keyword\">TRUE</span> = 成功</span><br><span class=\"line\">    // 返回<span class=\"type\">Boolean</span>.<span class=\"keyword\">FALSE</span> = 拒绝</span><br><span class=\"line\">    // 返回<span class=\"keyword\">null</span> = 交下一个处理</span><br><span class=\"line\">\t<span class=\"type\">Boolean</span> process(Request request);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>并且做好约定：如果返回<code>Boolean.TRUE</code>，表示处理成功，如果返回<code>Boolean.FALSE</code>，表示处理失败（请求被拒绝），如果返回<code>null</code>，则交由下一个<code>Handler</code>处理。</p>\n<p>然后，依次编写ManagerHandler、DirectorHandler和CEOHandler。以ManagerHandler为例：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> ManagerHandler <span class=\"keyword\">implements</span> Handler &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">Boolean</span> process(Request request) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果超过1000元，处理不了，交下一个处理:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (request.getAmount().<span class=\"keyword\">compareTo</span>(BigDecimal.valueOf(<span class=\"number\">1000</span>)) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 对Bob有偏见:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> !request.getName().equalsIgnoreCase(<span class=\"string\">&quot;bob&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有了不同的<code>Handler</code>后，我们还要把这些<code>Handler</code>组合起来，变成一个链，并通过一个统一入口处理：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HandlerChain</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 持有所有Handler:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Handler&gt; handlers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addHandler</span><span class=\"params\">(Handler <span class=\"keyword\">handler</span>)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.handlers.add(<span class=\"keyword\">handler</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">process</span><span class=\"params\">(Request request)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 依次调用每个Handler:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Handler <span class=\"keyword\">handler</span> : handlers) &#123;</span><br><span class=\"line\">            Boolean r = <span class=\"keyword\">handler</span>.process(request);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果返回TRUE或FALSE，处理结束:</span></span><br><span class=\"line\">                System.out.println(request + <span class=\"string\">&quot; &quot;</span> + (r ? <span class=\"string\">&quot;Approved by &quot;</span> : <span class=\"string\">&quot;Denied by &quot;</span>) + <span class=\"keyword\">handler</span>.getClass().getSimpleName());</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Could not handle request: &quot;</span> + request);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们就可以在客户端组装出责任链，然后用责任链来处理请求：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造责任链:</span></span><br><span class=\"line\">HandlerChain chain = <span class=\"keyword\">new</span> <span class=\"type\">HandlerChain</span>();</span><br><span class=\"line\">chain.addHandler(<span class=\"keyword\">new</span> <span class=\"type\">ManagerHandler</span>());</span><br><span class=\"line\">chain.addHandler(<span class=\"keyword\">new</span> <span class=\"type\">DirectorHandler</span>());</span><br><span class=\"line\">chain.addHandler(<span class=\"keyword\">new</span> <span class=\"type\">CEOHandler</span>());</span><br><span class=\"line\"><span class=\"comment\">// 处理请求:</span></span><br><span class=\"line\">chain.process(<span class=\"keyword\">new</span> <span class=\"type\">Request</span>(<span class=\"string\">&quot;Bob&quot;</span>, <span class=\"keyword\">new</span> <span class=\"type\">BigDecimal</span>(<span class=\"string\">&quot;123.45&quot;</span>)));</span><br><span class=\"line\">chain.process(<span class=\"keyword\">new</span> <span class=\"type\">Request</span>(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"keyword\">new</span> <span class=\"type\">BigDecimal</span>(<span class=\"string\">&quot;1234.56&quot;</span>)));</span><br><span class=\"line\">chain.process(<span class=\"keyword\">new</span> <span class=\"type\">Request</span>(<span class=\"string\">&quot;Bill&quot;</span>, <span class=\"keyword\">new</span> <span class=\"type\">BigDecimal</span>(<span class=\"string\">&quot;12345.67&quot;</span>)));</span><br><span class=\"line\">chain.process(<span class=\"keyword\">new</span> <span class=\"type\">Request</span>(<span class=\"string\">&quot;John&quot;</span>, <span class=\"keyword\">new</span> <span class=\"type\">BigDecimal</span>(<span class=\"string\">&quot;123456.78&quot;</span>)));</span><br></pre></td></tr></table></figure>\n\n<p>责任链模式本身很容易理解，需要注意的是，<code>Handler</code>添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。</p>\n<p>此外，责任链模式有很多变种。有些责任链的实现方式是通过某个<code>Handler</code>手动调用下一个<code>Handler</code>来传递<code>Request</code>，例如：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">AHandler</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">Handler</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Handler next;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> process(Request request) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!canProcess(request)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 手动交给下一个Handler处理:</span></span><br><span class=\"line\">            next.process(request);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>还有一些责任链模式，每个<code>Handler</code>都有机会处理<code>Request</code>，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个<code>Handler</code>处理掉<code>Request</code>，而是每个<code>Handler</code>都做一些工作，比如：</p>\n<ul>\n<li>记录日志；</li>\n<li>检查权限；</li>\n<li>准备相关资源；</li>\n<li>…</li>\n</ul>\n<p>例如，JavaEE的Servlet规范定义的<code>Filter</code>就是一种责任链模式，它不但允许每个<code>Filter</code>都有机会处理请求，还允许每个<code>Filter</code>决定是否将请求“放行”给下一个<code>Filter</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> AuditFilter implements Filter &#123;</span><br><span class=\"line\">    public void <span class=\"keyword\">do</span><span class=\"constructor\">Filter(ServletRequest <span class=\"params\">req</span>, ServletResponse <span class=\"params\">resp</span>, FilterChain <span class=\"params\">chain</span>)</span> throws IOException, ServletException &#123;</span><br><span class=\"line\">        log(req);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check(req)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 放行:</span></span><br><span class=\"line\">            chain.<span class=\"keyword\">do</span><span class=\"constructor\">Filter(<span class=\"params\">req</span>, <span class=\"params\">resp</span>)</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 拒绝:</span></span><br><span class=\"line\">            send<span class=\"constructor\">Error(<span class=\"params\">resp</span>)</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种模式不但允许一个<code>Filter</code>自行决定处理<code>ServletRequest</code>和<code>ServletResponse</code>，还可以“伪造”<code>ServletRequest</code>和<code>ServletResponse</code>以便让下一个<code>Filter</code>处理，能实现非常复杂的功能。</p>\n<h2 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h2><blockquote>\n<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>\n</blockquote>\n<p>命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。</p>\n<p>在使用命令模式前，我们先以一个编辑器为例子，看看如何实现简单的编辑操作：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextEditor</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringBuilder buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">StringBuilder</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">copy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">paste</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> text = <span class=\"built_in\">getFromClipBoard</span>();</span><br><span class=\"line\">        <span class=\"built_in\">add</span>(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">String</span> s)</span> </span>&#123;</span><br><span class=\"line\">        buffer.<span class=\"built_in\">append</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffer.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            buffer.<span class=\"built_in\">deleteCharAt</span>(buffer.<span class=\"built_in\">length</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">String</span> <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buffer.<span class=\"built_in\">toString</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们用一个<code>StringBuilder</code>模拟一个文本编辑器，它支持<code>copy()</code>、<code>paste()</code>、<code>add()</code>、<code>delete()</code>等方法。</p>\n<p>正常情况，我们像这样调用<code>TextEditor</code>：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">TextEditor editor = new TextEditor()<span class=\"comment\">;</span></span><br><span class=\"line\">editor.add(<span class=\"string\">&quot;Command pattern in text editor.\\n&quot;</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">editor.copy()<span class=\"comment\">;</span></span><br><span class=\"line\">editor.paste()<span class=\"comment\">;</span></span><br><span class=\"line\">System.out.println(editor.getState())<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>这是直接调用方法，调用方需要了解<code>TextEditor</code>的所有接口信息。</p>\n<p>如果改用命令模式，我们就要把调用方发送命令和执行方执行命令分开。怎么分？</p>\n<p>解决方案是引入一个<code>Command</code>接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用方创建一个对应的<code>Command</code>，然后执行，并不关心内部是如何具体执行的。</p>\n<p>为了支持<code>CopyCommand</code>和<code>PasteCommand</code>这两个命令，我们从<code>Command</code>接口派生：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CopyCommand</span> <span class=\"keyword\">implements</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 持有执行者对象:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextEditor receiver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CopyCommand</span><span class=\"params\">(TextEditor receiver)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.receiver = receiver;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        receiver.copy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PasteCommand</span> <span class=\"keyword\">implements</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextEditor receiver;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PasteCommand</span><span class=\"params\">(TextEditor receiver)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.receiver = receiver;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        receiver.paste();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后我们把<code>Command</code>和<code>TextEditor</code>组装一下，客户端这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">TextEditor editor = <span class=\"keyword\">new</span> <span class=\"constructor\">TextEditor()</span>;</span><br><span class=\"line\">editor.add(<span class=\"string\">&quot;Command pattern in text editor.\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 执行一个CopyCommand:</span></span><br><span class=\"line\">Command copy = <span class=\"keyword\">new</span> <span class=\"constructor\">CopyCommand(<span class=\"params\">editor</span>)</span>;</span><br><span class=\"line\">copy.execute<span class=\"literal\">()</span>;</span><br><span class=\"line\">editor.add(<span class=\"string\">&quot;----\\n&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 执行一个PasteCommand:</span></span><br><span class=\"line\">Command paste = <span class=\"keyword\">new</span> <span class=\"constructor\">PasteCommand(<span class=\"params\">editor</span>)</span>;</span><br><span class=\"line\">paste.execute<span class=\"literal\">()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(editor.get<span class=\"constructor\">State()</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这就是命令模式的结构：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌──────┐      ┌───────┐</span><br><span class=\"line\">│Client│─ ─ ─&gt;│Command│</span><br><span class=\"line\">└──────┘      └───────┘</span><br><span class=\"line\">                  │  ┌──────────────┐</span><br><span class=\"line\">                  ├─&gt;│ CopyCommand  │</span><br><span class=\"line\">                  │  ├──────────────┤</span><br><span class=\"line\">                  │  │editor.copy() │─ ┐</span><br><span class=\"line\">                  │  └──────────────┘</span><br><span class=\"line\">                  │                    │  ┌────────────┐</span><br><span class=\"line\">                  │  ┌──────────────┐   ─&gt;│ TextEditor │</span><br><span class=\"line\">                  └─&gt;│ PasteCommand │  │  └────────────┘</span><br><span class=\"line\">                     ├──────────────┤</span><br><span class=\"line\">                     │editor.paste()│─ ┘</span><br><span class=\"line\">                     └──────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>有的童鞋会有疑问：搞了一大堆<code>Command</code>，多了好几个类，还不如直接这么写简单：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">TextEditor editor = new TextEditor()<span class=\"comment\">;</span></span><br><span class=\"line\">editor.add(<span class=\"string\">&quot;Command pattern in text editor.\\n&quot;</span>)<span class=\"comment\">;</span></span><br><span class=\"line\">editor.copy()<span class=\"comment\">;</span></span><br><span class=\"line\">editor.paste()<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上，使用命令模式，确实增加了系统的复杂度。如果需求很简单，那么直接调用显然更直观而且更简单。</p>\n<p>那么我们还需要命令模式吗？</p>\n<p>答案是视需求而定。如果<code>TextEditor</code>复杂到一定程度，并且需要支持Undo、Redo的功能时，就需要使用命令模式，因为我们可以给每个命令增加<code>undo()</code>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Command</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">undo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后把执行的一系列命令用<code>List</code>保存起来，就既能支持Undo，又能支持Redo。这个时候，我们又需要一个<code>Invoker</code>对象，负责执行命令并保存历史命令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────┐</span><br><span class=\"line\">│   Client    │</span><br><span class=\"line\">└─────────────┘</span><br><span class=\"line\">       │</span><br><span class=\"line\"></span><br><span class=\"line\">       │</span><br><span class=\"line\">       ▼</span><br><span class=\"line\">┌─────────────┐</span><br><span class=\"line\">│   Invoker   │</span><br><span class=\"line\">├─────────────┤    ┌───────┐</span><br><span class=\"line\">│List commands│─ ─&gt;│Command│</span><br><span class=\"line\">│invoke(c)    │    └───────┘</span><br><span class=\"line\">│undo()       │        │  ┌──────────────┐</span><br><span class=\"line\">└─────────────┘        ├─&gt;│ CopyCommand  │</span><br><span class=\"line\">                       │  ├──────────────┤</span><br><span class=\"line\">                       │  │editor.copy() │─ ┐</span><br><span class=\"line\">                       │  └──────────────┘</span><br><span class=\"line\">                       │                    │  ┌────────────┐</span><br><span class=\"line\">                       │  ┌──────────────┐   ─&gt;│ TextEditor │</span><br><span class=\"line\">                       └─&gt;│ PasteCommand │  │  └────────────┘</span><br><span class=\"line\">                          ├──────────────┤</span><br><span class=\"line\">                          │editor.paste()│─ ┘</span><br><span class=\"line\">                          └──────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>可见，模式带来的设计复杂度的增加是随着需求而增加的，它减少的是系统各组件的耦合度。</p>\n<h2 id=\"解释器模式\"><a href=\"#解释器模式\" class=\"headerlink\" title=\"解释器模式\"></a>解释器模式</h2><blockquote>\n<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>\n</blockquote>\n<p>解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件：</p>\n<ul>\n<li>以<code>+</code>开头的数字表示的区号和电话号码，如<code>+861012345678</code>；</li>\n<li>以英文开头，后接英文和数字，并以.分隔的域名，如<code>www.liaoxuefeng.com</code>；</li>\n<li>以<code>/</code>开头的文件路径，如<code>/path/to/file.txt</code>；</li>\n<li>…</li>\n</ul>\n<p>因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p>\n<p>实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p>\n<figure class=\"highlight abnf\"><table><tr><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">&quot;+861012345678&quot;</span><span class=\"comment\">;</span></span><br><span class=\"line\">System.out.println(s.matches(<span class=\"string\">&quot;^\\\\+\\\\d+$&quot;</span>))<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n\n<p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p>\n<h2 id=\"迭代器模式\"><a href=\"#迭代器模式\" class=\"headerlink\" title=\"迭代器模式\"></a>迭代器模式</h2><blockquote>\n<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>\n</blockquote>\n<p>迭代器模式（Iterator）实际上在Java的集合类中已经广泛使用了。我们以<code>List</code>为例，要遍历<code>ArrayList</code>，即使我们知道它的内部存储了一个<code>Object[]</code>数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用<code>Iterator</code>遍历，那么，<code>ArrayList</code>和<code>LinkedList</code>都可以以一种统一的接口来遍历：</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;<span class=\"built_in\">String</span>&gt; <span class=\"keyword\">list</span> = ...</span><br><span class=\"line\"><span class=\"keyword\">for</span> (Iterator&lt;<span class=\"built_in\">String</span>&gt; <span class=\"literal\">it</span> = <span class=\"keyword\">list</span>.iterator(); <span class=\"literal\">it</span>.hasNext(); ) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">String</span> s = <span class=\"literal\">it</span>.next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际上，因为Iterator模式十分有用，因此，Java允许我们直接把任何支持<code>Iterator</code>的集合对象用<code>foreach</code>循环写出来：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">List</span>&lt;<span class=\"built_in\">String</span>&gt; <span class=\"built_in\">list</span> = <span class=\"params\">...</span></span><br><span class=\"line\">for (<span class=\"built_in\">String</span> s : <span class=\"built_in\">list</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后由Java编译器完成Iterator模式的所有循环代码。</p>\n<p>虽然我们对如何使用Iterator有了一定了解，但如何实现一个Iterator模式呢？我们以一个自定义的集合为例，通过Iterator模式实现倒序遍历：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">ReverseArrayCollection</span>&lt;<span class=\"symbol\">T</span>&gt; <span class=\"symbol\">implements</span> <span class=\"symbol\">Iterable</span>&lt;<span class=\"symbol\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 以数组形式持有集合:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> T[] <span class=\"built_in\">array</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ReverseArrayCollection(T... objs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"built_in\">array</span> = Arrays.copyOfRange(objs, <span class=\"number\">0</span>, objs.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Iterator&lt;T&gt; iterator() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ???;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现Iterator模式的关键是返回一个<code>Iterator</code>对象，该对象知道集合的内部结构，因为它可以实现倒序遍历。我们使用Java的内部类实现这个<code>Iterator</code>：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">ReverseArrayCollection</span>&lt;<span class=\"symbol\">T</span>&gt; <span class=\"symbol\">implements</span> <span class=\"symbol\">Iterable</span>&lt;<span class=\"symbol\">T</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T[] <span class=\"built_in\">array</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ReverseArrayCollection(T... objs) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.<span class=\"built_in\">array</span> = Arrays.copyOfRange(objs, <span class=\"number\">0</span>, objs.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Iterator&lt;T&gt; iterator() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> new ReverseIterator();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"symbol\">ReverseIterator</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">Iterator</span>&lt;<span class=\"symbol\">T</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 索引位置:</span></span><br><span class=\"line\">        <span class=\"built_in\">int</span> index;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> ReverseIterator() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 创建Iterator时,索引在数组末尾:</span></span><br><span class=\"line\">            <span class=\"keyword\">this</span>.index = ReverseArrayCollection.<span class=\"keyword\">this</span>.<span class=\"built_in\">array</span>.length;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"built_in\">bool</span>ean hasNext() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> index &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> T next() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 将索引移动到下一个元素并返回(倒序往前移动):</span></span><br><span class=\"line\">            index--;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">array</span>[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用内部类的好处是内部类隐含地持有一个它所在对象的<code>this</code>引用，可以通过<code>ReverseArrayCollection.this</code>引用到它所在的集合。上述代码实现的逻辑非常简单，但是实际应用时，如果考虑到多线程访问，当一个线程正在迭代某个集合，而另一个线程修改了集合的内容时，是否能继续安全地迭代，还是抛出<code>ConcurrentModificationException</code>，就需要更仔细地设计。</p>\n<h2 id=\"中介模式\"><a href=\"#中介模式\" class=\"headerlink\" title=\"中介模式\"></a>中介模式</h2><blockquote>\n<p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>\n</blockquote>\n<p>中介模式（Mediator）又称调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p>\n<p>有些童鞋听到中介立刻想到房产中介，立刻气不打一处来。这个中介模式与房产中介还真有点像，所以消消气，先看例子。</p>\n<p>考虑一个简单的点餐输入：</p>\n<p> 汉堡</p>\n<p> 鸡块</p>\n<p> 薯条</p>\n<p> 咖啡</p>\n<p>选择全部 取消所有 反选</p>\n<p>这个小系统有4个参与对象：</p>\n<ul>\n<li>多选框；</li>\n<li>“选择全部”按钮；</li>\n<li>“取消所有”按钮；</li>\n<li>“反选”按钮。</li>\n</ul>\n<p>它的复杂性在于，当多选框变化时，它会影响“选择全部”和“取消所有”按钮的状态（是否可点击），当用户点击某个按钮时，例如“反选”，除了会影响多选框的状态，它又可能影响“选择全部”和“取消所有”按钮的状态。</p>\n<p>所以这是一个多方会谈，逻辑写起来很复杂：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────────────┐     ┌─────────────────┐</span><br><span class=\"line\">│  CheckBox List  │&lt;───&gt;│SelectAll Button │</span><br><span class=\"line\">└─────────────────┘     └─────────────────┘</span><br><span class=\"line\">         ▲ ▲                     ▲</span><br><span class=\"line\">         │ └─────────────────────┤</span><br><span class=\"line\">         ▼                       │</span><br><span class=\"line\">┌─────────────────┐     ┌────────┴────────┐</span><br><span class=\"line\">│SelectNone Button│&lt;────│ Inverse Button  │</span><br><span class=\"line\">└─────────────────┘     └─────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>如果我们引入一个中介，把多方会谈变成多个双方会谈，虽然多了一个对象，但对象之间的关系就变简单了：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">            ┌─────────────────┐</span><br><span class=\"line\">     ┌─────&gt;│  CheckBox List  │</span><br><span class=\"line\">     │      └─────────────────┘</span><br><span class=\"line\">     │      ┌─────────────────┐</span><br><span class=\"line\">     │ ┌───&gt;│SelectAll Button │</span><br><span class=\"line\">     ▼ ▼    └─────────────────┘</span><br><span class=\"line\">┌─────────┐</span><br><span class=\"line\">│Mediator │</span><br><span class=\"line\">└─────────┘</span><br><span class=\"line\">     ▲ ▲    ┌─────────────────┐</span><br><span class=\"line\">     │ └───&gt;│SelectNone Button│</span><br><span class=\"line\">     │      └─────────────────┘</span><br><span class=\"line\">     │      ┌─────────────────┐</span><br><span class=\"line\">     └─────&gt;│ Inverse Button  │</span><br><span class=\"line\">            └─────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>下面我们用中介模式来实现各个UI组件的交互。首先把UI组件给画出来：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> Main &#123;</span><br><span class=\"line\">    public static void main(String<span class=\"literal\">[]</span> args) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"constructor\">OrderFrame(<span class=\"string\">&quot;Hanburger&quot;</span>, <span class=\"string\">&quot;Nugget&quot;</span>, <span class=\"string\">&quot;Chip&quot;</span>, <span class=\"string\">&quot;Coffee&quot;</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> OrderFrame extends JFrame &#123;</span><br><span class=\"line\">    public <span class=\"constructor\">OrderFrame(String<span class=\"operator\">...</span> <span class=\"params\">names</span>)</span> &#123;</span><br><span class=\"line\">        set<span class=\"constructor\">Title(<span class=\"string\">&quot;Order&quot;</span>)</span>;</span><br><span class=\"line\">        set<span class=\"constructor\">Size(460, 200)</span>;</span><br><span class=\"line\">        set<span class=\"constructor\">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class=\"line\">        Container c = get<span class=\"constructor\">ContentPane()</span>;</span><br><span class=\"line\">        c.set<span class=\"constructor\">Layout(<span class=\"params\">new</span> FlowLayout(FlowLayout.LEADING, 20, 20)</span>);</span><br><span class=\"line\">        c.add(<span class=\"keyword\">new</span> <span class=\"constructor\">JLabel(<span class=\"string\">&quot;Use Mediator Pattern&quot;</span>)</span>);</span><br><span class=\"line\">        List&lt;JCheckBox&gt; checkboxList = add<span class=\"constructor\">CheckBox(<span class=\"params\">names</span>)</span>;</span><br><span class=\"line\">        JButton selectAll = add<span class=\"constructor\">Button(<span class=\"string\">&quot;Select All&quot;</span>)</span>;</span><br><span class=\"line\">        JButton selectNone = add<span class=\"constructor\">Button(<span class=\"string\">&quot;Select None&quot;</span>)</span>;</span><br><span class=\"line\">        selectNone.set<span class=\"constructor\">Enabled(<span class=\"params\">false</span>)</span>;</span><br><span class=\"line\">        JButton selectInverse = add<span class=\"constructor\">Button(<span class=\"string\">&quot;Inverse Select&quot;</span>)</span>;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"constructor\">Mediator(<span class=\"params\">checkBoxList</span>, <span class=\"params\">selectAll</span>, <span class=\"params\">selectNone</span>, <span class=\"params\">selectInverse</span>)</span>;</span><br><span class=\"line\">        set<span class=\"constructor\">Visible(<span class=\"params\">true</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;JCheckBox&gt; add<span class=\"constructor\">CheckBox(String<span class=\"operator\">...</span> <span class=\"params\">names</span>)</span> &#123;</span><br><span class=\"line\">        JPanel panel = <span class=\"keyword\">new</span> <span class=\"constructor\">JPanel()</span>;</span><br><span class=\"line\">        panel.add(<span class=\"keyword\">new</span> <span class=\"constructor\">JLabel(<span class=\"string\">&quot;Menu:&quot;</span>)</span>);</span><br><span class=\"line\">        List&lt;JCheckBox&gt; <span class=\"built_in\">list</span> = <span class=\"keyword\">new</span> ArrayList&lt;&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String name : names) &#123;</span><br><span class=\"line\">            JCheckBox checkbox = <span class=\"keyword\">new</span> <span class=\"constructor\">JCheckBox(<span class=\"params\">name</span>)</span>;</span><br><span class=\"line\">            <span class=\"built_in\">list</span>.add(checkbox);</span><br><span class=\"line\">            panel.add(checkbox);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        get<span class=\"constructor\">ContentPane()</span>.add(panel);</span><br><span class=\"line\">        return <span class=\"built_in\">list</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JButton add<span class=\"constructor\">Button(String <span class=\"params\">label</span>)</span> &#123;</span><br><span class=\"line\">        JButton button = <span class=\"keyword\">new</span> <span class=\"constructor\">JButton(<span class=\"params\">label</span>)</span>;</span><br><span class=\"line\">        get<span class=\"constructor\">ContentPane()</span>.add(button);</span><br><span class=\"line\">        return button;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们设计一个Mediator类，它引用4个UI组件，并负责跟它们交互：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mediator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 引用UI组件:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;JCheckBox&gt; checkBoxList;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> JButton selectAll;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> JButton selectNone;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> JButton selectInverse;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"title\">Mediator</span>(<span class=\"params\">List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.checkBoxList = checkBoxList;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.selectAll = selectAll;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.selectNone = selectNone;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.selectInverse = selectInverse;</span><br><span class=\"line\">        <span class=\"comment\">// 绑定事件:</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.checkBoxList.forEach(checkBox -&gt; &#123;</span><br><span class=\"line\">            checkBox.addChangeListener(<span class=\"built_in\">this</span>::onCheckBoxChanged);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.selectAll.addActionListener(<span class=\"built_in\">this</span>::onSelectAllClicked);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.selectNone.addActionListener(<span class=\"built_in\">this</span>::onSelectNoneClicked);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.selectInverse.addActionListener(<span class=\"built_in\">this</span>::onSelectInverseClicked);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当checkbox有变化时:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">onCheckBoxChanged</span>(<span class=\"params\">ChangeEvent event</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">boolean</span> allChecked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"built_in\">boolean</span> allUnchecked = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> checkBox : checkBoxList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (checkBox.isSelected()) &#123;</span><br><span class=\"line\">                allUnchecked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                allChecked = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        selectAll.setEnabled(!allChecked);</span><br><span class=\"line\">        selectNone.setEnabled(!allUnchecked);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当点击select all:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">onSelectAllClicked</span>(<span class=\"params\">ActionEvent event</span>)</span> &#123;</span><br><span class=\"line\">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class=\"literal\">true</span>));</span><br><span class=\"line\">        selectAll.setEnabled(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        selectNone.setEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当点击select none:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">onSelectNoneClicked</span>(<span class=\"params\">ActionEvent event</span>)</span> &#123;</span><br><span class=\"line\">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class=\"literal\">false</span>));</span><br><span class=\"line\">        selectAll.setEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        selectNone.setEnabled(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 当点击select inverse:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">onSelectInverseClicked</span>(<span class=\"params\">ActionEvent event</span>)</span> &#123;</span><br><span class=\"line\">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));</span><br><span class=\"line\">        onCheckBoxChanged(<span class=\"literal\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行一下看看效果：</p>\n<p><img src=\"/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189660629622.png\" alt=\"mediator\"></p>\n<p>使用Mediator模式后，我们得到了以下好处：</p>\n<ul>\n<li>各个UI组件互不引用，这样就减少了组件之间的耦合关系；</li>\n<li>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件；</li>\n<li>如果新增一个UI组件，我们只需要修改Mediator更新状态的逻辑，现有的其他UI组件代码不变。</li>\n</ul>\n<p>Mediator模式经常用在有众多交互组件的UI上。为了简化UI程序，MVC模式以及MVVM模式都可以看作是Mediator模式的扩展。</p>\n<h2 id=\"备忘录模式\"><a href=\"#备忘录模式\" class=\"headerlink\" title=\"备忘录模式\"></a>备忘录模式</h2><blockquote>\n<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>\n</blockquote>\n<p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p>\n<p>其实我们使用的几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。对于文本编辑器来说，保存就是把<code>TextEditor</code>类的字符串存储到文件，打开就是恢复<code>TextEditor</code>类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。</p>\n<p>在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把<code>TextEditor</code>类的字符串复制一份存起来，这样就可以Undo或Redo。</p>\n<p>标准的备忘录模式有这么几种角色：</p>\n<ul>\n<li>Memonto：存储的内部状态；</li>\n<li>Originator：创建一个备忘录并设置其状态；</li>\n<li>Caretaker：负责保存备忘录。</li>\n</ul>\n<p>实际上我们在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似<code>TextEditor</code>的类，增加<code>getState()</code>和<code>setState()</code>就可以了。</p>\n<p>我们以一个文本编辑器<code>TextEditor</code>为例，它内部使用<code>StringBuilder</code>允许用户增删字符：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextEditor</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StringBuilder buffer = <span class=\"keyword\">new</span> <span class=\"built_in\">StringBuilder</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">char</span> ch)</span> </span>&#123;</span><br><span class=\"line\">        buffer.<span class=\"built_in\">append</span>(ch);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">String</span> s)</span> </span>&#123;</span><br><span class=\"line\">        buffer.<span class=\"built_in\">append</span>(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buffer.<span class=\"built_in\">length</span>() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            buffer.<span class=\"built_in\">deleteCharAt</span>(buffer.<span class=\"built_in\">length</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>为了支持这个<code>TextEditor</code>能保存和恢复状态，我们增加<code>getState()</code>和<code>setState()</code>两个方法：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextEditor</span> &#123;</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取状态:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">String</span> <span class=\"title\">getState</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> buffer.<span class=\"built_in\">toString</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 恢复状态:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">String</span> state)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.buffer.<span class=\"built_in\"><span class=\"keyword\">delete</span></span>(<span class=\"number\">0</span>, <span class=\"keyword\">this</span>.buffer.<span class=\"built_in\">length</span>());</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.buffer.<span class=\"built_in\">append</span>(state);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对这个简单的文本编辑器，用一个<code>String</code>就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><blockquote>\n<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>\n</blockquote>\n<p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub&#x2F;Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p>\n<p>要理解观察者模式，我们还是看例子。</p>\n<p>假设一个电商网站，有多种<code>Product</code>（商品），同时，<code>Customer</code>（消费者）和<code>Admin</code>（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，<code>Store</code>（商场）可以这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> Store &#123;</span><br><span class=\"line\">    Customer customer;</span><br><span class=\"line\">    Admin admin;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Product&gt; products = <span class=\"keyword\">new</span> HashMap&lt;&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void add<span class=\"constructor\">NewProduct(String <span class=\"params\">name</span>, <span class=\"params\">double</span> <span class=\"params\">price</span>)</span> &#123;</span><br><span class=\"line\">        Product p = <span class=\"keyword\">new</span> <span class=\"constructor\">Product(<span class=\"params\">name</span>, <span class=\"params\">price</span>)</span>;</span><br><span class=\"line\">        products.put(p.get<span class=\"constructor\">Name()</span>, p);</span><br><span class=\"line\">        <span class=\"comment\">// 通知用户:</span></span><br><span class=\"line\">        customer.on<span class=\"constructor\">Published(<span class=\"params\">p</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 通知管理员:</span></span><br><span class=\"line\">        admin.on<span class=\"constructor\">Published(<span class=\"params\">p</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void set<span class=\"constructor\">ProductPrice(String <span class=\"params\">name</span>, <span class=\"params\">double</span> <span class=\"params\">price</span>)</span> &#123;</span><br><span class=\"line\">        Product p = products.get(name);</span><br><span class=\"line\">        p.set<span class=\"constructor\">Price(<span class=\"params\">price</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 通知用户:</span></span><br><span class=\"line\">        customer.on<span class=\"constructor\">PriceChanged(<span class=\"params\">p</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 通知管理员:</span></span><br><span class=\"line\">        admin.on<span class=\"constructor\">PriceChanged(<span class=\"params\">p</span>)</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们观察上述<code>Store</code>类的问题：它直接引用了<code>Customer</code>和<code>Admin</code>。先不考虑多个<code>Customer</code>或多个<code>Admin</code>的问题，上述<code>Store</code>类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，<code>Store</code>类就必须继续改动。</p>\n<p>因此，上述问题的本质是<code>Store</code>希望发送通知给那些关心<code>Product</code>的对象，但<code>Store</code>并不想知道这些人是谁。观察者模式就是要分离被观察者和观察者之间的耦合关系。</p>\n<p>要实现这一目标也很简单，<code>Store</code>不能直接引用<code>Customer</code>和<code>Admin</code>，相反，它引用一个<code>ProductObserver</code>接口，任何人想要观察<code>Store</code>，只要实现该接口，并且把自己注册到<code>Store</code>即可：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> Store &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;ProductObserver&gt; observers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Map&lt;String, Product&gt; products = <span class=\"keyword\">new</span> HashMap&lt;&gt;<span class=\"literal\">()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 注册观察者:</span></span><br><span class=\"line\">    public void add<span class=\"constructor\">Observer(ProductObserver <span class=\"params\">observer</span>)</span> &#123;</span><br><span class=\"line\">        this.observers.add(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 取消注册:</span></span><br><span class=\"line\">    public void remove<span class=\"constructor\">Observer(ProductObserver <span class=\"params\">observer</span>)</span> &#123;</span><br><span class=\"line\">        this.observers.remove(observer);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void add<span class=\"constructor\">NewProduct(String <span class=\"params\">name</span>, <span class=\"params\">double</span> <span class=\"params\">price</span>)</span> &#123;</span><br><span class=\"line\">        Product p = <span class=\"keyword\">new</span> <span class=\"constructor\">Product(<span class=\"params\">name</span>, <span class=\"params\">price</span>)</span>;</span><br><span class=\"line\">        products.put(p.get<span class=\"constructor\">Name()</span>, p);</span><br><span class=\"line\">        <span class=\"comment\">// 通知观察者:</span></span><br><span class=\"line\">        observers.<span class=\"keyword\">for</span><span class=\"constructor\">Each(<span class=\"params\">o</span> -&gt; <span class=\"params\">o</span>.<span class=\"params\">onPublished</span>(<span class=\"params\">p</span>)</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public void set<span class=\"constructor\">ProductPrice(String <span class=\"params\">name</span>, <span class=\"params\">double</span> <span class=\"params\">price</span>)</span> &#123;</span><br><span class=\"line\">        Product p = products.get(name);</span><br><span class=\"line\">        p.set<span class=\"constructor\">Price(<span class=\"params\">price</span>)</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 通知观察者:</span></span><br><span class=\"line\">        observers.<span class=\"keyword\">for</span><span class=\"constructor\">Each(<span class=\"params\">o</span> -&gt; <span class=\"params\">o</span>.<span class=\"params\">onPriceChanged</span>(<span class=\"params\">p</span>)</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>就是这么一个小小的改动，使得观察者类型就可以无限扩充，而且，观察者的定义可以放到客户端：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// observer:</span></span><br><span class=\"line\">Admin a = <span class=\"keyword\">new</span> <span class=\"constructor\">Admin()</span>;</span><br><span class=\"line\">Customer c = <span class=\"keyword\">new</span> <span class=\"constructor\">Customer()</span>;</span><br><span class=\"line\"><span class=\"comment\">// store:</span></span><br><span class=\"line\">Store store = <span class=\"keyword\">new</span> <span class=\"constructor\">Store()</span>;</span><br><span class=\"line\"><span class=\"comment\">// 注册观察者:</span></span><br><span class=\"line\">store.add<span class=\"constructor\">Observer(<span class=\"params\">a</span>)</span>;</span><br><span class=\"line\">store.add<span class=\"constructor\">Observer(<span class=\"params\">c</span>)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>甚至可以注册匿名观察者：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\">store.addObserver(<span class=\"keyword\">new</span> <span class=\"function\"><span class=\"title\">ProductObserver</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">onPublished</span>(<span class=\"params\">Product product</span>)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[Log] on product published: &quot;</span> + product);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">onPriceChanged</span>(<span class=\"params\">Product product</span>)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;[Log] on product price changed: &quot;</span> + product);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>用一张图画出观察者模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌─────────┐      ┌───────────────┐</span><br><span class=\"line\">│  Store  │─ ─ ─&gt;│ProductObserver│</span><br><span class=\"line\">└─────────┘      └───────────────┘</span><br><span class=\"line\">     │                   ▲</span><br><span class=\"line\">                         │</span><br><span class=\"line\">     │             ┌─────┴─────┐</span><br><span class=\"line\">     ▼             │           │</span><br><span class=\"line\">┌─────────┐   ┌─────────┐ ┌─────────┐</span><br><span class=\"line\">│ Product │   │  Admin  │ │Customer │ ...</span><br><span class=\"line\">└─────────┘   └─────────┘ └─────────┘</span><br></pre></td></tr></table></figure>\n\n<p>观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ProductObservable</span> </span>&#123; <span class=\"comment\">// 注意此处拼写是Observable不是Observer!</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addObserver</span><span class=\"params\">(ProductObserver observer)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(ProductObserver observer)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对应的实体被观察者就要实现该接口：</p>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"symbol\">Store</span> <span class=\"symbol\">implements</span> <span class=\"symbol\">ProductObservable</span> &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">ProductObserver</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onEvent</span>(<span class=\"params\">ProductEvent <span class=\"keyword\">event</span></span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>让观察者自己从Event对象中读取通知类型和通知数据。</p>\n<p>广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class=\"line\">                   Messaging System</span><br><span class=\"line\">                 │                       │</span><br><span class=\"line\">                   ┌──────────────────┐</span><br><span class=\"line\">              ┌──┼&gt;│Topic:newProduct  │──┼─┐    ┌─────────┐</span><br><span class=\"line\">              │    └──────────────────┘    ├───&gt;│ConsumerA│</span><br><span class=\"line\">┌─────────┐   │  │ ┌──────────────────┐  │ │    └─────────┘</span><br><span class=\"line\">│Producer │───┼───&gt;│Topic:priceChanged│────┘</span><br><span class=\"line\">└─────────┘   │  │ └──────────────────┘  │</span><br><span class=\"line\">              │    ┌──────────────────┐         ┌─────────┐</span><br><span class=\"line\">              └──┼&gt;│Topic:soldOut     │──┼─────&gt;│ConsumerB│</span><br><span class=\"line\">                   └──────────────────┘         └─────────┘</span><br><span class=\"line\">                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>\n\n<p>消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。</p>\n<p>使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。</p>\n<p>此外，注意到我们在编写观察者模式的时候，通知Observer是依靠语句：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">observers.<span class=\"keyword\">for</span><span class=\"constructor\">Each(<span class=\"params\">o</span> -&gt; <span class=\"params\">o</span>.<span class=\"params\">onPublished</span>(<span class=\"params\">p</span>)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>这说明各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</p>\n<p>思考：如何改成异步通知，使得所有观察者可以并发同时处理？</p>\n<p>有的童鞋可能发现Java标准库有个<code>java.util.Observable</code>类和一个<code>Observer</code>接口，用来帮助我们实现观察者模式。但是，这个类非常不！好！用！实现观察者模式的时候，也不推荐借助这两个东东。</p>\n<h2 id=\"状态模式\"><a href=\"#状态模式\" class=\"headerlink\" title=\"状态模式\"></a>状态模式</h2><blockquote>\n<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>\n</blockquote>\n<p>状态模式（State）经常用在带有状态的对象中。</p>\n<p>什么是状态？我们以QQ聊天为例，一个用户的QQ有几种状态：</p>\n<ul>\n<li>离线状态（尚未登录）；</li>\n<li>正在登录状态；</li>\n<li>在线状态；</li>\n<li>忙状态（暂时离开）。</li>\n</ul>\n<p>如何表示状态？我们定义一个<code>enum</code>就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (<span class=\"keyword\">state</span> == ONLINE) &#123;</span><br><span class=\"line\">    // 闪烁图标</span><br><span class=\"line\">&#125; else if (<span class=\"keyword\">state</span> == BUSY) &#123;</span><br><span class=\"line\">    reply(<span class=\"string\">&quot;现在忙，稍后回复&quot;</span>);</span><br><span class=\"line\">&#125; else if ...</span><br></pre></td></tr></table></figure>\n\n<p>状态模式的目的是为了把上述一大串<code>if...else...</code>的逻辑给分拆到不同的状态类中，使得将来增加状态比较容易。</p>\n<p>例如，我们设计一个聊天机器人，它有两个状态：</p>\n<ul>\n<li>未连线；</li>\n<li>已连线。</li>\n</ul>\n<p>对于未连线状态，我们收到消息也不回复：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DisconnectedState</span> <span class=\"title\">implements</span> <span class=\"title\">State</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">init</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Bye!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">reply</span>(<span class=\"params\"><span class=\"built_in\">String</span> input</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对于已连线状态，我们回应收到的消息：</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">public</span> <span class=\"keyword\">class</span> ConnectedState implements State &#123;</span><br><span class=\"line\">    <span class=\"built_in\">public</span> String init() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &quot;Hello, I&#x27;m Bob.&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">public</span> String reply(String <span class=\"keyword\">input</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">input</span>.endsWith(&quot;?&quot;)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> &quot;Yes. &quot; + <span class=\"keyword\">input</span>.substring(<span class=\"number\">0</span>, <span class=\"keyword\">input</span>.length() - <span class=\"number\">1</span>) + &quot;!&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">input</span>.endsWith(&quot;.&quot;)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">input</span>.substring(<span class=\"number\">0</span>, <span class=\"keyword\">input</span>.length() - <span class=\"number\">1</span>) + &quot;!&quot;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">input</span>.substring(<span class=\"number\">0</span>, <span class=\"keyword\">input</span>.length() - <span class=\"number\">1</span>) + &quot;?&quot;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>状态模式的关键设计思想在于状态切换，我们引入一个<code>BotContext</code>完成状态切换：</p>\n<figure class=\"highlight pf\"><table><tr><td class=\"code\"><pre><span class=\"line\">public class BotContext &#123;</span><br><span class=\"line\">\tprivate State <span class=\"keyword\">state</span> = new DisconnectedState();</span><br><span class=\"line\"></span><br><span class=\"line\">\tpublic String chat(String input) &#123;</span><br><span class=\"line\">\t\tif (<span class=\"string\">&quot;hello&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class=\"line\">            // 收到hello切换到在线状态:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">state</span> = new ConnectedState();</span><br><span class=\"line\">\t\t\treturn <span class=\"keyword\">state</span>.init();</span><br><span class=\"line\">\t\t&#125; else if (<span class=\"string\">&quot;bye&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class=\"line\">            /  收到bye切换到离线状态:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">state</span> = new DisconnectedState();</span><br><span class=\"line\">\t\t\treturn <span class=\"keyword\">state</span>.init();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\treturn <span class=\"keyword\">state</span>.reply(input);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，一个价值千万的AI聊天机器人就诞生了：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">Scanner scanner = <span class=\"keyword\">new</span> <span class=\"constructor\">Scanner(System.<span class=\"params\">in</span>)</span>;</span><br><span class=\"line\">BotContext bot = <span class=\"keyword\">new</span> <span class=\"constructor\">BotContext()</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.print(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">    String input = scanner.next<span class=\"constructor\">Line()</span>;</span><br><span class=\"line\">    String output = bot.chat(input);</span><br><span class=\"line\">    <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(output.is<span class=\"constructor\">Empty()</span> ? <span class=\"string\">&quot;(no reply)&quot;</span> : <span class=\"string\">&quot;&lt; &quot;</span> + output);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>试试效果：</p>\n<figure class=\"highlight node-repl\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\">hello</span></span><br><span class=\"line\">&lt; Hello, I&#x27;m Bob.</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\">Nice to meet you.</span></span><br><span class=\"line\">&lt; Nice to meet you!</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\">Today is cold?</span></span><br><span class=\"line\">&lt; Yes. Today is cold!</span><br><span class=\"line\"><span class=\"meta\">&gt;</span> <span class=\"javascript\">bye</span></span><br><span class=\"line\">&lt; Bye!</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h2><blockquote>\n<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>\n</blockquote>\n<p>策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p>\n<p>策略模式在Java标准库中应用非常广泛，我们以排序为例，看看如何通过<code>Arrays.sort()</code>实现忽略大小写排序：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>如果我们想忽略大小写排序，就传入<code>String::compareToIgnoreCase</code>，如果我们想倒序排序，就传入<code>(s1, s2) -&gt; -s1.compareTo(s2)</code>，这个比较两个元素大小的算法就是策略。</p>\n<p>我们观察<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们传入的<code>Comparator</code>对象，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。</p>\n<p>因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。</p>\n<p>如果我们自己实现策略模式的排序，用冒泡法编写如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p>一个完整的策略模式要定义策略以及使用策略的上下文。我们以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">DiscountStrategy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 计算折扣额度:</span></span><br><span class=\"line\">    <span class=\"function\">BigDecimal <span class=\"title\">getDiscount</span><span class=\"params\">(BigDecimal total)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来，就是实现各种策略。普通用户策略如下：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDiscountStrategy</span> <span class=\"keyword\"><span class=\"keyword\">implements</span> <span class=\"type\">DiscountStrategy</span></span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> BigDecimal getDiscount(BigDecimal total) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 普通会员打九折:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> total.multiply(<span class=\"keyword\">new</span> <span class=\"type\">BigDecimal</span>(<span class=\"string\">&quot;0.1&quot;</span>)).setScale(<span class=\"number\">2</span>, RoundingMode.DOWN);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>满减策略如下：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">public <span class=\"keyword\">class</span> OverDiscountStrategy implements DiscountStrategy &#123;</span><br><span class=\"line\">    public BigDecimal get<span class=\"constructor\">Discount(BigDecimal <span class=\"params\">total</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 满100减20优惠:</span></span><br><span class=\"line\">        return total.compare<span class=\"constructor\">To(BigDecimal.<span class=\"params\">valueOf</span>(100)</span>) &gt;= <span class=\"number\">0</span> ? <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">BigDecimal</span>.</span></span>value<span class=\"constructor\">Of(20)</span> : BigDecimal.ZERO;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后，要应用策略，我们需要一个<code>DiscountContext</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DiscountContext</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 持有某个策略:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiscountStrategy strategy = <span class=\"keyword\">new</span> UserDiscountStrategy();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 允许客户端设置新策略:</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">setStrategy</span>(<span class=\"params\">DiscountStrategy strategy</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.strategy = strategy;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> BigDecimal <span class=\"function\"><span class=\"title\">calculatePrice</span>(<span class=\"params\">BigDecimal total</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> total.subtract(<span class=\"built_in\">this</span>.strategy.getDiscount(total)).setScale(<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>调用方必须首先创建一个DiscountContext，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">DiscountContext ctx = <span class=\"keyword\">new</span> <span class=\"constructor\">DiscountContext()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 默认使用普通会员折扣:</span></span><br><span class=\"line\">BigDecimal pay1 = ctx.calculate<span class=\"constructor\">Price(BigDecimal.<span class=\"params\">valueOf</span>(105)</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(pay1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用满减折扣:</span></span><br><span class=\"line\">ctx.set<span class=\"constructor\">Strategy(<span class=\"params\">new</span> OverDiscountStrategy()</span>);</span><br><span class=\"line\">BigDecimal pay2 = ctx.calculate<span class=\"constructor\">Price(BigDecimal.<span class=\"params\">valueOf</span>(105)</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(pay2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Prime会员折扣:</span></span><br><span class=\"line\">ctx.set<span class=\"constructor\">Strategy(<span class=\"params\">new</span> PrimeDiscountStrategy()</span>);</span><br><span class=\"line\">BigDecimal pay3 = ctx.calculate<span class=\"constructor\">Price(BigDecimal.<span class=\"params\">valueOf</span>(105)</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(pay3);</span><br></pre></td></tr></table></figure>\n\n<p>上述完整的策略模式如下图所示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">┌───────────────┐      ┌─────────────────┐</span><br><span class=\"line\">│DiscountContext│─ ─ ─&gt;│DiscountStrategy │</span><br><span class=\"line\">└───────────────┘      └─────────────────┘</span><br><span class=\"line\">                                ▲</span><br><span class=\"line\">                                │ ┌─────────────────────┐</span><br><span class=\"line\">                                ├─│UserDiscountStrategy │</span><br><span class=\"line\">                                │ └─────────────────────┘</span><br><span class=\"line\">                                │ ┌─────────────────────┐</span><br><span class=\"line\">                                ├─│PrimeDiscountStrategy│</span><br><span class=\"line\">                                │ └─────────────────────┘</span><br><span class=\"line\">                                │ ┌─────────────────────┐</span><br><span class=\"line\">                                └─│OverDiscountStrategy │</span><br><span class=\"line\">                                  └─────────────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。</p>\n<h2 id=\"模式方法模板\"><a href=\"#模式方法模板\" class=\"headerlink\" title=\"模式方法模板\"></a>模式方法模板</h2><blockquote>\n<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>\n</blockquote>\n<p>模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p>\n<p>因此，模板方法的核心在于定义一个“骨架”。我们还是举例说明。</p>\n<p>假设我们开发了一个从数据库读取设置的类：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Setting</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> final <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">getSetting</span>(<span class=\"params\"><span class=\"built_in\">String</span> key</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">String</span> value = readFromDatabase(key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">readFromDatabase</span>(<span class=\"params\"><span class=\"built_in\">String</span> key</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// <span class=\"doctag\">TODO:</span> 从数据库读取</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由于从数据库读取数据较慢，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库了。但是怎么实现缓存，暂时没想好，但不妨碍我们先写出使用缓存的代码：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> class Setting &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> getSetting(<span class=\"keyword\">String</span> <span class=\"built_in\">key</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 先从缓存读取:</span></span><br><span class=\"line\">        <span class=\"keyword\">String</span> value = lookupCache(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 在缓存中未找到,从数据库读取:</span></span><br><span class=\"line\">            value = readFromDatabase(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;[DEBUG] load from db: &quot;</span> + <span class=\"built_in\">key</span> + <span class=\"string\">&quot; = &quot;</span> + value);</span><br><span class=\"line\">            <span class=\"comment\">// 放入缓存:</span></span><br><span class=\"line\">            putIntoCache(<span class=\"built_in\">key</span>, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.<span class=\"built_in\">println</span>(<span class=\"string\">&quot;[DEBUG] load from cache: &quot;</span> + <span class=\"built_in\">key</span> + <span class=\"string\">&quot; = &quot;</span> + value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整个流程没有问题，但是，<code>lookupCache(key)</code>和<code>putIntoCache(key, value)</code>这两个方法还根本没实现，怎么编译通过？这个不要紧，我们声明抽象方法就可以：</p>\n<figure class=\"highlight processing\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> class AbstractSetting &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">String</span> getSetting(<span class=\"keyword\">String</span> <span class=\"built_in\">key</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">String</span> value = lookupCache(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            value = readFromDatabase(<span class=\"built_in\">key</span>);</span><br><span class=\"line\">            putIntoCache(<span class=\"built_in\">key</span>, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">String</span> lookupCache(<span class=\"keyword\">String</span> <span class=\"built_in\">key</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> putIntoCache(<span class=\"keyword\">String</span> <span class=\"built_in\">key</span>, <span class=\"keyword\">String</span> value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因为声明了抽象方法，自然整个类也必须是抽象类。如何实现<code>lookupCache(key)</code>和<code>putIntoCache(key, value)</code>这两个方法就交给子类了。子类其实并不关心核心代码<code>getSetting(key)</code>的逻辑，它只需要关心如何完成两个小小的子任务就可以了。</p>\n<p>假设我们希望用一个<code>Map</code>做缓存，那么可以写一个<code>LocalSetting</code>：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LocalSetting</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractSetting</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">Map</span>&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"built_in\">String</span> <span class=\"function\"><span class=\"title\">lookupCache</span>(<span class=\"params\"><span class=\"built_in\">String</span> key</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cache.get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> <span class=\"built_in\">void</span> <span class=\"function\"><span class=\"title\">putIntoCache</span>(<span class=\"params\"><span class=\"built_in\">String</span> key, <span class=\"built_in\">String</span> value</span>)</span> &#123;</span><br><span class=\"line\">        cache.put(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们要使用Redis做缓存，那么可以再写一个<code>RedisSetting</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisSetting</span> <span class=\"title\">extends</span> <span class=\"title\">AbstractSetting</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisClient client = RedisClient.<span class=\"built_in\">create</span>(<span class=\"string\">&quot;redis://localhost:6379&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">String</span> <span class=\"title\">lookupCache</span><span class=\"params\">(<span class=\"keyword\">String</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">try</span></span> (StatefulRedisConnection&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; connection = client.<span class=\"built_in\">connect</span>()) &#123;</span><br><span class=\"line\">            RedisCommands&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; commands = connection.<span class=\"built_in\">sync</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> commands.<span class=\"built_in\">get</span>(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">putIntoCache</span><span class=\"params\">(<span class=\"keyword\">String</span> key, <span class=\"keyword\">String</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">try</span></span> (StatefulRedisConnection&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; connection = client.<span class=\"built_in\">connect</span>()) &#123;</span><br><span class=\"line\">            RedisCommands&lt;<span class=\"keyword\">String</span>, <span class=\"keyword\">String</span>&gt; commands = connection.<span class=\"built_in\">sync</span>();</span><br><span class=\"line\">            commands.<span class=\"built_in\">set</span>(key, value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>客户端代码使用本地缓存的代码这么写：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">AbstractSetting setting1 = <span class=\"keyword\">new</span> <span class=\"constructor\">LocalSetting()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;test = &quot;</span> + setting1.get<span class=\"constructor\">Setting(<span class=\"string\">&quot;test&quot;</span>)</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;test = &quot;</span> + setting1.get<span class=\"constructor\">Setting(<span class=\"string\">&quot;test&quot;</span>)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>要改成Redis缓存，只需要把<code>LocalSetting</code>替换为<code>RedisSetting</code>：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"code\"><pre><span class=\"line\">AbstractSetting setting2 = <span class=\"keyword\">new</span> <span class=\"constructor\">RedisSetting()</span>;</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;autosave = &quot;</span> + setting2.get<span class=\"constructor\">Setting(<span class=\"string\">&quot;autosave&quot;</span>)</span>);</span><br><span class=\"line\"><span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">System</span>.</span></span>out.println(<span class=\"string\">&quot;autosave = &quot;</span> + setting2.get<span class=\"constructor\">Setting(<span class=\"string\">&quot;autosave&quot;</span>)</span>);</span><br></pre></td></tr></table></figure>\n\n<p>可见，模板方法的核心思想是：父类定义骨架，子类实现某些细节。</p>\n<p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用<code>final</code>。对于需要子类实现的抽象方法，一般声明为<code>protected</code>，使得这些方法对外部客户端不可见。</p>\n<p>Java标准库也有很多模板方法的应用。在集合类中，<code>AbstractList</code>和<code>AbstractQueuedSynchronizer</code>都定义了很多通用操作，子类只需要实现某些必要方法。</p>\n<h2 id=\"3-11-访问者模式\"><a href=\"#3-11-访问者模式\" class=\"headerlink\" title=\"3.11 访问者模式\"></a>3.11 访问者模式</h2><blockquote>\n<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>\n</blockquote>\n<p>访问者模式（Visitor）是一种操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p>\n<p>访问者模式的设计比较复杂，如果我们查看GoF原始的访问者模式，它是这么设计的：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">   ┌─────────┐       ┌───────────────────────┐</span><br><span class=\"line\">   │ Client  │─ ─ ─ &gt;│        Visitor        │</span><br><span class=\"line\">   └─────────┘       ├───────────────────────┤</span><br><span class=\"line\">        │            │visitElementA(ElementA)│</span><br><span class=\"line\">                     │visitElementB(ElementB)│</span><br><span class=\"line\">        │            └───────────────────────┘</span><br><span class=\"line\">                                 ▲</span><br><span class=\"line\">        │                ┌───────┴───────┐</span><br><span class=\"line\">                         │               │</span><br><span class=\"line\">        │         ┌─────────────┐ ┌─────────────┐</span><br><span class=\"line\">                  │  VisitorA   │ │  VisitorB   │</span><br><span class=\"line\">        │         └─────────────┘ └─────────────┘</span><br><span class=\"line\">        ▼</span><br><span class=\"line\">┌───────────────┐        ┌───────────────┐</span><br><span class=\"line\">│ObjectStructure│─ ─ ─ ─&gt;│    Element    │</span><br><span class=\"line\">├───────────────┤        ├───────────────┤</span><br><span class=\"line\">│handle(Visitor)│        │accept(Visitor)│</span><br><span class=\"line\">└───────────────┘        └───────────────┘</span><br><span class=\"line\">                                 ▲</span><br><span class=\"line\">                        ┌────────┴────────┐</span><br><span class=\"line\">                        │                 │</span><br><span class=\"line\">                ┌───────────────┐ ┌───────────────┐</span><br><span class=\"line\">                │   ElementA    │ │   ElementB    │</span><br><span class=\"line\">                ├───────────────┤ ├───────────────┤</span><br><span class=\"line\">                │accept(Visitor)│ │accept(Visitor)│</span><br><span class=\"line\">                │doA()          │ │doB()          │</span><br><span class=\"line\">                └───────────────┘ └───────────────┘</span><br></pre></td></tr></table></figure>\n\n<p>上述模式的复杂之处在于上述访问者模式为了实现所谓的“双重分派”，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。</p>\n<p>这里我们只介绍简化的访问者模式。假设我们要递归遍历某个文件夹的所有子文件夹和文件，然后找出<code>.java</code>文件，正常的做法是写个递归：</p>\n<figure class=\"highlight sas\"><table><tr><td class=\"code\"><pre><span class=\"line\">void<span class=\"meta\"> scan(</span><span class=\"meta\">File</span> dir, <span class=\"meta\">List</span>&lt;<span class=\"meta\">File</span>&gt; collector) &#123;</span><br><span class=\"line\">    for (<span class=\"meta\">File</span> <span class=\"meta\">file</span> : dir.listFiles()) &#123;</span><br><span class=\"line\">        <span class=\"meta\">if</span> (<span class=\"meta\">file</span>.isFile() <span class=\"variable\">&amp;&amp;</span> <span class=\"meta\">file</span>.getName().endsWith(<span class=\"string\">&quot;.java&quot;</span>)) &#123;</span><br><span class=\"line\">            collector.<span class=\"meta\">add</span>(<span class=\"meta\">file</span>);</span><br><span class=\"line\">        &#125; <span class=\"meta\">else</span> <span class=\"meta\">if</span> (<span class=\"meta\">file</span>.isDir()) &#123;</span><br><span class=\"line\">            // 递归调用:</span><br><span class=\"line\">           <span class=\"meta\"> scan(</span><span class=\"meta\">file</span>, collector);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述代码的问题在于，扫描目录的逻辑和处理.java文件的逻辑混在了一起。如果下次需要增加一个清理<code>.class</code>文件的功能，就必须再重复写扫描逻辑。</p>\n<p>因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离开，以后如果要新增操作（例如清理<code>.class</code>文件），只需要新增访问者，不需要改变现有逻辑。</p>\n<p>用访问者模式改写上述代码步骤如下：</p>\n<p>首先，我们需要定义访问者接口，即该访问者能够干的事情：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> interface Visitor &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 访问文件夹:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visitDir</span><span class=\"params\">(<span class=\"built_in\">File</span> dir)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// 访问文件:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">visitFile</span><span class=\"params\">(<span class=\"built_in\">File</span> file)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>紧接着，我们要定义能持有文件夹和文件的数据结构<code>FileStructure</code>：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileStructure</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// 根目录:</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">File</span> path;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FileStructure</span><span class=\"params\">(<span class=\"built_in\">File</span> path)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.path = path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们给<code>FileStructure</code>增加一个<code>handle()</code>方法，传入一个访问者：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> FileStructure &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> handle(Visitor visitor) &#123;</span><br><span class=\"line\">\t\tscan(<span class=\"keyword\">this</span>.path, visitor);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">void</span> scan(<span class=\"keyword\">File</span> <span class=\"keyword\">file</span>, Visitor visitor) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">file</span>.isDirectory()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 让访问者处理文件夹:</span></span><br><span class=\"line\">\t\t\tvisitor.visitDir(<span class=\"keyword\">file</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">File</span> sub : <span class=\"keyword\">file</span>.listFiles()) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 递归处理子文件夹:</span></span><br><span class=\"line\">\t\t\t\tscan(sub, visitor);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">file</span>.isFile()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 让访问者处理文件:</span></span><br><span class=\"line\">\t\t\tvisitor.visitFile(<span class=\"keyword\">file</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样，我们就把访问者的行为抽象出来了。如果我们要实现一种操作，例如，查找<code>.java</code>文件，就传入<code>JavaFileVisitor</code>：</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"code\"><pre><span class=\"line\">FileStructure fs = <span class=\"keyword\">new</span> <span class=\"type\">FileStructure</span>(<span class=\"keyword\">new</span> <span class=\"type\">File</span>(<span class=\"string\">&quot;.&quot;</span>));</span><br><span class=\"line\">fs.handle(<span class=\"keyword\">new</span> <span class=\"type\">JavaFileVisitor</span>());</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>JavaFileVisitor</code>实现如下：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> JavaFileVisitor <span class=\"keyword\">implements</span> Visitor &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> visitDir(<span class=\"keyword\">File</span> dir) &#123;</span><br><span class=\"line\">        System.out.<span class=\"keyword\">println</span>(<span class=\"string\">&quot;Visit dir: &quot;</span> + dir);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> visitFile(<span class=\"keyword\">File</span> <span class=\"keyword\">file</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">file</span>.getName().endsWith(<span class=\"string\">&quot;.java&quot;</span>)) &#123;</span><br><span class=\"line\">            System.out.<span class=\"keyword\">println</span>(<span class=\"string\">&quot;Found java file: &quot;</span> + <span class=\"keyword\">file</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>类似的，如果要清理<code>.class</code>文件，可以再写一个<code>ClassFileClearnerVisitor</code>：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> ClassFileCleanerVisitor <span class=\"keyword\">implements</span> Visitor &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> visitDir(<span class=\"keyword\">File</span> dir) &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> visitFile(<span class=\"keyword\">File</span> <span class=\"keyword\">file</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (<span class=\"keyword\">file</span>.getName().endsWith(<span class=\"string\">&quot;.class&quot;</span>)) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.<span class=\"keyword\">println</span>(<span class=\"string\">&quot;Will clean class file: &quot;</span> + <span class=\"keyword\">file</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可见，访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p>\n<p>实际上，Java标准库提供的<code>Files.walkFileTree()</code>已经实现了一个访问者模式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.nio.file.attribute.*;</span><br></pre></td></tr></table></figure>\n\n<p> Run</p>\n<p><code>Files.walkFileTree()</code>允许访问者返回<code>FileVisitResult.CONTINUE</code>以便继续访问，或者返回<code>FileVisitResult.TERMINATE</code>停止访问。</p>\n<p>类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Handler作为访问者处理XML的各个节点。</p>\n","categories":["Java","5.JavaEE进阶","6.设计模式"],"tags":["写作"]},{"title":"1.并发编程","url":"/2022/02/04/4-Java_7.Java%E9%AB%98%E7%BA%A7_1.%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","content":"<h1 id=\"线程和进程\"><a href=\"#线程和进程\" class=\"headerlink\" title=\"线程和进程\"></a>线程和进程</h1><h1 id=\"线程状态\"><a href=\"#线程状态\" class=\"headerlink\" title=\"线程状态\"></a>线程状态</h1><h1 id=\"并行和并发\"><a href=\"#并行和并发\" class=\"headerlink\" title=\"并行和并发\"></a>并行和并发</h1><h1 id=\"同步和异步\"><a href=\"#同步和异步\" class=\"headerlink\" title=\"同步和异步\"></a>同步和异步</h1><h1 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"Synchronized\"></a>Synchronized</h1><h1 id=\"Volatile-关键字\"><a href=\"#Volatile-关键字\" class=\"headerlink\" title=\"Volatile. 关键字\"></a>Volatile. 关键字</h1><h1 id=\"Lock-锁\"><a href=\"#Lock-锁\" class=\"headerlink\" title=\"Lock. 锁\"></a>Lock. 锁</h1><h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><h1 id=\"可重入锁\"><a href=\"#可重入锁\" class=\"headerlink\" title=\"可重入锁\"></a>可重入锁</h1><h1 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h1><h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><h1 id=\"JUC-的使用\"><a href=\"#JUC-的使用\" class=\"headerlink\" title=\"JUC. 的使用\"></a>JUC. 的使用</h1><h1 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h1><h1 id=\"Fork-Join\"><a href=\"#Fork-Join\" class=\"headerlink\" title=\"Fork. Join\"></a>Fork. Join</h1><h1 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h1>","categories":["Java","7.Java高级","1.并发编程"],"tags":["写作"]},{"title":"2.JVM","url":"/2022/02/04/4-Java_7.Java%E9%AB%98%E7%BA%A7_2.JVM/","content":"<h2 id=\"JVM-内存结构\"><a href=\"#JVM-内存结构\" class=\"headerlink\" title=\"JVM 内存结构\"></a>JVM 内存结构</h2><h2 id=\"JVM-生命周期\"><a href=\"#JVM-生命周期\" class=\"headerlink\" title=\"JVM 生命周期\"></a>JVM 生命周期</h2><h2 id=\"主流虚拟机\"><a href=\"#主流虚拟机\" class=\"headerlink\" title=\"主流虚拟机\"></a>主流虚拟机</h2><h2 id=\"Java-代码执行流程\"><a href=\"#Java-代码执行流程\" class=\"headerlink\" title=\"Java 代码执行流程\"></a>Java 代码执行流程</h2><h2 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h2><h3 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h3><h3 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h3><h3 id=\"双亲委派机制\"><a href=\"#双亲委派机制\" class=\"headerlink\" title=\"双亲委派机制\"></a>双亲委派机制</h3><h2 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h2><h3 id=\"垃圾回收器\"><a href=\"#垃圾回收器\" class=\"headerlink\" title=\"垃圾回收器\"></a>垃圾回收器</h3><h3 id=\"垃圾回收策略\"><a href=\"#垃圾回收策略\" class=\"headerlink\" title=\"垃圾回收策略\"></a>垃圾回收策略</h3><h3 id=\"垃圾回收算法\"><a href=\"#垃圾回收算法\" class=\"headerlink\" title=\"垃圾回收算法\"></a>垃圾回收算法</h3><h3 id=\"StopTheWorld\"><a href=\"#StopTheWorld\" class=\"headerlink\" title=\"StopTheWorld\"></a>StopTheWorld</h3><h2 id=\"字节码\"><a href=\"#字节码\" class=\"headerlink\" title=\"字节码\"></a>字节码</h2><h2 id=\"内存分配和回收\"><a href=\"#内存分配和回收\" class=\"headerlink\" title=\"内存分配和回收\"></a>内存分配和回收</h2><h2 id=\"JVM-性能调优\"><a href=\"#JVM-性能调优\" class=\"headerlink\" title=\"JVM 性能调优\"></a>JVM 性能调优</h2><h3 id=\"性能分析方法\"><a href=\"#性能分析方法\" class=\"headerlink\" title=\"性能分析方法\"></a>性能分析方法</h3><h3 id=\"常用工具\"><a href=\"#常用工具\" class=\"headerlink\" title=\"常用工具\"></a>常用工具</h3><h3 id=\"参数设置\"><a href=\"#参数设置\" class=\"headerlink\" title=\"参数设置\"></a>参数设置</h3>","categories":["Java","7.Java高级","2.JVM"],"tags":["写作"]},{"title":"3.接口管理","url":"/2022/02/04/4-Java_6.%E5%BE%AE%E6%9C%8D%E5%8A%A1_3.%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86/","content":"<h1 id=\"Swagger-接口文档\"><a href=\"#Swagger-接口文档\" class=\"headerlink\" title=\"Swagger 接口文档\"></a>Swagger 接口文档</h1><h1 id=\"Postman-接口测试\"><a href=\"#Postman-接口测试\" class=\"headerlink\" title=\"Postman 接口测试\"></a>Postman 接口测试</h1>","categories":["Java","6.微服务","3.接口管理"],"tags":["写作"]},{"title":"3.架构设计","url":"/2022/02/04/4-Java_7.Java%E9%AB%98%E7%BA%A7_3.%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/","content":"<h1 id=\"分布式\"><a href=\"#分布式\" class=\"headerlink\" title=\"分布式\"></a>分布式</h1><h2 id=\"分布式理论\"><a href=\"#分布式理论\" class=\"headerlink\" title=\"分布式理论\"></a>分布式理论</h2><h3 id=\"CAP\"><a href=\"#CAP\" class=\"headerlink\" title=\"CAP\"></a>CAP</h3><h3 id=\"BASE\"><a href=\"#BASE\" class=\"headerlink\" title=\"BASE\"></a>BASE</h3><h2 id=\"分布式缓存\"><a href=\"#分布式缓存\" class=\"headerlink\" title=\"分布式缓存\"></a>分布式缓存</h2><h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><h3 id=\"Etcd\"><a href=\"#Etcd\" class=\"headerlink\" title=\"Etcd\"></a>Etcd</h3><h2 id=\"一致性算法\"><a href=\"#一致性算法\" class=\"headerlink\" title=\"一致性算法\"></a>一致性算法</h2><h3 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h3><h3 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h3><h2 id=\"分布式事务\"><a href=\"#分布式事务\" class=\"headerlink\" title=\"分布式事务\"></a>分布式事务</h2><h2 id=\"分布式-id-生成\"><a href=\"#分布式-id-生成\" class=\"headerlink\" title=\"分布式 id 生成\"></a>分布式 id 生成</h2><h2 id=\"分布式服务调用\"><a href=\"#分布式服务调用\" class=\"headerlink\" title=\"分布式服务调用\"></a>分布式服务调用</h2><h2 id=\"分布式存储\"><a href=\"#分布式存储\" class=\"headerlink\" title=\"分布式存储\"></a>分布式存储</h2><h2 id=\"分布式数据库\"><a href=\"#分布式数据库\" class=\"headerlink\" title=\"分布式数据库\"></a>分布式数据库</h2><h2 id=\"分布式文件系统\"><a href=\"#分布式文件系统\" class=\"headerlink\" title=\"分布式文件系统\"></a>分布式文件系统</h2><h2 id=\"分布式协调\"><a href=\"#分布式协调\" class=\"headerlink\" title=\"分布式协调\"></a>分布式协调</h2><h3 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h3><h2 id=\"分布式监控\"><a href=\"#分布式监控\" class=\"headerlink\" title=\"分布式监控\"></a>分布式监控</h2><h3 id=\"Prometheus\"><a href=\"#Prometheus\" class=\"headerlink\" title=\"Prometheus\"></a>Prometheus</h3><h2 id=\"分布式消息队列\"><a href=\"#分布式消息队列\" class=\"headerlink\" title=\"分布式消息队列\"></a>分布式消息队列</h2><h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><h3 id=\"Apache-Pulsar\"><a href=\"#Apache-Pulsar\" class=\"headerlink\" title=\"Apache Pulsar\"></a>Apache Pulsar</h3><h2 id=\"分布式日志收集\"><a href=\"#分布式日志收集\" class=\"headerlink\" title=\"分布式日志收集\"></a>分布式日志收集</h2><h3 id=\"Elastic-Stack\"><a href=\"#Elastic-Stack\" class=\"headerlink\" title=\"Elastic Stack\"></a>Elastic Stack</h3><h3 id=\"Loki\"><a href=\"#Loki\" class=\"headerlink\" title=\"Loki\"></a>Loki</h3><h2 id=\"分布式搜索引擎\"><a href=\"#分布式搜索引擎\" class=\"headerlink\" title=\"分布式搜索引擎\"></a>分布式搜索引擎</h2><h3 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h3><h2 id=\"分布式链路追踪\"><a href=\"#分布式链路追踪\" class=\"headerlink\" title=\"分布式链路追踪\"></a>分布式链路追踪</h2><h3 id=\"Apache-SkyWalking\"><a href=\"#Apache-SkyWalking\" class=\"headerlink\" title=\"Apache SkyWalking\"></a>Apache SkyWalking</h3><h2 id=\"分布式配置中心\"><a href=\"#分布式配置中心\" class=\"headerlink\" title=\"分布式配置中心\"></a>分布式配置中心</h2><h3 id=\"Apollo\"><a href=\"#Apollo\" class=\"headerlink\" title=\"Apollo\"></a>Apollo</h3><h3 id=\"Nacos\"><a href=\"#Nacos\" class=\"headerlink\" title=\"Nacos\"></a>Nacos</h3><h1 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h1><h2 id=\"主从\"><a href=\"#主从\" class=\"headerlink\" title=\"主从\"></a>主从</h2><h2 id=\"异地多活\"><a href=\"#异地多活\" class=\"headerlink\" title=\"异地多活\"></a>异地多活</h2><h2 id=\"容灾备份\"><a href=\"#容灾备份\" class=\"headerlink\" title=\"容灾备份\"></a>容灾备份</h2><h1 id=\"高并发\"><a href=\"#高并发\" class=\"headerlink\" title=\"高并发\"></a>高并发</h1><h2 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h2><h3 id=\"分库分表\"><a href=\"#分库分表\" class=\"headerlink\" title=\"分库分表\"></a>分库分表</h3><h3 id=\"读写分离\"><a href=\"#读写分离\" class=\"headerlink\" title=\"读写分离\"></a>读写分离</h3><h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><h3 id=\"负载均衡算法\"><a href=\"#负载均衡算法\" class=\"headerlink\" title=\"负载均衡算法\"></a>负载均衡算法</h3><h3 id=\"软硬件负载均衡（2-3-4-7-层）\"><a href=\"#软硬件负载均衡（2-3-4-7-层）\" class=\"headerlink\" title=\"软硬件负载均衡（2-3-4-7 层）\"></a>软硬件负载均衡（2-3-4-7 层）</h3><h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"监控告警\"><a href=\"#监控告警\" class=\"headerlink\" title=\"监控告警\"></a>监控告警</h2><h2 id=\"领域驱动设计\"><a href=\"#领域驱动设计\" class=\"headerlink\" title=\"领域驱动设计\"></a>领域驱动设计</h2><h2 id=\"应用安全\"><a href=\"#应用安全\" class=\"headerlink\" title=\"应用安全\"></a>应用安全</h2><h2 id=\"线上故障分析\"><a href=\"#线上故障分析\" class=\"headerlink\" title=\"线上故障分析\"></a>线上故障分析</h2><h2 id=\"服务网格\"><a href=\"#服务网格\" class=\"headerlink\" title=\"服务网格\"></a>服务网格</h2><h2 id=\"Serverless\"><a href=\"#Serverless\" class=\"headerlink\" title=\"Serverless\"></a>Serverless</h2><h2 id=\"云原生\"><a href=\"#云原生\" class=\"headerlink\" title=\"云原生\"></a>云原生</h2>","categories":["Java","7.Java高级","3.架构设计"],"tags":["写作"]}]