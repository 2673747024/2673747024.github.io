<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="树树的定义 树是n（n之0）个节点的有限集。当n&#x3D;0时，称为空树  在任意一棵非空树中应满足  有且仅有一个特定的称为根的结点  当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1，T2……Tm，其中每个集合本身又是一棵树，并且称为根的子树  根结点的子树是互不相交的，如果相交就不是树     树是一种逻辑结构，也是一种分层结构  树的根结点没有前驱，除根结点外的所">
<meta property="og:type" content="article">
<meta property="og:title" content="树与二叉树">
<meta property="og:url" content="https://2673747024.github.io/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="树树的定义 树是n（n之0）个节点的有限集。当n&#x3D;0时，称为空树  在任意一棵非空树中应满足  有且仅有一个特定的称为根的结点  当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1，T2……Tm，其中每个集合本身又是一棵树，并且称为根的子树  根结点的子树是互不相交的，如果相交就不是树     树是一种逻辑结构，也是一种分层结构  树的根结点没有前驱，除根结点外的所">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/79541708-46ee-4f07-a79f-789ac06320ff-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/5fa7979e-10f1-4c4a-808b-f6a987619631-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/dfe5e8a7-7110-4149-b3aa-9932867c2d90-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/274a9d9c-7698-4f1c-bc3a-ac5dea47fa83-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/ad122d7b-66c8-45b5-9623-a8dfe15c238b-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/1b2a1ad5-2c9d-458d-8554-fd73a176010d-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/cf9c0610-c809-47fd-9460-a548727d361c-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/d0260f4a-598d-4c78-8b19-49894c086fbb-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/b700c77b-c875-4ff3-b649-a9390750a13d-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/24e9f9eb-e991-4b07-a411-5fec6ad1b89f-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/076d411e-0555-4a7b-9364-3e4411db4b81-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/475b7c69-2f41-4986-8ce2-6858f8ed205f-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/4500ae20-68af-4289-9c32-9417f414dff7-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/6e0be798-ce73-405d-a16e-60d505cf06e5-3224585.jpg">
<meta property="article:published_time" content="2022-02-03T14:59:42.373Z">
<meta property="article:modified_time" content="2022-02-04T16:11:23.047Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api2.mubu.com/v3/document_image/79541708-46ee-4f07-a79f-789ac06320ff-3224585.jpg">


<link rel="canonical" href="https://2673747024.github.io/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/","path":"2022/02/03/2-计算机408_3.数据结构_5树与二叉树/","title":"树与二叉树"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>树与二叉树 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">1.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">树的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.2.</span> <span class="nav-text">基本术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">1.3.</span> <span class="nav-text">树的性质</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">2.</span> <span class="nav-text">二叉树的概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E5%85%B6%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">二叉树的定义及其主要特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">2.1.1.</span> <span class="nav-text">二叉树的定义：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%BA%A6%E4%B8%BA2%E7%9A%84%E6%9C%89%E5%BA%8F%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.2.</span> <span class="nav-text">二叉树与度为2的有序树的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%94%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%8A%B6%E6%80%81"><span class="nav-number">2.1.3.</span> <span class="nav-text">二叉树的五种不同状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.1.4.</span> <span class="nav-text">特殊的二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-number">2.1.5.</span> <span class="nav-text">二叉树的性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.1.</span> <span class="nav-text">顺序存储结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.2.</span> <span class="nav-text">链式存储结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">二叉树的遍历和线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6O-n-%EF%BC%89%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E5%92%8C%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9A%E5%88%A9%E7%94%A8%E6%A0%88%E8%BF%9B%E8%A1%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.</span> <span class="nav-text">二叉树的遍历（时间复杂度O(n)）——递归算法和非递归算法的转换：利用栈进行实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E6%89%8B%E7%AE%97%E7%BB%83%E4%B9%A0%EF%BC%89%E2%80%94%E2%80%94%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9%E9%80%90%E5%B1%82%E5%B1%95%E5%BC%80%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">二叉树的遍历（手算练习）——分支结点逐层展开法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E9%81%8D%E5%8E%86%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%BC%80%E8%BE%9F%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E6%9D%A5%E5%AD%98%E5%82%A8%E5%BD%93%E5%89%8D%E7%9A%84%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="nav-number">3.3.</span> <span class="nav-text">三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%EF%BC%88%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">求树的深度（递归算法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="nav-number">3.5.</span> <span class="nav-text">层次遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">3.6.</span> <span class="nav-text">具体实现：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.7.</span> <span class="nav-text">由遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.8.</span> <span class="nav-text">线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.8.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">3.8.2.</span> <span class="nav-text">中序线索二叉树的构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BA%BF%E7%B4%A2%E5%8C%96%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.8.3.</span> <span class="nav-text">二叉树线索化的具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">3.9.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E7%BB%93%E7%82%B9q"><span class="nav-number">3.10.</span> <span class="nav-text">访问结点q</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%9F%A5%E6%89%BE%E7%BB%93%E7%82%B9p%E7%9A%84%E5%89%8D%E9%A9%B1"><span class="nav-number">3.11.</span> <span class="nav-text">辅助全局变量，用于查找结点p的前驱</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96%E2%80%94%E2%80%94%E7%8E%8B%E9%81%93%E4%B9%A6%E7%89%88%E6%9C%AC"><span class="nav-number">3.12.</span> <span class="nav-text">先序线索化——王道书版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96%E2%80%94%E2%80%94%E7%8E%8B%E9%81%93%E4%B9%A6%E7%89%88%E6%9C%AC"><span class="nav-number">3.13.</span> <span class="nav-text">后序线索化——王道书版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%BE%E5%89%8D%E9%A9%B1%E3%80%81%E5%90%8E%E7%BB%A7"><span class="nav-number">3.13.1.</span> <span class="nav-text">线索二叉树找前驱、后继</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="nav-number">4.</span> <span class="nav-text">树、森林</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">4.1.1.</span> <span class="nav-text">双亲表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="nav-number">4.1.2.</span> <span class="nav-text">孩子表示法（顺序+链式存储）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E8%8B%A5%E4%B8%BA%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E5%A2%9E%E8%AE%BE%E4%B8%80%E4%B8%AAparent%E5%9F%9F%E6%8C%87%E5%90%91%E5%85%B6%E7%88%B6%E7%BB%93%E7%82%B9%EF%BC%8C%E5%88%99%E6%9F%A5%E6%89%BE%E7%BB%93%E7%82%B9%E7%9A%84%E7%88%B6%E7%BB%93%E7%82%B9%E4%B9%9F%E5%BE%88%E6%96%B9%E4%BE%BF%EF%BC%89%EF%BC%88%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="nav-number">4.1.3.</span> <span class="nav-text">孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.2.</span> <span class="nav-text">树、森林与二叉树的转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">4.3.</span> <span class="nav-text">树和森林的遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%AA%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.4.</span> <span class="nav-text">伪代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">树与二叉树的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="nav-number">5.1.</span> <span class="nav-text">二叉排序树（BST）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="nav-number">5.2.</span> <span class="nav-text">平衡二叉树（AVL）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.3.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">5.4.</span> <span class="nav-text">哈夫曼树和哈夫曼编码</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">112</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          树与二叉树
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-03 22:59:42" itemprop="dateCreated datePublished" datetime="2022-02-03T22:59:42+08:00">2022-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-05 00:11:23" itemprop="dateModified" datetime="2022-02-05T00:11:23+08:00">2022-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/" itemprop="url" rel="index"><span itemprop="name">计算机408</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">3.数据结构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">5.树与二叉树</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：9.9k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈34 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><ul>
<li><p>树是n（n之0）个节点的有限集。当n&#x3D;0时，称为空树</p>
</li>
<li><p>在任意一棵非空树中应满足</p>
<ul>
<li><p>有且仅有一个特定的称为根的结点</p>
</li>
<li><p>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1，T2……Tm，其中每个集合本身又是一棵树，并且称为根的子树</p>
<ul>
<li>根结点的子树是互不相交的，如果相交就不是树</li>
</ul>
</li>
</ul>
</li>
<li><p>树是一种逻辑结构，也是一种分层结构</p>
<ul>
<li><p>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱</p>
<ul>
<li>否则不是树，而是图（网）</li>
</ul>
</li>
<li><p>树中所有结点可以有零个或多个后继</p>
</li>
</ul>
</li>
</ul>
<h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><ul>
<li><p>示意图<img src="https://api2.mubu.com/v3/document_image/79541708-46ee-4f07-a79f-789ac06320ff-3224585.jpg" alt="img"></p>
</li>
<li><p>考虑结点K</p>
<ul>
<li><p>K的祖先：根A到结点K的唯一路径上的任意结点</p>
<ul>
<li>从该点出发一直到根结点，路径上所有的结点都是祖先结点</li>
</ul>
</li>
<li><p>子孙：结点B是结点K的祖先，而结点K是结点B的子孙</p>
<ul>
<li>从自身出发，所有的分支上的所有结点</li>
</ul>
</li>
<li><p>双亲与孩子：路径上最接近结点K的结点E称为K的双亲（直接前驱），而K为结点E的孩子（直接后继）</p>
</li>
<li><p>兄弟：有相同双亲的结点称为兄弟，如结点K和结点L有相同的双亲E，即K和L为兄弟</p>
</li>
<li><p>堂兄弟结点：同一层除兄弟结点外的结点</p>
</li>
</ul>
</li>
<li><p>结点的度：树中一个结点的孩子个数，树中结点的最大度数称为树的度</p>
</li>
<li><p>根结点：A</p>
</li>
<li><p>分支结点：度大于0的结点，有下一级分支</p>
</li>
<li><p>叶子结点（又称终端结点）：度为0 （没有子女结点）的结点</p>
</li>
<li><p>结点的层次：从树根开始定义，根结点为第1层（有可能规定从0开始），它的子结点为第2层，以此类推（从上往下数）</p>
</li>
<li><p>结点的深度：从根结点开始自顶向下逐层累加的</p>
</li>
<li><p>结点的高度：从叶结点开始自底向上逐层累加的</p>
</li>
<li><p>树的高度（或深度） ：树中结点的最大层数</p>
</li>
<li><p>结点的度：有几个孩子（分支）</p>
</li>
<li><p>树的度：各结点的度的最大值</p>
</li>
<li><p>有序树和无序树：树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树（例如家谱，左边的年龄大），否则称为无序树（从左到右是无次序的，可以互换；例如行政区，左右无区别）</p>
</li>
<li><p>路径和路径长度：</p>
<ul>
<li><p>树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的（只能从上往下，路径是单向的）</p>
</li>
<li><p>路径长度是路径上所经过的边的个数</p>
</li>
</ul>
</li>
<li><p>森林：森林是n棵互不相交的树的集合（考点：树与森林相互转化）</p>
<ul>
<li><p>只要把树的根结点删去就成了森林</p>
</li>
<li><p>给农棵独立的树加上一个结点，并把这m棵树作为该结点的子树，则森林就变成了树</p>
</li>
<li><p>有空树，有空森林</p>
</li>
</ul>
</li>
</ul>
<h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><ul>
<li><p>1、树中的结点数等于所有结点的度数（等于分支数）加1</p>
</li>
<li><p>2、树的度——各结点的度的最大值；m叉树——每个结点最多有m个孩子的树</p>
<ul>
<li><p>图：00:00:45</p>
</li>
<li><p>相同2&#x2F;区别1</p>
</li>
</ul>
</li>
<li><p>3、度为m的树（或m叉树）中第i层上至多有   个结点（i大于等于1）<img src="https://api2.mubu.com/v3/document_image/5fa7979e-10f1-4c4a-808b-f6a987619631-3224585.jpg" alt="img"></p>
</li>
<li><p>4、高度为h的m叉树（或者度为m的树）至多有   个结点</p>
<ul>
<li>将每次最多结点数相加，等比数列求和</li>
</ul>
</li>
<li><p>5、高度为h的m叉树至少有h个结点；高度为h、度为m的树至少有h+m-1个结点</p>
<ul>
<li>m叉树每个结点只有一个孩子；度为m的树，至少有一层为m个结点，其余层只有一个结点</li>
</ul>
</li>
<li><p>6、具有n个结点的m叉树的最小高度为</p>
<ul>
<li>为保证高度最小，每一层有尽可能多的孩子，使用4进行计算</li>
</ul>
</li>
<li><p>m叉树——每个结点最多只能有m个孩子的树</p>
<ul>
<li><p>任意结点的度 &lt;&#x3D; m（最多m个孩子）</p>
</li>
<li><p>允许所有结点的度都&lt;M</p>
</li>
<li><p>可以是空树</p>
</li>
</ul>
</li>
<li><p>度为m的树</p>
<ul>
<li><p>任意结点的度 &lt;&#x3D; m （最多m个孩子）</p>
</li>
<li><p>至少有一个结点度 &#x3D; m（有m个孩子）</p>
</li>
<li><p>一定是非空树，至少有m+1个结点</p>
</li>
</ul>
</li>
</ul>
<h1 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h1><h2 id="二叉树的定义及其主要特性"><a href="#二叉树的定义及其主要特性" class="headerlink" title="二叉树的定义及其主要特性"></a>二叉树的定义及其主要特性</h2><h3 id="二叉树的定义："><a href="#二叉树的定义：" class="headerlink" title="二叉树的定义："></a>二叉树的定义：</h3><ul>
<li><p>二叉树：另一种树形结构，不属于树（二叉树可以为空，而树不能为空）</p>
<ul>
<li>二叉树可能是空二叉树，或者是一个根结点和两个互不相交的左子树和右子树组成（分别是二叉树，左右子树可以是空二叉树）</li>
</ul>
</li>
<li><p>3特点：每个结点至多只有两棵子树，并且二叉树的子树有左右之分，其次序不能任意颠倒</p>
</li>
</ul>
<h3 id="二叉树与度为2的有序树的区别"><a href="#二叉树与度为2的有序树的区别" class="headerlink" title="二叉树与度为2的有序树的区别"></a>二叉树与度为2的有序树的区别</h3><ul>
<li><p>度为2的树至少有3个结点，而二叉树可以为空</p>
</li>
<li><p>孩子结点</p>
<ul>
<li><p>度为2的有序树的孩子的左右次序是相对于另一孩子而言的，若某个结点只有一个孩子，则这个孩子就无须区分其左右次序</p>
</li>
<li><p>二叉树无论其孩子数是否为2，均需确定其左右次序</p>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树的五种不同状态"><a href="#二叉树的五种不同状态" class="headerlink" title="二叉树的五种不同状态"></a>二叉树的五种不同状态</h3><ul>
<li><p>空二叉树</p>
</li>
<li><p>只有左子树</p>
</li>
<li><p>只有右子树</p>
</li>
<li><p>只有根结点</p>
</li>
<li><p>左右子树都有</p>
</li>
</ul>
<h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><ul>
<li><p>满二叉树</p>
<ul>
<li><p>一棵高度为h，且含有2^h-1个结点的二叉树称为满二叉树</p>
</li>
<li><p>特点：</p>
<ul>
<li><p>只有最后一层有叶子结点</p>
</li>
<li><p>不存在度为1的结点</p>
</li>
</ul>
</li>
<li><p>对于编号为i的结点</p>
<ul>
<li><p>双亲为<img src="https://api2.mubu.com/v3/document_image/dfe5e8a7-7110-4149-b3aa-9932867c2d90-3224585.jpg" alt="img"></p>
</li>
<li><p>若有左孩子，则左孩子为2i</p>
</li>
<li><p>若有右孩子，则右孩子为2i + 1</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>完全二叉树</p>
<ul>
<li><p>高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树（在满二叉树的基础上，将编号更大的结点去掉）</p>
</li>
<li><p>特点</p>
<ul>
<li><p>叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上 </p>
</li>
<li><p>若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）</p>
</li>
<li><p>按层序编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点</p>
</li>
<li><p>如果   ，则结点为分支结点（孩子&lt;&#x3D;n），否则为叶子结点（孩子&gt;n）<img src="https://api2.mubu.com/v3/document_image/274a9d9c-7698-4f1c-bc3a-ac5dea47fa83-3224585.jpg" alt="img"></p>
</li>
<li><p>若n为奇数，则每个分支结点都有左孩子和右孩子</p>
</li>
<li><p>若n为偶数，则编号最大的分支结点（编号为n&#x2F;2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树</p>
<ul>
<li><p>左子树上所有结点的关键字均小于根结点的关键字</p>
</li>
<li><p>右子树上的所有结点的关键字均大于根结点的关键字</p>
</li>
<li><p>左子树和右子树又各是一棵二叉排序树</p>
</li>
<li><p>关键字查找（插入、删除）：从根结点开始，如果关键字小于根结点，搜索左子树；如果关键字大于根结点，搜索右子树</p>
</li>
</ul>
</li>
<li><p>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1</p>
<ul>
<li>为什么：平衡二叉树的关键字搜索效率更高</li>
</ul>
</li>
</ul>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ul>
<li><p>1、非空二叉树上的叶子结点数（度为0的结点）等于度为2的结点数+1</p>
<ul>
<li><p>计算：</p>
<ul>
<li><p>结点总数n&#x3D;n0+n1+n2（直接求结点）</p>
</li>
<li><p>n&#x3D;n1+2*n2+1（根据分支数（总度数）求结点，除根结点外所有结点通过一个分支与双亲相连）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2、非空二叉树上第k层上<img src="https://api2.mubu.com/v3/document_image/ad122d7b-66c8-45b5-9623-a8dfe15c238b-3224585.jpg" alt="img"></p>
</li>
<li><p>3、高度为h的二叉树<img src="https://api2.mubu.com/v3/document_image/1b2a1ad5-2c9d-458d-8554-fd73a176010d-3224585.jpg" alt="img"></p>
</li>
<li><p>对完全二叉树按从上到下、从左到右的顺序依次编号1，2，……，则有以下关系</p>
<ul>
<li><p>具有n个(n&gt;0)结点的完全二叉树的高度为<img src="https://api2.mubu.com/v3/document_image/cf9c0610-c809-47fd-9460-a548727d361c-3224585.jpg" alt="img"></p>
</li>
<li><p>具有n个结点的完全二叉树的n0、n1、n2之间的关系</p>
<ul>
<li><p>若完全二叉树有2k（偶数）个结点，则有n1&#x3D;1，n0&#x3D;k，n2&#x3D;k-1</p>
</li>
<li><p>若完全二叉树有2k-1（奇数）个结点，则有n1&#x3D;0，n0&#x3D;k，n2&#x3D;k-1</p>
</li>
<li><p>计算：</p>
<ul>
<li><p>n1&#x3D;0或1（最多只有一个度为1的结点）</p>
</li>
<li><p>n0&#x3D;n2+1（根据结点总数n推导得）&#x3D;》n0+n2一定是奇数</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>当i&gt;1时，结点i的双亲的编号为，即当i为偶数时，其双亲的编号为i&#x2F;2，它是双亲的左孩子；当i为奇数时，其双亲的编号为(i—1)&#x2F;2，它是双亲的右孩子<img src="https://api2.mubu.com/v3/document_image/d0260f4a-598d-4c78-8b19-49894c086fbb-3224585.jpg" alt="img"></p>
</li>
<li><p>2i &lt;&#x3D; n，结点i的做孩子编号2i，否则无左孩子</p>
</li>
<li><p>2i+1 &lt;&#x3D; n 结点的右孩子编号为2i+1，否则无右孩子</p>
</li>
<li><p>结点i所在层次(深度)为<img src="https://api2.mubu.com/v3/document_image/b700c77b-c875-4ff3-b649-a9390750a13d-3224585.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><ul>
<li><p>实现思想：</p>
<ul>
<li>用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标为i - 1的分量中</li>
</ul>
</li>
<li><p>最常适用于：</p>
<ul>
<li>完全二叉树和满二叉树<ul>
<li>普通二叉树不能 从结点编号反映出结点间的逻辑关系</li>
</ul>
</li>
</ul>
</li>
<li><p>如何顺序存储普通二叉树：</p>
<ul>
<li><p>一般的二叉树，为了能反映二叉树中结点之间的逻辑关系</p>
</li>
<li><p>只能添加并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中</p>
</li>
<li><p>使用isEmpty判断是否是空结点</p>
</li>
</ul>
</li>
<li><p>顺序存储普通二叉树的缺点：</p>
<ul>
<li>浪费大量的存储空间，所以顺序存储只适合存储完全二叉树</li>
</ul>
</li>
</ul>
<h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><ul>
<li><p>由于顺序存储的空间利用率较低，因此二叉树一般都采用链式存储结构，用链表结点来存储二叉树中的每个结点</p>
</li>
<li><p>结构描述<img src="https://api2.mubu.com/v3/document_image/24e9f9eb-e991-4b07-a411-5fec6ad1b89f-3224585.jpg" alt="img"></p>
</li>
<li><p>在含有n个结点的二叉链表中，含有n+1个空链域</p>
<ul>
<li><p>n个结点有2n个指针域，n-1个结点被指针所指向</p>
</li>
<li><p>所以这些指针域可以被利用起来构造线索二叉树</p>
</li>
<li><p>二叉链表：每个结点有两个指针</p>
</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li><p>找到孩子结点很简单</p>
</li>
<li><p>找到父结点需要从根开始遍历寻找，耗时</p>
<ul>
<li><p>此时在结点内定义一个新的指针指向父结点，所以结点有三个指针，称为三叉链表</p>
</li>
<li><p>根据实际需求决定是否增加父指针（查找父结点的操作是否多，树的体量是不是大）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="二叉树的遍历和线索二叉树"><a href="#二叉树的遍历和线索二叉树" class="headerlink" title="二叉树的遍历和线索二叉树"></a>二叉树的遍历和线索二叉树</h1><h2 id="二叉树的遍历（时间复杂度O-n-）——递归算法和非递归算法的转换：利用栈进行实现"><a href="#二叉树的遍历（时间复杂度O-n-）——递归算法和非递归算法的转换：利用栈进行实现" class="headerlink" title="二叉树的遍历（时间复杂度O(n)）——递归算法和非递归算法的转换：利用栈进行实现"></a>二叉树的遍历（时间复杂度O(n)）——递归算法和非递归算法的转换：利用栈进行实现</h2><ul>
<li><p>先序遍历（对一个表达式进行先序遍历的结果就是前缀表达式）</p>
<ul>
<li><p>访问根结点</p>
</li>
<li><p>先序遍历左子树</p>
</li>
<li><p>先序遍历右子树</p>
</li>
</ul>
</li>
<li><p>中序遍历（对一个表达式进行中序遍历的结果就是中缀表达式（需要加界限符））</p>
<ul>
<li><p>中序遍历左子树</p>
</li>
<li><p>访问根结点</p>
</li>
<li><p>中序遍历右子树</p>
</li>
</ul>
</li>
<li><p>后序遍历（对一个表达式进行后序遍历的结果就是后缀表达式）</p>
<ul>
<li><p>后序遍历左子树</p>
</li>
<li><p>后序遍历右子树</p>
</li>
<li><p>访问根结点</p>
</li>
</ul>
</li>
<li><p>三种遍历算法的空间复杂度：O(h)，h指二叉树的高度，递归调用时每一层都有一个结点的函数会被压到栈中，最多有h+1个结点的函数被压到栈里面（最下一层结点的空孩子结点的函数也会被压到栈顶，该函数执行后就会被弹出栈）</p>
</li>
</ul>
<h2 id="二叉树的遍历（手算练习）——分支结点逐层展开法"><a href="#二叉树的遍历（手算练习）——分支结点逐层展开法" class="headerlink" title="二叉树的遍历（手算练习）——分支结点逐层展开法"></a>二叉树的遍历（手算练习）——分支结点逐层展开法</h2><h2 id="三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息"><a href="#三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息" class="headerlink" title="三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息"></a>三种遍历的具体实现：调用函数时，系统会开辟一个函数调用栈来存储当前的函数相关信息</h2><ul>
<li><p>先序遍历</p>
</li>
<li><p>中序遍历</p>
</li>
<li><p>后序遍历</p>
</li>
</ul>
<h2 id="求树的深度（递归算法）"><a href="#求树的深度（递归算法）" class="headerlink" title="求树的深度（递归算法）"></a>求树的深度（递归算法）</h2><h2 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h2><ul>
<li><p>利用队列实现</p>
</li>
<li><p>实现思想：</p>
<ul>
<li><p>初始化一个辅助队列</p>
</li>
<li><p>根结点入队（结点入队时，只使用队列保存结点的指针即可，节省存储空间）</p>
</li>
<li><p>若队列非空，则队头结点出队，访问该结点，并将左&#x2F;右孩子插入队尾（如果有的话）</p>
</li>
<li><p>重复上一步骤，直至队列为空</p>
</li>
</ul>
</li>
<li><h2 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h2></li>
</ul>
<h2 id="由遍历序列构造二叉树"><a href="#由遍历序列构造二叉树" class="headerlink" title="由遍历序列构造二叉树"></a>由遍历序列构造二叉树</h2><ul>
<li><p>单个遍历序列不能确定唯一的二叉树</p>
<ul>
<li><p>二叉树的先序序列、中序序列、后序序列、层序序列可能对应多种二叉树形态</p>
</li>
<li><p>如果只是给出一颗二叉树的前中后层遍历序列的一种是不能唯一确认一棵二叉树的</p>
</li>
</ul>
</li>
<li><p>使用两个遍历序列构造二叉树（必须有中序遍历）</p>
<ul>
<li><p>前序+中序</p>
<ul>
<li><p>如何确定二叉树？</p>
<ul>
<li><p>根据前序遍历的第一个结点确认根结点</p>
</li>
<li><p>中序遍历的左侧部分是左子树</p>
</li>
<li><p>所以前序遍历中的对应部分也是左子树，其余的就是右子树的前序遍历序列</p>
</li>
<li><p>循环</p>
<ul>
<li>对应部分的第一个结点时左子树的根结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>后序+中序</p>
<ul>
<li><p>如何确定二叉树？</p>
<ul>
<li><p>根据后序遍历的第一个结点确认根结点</p>
</li>
<li><p>中序遍历的左侧部分是左子树</p>
</li>
<li><p>所以后序遍历中的对应部分也是左子树，其余的就是右子树的后序遍历序列</p>
</li>
<li><p>循环</p>
<ul>
<li>对应部分的第一个结点时左子树的根结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>层序+中序</p>
<ul>
<li><p>如何确定二叉树？</p>
<ul>
<li><p>根据层次遍历的第一个结点确认根结点</p>
</li>
<li><p>中序遍历的左侧部分是左子树，中序遍历的右侧部分是右子树</p>
</li>
<li><p>中序遍历中已经确定位置的结点，在层次遍历中也会跳过</p>
</li>
<li><p>循环</p>
<ul>
<li>层序遍历的下一个结点是左子树的根结点</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>关键：找到树的根结点，并根据中序序列划分左右子树，再找到左右子树根结点</p>
</li>
</ul>
</li>
</ul>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>线索二叉树的基本概念</p>
<ul>
<li><p>遍历二叉树是以一定的规则将二叉树中的结点排列成一个线性序列，从而得到几种遍历序列</p>
</li>
<li><p>使得该序列中的每个结点（第一个和最后一个结点除外）都有一个直接前驱和直接后继（基于遍历序列的前驱和后继）</p>
</li>
</ul>
</li>
<li><p>线索二叉树出现的原因</p>
<ul>
<li><p>普通二叉树进行遍历的时候都必须从根结点出发，如果从一个指定结点p开始将无法遍历线性序列的后继、前驱（遍历序列的前驱、后继）</p>
</li>
<li><p>普通二叉树二叉树查找前驱、后继</p>
<ul>
<li><p>找到p结点的中序遍历的前驱，思路：</p>
<ul>
<li><p>从根结点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针pre记录上一个倍访问的结点</p>
</li>
<li><p>当q&#x3D;&#x3D;p时，pre则为前驱</p>
</li>
</ul>
</li>
<li><p>找到p结点的中序遍历的后继，思路：</p>
<ul>
<li><p>从根结点出发，重新进行一次中序遍历，指针q记录当前访问的结点，指针pre记录上一个倍访问的结点</p>
</li>
<li><p>当pre&#x3D;&#x3D;p时，q则为后继</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>普通二叉树缺点：</p>
<ul>
<li><p>找前驱、后继很不方便</p>
</li>
<li><p>每次遍历都必须从根结点开始</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>中序线索二叉树的特点</p>
<ul>
<li>n个结点的二叉树，有n+1个空链域，可以用来记录前驱、后继的信息</li>
</ul>
</li>
<li><p>建立 中序线索二叉树的目的</p>
<ul>
<li>使得查找前驱、后继和遍历更加方便</li>
</ul>
</li>
<li><p>规定</p>
<ul>
<li><p>若无左子树， 令lchild指向其前驱结点</p>
</li>
<li><p>若无右子树， 令rchild指向其后继结点</p>
</li>
</ul>
</li>
<li><p>结点结构（该结点结构的线索二叉树称为线索链表）</p>
<ul>
<li><p>标志域的含义</p>
<ul>
<li><p>Itag</p>
<ul>
<li><p>0</p>
</li>
<li><p>lchild域指示结点的左孩子</p>
</li>
<li><p>1</p>
</li>
<li><p>Ichild域指示结点的前驱</p>
</li>
</ul>
</li>
<li><p>rtag</p>
<ul>
<li><p>0</p>
</li>
<li><p>rchild域指示结点的右孩子</p>
</li>
<li><p>1</p>
</li>
<li><p>rchild域指示结点的后继</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="中序线索二叉树的构造"><a href="#中序线索二叉树的构造" class="headerlink" title="中序线索二叉树的构造"></a>中序线索二叉树的构造</h3><ul>
<li><p>概念</p>
<ul>
<li><p>二叉树的线索化是将二叉链表中的空指针改为指向前驱或后继的线索</p>
</li>
<li><p>而前驱或后继的信息只有在遍历时才能得到，因此线索化的实质就是遍历一次二叉树</p>
</li>
</ul>
</li>
<li><p>中序线索二叉树的建立</p>
<ul>
<li><p>附设指针pre指向刚刚访问过的结点，指针p指向正在访问的结点，即pre指向p的前驱</p>
</li>
<li><p>在中序遍历的过程中</p>
<ul>
<li><p>检查p的左指针是否为空，若为空就将它指向pre</p>
</li>
<li><p>检查pre的右指针是否为空，若为空就将它指向p</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>中序线索二叉树的遍历</p>
<ul>
<li>若其右标志为”1”，则右链为线索，指示其后继，否则遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继</li>
</ul>
</li>
<li><p>先序线索二树</p>
<ul>
<li><p>先序序列为ABCDF，然后依次判断每个结点的左右链域，如果为空则将其改造为线索</p>
</li>
<li><p>结点A，B均有左右孩子；结点C无左孩子，将左链域指向前驱B，无右孩子，将右链域指向后继D</p>
</li>
<li><p>结点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继F</p>
</li>
<li><p>结点F无左孩子，将左链域指向前驱D，无右孩子，也无后继故置空</p>
</li>
</ul>
</li>
<li><p>后序线索二叉树</p>
<ul>
<li><p>后序序列为CDBFA，结点C无左孩子，也无前驱故置空，无右孩子，将右链域指向后继D</p>
</li>
<li><p>结点D无左孩子，将左链域指向前驱C，无右孩子，将右链域指向后继B</p>
</li>
<li><p>结点F无左孩子，将左链域指向前驱B，无右孩子，将右链域指向后继A</p>
</li>
</ul>
</li>
<li><p>三种线索二叉树的对比</p>
<ul>
<li><p>确定结点的前驱、后继关系时，是按照前序遍历还是中序遍历还是后序遍历</p>
</li>
<li><p>6个概念</p>
<ul>
<li><p>中序前驱</p>
<ul>
<li>按照中序遍历的前驱，也就是中序遍历序列的前驱、后继</li>
</ul>
</li>
<li><p>中序后继、先序前驱、先序后继、后序前驱、后序后继</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二叉树线索化的具体实现"><a href="#二叉树线索化的具体实现" class="headerlink" title="二叉树线索化的具体实现"></a>二叉树线索化的具体实现</h3><ul>
<li><p>普通二叉树找到中序前驱</p>
<ul>
<li><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2></li>
<li><h2 id="访问结点q"><a href="#访问结点q" class="headerlink" title="访问结点q"></a>访问结点q</h2></li>
<li><h2 id="辅助全局变量，用于查找结点p的前驱"><a href="#辅助全局变量，用于查找结点p的前驱" class="headerlink" title="辅助全局变量，用于查找结点p的前驱"></a>辅助全局变量，用于查找结点p的前驱</h2></li>
</ul>
</li>
<li><p>对二叉树进行中序线索化</p>
<ul>
<li><p>中序遍历</p>
</li>
<li><p>线索二叉树结点定义</p>
</li>
<li><p>定义全局变量pre</p>
</li>
<li><p>访问当前结点</p>
</li>
</ul>
</li>
<li><p>中序线索化——王道书版本</p>
<ul>
<li>pre参数是引用类型，可以在函数内部修改pre参数的值</li>
</ul>
</li>
<li><p>先序线索化</p>
<p>- </p>
<ul>
<li>区别：避免无限循环</li>
</ul>
</li>
<li><h2 id="先序线索化——王道书版本"><a href="#先序线索化——王道书版本" class="headerlink" title="先序线索化——王道书版本"></a>先序线索化——王道书版本</h2></li>
<li><p>后序线索化</p>
<p>- </p>
<ul>
<li>不会出现无限循环</li>
</ul>
</li>
<li><h2 id="后序线索化——王道书版本"><a href="#后序线索化——王道书版本" class="headerlink" title="后序线索化——王道书版本"></a>后序线索化——王道书版本</h2></li>
</ul>
<h3 id="线索二叉树找前驱、后继"><a href="#线索二叉树找前驱、后继" class="headerlink" title="线索二叉树找前驱、后继"></a>线索二叉树找前驱、后继</h3><ul>
<li><p>中序线索二叉树</p>
<ul>
<li><p>找中序前驱</p>
<ul>
<li><p>实现思想：</p>
<ul>
<li><p>若p-&gt;rtag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;rchild</p>
</li>
<li><p>若p-&gt;rtag &#x3D;&#x3D;0，则next &#x3D; p的右子树中最左下结点（右子树第一个被访问）</p>
</li>
</ul>
</li>
<li><p>具体实现：</p>
<ul>
<li><p>找到以p为根的子树中，第一个被中序遍历的结点</p>
</li>
<li><p>在中序线索二叉树中找到结点p的后继结点</p>
</li>
</ul>
</li>
<li><p>如何实现中序线索二叉树的中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>
</li>
</ul>
</li>
<li><p>找中序后继</p>
<ul>
<li><p>实现思想：</p>
<ul>
<li><p>若p-&gt;ltag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;lchild</p>
</li>
<li><p>若p-&gt;ltag &#x3D;&#x3D;0，则next &#x3D; p的左子树中最右下结点（左子树最后一个被访问）</p>
</li>
</ul>
</li>
<li><p>具体实现：</p>
<ul>
<li><p>找到以p为根的子树中，最后一个被中序遍历的结点</p>
</li>
<li><p>在中序线索二叉树中找到结点p的前驱结点</p>
</li>
</ul>
</li>
<li><p>如何实现中序线索二叉树的逆向中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>先序线索二叉树</p>
<ul>
<li><p>先序后继</p>
<ul>
<li><p>实现思想：</p>
<ul>
<li><p>若p-&gt;rtag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;rchild</p>
</li>
<li><p>若p-&gt;rtag &#x3D;&#x3D;0</p>
<ul>
<li><p>如果p有左孩子，则next &#x3D; p的左子树中根结点（左子树第一个被访问）</p>
</li>
<li><p>如果p没有左孩子，则next&#x3D;p的右子树中根结点（右子树第一个被访问）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体实现：</p>
</li>
<li><p>如何实现中序线索二叉树的中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>
</li>
</ul>
</li>
<li><p>先序前驱</p>
<ul>
<li><p>实现思想：</p>
<ul>
<li><p>若p-&gt;ltag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;lchild</p>
</li>
<li><p>若p-&gt;ltag &#x3D;&#x3D;0</p>
<ul>
<li><p>找不到先序前驱，除非从头开始遍历</p>
</li>
<li><p>1.如果能找到p的父节点（三叉链表存储），且p是左孩子</p>
<ul>
<li>next&#x3D;p的父节点</li>
</ul>
</li>
<li><p>2.如果能找到p的父节点，且p是右孩子，其左兄弟为空</p>
<ul>
<li>next&#x3D;p的父节点</li>
</ul>
</li>
<li><p>3.如果能找到p的父节点，且p是右孩子，其左兄弟非空</p>
<ul>
<li>next&#x3D;p的左子树中最后一个被访问的结点（左子树中尽可能往右走，走到尽头可能会往左走，接着再往右走）</li>
</ul>
</li>
<li><p>4.如果p是根结点，则next&#x3D;空</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体实现：</p>
</li>
<li><p>如何实现中序线索二叉树的逆向中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>后序线索二叉树</p>
<ul>
<li><p>后续前驱</p>
<ul>
<li><p>实现思想：</p>
<ul>
<li><p>若p-&gt;ltag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;lchild</p>
</li>
<li><p>若p-&gt;ltag &#x3D;&#x3D;0</p>
<ul>
<li><p>若p有右孩子，则next&#x3D;p的右子树的根结点</p>
</li>
<li><p>若p没有右孩子，则next&#x3D;p的左子树的根结点</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体实现：</p>
</li>
<li><p>如何实现中序线索二叉树的中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>
</li>
</ul>
</li>
<li><p>后续后继</p>
<ul>
<li><p>实现思想：</p>
<ul>
<li><p>若p-&gt;rtag &#x3D;&#x3D; 1，则next &#x3D; p-&gt;rchild</p>
</li>
<li><p>若p-&gt;rtag &#x3D;&#x3D;0</p>
<ul>
<li><p>找不到后续后继，除非从头开始遍历</p>
</li>
<li><p>1.如果能找到p的父节点（三叉链表存储），且p是右孩子</p>
<ul>
<li>next&#x3D;p的父节点</li>
</ul>
</li>
<li><p>2.如果能找到p的父节点，且p是左孩子，其有兄弟为空</p>
<ul>
<li>next&#x3D;p的父节点</li>
</ul>
</li>
<li><p>3.如果能找到p的父节点，且p是左孩子，其右兄弟非空</p>
<ul>
<li>next&#x3D;p的右子树中第一个被访问的结点（右子树中尽可能往左走，走到尽头可能会往右走，接着再往左走）</li>
</ul>
</li>
<li><p>4.如果p是根结点，则p没有后继结点</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体实现：</p>
</li>
<li><p>如何实现中序线索二叉树的逆向中序遍历（非递归算法，空间复杂度&#x3D;O(1)）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h1><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><ul>
<li><p>采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置</p>
</li>
<li><p>根结点下标为0，其伪指针域为-1</p>
</li>
<li><p>代码实现</p>
</li>
<li><p>基本操作</p>
<ul>
<li><p>增加：在data中写入值（顺序无所谓），指针指向父节点</p>
</li>
<li><p>删除：最后还要删除以这些结点为根结点的子树</p>
<ul>
<li><p>方法一：将data置为空，将指针域设为-1</p>
<ul>
<li>空数据会使得遍历更慢</li>
</ul>
</li>
<li><p>方法二：使用最下方结点的数据覆盖要删除的结点</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>利用了每个结点（根结点除外）只有唯一双亲的性质，（有伪指针）可以很快得到每个结点的双亲结点</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>但求结点的孩子时需要遍历整个结构</li>
</ul>
</li>
<li><p>应用：使用二叉树的顺序存储时，一定要把二叉树的结点编号和完全二叉树对应起来</p>
<ul>
<li>结点编号不仅反映了存储位置，也隐含了结点之间的逻辑关系</li>
</ul>
</li>
</ul>
<h3 id="孩子表示法（顺序-链式存储）"><a href="#孩子表示法（顺序-链式存储）" class="headerlink" title="孩子表示法（顺序+链式存储）"></a>孩子表示法（顺序+链式存储）</h3><ul>
<li><p>将每个结点的孩子结点都用单链表链接起来，形成一个线性结构，此时n个结点就有n个孩子链表（叶子结点的孩子链表为空表）</p>
</li>
<li><p>代码实现</p>
</li>
<li><p>如何实现增、删、查</p>
</li>
<li><p>优点</p>
<ul>
<li>寻找子女的操作非常直接</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>寻找双亲的操作需要遍历n个结点中孩子链表指针域所指向的n个孩子链表</li>
</ul>
</li>
</ul>
<h3 id="孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）"><a href="#孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）" class="headerlink" title="孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）"></a>孩子兄弟表示法（若为每个结点增设一个parent域指向其父结点，则查找结点的父结点也很方便）（链式存储）</h3><ul>
<li><p>以二叉链表作为树的存储结构，孩子兄弟表示法使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针、及指向结点下一个兄弟结点的指针</p>
</li>
<li><p>优点</p>
<ul>
<li>这种存储表示法比较灵活其最大的优点是可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>从当前结点查找其双亲结点比较麻烦</li>
</ul>
</li>
</ul>
<h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><ul>
<li><p>树转换为二叉树的规则</p>
<ul>
<li>每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟</li>
</ul>
</li>
<li><p>树转换成二叉树的画法</p>
<ul>
<li><p>在兄弟结点之间加一连线</p>
</li>
<li><p>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉</p>
</li>
<li><p>以树根为轴心,顺时针旋转45度</p>
</li>
</ul>
</li>
<li><p>森林转换为二叉树的画法</p>
<ul>
<li><p>将森林中的每棵树转换成相应的二叉树</p>
</li>
<li><p>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根连线</p>
</li>
<li><p>以第一棵树的根为轴心顺时针旋转45</p>
</li>
</ul>
</li>
<li><p>二叉树转换为森林的规则</p>
<ul>
<li><p>若二叉树非空，则二叉树的根及其左子树为第一棵树的二叉树形式，故将根的右链断开</p>
</li>
<li><p>二叉树根的右子树又可视为一个由除第一棵树外的森林转换后的二叉树</p>
</li>
<li><p>应用同样的方法，直到最后只剩一棵没有右子树的二叉树为止，最后再将每棵二叉树依次转换成树，就得到了原森林</p>
</li>
</ul>
</li>
</ul>
<h2 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h2><ul>
<li><p>树的遍历</p>
<ul>
<li><p>先根遍历——树的深度优先遍历</p>
<ul>
<li><p>若树非空，先访问根结点再依次遍历根结点的每棵子树，遍历子树时仍遵循先根后子树的规则</p>
</li>
<li><p>其遍历序列与这棵树相应二叉树的先序序列相同</p>
</li>
<li><h2 id="伪代码实现"><a href="#伪代码实现" class="headerlink" title="伪代码实现"></a>伪代码实现</h2></li>
</ul>
</li>
<li><p>后根遍历——树的深度优先遍历</p>
<ul>
<li><p>若树非空，先依次遍历根结点的每棵子树，再访问根结点，遍历子树时仍遵循先子树后根的规则</p>
</li>
<li><p>其遍历序列与这棵树相应二叉树的中序序列相同</p>
</li>
<li><p>伪代码实现</p>
</li>
</ul>
</li>
<li><p>层序遍历（队列实现）——也称为对树的广度优先遍历</p>
<ul>
<li><p>1.若树非空，则根结点入队</p>
</li>
<li><p>2.若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</p>
</li>
<li><p>3.重复2</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>森林的遍历</p>
<ul>
<li><p>先序遍历森林（相当于依次对各个树进行先根遍历，也等同于对二叉树的先序遍历）</p>
<ul>
<li><p>访问森林中第一棵树的根结点</p>
</li>
<li><p>先序遍历第一棵树中根结点的子树森林</p>
</li>
<li><p>先序遍历除去第一棵树之后剩余的树构成的森林</p>
</li>
</ul>
</li>
<li><p>中序遍历森林（相当于依次对各个树进行后根遍历，也等同于对二叉树的中序遍历）</p>
<ul>
<li><p>中序遍历森林中第一棵树的根结点的子树森林</p>
</li>
<li><p>访问第一棵树的根结点</p>
</li>
<li><p>中序遍历除去第一棵树之后剩余的树构成的森林</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>树的应用——并查集</p>
<ul>
<li><p>支持操作</p>
<ul>
<li><p>1）Union（S，Root1，Root2）：把集合S中的子集合Root2并入子集合Root1。要求Root1和Root2互不相交，否则不执行合并</p>
</li>
<li><p>2）Find（S.x）：查找集合S中单元素x所在的子集合，并返回该子集合的名字</p>
</li>
<li><p>3）Initial（S）：将集合S中的每个元素都初始化为只有一个单元素的子集合</p>
</li>
</ul>
</li>
<li><p>具体实现</p>
<ul>
<li><p>用树（森林）的双亲表示作为并查集的存储结构，每个子集合以一棵树表示</p>
</li>
<li><p>所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内</p>
</li>
<li><p>通常用数组元素的下标代表元素名，用根结点的下标代表子集合名，根结点的双亲结点为负数</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="树与二叉树的应用"><a href="#树与二叉树的应用" class="headerlink" title="树与二叉树的应用"></a>树与二叉树的应用</h1><h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><ul>
<li><p>二叉排序树的定义</p>
<ul>
<li><p>特性（左子树任一结点值 &lt; 根结点值 &lt; 右子树任一结点值 ）</p>
<ul>
<li><p>1）若左子树非空，则左子树上所有结点的值均小于根结点的值</p>
</li>
<li><p>2）若右子树非空，则右子树上所有结点的值均大于根结点的值</p>
</li>
<li><p>3）左、右子树也分别是一棵二叉排序树</p>
</li>
<li><p>使用中序遍历，可以得到一个递增的有序序列</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树的查找</p>
<ul>
<li><p>二叉排序树的查找是从根结点开始，沿某个分支逐层向下比较的过程，若二叉排序树非空，先将给定值与根结点的关键字比较</p>
<ul>
<li><p>若相等，则查找成功</p>
</li>
<li><p>若不等，如果小于根结点的关键字，则在根结点的左子树上查找</p>
</li>
<li><p>否则在根结点的右子树上查找</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li><p>非递归实现——空间复杂度O(1)</p>
</li>
<li><p>递归实现——空间复杂度O(h)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树的插入</p>
<ul>
<li><p>插入结点的过程（插入的结点一定是一个新添加的叶结点，且是查找失败时的查找路径上访间的最后一个结点 的左孩子或右孩子）</p>
<ul>
<li><p>若原二叉排序树为空，则直接插入结点</p>
</li>
<li><p>若关键字k小于根结点值，则插入到左子树</p>
</li>
<li><p>若关键字k大于根结点值，则插入到右子树</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li><p>递归实现</p>
</li>
<li><p>非递归实现</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树的构造</p>
<ul>
<li><p>设查找的关键字序列为{45，24，53，45，12，24}，则生成的二叉排序树</p>
</li>
<li><p>生成示意图<img src="https://api2.mubu.com/v3/document_image/076d411e-0555-4a7b-9364-3e4411db4b81-3224585.jpg" alt="img"></p>
</li>
<li><p>代码实现</p>
</li>
</ul>
</li>
<li><p>二叉排序树的删除</p>
<ul>
<li><p>1.若被删除结点z是叶结点，则直接删除，不会破坏二叉排序树的性质</p>
</li>
<li><p>2.若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置</p>
</li>
<li><p>3.若结点z有左、右两棵子树</p>
<ul>
<li><p>则令z的直接后继（z的右子树的最左下结点）替代z，然后从二叉排序树中删去这个直接后继</p>
<ul>
<li><p>如果直接后继是叶子结点，则直接删除</p>
</li>
<li><p>如果直接后继有右子树，将这个直接后继的右子树成为直接后继的父节点的子树</p>
</li>
</ul>
</li>
<li><p>则令z的直接前驱（z的左子树的最右下结点）替代z，然后从二叉排序树中删去这个直接前驱</p>
<ul>
<li><p>如果直接前驱是叶子结点，则直接删除</p>
</li>
<li><p>如果直接前驱有左子树，将这个直接前驱的左子树成为直接前驱的父节点的子树</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉排序树的查找效率分析</p>
<ul>
<li><p>查找长度：在查找过程中，需要对比关键字的次数，反映了查找操作时间复杂度</p>
</li>
<li><p>查找成功的平均查找长度ASL：对比关键字的平均次数</p>
</li>
<li><p>查找成功的平均执行时间为</p>
<ul>
<li><p>最坏情况：每个结点只有一个分支，树高&#x3D;结点数n，平均查找长度&#x3D;O(n)</p>
</li>
<li><p>最好情况：n个结点的二叉树最小高度为（log_2(n)向下取整）+1，平均查找长度O(n)</p>
</li>
<li><p>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1</p>
</li>
</ul>
</li>
<li><p>查找失败的平均查找长度ASL：补上空结点，计算查找空结点时需要对比关键字的平均次数</p>
</li>
</ul>
</li>
</ul>
<h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h2><ul>
<li><p>平衡二叉树的定义</p>
<ul>
<li><p>在插入和删除二叉树结点时，要保证任意结点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树</p>
</li>
<li><p>平衡因子：左子树与右子树的高度差为该结点的平衡因子 平衡因子的值只可能是—1、0或1</p>
</li>
<li><p>代码实现</p>
</li>
</ul>
</li>
<li><p>平衡二叉树的插入</p>
<ul>
<li><p>当在二叉排序树中插入（或删除）一个结点时</p>
<ul>
<li><p>首先检查其插入路径上的所有结点是否因为此次操作而导致了不平衡</p>
</li>
<li><p>若导致了不平衡，则先找到插入路径上离插入结点最近的平衡因子的绝对值大于1的结点A</p>
</li>
<li><p>再对以A为根的子树，在保持二叉排序动特性的前提下，调整各结点的位置关系，使之重新达到平衡</p>
</li>
</ul>
</li>
<li><p>规律归纳（插入新结点后调整不平衡问题）</p>
<ul>
<li><p>LL平衡旋转（右单旋结）</p>
<ul>
<li><p>由于在结点A的左孩子（L）的左子树（L）上插入了新结点</p>
</li>
<li><p>A的平衡因子由1增至2，导致以A为根的子树失去平衡</p>
</li>
<li><p>目的：恢复平衡，保持二叉排序树特性</p>
</li>
<li><p>需要一次向右的旋转操作，此时B变成根，A成为B的右子树，那么B原来的右子树只能成为A的左子树</p>
</li>
<li><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li>
</ul>
</li>
<li><p>RR平衡旋转（左单旋转）</p>
<ul>
<li><p>由于在结点A的右孩子（R）的右子树（R）上插入了新结点</p>
</li>
<li><p>A的平衡因子由-1减至-2，导致以A为根的子树失去平衡</p>
</li>
<li><p>需要一次向左的旋转操作，此时B变成根，A成为B的左子树，那么B原来的左子树只能成为A的右子树</p>
</li>
<li><p>代码实现</p>
</li>
</ul>
</li>
<li><p>LR平衡旋转（先左后右双旋转）</p>
<ul>
<li><p>由于在A的左孩子（L）的右子树（R）上插入新结点</p>
</li>
<li><p>A平衡因子由-1增至2，导致以A为根的子树失去平衡</p>
</li>
<li><p>需要进行两次旋转操作，先左旋转后右旋转</p>
<ul>
<li><p>1.C到B的位置，B变为C的左孩子，CL成为B的右孩子</p>
</li>
<li><p>2.C到A的位置，A变为C的右孩子，CR变为A的左孩子</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
</li>
</ul>
</li>
<li><p>RL平衡旋转（先右后左双旋转）</p>
<ul>
<li><p>由于在A的右孩子（R）的左子树（L）上插入新结点</p>
</li>
<li><p>A的平衡因子由-1减至-2，导致以A为根的子树失去平衡</p>
</li>
<li><p>需要进行两次旋转操作，先右旋转后左旋转</p>
<ul>
<li><p>1.C到B的位置，B变为C的右孩子，CR成为B的左孩子</p>
</li>
<li><p>2.C到A的位置，A变为C的左孩子，CL变为A的右孩子‘</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么解决最小不平衡子树之后，整个树就平衡了？</p>
<ul>
<li>插入操作导致最小不平衡子树高度+1，经过调整后高度恢复原状</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平衡二叉树的查找</p>
<ul>
<li><p>平均查找长度ASL：不超过O(h)——查找操作的时间复杂度</p>
</li>
<li><p>深度为h的平衡树最少含有的结点数</p>
<ul>
<li>递推公式n(h)&#x3D;n(h-1)+n(h-2)+1</li>
</ul>
</li>
<li><p>平衡二叉树的最大深度：h&#x3D;Log_2(n)</p>
</li>
<li><p>平衡二叉树的平均查找长度：Log_2(n)</p>
</li>
</ul>
</li>
</ul>
<h2 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h2><ul>
<li><p>带权路径长度（WPL）</p>
<ul>
<li><p>结点的权：结点有某种现实含义的数值（如：用于表示结点的重要性）</p>
</li>
<li><p>结点的带权路径长度：从（树的）根到任意结点的路径长度（经过的边数）与该结点上权值的乘积</p>
</li>
<li><p>树中所有叶子结点的带权路径长度之和称为该树的带权路径长度</p>
<ul>
<li><p>计算公式（重点：叶子结点）<img src="https://api2.mubu.com/v3/document_image/475b7c69-2f41-4986-8ce2-6858f8ed205f-3224585.jpg" alt="img"></p>
</li>
<li><p>是第i个叶结点所带的权值</p>
</li>
<li><p>是该叶结点到根结点的路径长度</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>哈夫曼树的定义</p>
<ul>
<li>称为哈夫曼树，也称最优二叉树：在含有n个带权叶结点的二叉树中其中带权路径长度（WPL）最小的二叉树<ul>
<li>哈夫曼树中只有叶子结点有意义</li>
</ul>
</li>
</ul>
</li>
<li><p>哈夫曼树的构造</p>
<ul>
<li><p>算法</p>
<ul>
<li><p>每次从合成后存在的结点中选出两个最小的进行构造二叉树</p>
</li>
<li><p>并将这两个结点的权值之和作为该二叉树根结点的权值</p>
</li>
<li><p>重复</p>
</li>
</ul>
</li>
<li><p>示意图<img src="https://api2.mubu.com/v3/document_image/4500ae20-68af-4289-9c32-9417f414dff7-3224585.jpg" alt="img"></p>
</li>
<li><p>特点</p>
<ul>
<li><p>每个初始结点最终都是叶子结点，且权值越小的结点到根结点的路径长度越大</p>
</li>
<li><p>一共合并n-1次，所以哈夫曼树的结点总数为2n-1</p>
</li>
<li><p>哈夫曼树不存在度为1的结点（哈夫曼树中各个结点的度只能为0或2）</p>
</li>
<li><p>哈夫曼树不唯一，但WPL必定相同且最优</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>哈夫曼编码（可变长度编码+前缀编码）</p>
<ul>
<li><p>基本概念（可变长度编码比固定长度编码要好）</p>
<ul>
<li><p>固定长度编码：在数据通信中，若对每个字符用相等长度的二进制位表示</p>
</li>
<li><p>可变长度编码</p>
<ul>
<li><p>允许对不同字符用不等长的二进制位表示</p>
</li>
<li><p>特点</p>
<ul>
<li><p>对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码</p>
</li>
<li><p>可以使字符的平均编码长度减短，起到压缩数据的效果</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>前缀编码：没有一个编码是另一个编码的前缀</p>
<ul>
<li>为什么只能有叶子结点存在编码？<ul>
<li>假设非叶子结点有编码为1表示A，编码11表示B。如果发送11111，就不知道究竟是AAAAA还是BBA，会有歧义。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码</p>
<ul>
<li>可以用于数据压缩</li>
</ul>
</li>
<li><p>构造哈夫曼编码——本质就是构造哈夫曼树</p>
<ul>
<li><p>将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树</p>
</li>
<li><p>将字符的编码解释为从根至该字符的路径上边标记的序列</p>
</li>
<li><p>其中边标记为0表示”转向左孩子”，标记为1表示”转向右孩子”</p>
</li>
<li><p>示意图<img src="https://api2.mubu.com/v3/document_image/6e0be798-ce73-405d-a16e-60d505cf06e5-3224585.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4%E4%B8%B2/" rel="prev" title="串">
                  <i class="fa fa-chevron-left"></i> 串
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/03/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6%E5%9B%BE/" rel="next" title="图">
                  图 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
