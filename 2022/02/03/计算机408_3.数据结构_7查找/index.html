<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找  查找表（查找结构） ：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型  关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的  查找表操作  查询某个特定的数据元素是否在查找表中  检索满足条件的某个特定的数据元素的各种属性  在查找表">
<meta property="og:type" content="article">
<meta property="og:title" content="查找">
<meta property="og:url" content="https://2673747024.github.io/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7%E6%9F%A5%E6%89%BE/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找  查找表（查找结构） ：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型  关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的  查找表操作  查询某个特定的数据元素是否在查找表中  检索满足条件的某个特定的数据元素的各种属性  在查找表">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/392c9d00-02e0-49c4-884d-fbdc98df1d23-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/b0e90783-27bd-4664-91e1-f4144d72fb74-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/c51c8c1b-62b1-44a7-b5af-4c8def6be8fe-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/cb807439-9f0e-4a3b-b308-8a495285f0af-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/4dc73481-b088-409b-b157-cbe708961cea-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/76b2ad8d-780b-42c0-8763-6351076a3175-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/5727dec9-0d04-490a-9548-3ac38d535f03-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/f6aaafc1-823f-48d2-8eeb-7d8ab5ca53e8-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/3b2075f1-356c-4ad8-a74e-64557bba4953-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/05efead1-169c-4816-84f2-54b8afd0ca63-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/d5426ede-20a7-484b-9160-f62fd8e8228a-3224585.jpg">
<meta property="article:published_time" content="2022-02-03T14:59:42.392Z">
<meta property="article:modified_time" content="2022-02-04T16:11:23.078Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api2.mubu.com/v3/document_image/392c9d00-02e0-49c4-884d-fbdc98df1d23-3224585.jpg">


<link rel="canonical" href="https://2673747024.github.io/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7%E6%9F%A5%E6%89%BE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7%E6%9F%A5%E6%89%BE/","path":"2022/02/03/计算机408_3.数据结构_7查找/","title":"查找"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>查找 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-number">2.</span> <span class="nav-text">顺序查找和折半查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">2.1.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%88%AC"><span class="nav-number">2.2.</span> <span class="nav-text">一般</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-number">2.3.</span> <span class="nav-text">折半查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-number">2.4.</span> <span class="nav-text">分块查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.5.</span> <span class="nav-text">代码实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E4%B8%8D%E5%9D%87%E5%8C%80%EF%BC%9A%E4%B8%8E%E5%88%86%E5%9D%97%E5%9D%87%E5%8C%80%E6%9C%89%E6%9E%81%E5%A4%A7%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.6.</span> <span class="nav-text">分块不均匀：与分块均匀有极大的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">B树和B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#B%E6%A0%91%E5%8F%8A%E5%85%B6%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">3.1.</span> <span class="nav-text">B树及其基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.2.</span> <span class="nav-text">B+树的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#M%E9%98%B6%E7%9A%84B-%E6%A0%91%E4%B8%8EM%E9%98%B6%E7%9A%84B%E6%A0%91%E7%9A%84%E4%B8%BB%E8%A6%81%E5%B7%AE%E5%BC%82"><span class="nav-number">3.3.</span> <span class="nav-text">M阶的B+树与M阶的B树的主要差异</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%88%E7%94%A8%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">散列表（用空间换时间）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">散列表的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%88%E7%9B%AE%E7%9A%84%EF%BC%9A%E5%86%B2%E7%AA%81%E6%9B%B4%E5%B0%91%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">散列函数的构造方法（目的：冲突更少）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">处理冲突的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%E5%8F%8A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-number">4.4.</span> <span class="nav-text">散列查找及性能分析</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">112</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7%E6%9F%A5%E6%89%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          查找
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-03 22:59:42" itemprop="dateCreated datePublished" datetime="2022-02-03T22:59:42+08:00">2022-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-05 00:11:23" itemprop="dateModified" datetime="2022-02-05T00:11:23+08:00">2022-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/" itemprop="url" rel="index"><span itemprop="name">计算机408</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">3.数据结构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7-%E6%9F%A5%E6%89%BE/" itemprop="url" rel="index"><span itemprop="name">7.查找</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：6.7k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈23 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ul>
<li><p>查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找</p>
</li>
<li><p>查找表（查找结构） ：用于查找的数据集合称为查找表，它由同一类型的数据元素（或记录）组成，可以是一个数组或链表等数据类型</p>
</li>
<li><p>关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的</p>
</li>
<li><p>查找表操作</p>
<ul>
<li><p>查询某个特定的数据元素是否在查找表中</p>
</li>
<li><p>检索满足条件的某个特定的数据元素的各种属性</p>
</li>
<li><p>在查找表中插入一个数据元素</p>
</li>
<li><p>从查找表中删除某个数据元素</p>
</li>
</ul>
</li>
<li><p>静态查找表</p>
<ul>
<li>查找后不会对表进行任何修改</li>
</ul>
</li>
<li><p>动态查找表</p>
<ul>
<li>查找后对表进行修改</li>
</ul>
</li>
<li><p>平均查找长度ASL：平均查找长度是衡量查找算法效率的最主要的指标</p>
<ul>
<li><p>在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值</p>
</li>
<li><p>数学表达式<img src="https://api2.mubu.com/v3/document_image/392c9d00-02e0-49c4-884d-fbdc98df1d23-3224585.jpg" alt="img"></p>
</li>
<li><p>参数含义</p>
<ul>
<li><p>n是查找表的长度</p>
</li>
<li><p>P是查找第i个数据元素的概率，一般认为每个数据元素的查找概率相等，即P&#x3D;1&#x2F;n</p>
</li>
<li><p>Ci是找到第个数据元素所需进行的比较次数</p>
</li>
</ul>
</li>
<li><p>评价一个查找算法的效率时，通常考虑查找成功&#x2F;查找失败两种情况的ASL</p>
</li>
</ul>
</li>
</ul>
<h1 id="顺序查找和折半查找"><a href="#顺序查找和折半查找" class="headerlink" title="顺序查找和折半查找"></a>顺序查找和折半查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul>
<li><p>又称线性查找，主要用于在线性表中进行查找。顺序查找通常分为对一般的无序线性表的顺序查找和对按关键字有序的顺序表的顺序查找</p>
</li>
<li><p>一般线性表的顺序查找</p>
<ul>
<li><p>基本思想</p>
<ul>
<li><p>从线性表的一端开始，逐个检查关键字是否满足给定的条件。</p>
</li>
<li><p>若查找到某个元素的关键字满足给定条件，则查找成功，返回该元素在线性表中的位置</p>
</li>
<li><p>若已经查找到表的另一端，但还没有查找到符合给定条件的元素，则返回查找失败的信息</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li><h2 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h2></li>
<li><p>0号位置增加哨兵</p>
<ul>
<li>优点：无需判断是否越界，效率更高</li>
</ul>
</li>
</ul>
</li>
<li><p>平均查找长度</p>
<ul>
<li><p>成功（查找的数据存在于线性表中，n为线性表中元素总个数）</p>
<ul>
<li>ASL成功 &#x3D; (n+1)&#x2F;2</li>
</ul>
</li>
<li><p>失败（查找的数据不存在于线性表中，n为线性表中元素总个数）</p>
<ul>
<li>ASL不成功 &#x3D; n+1</li>
</ul>
</li>
</ul>
</li>
<li><p>缺点：当n较大时，平均查找长度较大，效率低</p>
</li>
<li><p>优点</p>
<ul>
<li><p>对数据元素的存储没有要求，顺序存储或链式存储皆可</p>
</li>
<li><p>对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有序表的顺序查找（经常查找失败）</p>
<ul>
<li><p>基本思想</p>
<ul>
<li><p>假设表L是按关键字从小到大排列的，查找的顺序是从前往后，待查找元素的关键字为key</p>
</li>
<li><p>当查找到第i个元素时，发现第i个元素对应的关键字小于key，但第i+1个元素对应的关键字大于key，这时就可返回查找失败的信息</p>
</li>
<li><p>因为第i个元素之后的元素的关键字均大于key，所以表中不存在关键字为key的元素</p>
</li>
</ul>
</li>
<li><p>平均查找长度</p>
<ul>
<li><p>成功<img src="https://api2.mubu.com/v3/document_image/b0e90783-27bd-4664-91e1-f4144d72fb74-3224585.jpg" alt="img"></p>
</li>
<li><p>失败（前提：假设查找失败结点的概率相等，也就是每两个结点间的差相等）<img src="https://api2.mubu.com/v3/document_image/c51c8c1b-62b1-44a7-b5af-4c8def6be8fe-3224585.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>查找判定树的画法</p>
<ul>
<li><p>一个成功结点的查找长度&#x3D;自身所在层数</p>
</li>
<li><p>一个失败结点的查找长度&#x3D;其父结点所在层数</p>
</li>
<li><p>默认情况下，各种失败情况或成功情况都等概率发生</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>无序表的顺序查找（经常查找成功）</p>
<ul>
<li><p>被查找概率大的数据放在靠前位置</p>
</li>
<li><p>平均查找长度</p>
<ul>
<li><p>成功：小于(n+1)&#x2F;2</p>
</li>
<li><p>失败：n+1</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>时间复杂度：O(n)</p>
</li>
</ul>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><ul>
<li><p>折半查找又称二分查找，它仅适用于有序的顺序表</p>
<ul>
<li>顺序表：拥有随机存取（随机访问）的特性，而链表没有</li>
</ul>
</li>
<li><p>基本思想</p>
<ul>
<li><p>首先将给定值key与表中中间位置的元素比较，若相等则查找成功，返回该元素的存储位置</p>
</li>
<li><p>若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分</p>
</li>
<li><p>然后在缩小的范围内继续进行同样的查找如此重复，直到找到为止</p>
</li>
<li><p>或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li><p>升序</p>
</li>
<li><p>降序</p>
</li>
</ul>
</li>
<li><p>查找过程中可以生成判定树（平衡二叉树）</p>
<ul>
<li><p>树中每个圆形结点表示一个记录结点中的值为该记录的关键字值</p>
</li>
<li><p>树中最下面的叶结点都是方形的，它表示查找不成功的情况</p>
</li>
<li><p>若mid&#x3D;【(low+high)&#x2F;2】向下取整，则对于任何一个结点，一定有右子树结点数-左子树结点数&#x3D;0或1</p>
<ul>
<li><p>如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</p>
</li>
<li><p>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</p>
</li>
</ul>
</li>
<li><p>折半查找判定树的构造</p>
<ul>
<li><p>折半查找判定树一定是平衡二叉树</p>
</li>
<li><p>折半查找判定树中，只有最下面一层是不满的，元素个数为n时，树高为h&#x3D;【log_2(n+1)】向上取整（不包含失败结点）</p>
</li>
<li><p>折半查找判定树结点关键字：左&lt;中&lt;右，满足二叉排序树的定义</p>
</li>
<li><p>失败结点：n+1（等于成功结点的空链域数量）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平均查找长度</p>
<ul>
<li><p>成功</p>
<ul>
<li><p>h是树的高度，并且元素个数为n时，树高h&#x3D;log_2(n + 1)向上取整</p>
</li>
<li><p>ASL成功&lt;&#x3D;h</p>
</li>
</ul>
</li>
<li><p>失败</p>
<ul>
<li>ASL失败&lt;&#x3D;h</li>
</ul>
</li>
<li><p>时间复杂度：O(log_2(n))</p>
</li>
</ul>
</li>
<li><p>时间复杂度为<img src="https://api2.mubu.com/v3/document_image/cb807439-9f0e-4a3b-b308-8a495285f0af-3224585.jpg" alt="img"></p>
</li>
<li><p>仅适合于顺序存储结构，不适合于链式存储结构，且要求元素按关键字有序排列</p>
</li>
<li><p>拓展：</p>
<ul>
<li><p>大部分情况下，折半查找的速度优于顺序查找的速度（平均速率）；但是，折半查找的速度不是一定比顺序查找快</p>
</li>
<li><p>如果mid&#x3D;【(low+high)&#x2F;2】向上取整，判定树是怎样的？对于任何一个结点，一定有右子树结点数-左子树结点数&#x3D;0或1</p>
<ul>
<li><p>如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等</p>
</li>
<li><p>如果当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><ul>
<li><p>又称索引顺序查找，它吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找</p>
</li>
<li><p>基本思想</p>
<ul>
<li><p>将查找表分为若干子块</p>
</li>
<li><p>块内的元素可以无序，但块之间是有序的，第一个块中的最大关键字小于第二个块中的所有记录的关键字，以此类推</p>
</li>
<li><p>再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址（或分块的存储区间），索引表按关键字大小有序排列</p>
</li>
</ul>
</li>
<li><p>实现思想</p>
<ul>
<li><p>在索引表中确定待查记录所属的分块</p>
<ul>
<li><p>顺序查找</p>
<ul>
<li><p>将查找目标的关键字与索引表中的元素的关键字依次比较</p>
</li>
<li><p>索引表关键字小于查找目标关键字时，指针指向索引表下一个元素</p>
</li>
<li><p>直到索引表关键字大于等于查找目标关键字</p>
</li>
</ul>
</li>
<li><p>分块查找</p>
<ul>
<li><p>在索引表中，low指向索引表第一个元素，high指向索引表最后一个元素</p>
</li>
<li><p>当在索引表中查找成功时，直接返回该索引表项</p>
</li>
<li><p>当在索引表中查找失败时，返回low所指的索引表项</p>
<ul>
<li>因为low+1&#x3D;high时，mid&#x3D;low，此时mid&lt;目标，所以low&#x3D;high&gt;目标，mid&#x3D;low&#x3D;high&gt;目标，high&#x3D;mid-1，所以high&lt;目标&lt;low，应该从low所指元素的区间内寻找</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在块内顺序查找</p>
<ul>
<li><p>从索引表中该元素的起始地址开始查找</p>
</li>
<li><p>如果超出分块范围，那么查找失败</p>
</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li>
<li><p>查找成功长度</p>
<ul>
<li><h2 id="分块不均匀：与分块均匀有极大的区别"><a href="#分块不均匀：与分块均匀有极大的区别" class="headerlink" title="分块不均匀：与分块均匀有极大的区别"></a>分块不均匀：与分块均匀有极大的区别</h2></li>
<li><p>分块均匀</p>
<ul>
<li><p>将长度为n的查找表均匀地分为b块，每块有s个记录，（n&#x3D;s*b）在等概率情况下</p>
</li>
<li><p>索引查找的平均查找长度LI；决内查找的平均查找长度LS</p>
</li>
<li><p>在块内和索引表中均采用顺序查找，则平均查找长度（求平均查找长度最小值：函数求导）<img src="https://api2.mubu.com/v3/document_image/4dc73481-b088-409b-b157-cbe708961cea-3224585.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/76b2ad8d-780b-42c0-8763-6351076a3175-3224585.jpg" alt="img"></p>
</li>
<li><p>若对索引表采用折半查找时，则平均查找长度<img src="https://api2.mubu.com/v3/document_image/5727dec9-0d04-490a-9548-3ac38d535f03-3224585.jpg" alt="img"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>若查找表是“动态查找表”——使用链式存储</p>
</li>
</ul>
<h1 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h1><h2 id="B树及其基本操作"><a href="#B树及其基本操作" class="headerlink" title="B树及其基本操作"></a>B树及其基本操作</h2><ul>
<li><p>概述：又称多路平衡查找树，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示</p>
</li>
<li><p>B树要么为空树，要么满足如下特点：</p>
<ul>
<li><p>树中每个结点至多有m裸子树，即至多含有m—1个关键字</p>
<ul>
<li>一个关键字可以将一个查找区间分为两个部分</li>
</ul>
</li>
<li><p>若根结点不是终端结点，则至少有2棵子树，即1个关键字</p>
<ul>
<li>为了保证绝对平衡</li>
</ul>
</li>
<li><p>规定：除根结点外的所有非叶结点至少有   棵子树,即至少含有   个关键字</p>
<ul>
<li><p>从而保证每个结点内关键字不会太少，树不会很高，查找的层数不会很多，从而保证查找效率</p>
</li>
<li><p>如果整个树只有1个元素，根结点就只有两个分叉</p>
</li>
</ul>
</li>
<li><p>规定：B树是所有结点的平衡因子均等于0（对于任何一个结点，其所有子树的高度都要相同）的多路平衡查找树</p>
<ul>
<li>从而保证这个树是平衡的，保证查找效率</li>
</ul>
</li>
<li><p>所有的叶结点都出现在同一层次上，并且不带信息（实际上这些结点不存在，指向这些结点的指针为空）</p>
<ul>
<li>绝对平衡导致的结果</li>
</ul>
</li>
<li><p>每个结点内关键字的值：递增，且关键字左侧指针的关键字&lt;关键字&lt;关键字左侧指针的关键字</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li>结点定义</li>
</ul>
</li>
<li><p>推导性质</p>
<ul>
<li><p>结点的孩子个数等于该结点中关键字个数加1</p>
</li>
<li><p>如果根结点没有关键字就没有子树此时B树为空</p>
</li>
<li><p>如果根结点有关键字，则其子树必然大于等于两棵，因为子树个数等于关键字个数加1</p>
</li>
<li><p>结点中关键字从左到右递增有序，关键字两侧均有指向子树的指针，左边指针所指子树的所有关键字均小于该关键字，右边指针所指子树的所有关键字均大于该关键字</p>
</li>
</ul>
</li>
<li><p>B树的高度（磁盘存取次数）</p>
<ul>
<li><p>最小高度：</p>
<ul>
<li><p>n&lt;&#x3D;(m-1)(1+m+m^2+……+m^(h-1))，m-1为每个结点的关键字，第一层1个结点，第二次m个结点，……</p>
</li>
<li><p>h&gt;&#x3D;log_m(n+1)</p>
</li>
<li><p>结论：对任意一棵包含n个关键字、高度为h、阶数为m的B树<img src="https://api2.mubu.com/v3/document_image/f6aaafc1-823f-48d2-8eeb-7d8ab5ca53e8-3224585.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>最大高度：让每个结点中的关键字个数达到最少，则容纳同样多关键字的B树的高度达到最大</p>
<ul>
<li><p>n个关键字的B树必有n+1个叶子结点（n个关键字将整个区间切分为n+1个区间，也就是叶子结点）</p>
</li>
<li><p>第一层至少1个结点，第二层至少有2个结点，第三层至少有2【m&#x2F;2】向上取整，第h层有2(【m&#x2F;2】向上取整)^(h-2)，第h+1层（失败结点个数）有2(【m&#x2F;2】向上取整)^(h-1)个</p>
</li>
<li><p>n+1&gt;&#x3D;2(【m&#x2F;2】向上取整)^(h-1)，即h&lt;&#x3D;log_(【m&#x2F;2】向上取整)((n+1)&#x2F;2)+1</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B树的查找</p>
<ul>
<li><p>在B树上查找到某个结点后，先在有序表中进行查找</p>
</li>
<li><p>若找到则直找成功，否则按照对应的指针信息到所指的子树中去查找</p>
</li>
<li><p>查找到叶结点时（对应指针为空指针） ，则说明树中没有对应的关键字，直找失败</p>
</li>
</ul>
</li>
<li><p>B树的插入</p>
<ul>
<li><p>定位：利用前述的B树查找算法找出插入该关键字的最低层中的某个非叶结点（注意插入位置一定是最低层中的某个非叶结点）</p>
</li>
<li><p>插入：在B树中，每个非失败结点的关键字个数都在区间<img src="https://api2.mubu.com/v3/document_image/3b2075f1-356c-4ad8-a74e-64557bba4953-3224585.jpg" alt="img"></p>
</li>
<li><p>插入后的结点关键字个数小于m可以直接插入插入后检查被插入结点内关键字的个数，当插入后的结点关键字个数大于m-1时，必须对结点进行分裂</p>
<ul>
<li><p>从中间位置（【m&#x2F;2】向上取整）将关键字分为两部分，左侧部分存在原结点中，【m&#x2F;2】向上取整的结点插入到原结点的父结点（指向该结点指针所对应的位置），右侧部分放入新结点中与原结点成为兄弟（整个过程只增加了一个结点）</p>
</li>
<li><p>若父结点的关键字也超高了上限，则父结点继续进行分裂</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B树的删除</p>
<ul>
<li><p>终端结点的删除</p>
<ul>
<li><p>直接删除关键字：若被删除关键字所在结点的关键字个数为   ，说明该结点为终端结点，表明删除该关键字后仍满足B树的定义，则直接删去该关键字<img src="https://api2.mubu.com/v3/document_image/05efead1-169c-4816-84f2-54b8afd0ca63-3224585.jpg" alt="img"></p>
</li>
<li><p>删除结点后，结点内关键字数低于（【m&#x2F;2】向上取整-1）</p>
<ul>
<li><p>兄弟够借：若被删除关键字所在结点删除前的关键字个数为    ，且与此结点相邻的右（成左）兄弟结点的关键字个数为   ，则需要调整该结点的右（或左）兄弟结点及其双亲结点（父子换位法），以达到新的平衡</p>
<ul>
<li><p>右兄弟宽裕时，当前结点的后继和后继的后继填补空缺</p>
<ul>
<li>当前结点的后继（该关键字存放在父结点中）存放到该结点中，当前结点的后继的后继（该关键字存放在兄弟结点中）存放在父结点中</li>
</ul>
</li>
<li><p>左兄弟宽裕时，当前结点的前驱和前驱的前驱填补空缺</p>
</li>
</ul>
</li>
<li><p>兄弟不够借：若被删除关键字所在结点删除前的关键字个数    ，且此时与该结点相邻的左、右兄弟结点的关键字个数均     ，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</p>
<ul>
<li><p>该结点，与指向该结点指针和指向不够借的兄弟结点指针之间的双亲结点的关键字，与该结点的兄弟结点进行合并</p>
</li>
<li><p>若双亲结点也低于（【m&#x2F;2】向上取整-1），则重复操作，若根结点关键字个数减少到0，则直接删除根结点</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对非终端结点的删除转化为对终端结点的删除：若被删除关键字在非终端结点，则用直接前驱或直接后继来替代被删除的关键字</p>
<ul>
<li><p>直接前驱：当前关键字左侧指针所指子树中“最右下”的元素</p>
</li>
<li><p>直接后继：当前关键字右侧指针所指子树中“最左下”的元素</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="B-树的基本概念"><a href="#B-树的基本概念" class="headerlink" title="B+树的基本概念"></a>B+树的基本概念</h2><ul>
<li><p>与分块查找区别</p>
<ul>
<li>索引表中保存每个分块的最大关键字和分块的存储区间</li>
</ul>
</li>
<li><p>特性</p>
<ul>
<li><p>每个分支结点最多有m棵子树（孩子结点）</p>
</li>
<li><p>非叶根结点（根结点不是叶子）至少有两棵子树（保证平衡），其他每个分支结点至少有    棵子树<img src="https://api2.mubu.com/v3/document_image/d5426ede-20a7-484b-9160-f62fd8e8228a-3224585.jpg" alt="img"></p>
</li>
<li><p>结点的子树个数与关键字个数相等</p>
</li>
<li><p>所有叶子结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且相邻叶结点按大小顺序相互链接起来（B+树支持顺序查找）</p>
</li>
<li><p>所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）中关键字的最大值及指向其子结点的指针</p>
</li>
</ul>
</li>
<li><p>查找</p>
<ul>
<li><p>B+树中，无论查找成功还是失败，最终一定要走到最下层结点</p>
</li>
<li><p>必须找到叶子结点，叶子结点中该关键字的指针才指向该关键字的相关信息</p>
</li>
<li><p>B+树还可以根据p指针进行顺序查找</p>
</li>
</ul>
</li>
</ul>
<h2 id="M阶的B-树与M阶的B树的主要差异"><a href="#M阶的B-树与M阶的B树的主要差异" class="headerlink" title="M阶的B+树与M阶的B树的主要差异"></a>M阶的B+树与M阶的B树的主要差异</h2><ul>
<li><p>在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树，而在B树中且有n个关键字的结点含有n+1棵子树</p>
</li>
<li><p>在B+树中，每个结点（非根内部结点）的关键字个数n的范围是：    （根结点：1&lt;&#x3D;n&lt;&#x3D;m，其他结点关：【m&#x2F;2】向上取整  &lt;&#x3D;  n  &lt;&#x3D;  m）；在B树中，每个结点（非根内部结点）的关键字个数n的范围是    （根结点：1&lt;&#x3D;n&lt;&#x3D;m-1，其他结点：【m&#x2F;2】向上取整-1  &lt;&#x3D;  n  &lt;&#x3D;  m-1）</p>
</li>
<li><p>在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中叶结点包含的关键字和其他结点包含的关键字是不重复的</p>
</li>
<li><p>在B+树中，叶结点包含信息，所有非叶结点仅起索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址；B树结点中包含关键字对应记录的存储地址</p>
</li>
<li><p>B+树中，非叶结点不包含该关键字对应记录的存储地址，使得一个结点所需要的空间更少</p>
<ul>
<li>对B+树和B树的查找，每查找一个结点都需要读一次磁盘，直到找到叶子结点，读磁盘的速度很慢，所以B树和B+树都尽可能的使树更矮，每个结点尽可能包含更多的关键字信息</li>
</ul>
</li>
</ul>
<h1 id="散列表（用空间换时间）"><a href="#散列表（用空间换时间）" class="headerlink" title="散列表（用空间换时间）"></a>散列表（用空间换时间）</h1><h2 id="散列表的基本概念"><a href="#散列表的基本概念" class="headerlink" title="散列表的基本概念"></a>散列表的基本概念</h2><ul>
<li><p>散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key )&#x3D;Addr</p>
</li>
<li><p>冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址（这两个关键字为同义词）</p>
</li>
<li><p>散列表：根据关键字而直接进行访问的数据结构</p>
</li>
<li><p>对散列表进行查找的时间复杂度为0（1）</p>
</li>
</ul>
<h2 id="散列函数的构造方法（目的：冲突更少）"><a href="#散列函数的构造方法（目的：冲突更少）" class="headerlink" title="散列函数的构造方法（目的：冲突更少）"></a>散列函数的构造方法（目的：冲突更少）</h2><ul>
<li><p>注意</p>
<ul>
<li><p>散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围</p>
</li>
<li><p>散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生</p>
</li>
<li><p>散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址</p>
</li>
</ul>
</li>
<li><p>散列函数</p>
<ul>
<li><p>除留余数法</p>
<ul>
<li><p>假定散列表表长为m，取一个不大于m但最接近或等于m（最大）的质数p，利用以下公式把关键字转换成散列地址</p>
<ul>
<li><p>质数：即素数，指除了1和本身，不能被其他自然数整除的数</p>
</li>
<li><p>p取质数时，发生冲突的可能性更小（关键字的散列地址分布更加均匀）</p>
</li>
</ul>
</li>
<li><p>散列函数为H(key)&#x3D;key%p</p>
</li>
<li><p>特点</p>
<ul>
<li><p>最简单、最常用的方法</p>
</li>
<li><p>关键是选好p，使得每个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>直接定址法</p>
<ul>
<li><p>直接取关键字的某个线性函数值为散列地址</p>
</li>
<li><p>散列函数为H(key)&#x3D;key或H(key)&#x3D;a*key +b</p>
<ul>
<li>a和b是常数</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>计算最简单，且不会产生冲突</p>
</li>
<li><p>适合关键字的分布基本连续的情况</p>
</li>
<li><p>若关键字分布不连续，空位较多，则会造成存储空间的浪费</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数字分析法</p>
<ul>
<li><p>设关键字是r进制数，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等</p>
</li>
<li><p>而在某些位上分布不均匀只有某几种数码经常出现此时应选取数码分布较为均匀的若干位作为散列地址</p>
</li>
<li><p>特点</p>
<ul>
<li><p>适合于已知的关键字集合</p>
</li>
<li><p>若更换了关键字，则需要重新构造新的散列函数</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>平方取中法</p>
<ul>
<li><p>取关键字的平方值的中间几位作为散列地址</p>
<ul>
<li>平方的前几位和后几位可能值与关键字的前几位和后几位相关，平方的中间部分与关键字的整体相关</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>散列地址分布比较均匀</p>
</li>
<li><p>适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h2><ul>
<li><p>开放定址法：可存放新表项的空闲地址既向同义词表项开放，也向非同义词表项开放</p>
<ul>
<li><p>数学递推公式</p>
<ul>
<li><p>Hi&#x3D; (H(key) +di) %m</p>
</li>
<li><p>H（key）为散列函数</p>
</li>
<li><p>m表示散列表表长；di为增量序列（i指的是该元素发生第i次冲突）</p>
</li>
</ul>
</li>
<li><p>增量的取值方法</p>
<ul>
<li><p>线性探测法</p>
<ul>
<li><p>d&#x3D;0,1,2…,m-1</p>
</li>
<li><p>当出现冲突时，就会顺序的向下一个单元探测，直到单元没有发生冲突</p>
</li>
<li><p>查找操作</p>
<ul>
<li><p>发生冲突时，既要检查同义词，也要检查非同义词</p>
</li>
<li><p>空位置的判断也要算作一次比较</p>
</li>
<li><p>越早遇到空位置，就可以越早确认查找失败</p>
</li>
</ul>
</li>
<li><p>删除操作</p>
<ul>
<li><p>问题：又可能之前的删除操作操作产生空位置</p>
</li>
<li><p>采用“开放定址法”时，删除结点不能简单地将被删除结点的空间置为空，否则将截断在它之后填入散列表的同义词结点的查找路径，可以做一个“删除标记”，进行逻辑删除</p>
</li>
</ul>
</li>
<li><p>查找效率分析（ASL）</p>
<ul>
<li><p>ASL成功 &#x3D;（每个数据元素对比次数的累加）&#x2F;（数据元素个数）</p>
</li>
<li><p>ASL失败 &#x3D; （从每个位置探测到空位置的次数累加）&#x2F;（初次探测的地址数），因为此时的空位置就是没有放置过元素（无删除标记）</p>
</li>
</ul>
</li>
<li><p>优点：简单，容易实现</p>
</li>
<li><p>缺点：会出现聚集现象，降低查找效率</p>
<ul>
<li>冲突后再探测，一定是放在某个连续的位置</li>
</ul>
</li>
</ul>
</li>
<li><p>平方探测法</p>
<ul>
<li><p>di&#x3D;0^2, 1^2,-1^2,2^2,-2^2,…… ,k^2,-k^2</p>
</li>
<li><p>当在m位置发生冲突时，先探测m+1，再探测m-1，再探测m+4，再探测m-4，再探测m+9，再探测m-9</p>
</li>
<li><p>优点：可以避免出现”堆积“问题</p>
<ul>
<li>相对于线性探测法的改进</li>
</ul>
</li>
<li><p>缺点：不能探测到散列表上的所有单元，但至少能探测到一半单元</p>
<ul>
<li>散列表长度m必须是可以表示为4j+3的素数（质数），才能探测到所有位置</li>
</ul>
</li>
</ul>
</li>
<li><p>伪随机序列法</p>
<ul>
<li>di&#x3D;伪随机数序列时，称为伪随机序列法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>再散列法</p>
<ul>
<li><p>当通过第一个散列函数H（key ）得到的地址发生冲突时，则利用第二个散列函数Hash(key)计算该关键字的地址增量，直到不冲突为止</p>
</li>
<li><p>计算公式式Hi&#x3D;RH(key)</p>
</li>
</ul>
</li>
<li><p>拉链法（链地址法）</p>
<ul>
<li><p>把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识</p>
</li>
<li><p>所有同义词就像被拉链串在一起一样</p>
</li>
<li><p>空位置的判断不算作一次比较，拉链法的散列表是索引（指针），不存放具体的元素</p>
</li>
<li><p>优化：在插入新元素时，保持关键字有序</p>
</li>
</ul>
</li>
</ul>
<h2 id="散列查找及性能分析"><a href="#散列查找及性能分析" class="headerlink" title="散列查找及性能分析"></a>散列查找及性能分析</h2><ul>
<li><p>实现过程</p>
<ul>
<li><p>①检测查找表中地址为Addr的位置上是否有记录，若无记录，返回查找失败；若有记录，比较它与key的值，若相等，则返回查找成功标志，否则执行步骤2</p>
</li>
<li><p>②用给定的处理冲突方法计算“下一个散列地址”，并把Addr置为此地址，转入步骤1</p>
</li>
</ul>
</li>
<li><p>查找长度</p>
<ul>
<li><p>如果检测到查找表中地址为Addr的位置无记录，此时查找长度&#x3D;0（没有对比关键字）</p>
<ul>
<li>查找长度：在查找运算中，需要对比关键字的次数</li>
</ul>
</li>
<li><p>如果检测到查找表中地址为Addr的位置并对比了n次关键字均不是目标关键字，此时查找长度&#x3D;n</p>
</li>
<li><p>平均查找长度：</p>
<ul>
<li><p>ASL成功&#x3D;(结点个数与所在层数进行累加)&#x2F;结点数</p>
</li>
<li><p>ASL值&gt;&#x3D;1，ASL越小，查找成功的效率越高</p>
</li>
<li><p>最理想的效果：散列查找时间复杂度&#x3D;O(1)</p>
</li>
<li><p>ASL失败&#x3D;表中记录数n&#x2F;散列表长度m&#x3D;a（装填因子）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>平均查找长度作为衡量散列表的查找效率的度量</p>
</li>
<li><p>散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子</p>
</li>
<li><p>装填因子</p>
<ul>
<li><p>a&#x3D;表中记录数n&#x2F;散列表长度m</p>
</li>
<li><p>装填因子会直接影响散列表的查找效率，装填因子越大越容易发生冲突</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6%E5%9B%BE/" rel="prev" title="图">
                  <i class="fa fa-chevron-left"></i> 图
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8%E6%8E%92%E5%BA%8F/" rel="next" title="排序">
                  排序 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
