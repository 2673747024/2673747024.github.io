<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="图的基本概念图的定义 图G由顶点集V和边集E组成记为G&#x3D;（V，E ），其中V（G）表示图G中顶点的有限非空集；E（G ）表示图G中顶点之间的关系（边）集合  V&#x3D;{v1，v2，……，vn}，则用|V|表示图G中顶点的个数，也称图G的阶  E&#x3D;{（u，v）|u∈V，v∈V}，用|E|表示图G中边的条数  注意线性表可以是空表，树可以是空树，但图不可以是空图  图的顶点集">
<meta property="og:type" content="article">
<meta property="og:title" content="图">
<meta property="og:url" content="https://2673747024.github.io/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6%E5%9B%BE/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="图的基本概念图的定义 图G由顶点集V和边集E组成记为G&#x3D;（V，E ），其中V（G）表示图G中顶点的有限非空集；E（G ）表示图G中顶点之间的关系（边）集合  V&#x3D;{v1，v2，……，vn}，则用|V|表示图G中顶点的个数，也称图G的阶  E&#x3D;{（u，v）|u∈V，v∈V}，用|E|表示图G中边的条数  注意线性表可以是空表，树可以是空树，但图不可以是空图  图的顶点集">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/4f567b82-5e04-40f7-b044-c25477c6d7f5-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/7fb0fdf7-b0c2-4465-9ec0-5902e78339ed-3224585.jpg">
<meta property="article:published_time" content="2022-02-03T14:59:42.383Z">
<meta property="article:modified_time" content="2022-02-04T16:11:23.063Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api2.mubu.com/v3/document_image/4f567b82-5e04-40f7-b044-c25477c6d7f5-3224585.jpg">


<link rel="canonical" href="https://2673747024.github.io/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6%E5%9B%BE/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6%E5%9B%BE/","path":"2022/02/03/计算机408_3.数据结构_6图/","title":"图"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>图 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">图的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">图的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.2.</span> <span class="nav-text">图的一些基本概念及术语</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">图的存储及基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%B3%95"><span class="nav-number">2.1.</span> <span class="nav-text">邻接矩阵法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="nav-number">2.2.</span> <span class="nav-text">代码实现：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">邻接表法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A-1"><span class="nav-number">2.4.</span> <span class="nav-text">代码实现：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="nav-number">2.5.</span> <span class="nav-text">十字链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8"><span class="nav-number">2.6.</span> <span class="nav-text">邻接多重表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.</span> <span class="nav-text">基本操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">3.1.</span> <span class="nav-text">广度优先搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">3.2.</span> <span class="nav-text">深度优先搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">3.3.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="nav-number">3.4.</span> <span class="nav-text">图的遍历与图的连通性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">图的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">4.1.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="nav-number">4.2.</span> <span class="nav-text">最短路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Floyd%E7%AE%97%E6%B3%95%E6%B1%82%E5%90%84%E9%A1%B6%E7%82%B9%E4%B9%8B%E9%97%B4%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%EF%BC%88%E6%97%A0%E6%9D%83%E5%9B%BE%E5%92%8C%E5%B8%A6%E6%9D%83%E5%9B%BE%EF%BC%89"><span class="nav-number">4.3.</span> <span class="nav-text">Floyd算法求各顶点之间最短路径问题（无权图和带权图）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E6%8F%8F%E8%BF%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.4.</span> <span class="nav-text">有向无环图描述表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E8%A7%A3%E9%A2%98%E6%96%B9%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">求有向无环图的解题方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">4.6.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.7.</span> <span class="nav-text">DFS算法实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">4.8.</span> <span class="nav-text">逆拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%92%8C%E9%80%86%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E6%80%A7%E8%B4%A8"><span class="nav-number">4.9.</span> <span class="nav-text">拓扑排序和逆拓扑排序性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="nav-number">4.10.</span> <span class="nav-text">关键路径</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">112</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          图
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-03 22:59:42" itemprop="dateCreated datePublished" datetime="2022-02-03T22:59:42+08:00">2022-02-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-05 00:11:23" itemprop="dateModified" datetime="2022-02-05T00:11:23+08:00">2022-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/" itemprop="url" rel="index"><span itemprop="name">计算机408</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">3.数据结构</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6-%E5%9B%BE/" itemprop="url" rel="index"><span itemprop="name">6.图</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：8.2k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈29 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><h2 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h2><ul>
<li><p>图G由顶点集V和边集E组成记为G&#x3D;（V，E ），其中V（G）表示图G中顶点的有限非空集；E（G ）表示图G中顶点之间的关系（边）集合</p>
</li>
<li><p>V&#x3D;{v1，v2，……，vn}，则用|V|表示图G中顶点的个数，也称图G的阶</p>
</li>
<li><p>E&#x3D;{（u，v）|u∈V，v∈V}，用|E|表示图G中边的条数</p>
</li>
<li><p>注意线性表可以是空表，树可以是空树，但图不可以是空图</p>
<ul>
<li>图的顶点集一定是非空集，图的边集可以是空集</li>
</ul>
</li>
</ul>
<h2 id="图的一些基本概念及术语"><a href="#图的一些基本概念及术语" class="headerlink" title="图的一些基本概念及术语"></a>图的一些基本概念及术语</h2><ul>
<li><p>有向图</p>
<ul>
<li><p>若E是有向边（也称弧）的有限集合时，则图G为有向图</p>
</li>
<li><p>弧（有向边）是顶点的有序对，记为&lt;v，w&gt;</p>
<ul>
<li><p>其中v，w是顶点，v称为弧尾，w称为弧头，&lt;v，w&gt;称为从顶点v到顶点w的弧，也称v邻接w，或w邻接自v</p>
</li>
<li><p>&lt;v，w&gt;与&lt;w，v&gt;是不相等的，表示两个相反的弧</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>无向图</p>
<ul>
<li><p>若E是无向边（简称边）的有限集合时，则图G为无向图</p>
</li>
<li><p>边（无向边）是顶点的无序对，记为（v，w）或（w，v），因为（v，w ） &#x3D;（w，v），其中v，w是顶点</p>
</li>
<li><p>可以说顶点w和顶点v互为邻接点。边(v，w )依附于顶点w和v，或者说边(v,w)和顶点v，w相关联</p>
</li>
</ul>
</li>
<li><p>简单图</p>
<ul>
<li><p>不存在重复边</p>
</li>
<li><p>不存在顶点到自身的边</p>
</li>
</ul>
</li>
<li><p>多重图</p>
<ul>
<li><p>若图G中某两个结点之间的边数多于一条</p>
</li>
<li><p>且允许顶点通过同一条边和自己关联</p>
</li>
</ul>
</li>
<li><p>顶点的度、入度和出度</p>
<ul>
<li><p>度：定义为以该顶点为一个端点的边的数目</p>
</li>
<li><p>无向图：顶点v的度是指依附于该顶点的边的条数</p>
<ul>
<li>度的考点：无向图的全部顶点的度的和等于边数的2倍</li>
</ul>
</li>
<li><p>有向图：全部顶点的入度之和与出度之和相等，并且等于边数</p>
<ul>
<li><p>入度：以顶点v为终点的有向边的数目，记为ID(v)</p>
</li>
<li><p>出度：以顶点v为起点的有向边的数目，记为OD(v)</p>
</li>
<li><p>度的考点：TD(v)&#x3D;ID(v)+OD(v)、ID(v)&#x3D;OD(v)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>路径、路径长度和回路</p>
<ul>
<li><p>路径：两个顶点之间的一条路径就是顶点序列</p>
<ul>
<li><p>顶点之间有可能不存在路径</p>
</li>
<li><p>有向图的路径也是有向的</p>
</li>
</ul>
</li>
<li><p>回路或环：第一个顶点和最后一个顶点相同的路径</p>
<ul>
<li>A-B-C-A</li>
</ul>
</li>
<li><p>简单路径、简单回路</p>
<ul>
<li><p>简单路径：顶点不重复出现的路径</p>
</li>
<li><p>简单回路：除第一个顶点和最后一个顶点外其余顶点不重复出现的回路</p>
</li>
</ul>
</li>
<li><p>路径长度：路径上边的个数</p>
</li>
<li><p>点到点的距离</p>
<ul>
<li><p>从顶点u出发到顶点v的最短路经若存在，则此路径的长度称为从u到v的距离</p>
</li>
<li><p>若从u到v根本不存在路径，则记该距离为无穷（∞）</p>
</li>
</ul>
</li>
<li><p>若一个图有n个顶点并且有大于n-1条边，则此图一定有环</p>
</li>
</ul>
</li>
<li><p>连通、强连通图、强连通分量、连通图和连通分量</p>
<ul>
<li><p>连通：在无向图中，若从顶点v到而点w有路径存在，则称v和w是连通的</p>
</li>
<li><p>连通图：若无向图中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图</p>
</li>
<li><p>连通图考点：</p>
<ul>
<li><p>若一个无向图有n个顶点，并且边数小于n—1，则此图必是非连通图</p>
</li>
<li><p>无向图的最大边数为C_(n-1)^2——除一个顶点外两两连通</p>
</li>
</ul>
</li>
<li><p>强连通：在有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的</p>
</li>
<li><p>强连通图：若图中任何一对顶点都是强连通的，则称此图为强连通</p>
</li>
<li><p>强连通图考点：</p>
<ul>
<li>若有向图是强连通图，至少有n条边（形成回路，每个顶点的入度和出度均为1）</li>
</ul>
</li>
<li><p>无向图中的极大连通子图称为连通分量</p>
<ul>
<li>极大连通子图：子图必须连通，且包含尽可能多的顶点和边</li>
</ul>
</li>
<li><p>有向图中的极大强连通子图称为有向图的强连通分母</p>
<ul>
<li>极大强连通子图：子图必须强连通，同时保留尽可能多的边</li>
</ul>
</li>
</ul>
</li>
<li><p>子图</p>
<ul>
<li><p>设有两个图G&#x3D;（V，E )和G’&#x3D;(V’，E’)，若V是V的子集，且E’是E的子集，则称G’是G的子图</p>
<ul>
<li>子图必须符合图的定义（所以子图并不是任意的挑选出几个顶点、几条边）</li>
</ul>
</li>
<li><p>若有满足V(G’)&#x3D;V(G)的子图G’，则称其为G的生成子图（包含所有顶点）</p>
</li>
</ul>
</li>
<li><p>生成树、生成森林</p>
<ul>
<li><p>连通图的生成树是包含图中全部顶点的一个极小连通子图</p>
<ul>
<li><p>极小连通子图：边尽可能的少，但要保持连通</p>
</li>
<li><p>连通图的生成树不唯一</p>
</li>
</ul>
</li>
<li><p>若图中顶点数为n，则它的生成树含有n-1条边</p>
</li>
<li><p>对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路</p>
</li>
<li><p>在非连通图中，连通分量的生成树构成了非连通图的生成森林</p>
</li>
</ul>
</li>
<li><p>边的权和网</p>
<ul>
<li><p>每条边都可以标上具有某种含义的数值，该数值称为该边的权值。</p>
</li>
<li><p>这种边上带有权值的图称为带权图，也称网</p>
</li>
<li><p>带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度</p>
</li>
</ul>
</li>
<li><p>完全图（也称简单完全图）</p>
<ul>
<li><p>无向完全图：</p>
<ul>
<li><p>无向图中任意两个顶点之间都存在边</p>
</li>
<li><p>无向完全图考点：|E|的取值范围是0到n(n—1)&#x2F;2，有n( n-1)&#x2F;2条边的无向图称为完全图</p>
</li>
</ul>
</li>
<li><p>有向图完全图</p>
<ul>
<li><p>在有向完全图中任意两个顶点之间都存在方向相反的两条弧</p>
</li>
<li><p>有向完全图考点：|E|的取值范围是0到n(n-1)，有n(n—1)条弧的有向图称为有向完全图</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>稠密图、稀疏图</p>
<ul>
<li><p>边数很少的图称为稀疏图,反之称为稠密图</p>
</li>
<li><p>一般当图G满足|E| &lt; |V|log|V|可以将G视为稀疏图</p>
</li>
</ul>
</li>
<li><p>树&#x2F;有向树</p>
<ul>
<li><p>树：</p>
<ul>
<li><p>树是不存在回路，且连通的无向图</p>
</li>
<li><p>n个顶点的树，一定有n-1条边</p>
</li>
<li><p>考点：n个顶点的图，如果边&gt;n-1条，无向图一定是有回路的</p>
</li>
</ul>
</li>
<li><p>森林：</p>
<ul>
<li>各个子图是极小的，各个子图是连通的</li>
</ul>
</li>
<li><p>有向树</p>
<ul>
<li><p>一个顶点的入度为0、其余顶点的入度均为1的有向图，称为有向树</p>
</li>
<li><p>有向树并不是强连通图</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="图的存储及基本操作"><a href="#图的存储及基本操作" class="headerlink" title="图的存储及基本操作"></a>图的存储及基本操作</h1><h2 id="邻接矩阵法"><a href="#邻接矩阵法" class="headerlink" title="邻接矩阵法"></a>邻接矩阵法</h2><ul>
<li><p>邻接矩阵存储</p>
<ul>
<li><p>是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系）</p>
</li>
<li><p>存储顶点之间邻接关系的二维数组称为邻接矩阵</p>
</li>
<li><p>结构示意</p>
<ul>
<li><p>非带权图示意<img src="https://api2.mubu.com/v3/document_image/4f567b82-5e04-40f7-b044-c25477c6d7f5-3224585.jpg" alt="img"></p>
</li>
<li><p>带权图示意</p>
<ul>
<li>wij：边的权值</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2></li>
<li><p>邻接矩阵表示法的空间复杂度为O(n^2)，其中n为图的顶点数|V|</p>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>无向图的邻接矩阵一定是一个对称矩阵（并且唯一）。因此在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素</p>
</li>
<li><p>无向图</p>
<ul>
<li>第i个顶点的度TD（vi）：<ul>
<li>邻接矩阵的第i行（或第i列）非零元素的个数</li>
</ul>
</li>
</ul>
</li>
<li><p>有向图</p>
<ul>
<li><p>第i个顶点的出度 OD（vi）：</p>
<ul>
<li>邻接矩阵的第i行非零元素的个数</li>
</ul>
</li>
<li><p>第i个顶点的入度 ID（vi）：</p>
<ul>
<li>邻接矩阵的第i列非零元素的个数</li>
</ul>
</li>
<li><p>第i个顶点的度</p>
<ul>
<li>邻接矩阵的第i行、第i列非零元素的个数之和</li>
</ul>
</li>
</ul>
</li>
<li><p>用邻接矩阵法存储图，很容易确定图中任意两个顶点之间是否有边相连。但是要确定图中有多少条边，则必须按行、按列对每个元素进行检测所花费的时间代价很大</p>
</li>
<li><p>稠密图适合使用邻接矩阵的存储表示（空间复杂度高）</p>
</li>
</ul>
</li>
<li><p>性能分析：</p>
<ul>
<li>空间复杂度：O(n^2)<ul>
<li>顶点数为n，边数为n^2</li>
</ul>
</li>
</ul>
</li>
<li><p>邻接矩阵的性质：</p>
<ul>
<li><p>重点：设图G的邻接矩阵为A（矩阵元素为0&#x2F;1），则A^n的元素A^n[i][j]等于由顶点i到顶点j的长度为n的路径的数目</p>
</li>
<li><p>截图：</p>
</li>
</ul>
</li>
</ul>
<h2 id="邻接表法"><a href="#邻接表法" class="headerlink" title="邻接表法"></a>邻接表法</h2><ul>
<li><p>当一个图为稀疏图时，使用邻接矩阵法要浪费大量的存储空间，而图的邻接表法结合了顺序存储和链式存储方法，减少了不必要的浪费</p>
</li>
<li><p>结构</p>
<ul>
<li><p>对图G中的每个顶点建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边，这个单链表就称为顶点vi的边表（对于有向图则称为出边表）</p>
</li>
<li><p>邻接表中的两种结点</p>
<ul>
<li><p>顶点表结点</p>
<ul>
<li>顶点的数据信息、边表的头指针，采用顺序存储</li>
</ul>
</li>
<li><p>边表结点</p>
<ul>
<li>边结点（无数据信息）、指向下一条边&#x2F;弧的指针</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><h2 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h2></li>
<li><p>示意图<img src="https://api2.mubu.com/v3/document_image/7fb0fdf7-b0c2-4465-9ec0-5902e78339ed-3224585.jpg" alt="img"></p>
</li>
<li><p>特点</p>
<ul>
<li><p>对于稀疏图，采用邻接表表示将极大地节省存储空间</p>
</li>
<li><p>顶点的度：</p>
<ul>
<li><p>无向图：这个顶点的邻接表中的结点个数</p>
</li>
<li><p>有向图的出度：这个顶点的邻接表中的结点个数</p>
</li>
<li><p>有向图的入度：遍历全部的邻接表</p>
</li>
</ul>
</li>
<li><p>图的邻接表表示并不唯一，边结点在邻接表中出现的先后顺序是任意的</p>
</li>
<li><p>对于邻接矩阵，只要确定了顶点编号，图的邻接矩阵表示一定是唯一的</p>
</li>
</ul>
</li>
<li><p>性能分析：</p>
<ul>
<li><p>空间复杂度</p>
<ul>
<li><p>无向图：O(|V|+2|E|)，顶点数为V，边结点的数目是2|E|</p>
</li>
<li><p>有向图：O(|V|+|E|)，顶点数为V，边结点的数目是|E|</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h2><ul>
<li><p>十字链表是有向图的一种链式存储结构，在十字链表中，对应于有向图中的每条弧有一个结点，对应于每个顶点也有一个结点</p>
</li>
<li><p>顶点结点域结构</p>
<ul>
<li><p>data域存放顶点相关的数据信息</p>
</li>
<li><p>firstin和firstout两个域分别指向以该顶点为弧头或尾的第一个弧结点</p>
</li>
</ul>
</li>
<li><p>弧结点域结构</p>
<ul>
<li><p>头域（headvex）：弧头</p>
</li>
<li><p>尾域（tailvex ）：弧尾</p>
</li>
<li><p>头链域（hlink ）：指向弧头相同的下一条弧</p>
</li>
<li><p>尾链域（ tlink ） ：指向弧尾相同的下一条弧</p>
</li>
<li><p>info域：指向该弧的相关信息</p>
</li>
</ul>
</li>
<li><p>空间复杂度：O(|V|+|E|)</p>
</li>
<li><p>如何找到指定结点的所有出边：顺着绿色线路找（firstout、tlink）</p>
</li>
<li><p>如何找到指定结点的所有入边：顺着橙色线路找（firstin、hlink）</p>
</li>
<li><p>只能存储有向图</p>
</li>
</ul>
<h2 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h2><ul>
<li><p>邻接矩阵的空间复杂度高；邻接表的每条边都对应着两份冗余信息，所以删除顶点或边等操作的时间复杂度高</p>
</li>
<li><p>邻接多重表是无向图的另一种链式存储结构</p>
</li>
<li><p>边结构</p>
<ul>
<li><p>mark为标志域，可用以标记该条边是否被搜索过</p>
</li>
<li><p>ivex和jvex为该边依附的两个顶点在图中的位置</p>
</li>
<li><p>ilink指向下一条依附于顶点ivex的边</p>
</li>
<li><p>jlink指向下一条依附于顶点jvex的边</p>
</li>
<li><p>info为指向该边的相关信息</p>
</li>
</ul>
</li>
<li><p>顶点结构</p>
<ul>
<li><p>data域存储该顶点的相关信息</p>
</li>
<li><p>firstedge域指示第一条依附于该顶点的边</p>
</li>
</ul>
</li>
<li><p>邻接多重表每条边只有一份信息，删除顶点或边的操作简单</p>
</li>
<li><p>空间复杂度：O（|V| + |E|）</p>
</li>
<li><p>只能存储无向图</p>
</li>
</ul>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li><p>Adjacent(G，x，y)：判断图G中是否存在边&lt;x，y&gt;或(x，y)</p>
<ul>
<li><p>无向图和有向图</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(1)</p>
</li>
<li><p>邻接表的时间复杂度：O(1)~O(|V|)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Neighbors(G，x)：列出图G中与结点x邻接的边</p>
<ul>
<li><p>无向图</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(|V|)</p>
</li>
<li><p>邻接表的时间复杂度：O(1)~O(|V|)</p>
</li>
</ul>
</li>
<li><p>有向图</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(|V|)</p>
</li>
<li><p>邻接表出边的时间复杂度：O(1)~O(|V|)</p>
</li>
<li><p>邻接表入边的时间复杂度：O(|E|)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>InsertVertex(G，x)：在图中插入顶点x</p>
<ul>
<li><p>无向图和有向图：</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(1)</p>
</li>
<li><p>邻接表的时间复杂度：O(1)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>DeleteVertex(G，x)：从图中删除顶点x</p>
<ul>
<li><p>无向图：</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(|V|)</p>
</li>
<li><p>邻接表的时间复杂度：O(1)~O(|E|)</p>
</li>
</ul>
</li>
<li><p>有向图：</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(|V|)</p>
</li>
<li><p>邻接表的时间复杂度：</p>
<ul>
<li><p>删除出边：O(1)~O(|V|)</p>
</li>
<li><p>删除入边：O(|E|)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>AddEdge(G，x，y)：若无向边(x，y)或有向边&lt;x，y&gt;不存在，则向图G中添加该边</p>
<ul>
<li><p>无向图和有向图：</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(|1|)</p>
</li>
<li><p>邻接表的时间复杂度：O(1)~O(|V|)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>FirstNeighbor(G，x)：求图G中顶点x的第一个邻接点，若有则返回顶点好。若x没有邻接点或图中不存在，则返回-1</p>
<ul>
<li><p>无向图：</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(1)~O(|V|)</p>
</li>
<li><p>邻接表的时间复杂度：O(1)</p>
</li>
</ul>
</li>
<li><p>有向图：</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(1)~O(|V|)</p>
</li>
<li><p>邻接表的时间复杂度</p>
<ul>
<li><p>找出边邻接点：O(1)</p>
</li>
<li><p>找入边邻接点：O(1)~O(|E|)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>NextNeighbor(G，x，y)：顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</p>
<ul>
<li><p>无向图：</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(1)~O(|V|)</p>
</li>
<li><p>邻接表的时间复杂度：O(1)</p>
</li>
</ul>
</li>
<li><p>有向图：</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(1)~O(|V|)</p>
</li>
<li><p>邻接表的时间复杂度</p>
<ul>
<li><p>找出边邻接点：O(1)</p>
</li>
<li><p>找入边邻接点：O(1)~O(|E|)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Get_edge_value(G，x，y)：获取图G中边(x，y)或&lt;x，y&gt;对应的权值</p>
</li>
<li><p>Set_edge_value(G，x，y)：设置图G中边(x，y)或&lt;x，y&gt;对应的权值为v</p>
<ul>
<li><p>这两个操作核心在于找到边——Adjacent(G，x，y)：判断图G中是否存在边&lt;x，y&gt;或(x，y)</p>
</li>
<li><p>无向图和有向图</p>
<ul>
<li><p>邻接矩阵的时间复杂度：O(1)</p>
</li>
<li><p>邻接表的时间复杂度：O(1)~O(|V|)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><ul>
<li><p>广度优先搜索（BFS）</p>
<ul>
<li><p>类似于二叉树的层序遍历算法</p>
</li>
<li><p>算法思想</p>
<ul>
<li><p>首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1，w2，……，wi</p>
</li>
<li><p>然后依次访问w1，w2，wi的所有未被访问过的邻接顶点并标记这些顶点被访问过</p>
</li>
<li><p>再从这些访问过的顶点出发，访问它们所有未被访问过的邻接顶点直至图中所有顶点都被访问过为止</p>
</li>
</ul>
</li>
<li><p>算法实现：</p>
<ul>
<li><p>FirstNeighbor(G，x)和NextNeighbor(G，x，y)</p>
</li>
<li><p>bool visited[MAX_VERTEX_NUM]，该数组标记已被访问过的结点</p>
</li>
<li></li>
</ul>
</li>
<li><p>利用队列实现搜索</p>
</li>
</ul>
</li>
<li><p>树与图在广度优先遍历时的不同点</p>
<ul>
<li><p>树：不存在回路，搜索相邻的结点时，不可能搜到已经访问过的结点</p>
</li>
<li><p>图：搜索相邻的顶点时，有可能搜到已经访问过的顶点</p>
</li>
</ul>
</li>
<li><p>BFS算法无法完全遍历非连通图，此时遍历visited数组，找到数组中第一个值为false的顶点，在这个顶点出发调用BFS函数</p>
<ul>
<li>对于无向图，调用BFS函数的次数&#x3D;连通分量数</li>
</ul>
</li>
<li><p>BFS算法的性能分析</p>
<ul>
<li><p>在最坏的情况下，空间复杂度为O(|V|)——辅助队列（访问一个结点时，这个结点最多有V-1个邻接点）</p>
</li>
<li><p>时间复杂度</p>
<ul>
<li><p>邻接表存储方式： </p>
<ul>
<li><p>顶点：O（|V|）</p>
</li>
<li><p>边： O（|E|）</p>
</li>
<li><p>总时间复杂度：O（|V|+|E|）</p>
</li>
</ul>
</li>
<li><p>邻接矩阵存储方式：</p>
<ul>
<li><p>访问|V|个顶点的时间复杂度：O(|V|)</p>
</li>
<li><p>查找每个顶点的邻接点都需要O(|V|)的时间，所以查找边的时间复杂度：O(|V|^2)</p>
</li>
<li><p>总时间复杂度：O(|V|^2)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>广度优先生成树</p>
<ul>
<li><p>在广度遍历的过程中，我们可以得到一棵遍历树，称为广度优先生成树</p>
</li>
<li><p>唯一性</p>
<ul>
<li><p>邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的</p>
</li>
<li><p>由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>广度优先生成森林</p>
<ul>
<li>对非连通图的广度优先遍历，可以得到广度优先生成树</li>
</ul>
</li>
<li><p>BFS算法可以解决最短路径问题</p>
</li>
</ul>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><ul>
<li><p>深度优先搜索（DFS）</p>
<ul>
<li><p>类似于树的先序遍历。搜索策略是尽可能“深”地搜索一个图</p>
</li>
<li><p>算法思想</p>
<ul>
<li><p>首先访问图中某一起始顶点，然后由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未被访问的任一顶点w2……重复上述过程。</p>
</li>
<li><p>当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程直至图中所有顶点均被访问过为止</p>
</li>
</ul>
</li>
<li><p>递归算法</p>
<ul>
<li>需要借助一个递归工作栈</li>
</ul>
</li>
<li><p>算法实现</p>
<ul>
<li>bool visited[MAX_VERTEX_NUM]，该数组标记已被访问过的结点</li>
</ul>
</li>
</ul>
</li>
<li><p>DFS算法的性能分析</p>
<ul>
<li><p>空间复杂度O（|V|），函数调用栈</p>
</li>
<li><p>时间复杂度</p>
<ul>
<li><p>邻接矩阵</p>
<ul>
<li><p>访问|V|个顶点的时间复杂度：O(|V|)</p>
</li>
<li><p>查找每个顶点的邻接点都需要O(|V|)的时间，所以查找边的时间复杂度：O(|V|^2)</p>
</li>
<li><p>总时间复杂度：O(|V|^2)</p>
</li>
</ul>
</li>
<li><p>邻接链表：总时间复杂度O（|V|+|E|）</p>
<ul>
<li><p>找所有顶点的邻接点所需的时间为O（|E|）</p>
</li>
<li><p>访问顶点所需的时间为O（|V|）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>深度优先的生成树和生成森林：基于邻接表存储的深度优先生成树是不唯一的</p>
<ul>
<li><p>对连通图调用DFS才能产生深度优先生成树</p>
</li>
<li><p>非连通图产生的是深度优先生成森林</p>
</li>
</ul>
</li>
</ul>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的</p>
</li>
<li><p>基于邻接表的遍历所得到的DFS和BFS是不唯一的</p>
</li>
</ul>
<h2 id="图的遍历与图的连通性"><a href="#图的遍历与图的连通性" class="headerlink" title="图的遍历与图的连通性"></a>图的遍历与图的连通性</h2><ul>
<li><p>图的遍历算法可以用来判断图的连通性</p>
</li>
<li><p>对于无向图</p>
<ul>
<li><p>若无向图是连通的，则从任一结点出发，仅需一次遍历就能够访问图中的所有顶点</p>
</li>
<li><p>若无向图是非连通的，则从某一个顶点出发，一次遍历只能访问到该顶点所在连通分量的所有顶点，而对于图中其他连通分量的顶点，则无法通过这次遍历访问</p>
</li>
<li><p>调用BFS&#x2F;DFS函数的次数&#x3D;连通分量数</p>
</li>
<li><p>对于连通图，只需调用1次BFS&#x2F;DFS</p>
</li>
</ul>
</li>
<li><p>对于有向图</p>
<ul>
<li><p>若有向图是连通的，从初始点到图中的每个顶点都有路径，则能够访问到图中的所有顶点</p>
</li>
<li><p>若有向图是非连通的，不能访问到所有顶点</p>
</li>
<li><p>对于强连通图，从任一结点触发都只需调用1次BFS&#x2F;DFS</p>
</li>
</ul>
</li>
</ul>
<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><ul>
<li><p>一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边</p>
<ul>
<li><p>若砍去它的一条边，则会使生成树变成非连通图</p>
</li>
<li><p>若给它增加一条边，则会形成图中的一条回路</p>
</li>
<li><p>连通图的顶点数为n，生成树含有n-1条边</p>
</li>
</ul>
</li>
<li><p>最小生成树：权值之和最小的那棵生成树，则称为最小生成树</p>
<ul>
<li>非连通图没有最小生成树，只有生成森林</li>
</ul>
</li>
<li><p>最小生成树性质</p>
<ul>
<li><p>最小生成树不是唯一的，即最小生成树的树形不唯一</p>
</li>
<li><p>其对应的边的权值之和总是唯一的，而且是最小的</p>
</li>
<li><p>最小生成树的边数为顶点数减1</p>
</li>
</ul>
</li>
<li><p>最小生成树算法</p>
<ul>
<li><p>Prim算法</p>
<ul>
<li><p>概述</p>
<ul>
<li><p>开始时从图中任取一顶点加入树T，此时树中只含有一个顶点</p>
</li>
<li><p>之后选择一个与当前T中顶点集合距离最近的顶点，并将该顶点和相应的边加入T，每次操作后T中的顶点数和边数都增1</p>
</li>
<li><p>以此类推，直至图中所有的顶点都并入T，得到的T就是最小生成树。此时T中必然有n-1条边</p>
</li>
</ul>
</li>
<li><p>时间复杂度O(|V|^2)</p>
<ul>
<li><p>isJoin：标记结点是否已经加入到树</p>
</li>
<li><p>lowCast：各结点加入树的最低代价</p>
</li>
<li><p>1、遍历所有结点，找出lowCast最低的，且还没有加入树的顶点——O(n)</p>
</li>
<li><p>2、再次循环遍历，更新还没有加入各个顶点的lowCast值——O(n)</p>
</li>
<li><p>再次循环1&#x2F;2步骤，一共循环n-1次</p>
</li>
<li><p>总循环：(n-1)*2n，即O(n^2)</p>
</li>
</ul>
</li>
<li><p>适用于求解边稠密的图的最小生成树</p>
</li>
</ul>
</li>
<li><p>Kruskal算法</p>
<ul>
<li><p>概述</p>
<ul>
<li><p>初始时为只有n个顶点而无边的非连通图T&#x3D;{V，{}}，每个顶点自成一个连通分量</p>
</li>
<li><p>然后按照边的权值由小到大的顺序，不断选取当前未被选取过且权值最小的边</p>
</li>
<li><p>若该边依附的顶点落在中不同的连通分量上，则将此边加入T</p>
</li>
<li><p>否则舍弃此边而选择下一条权值最小的边</p>
</li>
<li><p>以此类推，直至T中所有顶点都在一个连通分量上</p>
</li>
</ul>
</li>
<li><p>时间复杂度O（log|E|）</p>
<ul>
<li><p>一共执行E轮（E条边）</p>
</li>
<li><p>每轮需要判断一次两个顶点是否是一个集合，需要的时间是O(log_2(E))</p>
</li>
</ul>
</li>
<li><p>适合于边稀疏而顶点较多的图</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ul>
<li><p>BFS算法（无权图）</p>
<ul>
<li><p>代码实现</p>
</li>
<li><p>最短路径长度：</p>
</li>
<li><p>最短路径：</p>
</li>
<li><p>实际上就是把无权图转化为以2为根，高度最小的生成树（广度优先生成树）</p>
</li>
</ul>
</li>
<li><p>Dijkstra算法求单源最短路径问题（无权图和带权图）</p>
<ul>
<li><p>辅助数组</p>
<ul>
<li><p>dist[]：记录从源点v0到其他各顶点当前的最短路径长度，它的初态为：若从v0到vi有弧，则dist[i]为弧上的权值；否则置dist[i]为无穷大</p>
</li>
<li><p>path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点</p>
</li>
</ul>
</li>
<li><p>实现过程</p>
<ul>
<li><p>1)初始化集合S初始为{0}，dist[]的初始值dist[i]&#x3D;arcs[0][i]，i&#x3D;1,2,……,n-1</p>
</li>
<li><p>2）从顶点集合V-S中选出vj，满足dist[j]&#x3D;Min{dist[i]|vi∈V-S}，vj就是当前求得的一条从v0出发的最短路径的终点，令S&#x3D;SU{j}</p>
</li>
<li><p>3）修改从V0出发到集合V-S上任一顶点vk可达的最短路径长度：若dist[i]+arcs[j][k]</p>
</li>
<li><p>4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中</p>
</li>
</ul>
</li>
<li><p>时间复杂度O(|V|^2)</p>
<ul>
<li><p>一共n-1轮处理</p>
</li>
<li><p>每轮处理：O(2n)</p>
<ul>
<li><p>遍历所有顶点O(n)</p>
</li>
<li><p>检查该顶点的所有邻接点O(n)</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不适用于边权值存在负数的情况</p>
</li>
</ul>
</li>
</ul>
<h2 id="Floyd算法求各顶点之间最短路径问题（无权图和带权图）"><a href="#Floyd算法求各顶点之间最短路径问题（无权图和带权图）" class="headerlink" title="Floyd算法求各顶点之间最短路径问题（无权图和带权图）"></a>Floyd算法求各顶点之间最短路径问题（无权图和带权图）</h2><ul>
<li><p>实现思想：动态规划，也就是将问题的求解分为多个阶段</p>
</li>
<li><p>辅助二维数组</p>
<ul>
<li><p>A：存储各个顶点间的最短路径长度</p>
</li>
<li><p>path：存储各个顶点之间的中转点</p>
</li>
</ul>
</li>
<li><p>实现过程</p>
<ul>
<li><p>初始时，不允许有其他顶点中转</p>
<ul>
<li><p>对于任意两个顶点vi和vi，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度</p>
</li>
<li><p>若它们之间不存在有向边，则以无穷大作为它们之间的最短路径长度</p>
</li>
</ul>
</li>
<li><p>以后逐步尝试在原路径中加入顶点k （k&#x3D;0，1，2..，n-1）作为中间顶点</p>
</li>
<li><p>若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径</p>
</li>
</ul>
</li>
<li><p>时间复杂度O（|V|^3）</p>
<ul>
<li><p>以某个顶点为中转点，循环|V|次——即以v1为中转点，以v1、v2为中转点……</p>
</li>
<li><p>遍历这个矩阵，判断当以该顶点为中转点时，路径长度是否变短，O(|V|^2)</p>
</li>
</ul>
</li>
<li><p>空间复杂度：O(|V|^2)——两个n行n列的辅助矩阵</p>
</li>
<li><p>允许图中有带负权值的边，但不允许有包含带负权值的边组成的回路</p>
</li>
<li><p>适用于带权无向图</p>
</li>
</ul>
<h2 id="有向无环图描述表达式"><a href="#有向无环图描述表达式" class="headerlink" title="有向无环图描述表达式"></a>有向无环图描述表达式</h2><ul>
<li><p>有向无环图：若一个有向图中不存在环，则称为有向无环图，简称DAG图</p>
</li>
<li><p>有向无环图是描述含有公共子式的表达式的有效工具</p>
</li>
</ul>
<h2 id="求有向无环图的解题方法"><a href="#求有向无环图的解题方法" class="headerlink" title="求有向无环图的解题方法"></a>求有向无环图的解题方法</h2><ul>
<li><p>将各个操作数不重复地排成一列</p>
</li>
<li><p>标出每个运算符的生效顺序</p>
</li>
<li><p>按顺序加入运算符，注意分层</p>
</li>
<li><p>自底向上逐层检查同层运算符是否可以合体</p>
</li>
</ul>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul>
<li><p>AOV网概述：是有向无环图，以顶点表示活动</p>
<ul>
<li><p>若用DAG图表示一个工程，其顶点表示活动，用有向边&lt;Vi，Vj&gt;表示获得Vi先于活动Vj进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为AOV网</p>
</li>
<li><p>活动Vi是活动Vj的直接前驱，活动Vj是活动Vi的直接后继</p>
</li>
<li><p>这种前驱和后继关系具有传递性，且任何活动不能以它自己作为自己的前驱或后继</p>
</li>
</ul>
</li>
<li><p>拓扑排序定义</p>
<ul>
<li><p>每个顶点出现且只出现一次</p>
</li>
<li><p>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径</p>
</li>
</ul>
</li>
<li><p>拓扑排序实现方法</p>
<ul>
<li><p>1、从AOV网中选择一个没有前驱的顶点并输出</p>
</li>
<li><p>2、从网中删除该顶点和所有以它为起点的有向边</p>
</li>
<li><p>3、重复1和2直到当前的AOV网为空（排序成功）或当前网中不存在无前驱的顶点（排序失败，说明有向图中必然存在回路）为止</p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<ul>
<li><p>indegree[]：当前顶点的入度</p>
</li>
<li><p>print[]：记录拓扑序列</p>
</li>
<li><p>栈（或队列）：保存度为0的顶点</p>
</li>
</ul>
</li>
<li><h2 id="DFS算法实现"><a href="#DFS算法实现" class="headerlink" title="DFS算法实现"></a>DFS算法实现</h2></li>
<li><p>注意</p>
<ul>
<li><p>入度为零的顶点，即没有前驱活动的或前驱活动都已经完成的顶点，工程可以从这个顶点所代表的活动开始或继续</p>
</li>
<li><p>若一个顶点有多个直接后继则拓扑排序的结果通常不唯一</p>
</li>
<li><p>若各个顶点已经排在一个线性有序的序列中，每个顶点有唯一的前驱后继关系，则拓扑排序的结果是唯一的</p>
</li>
<li><p>生成AOV网的新的邻接存储矩阵，可以是三角矩阵</p>
</li>
<li><p>对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑序列；反之则不一定成立</p>
</li>
</ul>
</li>
<li><p>时间复杂度：</p>
<ul>
<li><p>邻接表存储：O(|V|+|E|)</p>
</li>
<li><p>邻接矩阵：O(|V|^2)</p>
</li>
</ul>
</li>
</ul>
<h2 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h2><ul>
<li><p>具体实现</p>
<ul>
<li><p>1.类似于拓扑排序的算法</p>
</li>
<li><p>2.DFS算法：在顶点退栈前输出</p>
<ul>
<li>判断是否存在回路</li>
</ul>
</li>
</ul>
</li>
<li><p>思想</p>
<ul>
<li><p>1、从AOV网中选择一个没有后继（出度为0）的顶点并输出</p>
</li>
<li><p>2、从网中删除该顶点和所有以它为终点的有向边</p>
</li>
<li><p>3、重复1和2直到当前的AOV网为空</p>
</li>
</ul>
</li>
<li><p>时间复杂度：</p>
<ul>
<li><p>邻接矩阵：</p>
</li>
<li><p>逆邻接表：邻接表中保存指向该顶点的边</p>
</li>
</ul>
</li>
</ul>
<h2 id="拓扑排序和逆拓扑排序性质"><a href="#拓扑排序和逆拓扑排序性质" class="headerlink" title="拓扑排序和逆拓扑排序性质"></a>拓扑排序和逆拓扑排序性质</h2><ul>
<li><p>拓扑排序、逆拓扑排序序列可能不唯一</p>
</li>
<li><p>若图中有环，则不存在拓扑排序序列&#x2F;逆拓扑排序序列</p>
</li>
</ul>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><ul>
<li><p>AOE网概述：以有向边表示活动</p>
<ul>
<li>在带权有向图中，以顶点表示事件（没有开销），以有向边表示活动（有开销），以边上的权值表示完成该活动的开销（如完成活动所需的时间） ，称之为用边表示活动的网络</li>
</ul>
</li>
<li><p>AOE与AOV</p>
<ul>
<li><p>相同点</p>
<ul>
<li>AOE网和AOV网都是有向无环图</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>AOE网中的边有权值；而AOV网中的边无权值</li>
</ul>
</li>
</ul>
</li>
<li><p>AOE网性质</p>
<ul>
<li><p>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</p>
</li>
<li><p>只有在进入某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发生</p>
</li>
<li><p>有的活动可以并行进行</p>
</li>
</ul>
</li>
<li><p>关键路径与关键活动</p>
<ul>
<li><p>关键路径：从源点到汇点的所有路径中具有最大路径长度的路径</p>
<ul>
<li>关键路径的长度：完成整个工程的最短时间</li>
</ul>
</li>
<li><p>关键活动：关键路径上的活动</p>
<ul>
<li>若关键活动不能按时完成，则整个工程的完成时间就会延长</li>
</ul>
</li>
</ul>
</li>
<li><p>变量含义</p>
<ul>
<li><p>事件vk的最早发生事件ve（k）</p>
<ul>
<li><p>ve（源点）&#x3D;0</p>
</li>
<li><p>ve（k）&#x3D;Max{ve（j）+ Weight（vy，vk）}，vk为vj的任意后继，Weight （vi，vk）表示&lt;vj，vk&gt;上的权值</p>
</li>
<li><p>所有从vk开始的活动能够开工的最早时间</p>
</li>
</ul>
</li>
<li><p>事件vk的最迟发生事件vl（k）</p>
<ul>
<li><p>vl（汇点）&#x3D; ve（汇点）</p>
</li>
<li><p>vl（k）&#x3D;Min{vl（j）- Weight（vk，vj)}，vk为vj的任意前驱</p>
</li>
<li><p>指不推迟整个工程完成的前提下，该事件最迟必须完成的时间</p>
</li>
</ul>
</li>
<li><p>活动ai的最早开始时间e（i）</p>
<ul>
<li><p>该活动弧的起点的事件的最早发生时间</p>
</li>
<li><p>若边&lt;vk，vj&gt;表示活动ai，则有e（i）&#x3D;ve（k）</p>
</li>
</ul>
</li>
<li><p>活动ai的最迟开始时间l（i）</p>
<ul>
<li><p>该活动弧的终点的事件的最迟发生时间与该活动所需时间之差</p>
</li>
<li><p>若边&lt;vk，vj&gt;表示活动ai，则有l（i）&#x3D;vl（j）-Weight（vk，vj）</p>
</li>
</ul>
</li>
<li><p>活动的时间余量d(i)</p>
<ul>
<li><p>一个活动的最迟开始时间l（i）和最早开始时间e（i）的差额d（i）&#x3D;l（i）-e（i）</p>
</li>
<li><p>指在不增加完成整个工程所需总时间的前提下，该活动可以拖延的时间</p>
</li>
<li><p>若该活动的时间余量为0，表示该活动不能拖延，即该活动为关键活动</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>求关键路径的算法步骤</p>
<ul>
<li><p>从源点出发，令ve（源点）&#x3D;0，按拓扑有序求其余顶点的最早发生时间ve（）</p>
<ul>
<li><p>先找到拓扑排序序列</p>
</li>
<li><p>求各个顶点的最早发生时间（取最大值）</p>
</li>
</ul>
</li>
<li><p>从汇点出发，令vl（汇点） &#x3D;ve（汇点），按逆拓扑有序求其余顶点的最迟发生时间vl（）</p>
<ul>
<li><p>将汇点的最早发生时间赋值给汇点的最晚发生时间</p>
</li>
<li><p>按拓扑序列反向写出逆拓扑序列（取最小值）</p>
</li>
</ul>
</li>
<li><p>根据各顶点的ve（）值求所有孤的最早开始时间e（）</p>
<ul>
<li>活动的最早发生时间&#x3D;活动弧起点处事件的最早发生时间</li>
</ul>
</li>
<li><p>根据各顶点的vl（）值求所有弧的最迟开始时间1（）</p>
<ul>
<li>活动的最晚发生时间&#x3D;活动弧终点处事件的最晚发生时间 - 活动所需时间</li>
</ul>
</li>
<li><p>求AOE网中所有活动的差额d（），找出所有d（）&#x3D;0的活动构成关键路径</p>
<ul>
<li>活动的时间余量&#x3D;活动的最晚发生时间 - 活动的最早发生时间</li>
</ul>
</li>
</ul>
</li>
<li><p>关键活动、关键路径特性</p>
<ul>
<li><p>若关键活动耗时增加，则整个工程的工期将增加</p>
</li>
<li><p>关键路径上的所有活动都是关键活动，是决定整个工程的关键因素，因此可通过加快关键活动来缩短整个工程的工期</p>
</li>
<li><p>不能任意缩短关键活动，因为一旦缩短到一定的程度，该关键活动就可能会变成非关键活动</p>
</li>
<li><p>网中的关键路径并不唯一，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的</p>
</li>
<li><p>若关键活动耗时增加，则整个工程的工期将增长</p>
</li>
<li><p>缩短关键活动的时间，可以缩短整个工程的工期</p>
</li>
<li><p>当缩短到一定程度时，关键活动可能会变成非关键活动</p>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="prev" title="树与二叉树">
                  <i class="fa fa-chevron-left"></i> 树与二叉树
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/03/%E8%AE%A1%E7%AE%97%E6%9C%BA408_3.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7%E6%9F%A5%E6%89%BE/" rel="next" title="查找">
                  查找 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
