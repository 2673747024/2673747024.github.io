<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="网络编程基础网络编程是Java最擅长的方向之一，使用Java进行网络编程时，由虚拟机实现了底层复杂的网络协议，Java程序只需要调用Java标准库提供的接口，就可以简单高效地编写网络程序。 在学习Java网络编程之前，我们先来了解什么是计算机网络。 计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。 那什么是互联网呢？">
<meta property="og:type" content="article">
<meta property="og:title" content="2.网络编程">
<meta property="og:url" content="https://2673747024.github.io/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="网络编程基础网络编程是Java最擅长的方向之一，使用Java进行网络编程时，由虚拟机实现了底层复杂的网络协议，Java程序只需要调用Java标准库提供的接口，就可以简单高效地编写网络程序。 在学习Java网络编程之前，我们先来了解什么是计算机网络。 计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。 那什么是互联网呢？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://2673747024.github.io/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l.png">
<meta property="og:image" content="https://2673747024.github.io/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713672.png">
<meta property="og:image" content="https://2673747024.github.io/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713683.png">
<meta property="og:image" content="https://2673747024.github.io/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713684.png">
<meta property="og:image" content="https://2673747024.github.io/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713685.png">
<meta property="article:published_time" content="2022-02-04T14:30:57.787Z">
<meta property="article:modified_time" content="2022-02-04T15:04:32.717Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://2673747024.github.io/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l.png">


<link rel="canonical" href="https://2673747024.github.io/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","path":"2022/02/04/Java_5.JavaEE进阶_2.网络编程/","title":"2.网络编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>2.网络编程 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">网络编程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="nav-number">1.0.1.</span> <span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%9F%E5%90%8D"><span class="nav-number">1.0.2.</span> <span class="nav-text">域名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.0.3.</span> <span class="nav-text">网络模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.0.4.</span> <span class="nav-text">常用协议</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP%E7%BC%96%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">TCP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="nav-number">2.0.1.</span> <span class="nav-text">服务器端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">2.0.2.</span> <span class="nav-text">客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket%E6%B5%81"><span class="nav-number">2.0.3.</span> <span class="nav-text">Socket流</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#UDP%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">UDP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-1"><span class="nav-number">3.0.1.</span> <span class="nav-text">服务器端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="nav-number">3.0.2.</span> <span class="nav-text">客户端</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%91%E9%80%81Email"><span class="nav-number">4.</span> <span class="nav-text">发送Email</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87SMTP%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF"><span class="nav-number">4.0.1.</span> <span class="nav-text">准备SMTP登录信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6"><span class="nav-number">4.0.2.</span> <span class="nav-text">发送邮件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81HTML%E9%82%AE%E4%BB%B6"><span class="nav-number">4.0.3.</span> <span class="nav-text">发送HTML邮件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E9%99%84%E4%BB%B6"><span class="nav-number">4.0.4.</span> <span class="nav-text">发送附件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E5%86%85%E5%B5%8C%E5%9B%BE%E7%89%87%E7%9A%84HTML%E9%82%AE%E4%BB%B6"><span class="nav-number">4.0.5.</span> <span class="nav-text">发送内嵌图片的HTML邮件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">4.0.6.</span> <span class="nav-text">常见问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6Email"><span class="nav-number">5.</span> <span class="nav-text">接收Email</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP%E7%BC%96%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">HTTP编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%BC%96%E7%A8%8B-1"><span class="nav-number">6.0.1.</span> <span class="nav-text">HTTP编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RMI%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">RMI远程调用</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2.网络编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-04 22:30:57 / 修改时间：23:04:32" itemprop="dateCreated datePublished" datetime="2022-02-04T22:30:57+08:00">2022-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/5-JavaEE%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">5.JavaEE进阶</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：12k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈48 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="网络编程基础"><a href="#网络编程基础" class="headerlink" title="网络编程基础"></a>网络编程基础</h1><p>网络编程是Java最擅长的方向之一，使用Java进行网络编程时，由虚拟机实现了底层复杂的网络协议，Java程序只需要调用Java标准库提供的接口，就可以简单高效地编写网络程序。</p>
<p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p>
<p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>
<p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>
<p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP&#x2F;IP协议。</p>
<p>TCP&#x2F;IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP&#x2F;IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p>
<p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似<code>101.202.99.12</code>，而IPv6采用128位地址，类似<code>2001:0DA8:100A:0000:0000:1020:F2F3:1428</code>。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。</p>
<p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li>10.x.x.x</li>
</ul>
<p>有一个特殊的IP地址，称之为本机地址，它总是<code>127.0.0.1</code>。</p>
<p>IPv4地址实际上是一个32位整数。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1707762444 = 0x65ca630c</span><br><span class="line">           = 65  ca  63 0c</span><br><span class="line">           = 101.202.99.12</span><br></pre></td></tr></table></figure>

<p>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<code>127.0.0.1</code>，还有一个IP地址，例如<code>101.202.99.12</code>，可以通过这个IP地址接入网络。</p>
<p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p>
<p>某台计算机的IP是<code>101.202.99.2</code>，子网掩码是<code>255.255.255.0</code>，那么计算该计算机的网络号是：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">IP</span> = <span class="number">101.202</span>.<span class="number">99.2</span></span><br><span class="line"><span class="attr">Mask</span> = <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"><span class="attr">Network</span> = IP &amp; Mask = <span class="number">101.202</span>.<span class="number">99.0</span></span><br></pre></td></tr></table></figure>

<p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</p>
<p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。</p>
<p>所以，一台计算机的一个网卡会有3个关键配置：</p>
<p><img src="/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l.png" alt="network"></p>
<ul>
<li>IP地址，例如：<code>10.0.2.15</code></li>
<li>子网掩码，例如：<code>255.255.255.0</code></li>
<li>网关的IP地址，例如：<code>10.0.2.2</code></li>
</ul>
<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</p>
<p>用<code>nslookup</code>可以查看域名对应的IP地址：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup www<span class="selector-class">.liaoxuefeng</span><span class="selector-class">.com</span></span><br><span class="line">Server:  xxx<span class="selector-class">.xxx</span><span class="selector-class">.xxx</span><span class="selector-class">.xxx</span></span><br><span class="line">Address: xxx<span class="selector-class">.xxx</span><span class="selector-class">.xxx</span>.xxx#<span class="number">53</span></span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">Name:    www<span class="selector-class">.liaoxuefeng</span><span class="selector-class">.com</span></span><br><span class="line">Address: <span class="number">47.98</span>.<span class="number">33.223</span></span><br></pre></td></tr></table></figure>

<p>有一个特殊的本机域名<code>localhost</code>，它对应的IP地址总是本机地址<code>127.0.0.1</code>。</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>
</ul>
<p>互联网实际使用的TCP&#x2F;IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</p>
<table>
<thead>
<tr>
<th align="left">OSI</th>
<th align="left">TCP&#x2F;IP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">应用层</td>
<td align="left">应用层</td>
</tr>
<tr>
<td align="left">表示层</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">会话层</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">传输层</td>
<td align="left">传输层</td>
</tr>
<tr>
<td align="left">网络层</td>
<td align="left">IP层</td>
</tr>
<tr>
<td align="left">链路层</td>
<td align="left">网络接口层</td>
</tr>
<tr>
<td align="left">物理层</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h3><p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p>
<p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p>
<p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p>
<p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p>
<h1 id="TCP编程"><a href="#TCP编程" class="headerlink" title="TCP编程"></a>TCP编程</h1><p>在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP&#x2F;IP协议把数据传输到网络：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────┐                                   ┌───────────┐</span><br><span class="line">│Application│                                   │Application│</span><br><span class="line">├───────────┤                                   ├───────────┤</span><br><span class="line">│  Socket   │                                   │  Socket   │</span><br><span class="line">├───────────┤                                   ├───────────┤</span><br><span class="line">│    TCP    │                                   │    TCP    │</span><br><span class="line">├───────────┤      ┌──────┐       ┌──────┐      ├───────────┤</span><br><span class="line">│    IP     │&lt;────&gt;│Router│&lt;─────&gt;│Router│&lt;────&gt;│    IP     │</span><br><span class="line">└───────────┘      └──────┘       └──────┘      └───────────┘</span><br></pre></td></tr></table></figure>

<p>Socket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单的封装。例如，Java提供的几个Socket相关的类就封装了操作系统提供的接口。</p>
<p>为什么需要Socket进行网络通信？因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p>
<p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于<em>特权端口</em>，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p>
<ul>
<li>101.202.99.2:1201</li>
<li>101.202.99.2:1304</li>
<li>101.202.99.2:15000</li>
</ul>
<p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p>
<p>因此，当Socket连接成功地在服务器端和客户端之间建立后：</p>
<ul>
<li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li>
<li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li>
</ul>
<h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><p>要使用Socket编程，我们首先要编写服务器端程序。Java标准库提供了<code>ServerSocket</code>来实现对指定IP和指定端口的监听。<code>ServerSocket</code>的典型实现代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws IOException </span>&#123;</span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> <span class="built_in">ServerSocket</span>(<span class="number">6666</span>); <span class="comment">// 监听指定端口</span></span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">&quot;server is running...&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Socket sock = ss.<span class="built_in">accept</span>();</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;connected from &quot;</span> + sock.<span class="built_in">getRemoteSocketAddress</span>());</span><br><span class="line">            Thread t = <span class="keyword">new</span> <span class="built_in">Handler</span>(sock);</span><br><span class="line">            t.<span class="built_in">start</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="title">extends</span> <span class="title">Thread</span> &#123;</span></span><br><span class="line">    Socket sock;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Socket sock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sock = sock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">try</span></span> (InputStream input = <span class="keyword">this</span>.sock.<span class="built_in">getInputStream</span>()) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">try</span></span> (OutputStream output = <span class="keyword">this</span>.sock.<span class="built_in">getOutputStream</span>()) &#123;</span><br><span class="line">                <span class="built_in">handle</span>(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.sock.<span class="built_in">close</span>();</span><br><span class="line">            &#125; <span class="built_in"><span class="keyword">catch</span></span> (IOException ioe) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;client disconnected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(InputStream input, OutputStream output)</span> throws IOException </span>&#123;</span><br><span class="line">        var writer = <span class="keyword">new</span> <span class="built_in">BufferedWriter</span>(<span class="keyword">new</span> <span class="built_in">OutputStreamWriter</span>(output, StandardCharsets.UTF_8));</span><br><span class="line">        var reader = <span class="keyword">new</span> <span class="built_in">BufferedReader</span>(<span class="keyword">new</span> <span class="built_in">InputStreamReader</span>(input, StandardCharsets.UTF_8));</span><br><span class="line">        writer.<span class="built_in">write</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">        writer.<span class="built_in">flush</span>();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">String</span> s = reader.<span class="built_in">readLine</span>();</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">equals</span>(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                writer.<span class="built_in">write</span>(<span class="string">&quot;bye\n&quot;</span>);</span><br><span class="line">                writer.<span class="built_in">flush</span>();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            writer.<span class="built_in">write</span>(<span class="string">&quot;ok: &quot;</span> + s + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            writer.<span class="built_in">flush</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端通过代码：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ServerSocket ss</span> = new ServerSocket(6666);</span><br></pre></td></tr></table></figure>

<p>在指定端口<code>6666</code>监听。这里我们没有指定IP地址，表示在计算机的所有网络接口上进行监听。</p>
<p>如果<code>ServerSocket</code>监听成功，我们就使用一个无限循环来处理客户端的连接：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="comment">;;) &#123;</span></span><br><span class="line">    Socket sock = ss.accept()<span class="comment">;</span></span><br><span class="line">    Thread <span class="literal">t</span> = new Handler(<span class="name">sock</span>)<span class="comment">;</span></span><br><span class="line">    <span class="literal">t</span>.start()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到代码<code>ss.accept()</code>表示每当有新的客户端连接进来后，就返回一个<code>Socket</code>实例，这个<code>Socket</code>实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的<code>Socket</code>创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p>
<p>我们在多线程编程的章节中介绍过线程池，这里也完全可以利用线程池来处理客户端连接，能大大提高运行效率。</p>
<p>如果没有客户端连接进来，<code>accept()</code>方法会阻塞并一直等待。如果有多个客户端同时连接进来，<code>ServerSocket</code>会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用<code>accept()</code>就可以获取新的连接。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>相比服务器端，客户端程序就要简单很多。一个典型的客户端程序如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Client &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws IOException &#123;</span><br><span class="line">        Socket sock = <span class="keyword">new</span> <span class="constructor">Socket(<span class="string">&quot;localhost&quot;</span>, 6666)</span>; <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line">        <span class="keyword">try</span> (InputStream input = sock.get<span class="constructor">InputStream()</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> (OutputStream output = sock.get<span class="constructor">OutputStream()</span>) &#123;</span><br><span class="line">                handle(input, output);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sock.close<span class="literal">()</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;disconnected.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static void handle(InputStream input, OutputStream output) throws IOException &#123;</span><br><span class="line">        var writer = <span class="keyword">new</span> <span class="constructor">BufferedWriter(<span class="params">new</span> OutputStreamWriter(<span class="params">output</span>, StandardCharsets.UTF_8)</span>);</span><br><span class="line">        var reader = <span class="keyword">new</span> <span class="constructor">BufferedReader(<span class="params">new</span> InputStreamReader(<span class="params">input</span>, StandardCharsets.UTF_8)</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> <span class="constructor">Scanner(System.<span class="params">in</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;[server] &quot;</span> + reader.read<span class="constructor">Line()</span>);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">&quot;&gt;&gt;&gt; &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">            String s = scanner.next<span class="constructor">Line()</span>; <span class="comment">// 读取一行输入</span></span><br><span class="line">            writer.write(s);</span><br><span class="line">            writer.<span class="keyword">new</span><span class="constructor">Line()</span>;</span><br><span class="line">            writer.flush<span class="literal">()</span>;</span><br><span class="line">            String resp = reader.read<span class="constructor">Line()</span>;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;&lt;&lt;&lt; &quot;</span> + resp);</span><br><span class="line">            <span class="keyword">if</span> (resp.equals(<span class="string">&quot;bye&quot;</span>)) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端程序通过：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Socket sock</span> = new Socket(<span class="string">&quot;localhost&quot;</span>, 6666);</span><br></pre></td></tr></table></figure>

<p>连接到服务器端，注意上述代码的服务器地址是<code>&quot;localhost&quot;</code>，表示本机地址，端口号是<code>6666</code>。如果连接成功，将返回一个<code>Socket</code>实例，用于后续通信。</p>
<h3 id="Socket流"><a href="#Socket流" class="headerlink" title="Socket流"></a>Socket流</h3><p>当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用<code>Socket</code>实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用<code>InputStream</code>和<code>OutputStream</code>来封装Socket的数据流，这样我们使用Socket的流，和普通IO流类似：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 用于读取网络数据:</span><br><span class="line">InputStream <span class="keyword">in</span> = sock.getInputStream();</span><br><span class="line"><span class="regexp">//</span> 用于写入网络数据:</span><br><span class="line">OutputStream out = sock.getOutputStream();</span><br></pre></td></tr></table></figure>

<p>最后我们重点来看看，为什么写入网络数据时，要调用<code>flush()</code>方法。</p>
<p>如果不调用<code>flush()</code>，我们很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而我们又想强制把这些数据发送到网络，就必须调用<code>flush()</code>强制把缓冲区数据发送出去。</p>
<h1 id="UDP编程"><a href="#UDP编程" class="headerlink" title="UDP编程"></a>UDP编程</h1><p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p>
<p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p>
<h3 id="服务器端-1"><a href="#服务器端-1" class="headerlink" title="服务器端"></a>服务器端</h3><p>在服务器端，使用UDP也需要监听指定的端口。Java提供了<code>DatagramSocket</code>来实现这个功能，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> <span class="constructor">DatagramSocket(6666)</span>; <span class="comment">// 监听指定端口</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="comment">// 数据缓冲区:</span></span><br><span class="line">    byte<span class="literal">[]</span> buffer = <span class="keyword">new</span> byte<span class="literal">[<span class="number">1024</span>]</span>;</span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> <span class="constructor">DatagramPacket(<span class="params">buffer</span>, <span class="params">buffer</span>.<span class="params">length</span>)</span>;</span><br><span class="line">    ds.receive(packet); <span class="comment">// 收取一个UDP数据包</span></span><br><span class="line">    <span class="comment">// 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度</span></span><br><span class="line">    <span class="comment">// 将其按UTF-8编码转换为String:</span></span><br><span class="line">    String s = <span class="keyword">new</span> <span class="constructor">String(<span class="params">packet</span>.<span class="params">getData</span>()</span>, packet.get<span class="constructor">Offset()</span>, packet.get<span class="constructor">Length()</span>, StandardCharsets.UTF_8);</span><br><span class="line">    <span class="comment">// 发送数据:</span></span><br><span class="line">    byte<span class="literal">[]</span> data = <span class="string">&quot;ACK&quot;</span>.get<span class="constructor">Bytes(StandardCharsets.UTF_8)</span>;</span><br><span class="line">    packet.set<span class="constructor">Data(<span class="params">data</span>)</span>;</span><br><span class="line">    ds.send(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端首先使用如下语句在指定的端口监听UDP数据包：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">DatagramSocket ds</span> = new DatagramSocket(6666);</span><br></pre></td></tr></table></figure>

<p>如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="comment">;;) &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要接收一个UDP数据包，需要准备一个<code>byte[]</code>缓冲区，并通过<code>DatagramPacket</code>实现接收：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> <span class="built_in">DatagramPacket</span>(buffer, buffer.length);</span><br><span class="line">ds.<span class="built_in">receive</span>(packet);</span><br></pre></td></tr></table></figure>

<p>假设我们收取到的是一个<code>String</code>，那么，通过<code>DatagramPacket</code>返回的<code>packet.getOffset()</code>和<code>packet.getLength()</code>确定数据在缓冲区的起止位置：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> <span class="constructor">String(<span class="params">packet</span>.<span class="params">getData</span>()</span>, packet.get<span class="constructor">Offset()</span>, packet.get<span class="constructor">Length()</span>, StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure>

<p>当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。</p>
<p>发送UDP包也是通过<code>DatagramPacket</code>实现的，发送代码非常简单：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">byte</span>[] <span class="class"><span class="keyword">data</span> = ...</span></span><br><span class="line"><span class="title">packet</span>.setData(<span class="class"><span class="keyword">data</span>);</span></span><br><span class="line"><span class="title">ds</span>.send(packet);</span><br></pre></td></tr></table></figure>

<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><p>和服务器端相比，客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> <span class="constructor">DatagramSocket()</span>;</span><br><span class="line">ds.set<span class="constructor">SoTimeout(1000)</span>;</span><br><span class="line">ds.connect(<span class="module-access"><span class="module"><span class="identifier">InetAddress</span>.</span></span>get<span class="constructor">ByName(<span class="string">&quot;localhost&quot;</span>)</span>, <span class="number">6666</span>); <span class="comment">// 连接指定服务器和端口</span></span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line">byte<span class="literal">[]</span> data = <span class="string">&quot;Hello&quot;</span>.get<span class="constructor">Bytes()</span>;</span><br><span class="line">DatagramPacket packet = <span class="keyword">new</span> <span class="constructor">DatagramPacket(<span class="params">data</span>, <span class="params">data</span>.<span class="params">length</span>)</span>;</span><br><span class="line">ds.send(packet);</span><br><span class="line"><span class="comment">// 接收:</span></span><br><span class="line">byte<span class="literal">[]</span> buffer = <span class="keyword">new</span> byte<span class="literal">[<span class="number">1024</span>]</span>;</span><br><span class="line">packet = <span class="keyword">new</span> <span class="constructor">DatagramPacket(<span class="params">buffer</span>, <span class="params">buffer</span>.<span class="params">length</span>)</span>;</span><br><span class="line">ds.receive(packet);</span><br><span class="line">String resp = <span class="keyword">new</span> <span class="constructor">String(<span class="params">packet</span>.<span class="params">getData</span>()</span>, packet.get<span class="constructor">Offset()</span>, packet.get<span class="constructor">Length()</span>);</span><br><span class="line">ds.disconnect<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<p>客户端打开一个<code>DatagramSocket</code>使用以下代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">new</span> <span class="constructor">DatagramSocket()</span>;</span><br><span class="line">ds.set<span class="constructor">SoTimeout(1000)</span>;</span><br><span class="line">ds.connect(<span class="module-access"><span class="module"><span class="identifier">InetAddress</span>.</span></span>get<span class="constructor">ByName(<span class="string">&quot;localhost&quot;</span>)</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p>客户端创建<code>DatagramSocket</code>实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用<code>setSoTimeout(1000)</code>设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p>
<p>注意到客户端的<code>DatagramSocket</code>还调用了一个<code>connect()</code>方法“连接”到指定的服务器端。不是说UDP是无连接的协议吗？为啥这里需要<code>connect()</code>？</p>
<p>这个<code>connect()</code>方法不是真连接，它是为了在客户端的<code>DatagramSocket</code>实例中保存服务器端的IP和端口号，确保这个<code>DatagramSocket</code>实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p>
<p>如果客户端希望向两个不同的服务器发送UDP包，那么它必须创建两个<code>DatagramSocket</code>实例。</p>
<p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p>
<p>如果客户端认为通信结束，就可以调用<code>disconnect()</code>断开连接：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds.disconnect()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>注意到<code>disconnect()</code>也不是真正地断开连接，它只是清除了客户端<code>DatagramSocket</code>实例记录的远程服务器地址和端口号，这样，<code>DatagramSocket</code>实例就可以连接另一个服务器端。</p>
<h1 id="发送Email"><a href="#发送Email" class="headerlink" title="发送Email"></a>发送Email</h1><p>Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如<code>abc@example.com</code>，邮件软件比如Outlook都是用来收发邮件的。</p>
<p>使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。</p>
<p>传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">           ┌──────────┐    ┌──────────┐</span><br><span class="line">           │PostOffice│    │PostOffice│     .───.</span><br><span class="line">┌─────┐    ├──────────┤    ├──────────┤    (   ( )</span><br><span class="line">│═══ ░│───&gt;│ ┌─┐ ┌┐┌┐ │───&gt;│ ┌─┐ ┌┐┌┐ │───&gt; `─┬─&#x27;</span><br><span class="line">└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │</span><br><span class="line">           └─┴─┴──────┘    └─┴─┴──────┘       │</span><br></pre></td></tr></table></figure>

<p>电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">             ┌─────────┐    ┌─────────┐    ┌─────────┐</span><br><span class="line">             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│</span><br><span class="line">┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐</span><br><span class="line">│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│</span><br><span class="line">├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤</span><br><span class="line">│       │───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│&lt;───│       │</span><br><span class="line">└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘</span><br><span class="line">   MUA           MTA            MTA            MDA           MUA</span><br></pre></td></tr></table></figure>

<p>我们把类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p>
<p>MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p>
<p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。</p>
<p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。</p>
<h3 id="准备SMTP登录信息"><a href="#准备SMTP登录信息" class="headerlink" title="准备SMTP登录信息"></a>准备SMTP登录信息</h3><p>假设我们准备使用自己的邮件地址<code>me@example.com</code>给小明发送邮件，已知小明的邮件地址是<code>xiaoming@somewhere.com</code>，发送邮件前，我们首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是<code>smtp.example.com</code>，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：</p>
<ul>
<li>QQ邮箱：SMTP服务器是smtp.qq.com，端口是465&#x2F;587；</li>
<li>163邮箱：SMTP服务器是smtp.163.com，端口是465；</li>
<li>Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465&#x2F;587。</li>
</ul>
<p>有了SMTP服务器的域名和端口号，我们还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p>
<p>我们来看看如何使用JavaMail发送邮件。</p>
<p>首先，我们需要创建一个Maven工程，并把JavaMail相关的两个依赖加入进来：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.mail-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>然后，我们通过JavaMail API连接到SMTP服务器上：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器地址:</span></span><br><span class="line">String smtp = <span class="string">&quot;smtp.office365.com&quot;</span>;</span><br><span class="line"><span class="comment">// 登录用户名:</span></span><br><span class="line">String username = <span class="string">&quot;jxsmtp101@outlook.com&quot;</span>;</span><br><span class="line"><span class="comment">// 登录口令:</span></span><br><span class="line">String password = <span class="string">&quot;********&quot;</span>;</span><br><span class="line"><span class="comment">// 连接到SMTP服务器587端口:</span></span><br><span class="line">Properties props = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.host&quot;</span>, smtp); <span class="comment">// SMTP主机名</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.port&quot;</span>, <span class="string">&quot;587&quot;</span>); <span class="comment">// 主机端口号</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 是否需要用户认证</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.starttls.enable&quot;</span>, <span class="string">&quot;true&quot;</span>); <span class="comment">// 启用TLS加密</span></span><br><span class="line"><span class="comment">// 获取Session实例:</span></span><br><span class="line">Session session = <span class="module-access"><span class="module"><span class="identifier">Session</span>.</span></span>get<span class="constructor">Instance(<span class="params">props</span>, <span class="params">new</span> Authenticator()</span> &#123;</span><br><span class="line">    protected PasswordAuthentication get<span class="constructor">PasswordAuthentication()</span> &#123;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">PasswordAuthentication(<span class="params">username</span>, <span class="params">password</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 设置debug模式便于调试:</span></span><br><span class="line">session.set<span class="constructor">Debug(<span class="params">true</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>以587端口为例，连接SMTP服务器时，需要准备一个Properties对象，填入相关信息。最后获取Session实例时，如果服务器需要认证，还需要传入一个Authenticator对象，并返回指定的用户名和口令。</p>
<p>当我们获取到Session实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p>
<h3 id="发送邮件"><a href="#发送邮件" class="headerlink" title="发送邮件"></a>发送邮件</h3><p>发送邮件时，我们需要构造一个<code>Message</code>对象，然后调用<code>Transport.send(Message)</code>即可完成发送：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MimeMessage message = <span class="keyword">new</span> <span class="constructor">MimeMessage(<span class="params">session</span>)</span>;</span><br><span class="line"><span class="comment">// 设置发送方地址:</span></span><br><span class="line">message.set<span class="constructor">From(<span class="params">new</span> InternetAddress(<span class="string">&quot;me@example.com&quot;</span>)</span>);</span><br><span class="line"><span class="comment">// 设置接收方地址:</span></span><br><span class="line">message.set<span class="constructor">Recipient(Message.RecipientType.TO, <span class="params">new</span> InternetAddress(<span class="string">&quot;xiaoming@somewhere.com&quot;</span>)</span>);</span><br><span class="line"><span class="comment">// 设置邮件主题:</span></span><br><span class="line">message.set<span class="constructor">Subject(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line"><span class="comment">// 设置邮件正文:</span></span><br><span class="line">message.set<span class="constructor">Text(<span class="string">&quot;Hi Xiaoming...&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line"><span class="comment">// 发送:</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Transport</span>.</span></span>send(message);</span><br></pre></td></tr></table></figure>

<p>绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。</p>
<p>填入真实的地址，运行上述代码，我们可以在控制台看到JavaMail打印的调试信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">这是JavaMail打印的调试信息:</span><br><span class="line">DEBUG: setDebug: JavaMail version 1.6.2</span><br><span class="line">DEBUG: getProvider() returning javax.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]</span><br><span class="line">DEBUG SMTP: need username and password for authentication</span><br><span class="line">DEBUG SMTP: protocolConnect returning false, host=smtp.office365.com, ...</span><br><span class="line">DEBUG SMTP: useEhlo true, useAuth true</span><br><span class="line">开始尝试连接smtp.office365.com:</span><br><span class="line">DEBUG SMTP: trying to connect to host &quot;smtp.office365.com&quot;, port 587, ...</span><br><span class="line">DEBUG SMTP: connected to host &quot;smtp.office365.com&quot;, port: 587</span><br><span class="line">发送命令EHLO:</span><br><span class="line">EHLO localhost</span><br><span class="line">SMTP服务器响应250:</span><br><span class="line">250-SG3P274CA0024.outlook.office365.com Hello</span><br><span class="line">250-SIZE 157286400</span><br><span class="line">...</span><br><span class="line">DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;</span><br><span class="line">发送命令STARTTLS:</span><br><span class="line">STARTTLS</span><br><span class="line">SMTP服务器响应220:</span><br><span class="line">220 2.0.0 SMTP server ready</span><br><span class="line">EHLO localhost</span><br><span class="line">250-SG3P274CA0024.outlook.office365.com Hello [111.196.164.63]</span><br><span class="line">250-SIZE 157286400</span><br><span class="line">250-PIPELINING</span><br><span class="line">250-...</span><br><span class="line">DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;</span><br><span class="line">...</span><br><span class="line">尝试登录:</span><br><span class="line">DEBUG SMTP: protocolConnect login, host=smtp.office365.com, user=********, password=********</span><br><span class="line">DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 </span><br><span class="line">DEBUG SMTP: Using mechanism LOGIN</span><br><span class="line">DEBUG SMTP: AUTH LOGIN command trace suppressed</span><br><span class="line">登录成功:</span><br><span class="line">DEBUG SMTP: AUTH LOGIN succeeded</span><br><span class="line">DEBUG SMTP: use8bit false</span><br><span class="line">开发发送邮件，设置FROM:</span><br><span class="line">MAIL FROM:&lt;********@outlook.com&gt;</span><br><span class="line">250 2.1.0 Sender OK</span><br><span class="line">设置TO:</span><br><span class="line">RCPT TO:&lt;********@sina.com&gt;</span><br><span class="line">250 2.1.5 Recipient OK</span><br><span class="line">发送邮件数据:</span><br><span class="line">DATA</span><br><span class="line">服务器响应354:</span><br><span class="line">354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;</span><br><span class="line">真正的邮件数据:</span><br><span class="line">Date: Mon, 2 Dec 2019 09:37:52 +0800 (CST)</span><br><span class="line">From: ********@outlook.com</span><br><span class="line">To: ********001@sina.com</span><br><span class="line">Message-ID: &lt;1617791695.0.1575250672483@localhost&gt;</span><br><span class="line">邮件主题是编码后的文本:</span><br><span class="line">Subject: =?UTF-8?Q?JavaMail=E9=82=AE=E4=BB=B6?=</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line"></span><br><span class="line">邮件正文是Base64编码的文本:</span><br><span class="line">SGVsbG8sIOi/meaYr+S4gOWwgeadpeiHqmphdmFtYWls55qE6YKu5Lu277yB</span><br><span class="line">.</span><br><span class="line">邮件数据发送完成后，以\r\n.\r\n结束，服务器响应250表示发送成功:</span><br><span class="line">250 2.0.0 OK &lt;HK0PR03MB4961.apcprd03.prod.outlook.com&gt; [Hostname=HK0PR03MB4961.apcprd03.prod.outlook.com]</span><br><span class="line">DEBUG SMTP: message successfully delivered to mail server</span><br><span class="line">发送QUIT命令:</span><br><span class="line">QUIT</span><br><span class="line">服务器响应221结束TCP连接:</span><br><span class="line">221 2.0.0 Service closing transmission channel</span><br></pre></td></tr></table></figure>

<p>从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在<a target="_blank" rel="noopener" href="https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.txt">SMTP协议</a>中了，查看具体的响应码就可以知道出错原因。</p>
<p>如果一切顺利，对方将收到一封文本格式的电子邮件：</p>
<p><img src="/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713672.png" alt="javamail-text"></p>
<h3 id="发送HTML邮件"><a href="#发送HTML邮件" class="headerlink" title="发送HTML邮件"></a>发送HTML邮件</h3><p>发送HTML邮件和文本邮件是类似的，只需要把：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.set<span class="constructor">Text(<span class="params">body</span>, <span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">message.set<span class="constructor">Text(<span class="params">body</span>, <span class="string">&quot;UTF-8&quot;</span>, <span class="string">&quot;html&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>传入的<code>body</code>是类似<code>&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;Hi, xxx&lt;/p&gt;</code>这样的HTML字符串即可。</p>
<p>HTML邮件可以在邮件客户端直接显示为网页格式：</p>
<p><img src="/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713683.png" alt="javamail-html"></p>
<h3 id="发送附件"><a href="#发送附件" class="headerlink" title="发送附件"></a>发送附件</h3><p>要在电子邮件中携带附件，我们就不能直接调用<code>message.setText()</code>方法，而是要构造一个<code>Multipart</code>对象：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Multipart multipart = <span class="keyword">new</span> <span class="constructor">MimeMultipart()</span>;</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="keyword">new</span> <span class="constructor">MimeBodyPart()</span>;</span><br><span class="line">textpart.set<span class="constructor">Content(<span class="params">body</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>)</span>;</span><br><span class="line">multipart.add<span class="constructor">BodyPart(<span class="params">textpart</span>)</span>;</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="keyword">new</span> <span class="constructor">MimeBodyPart()</span>;</span><br><span class="line">imagepart.set<span class="constructor">FileName(<span class="params">fileName</span>)</span>;</span><br><span class="line">imagepart.set<span class="constructor">DataHandler(<span class="params">new</span> DataHandler(<span class="params">new</span> ByteArrayDataSource(<span class="params">input</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span>));</span><br><span class="line">multipart.add<span class="constructor">BodyPart(<span class="params">imagepart</span>)</span>;</span><br><span class="line"><span class="comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.set<span class="constructor">Content(<span class="params">multipart</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>一个<code>Multipart</code>对象可以添加若干个<code>BodyPart</code>，其中第一个<code>BodyPart</code>是文本，即邮件正文，后面的BodyPart是附件。<code>BodyPart</code>依靠<code>setContent()</code>决定添加的内容，如果添加文本，用<code>setContent(&quot;...&quot;, &quot;text/plain;charset=utf-8&quot;)</code>添加纯文本，或者用<code>setContent(&quot;...&quot;, &quot;text/html;charset=utf-8&quot;)</code>添加HTML文本。如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个<code>DataHandler()</code>，传入文件的MIME类型。二进制文件可以用<code>application/octet-stream</code>，Word文档则是<code>application/msword</code>。</p>
<p>最后，通过<code>setContent()</code>把<code>Multipart</code>添加到<code>Message</code>中，即可发送。</p>
<p>带附件的邮件在客户端会被提示下载：</p>
<p><img src="/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713684.png" alt="javamail-attachment"></p>
<h3 id="发送内嵌图片的HTML邮件"><a href="#发送内嵌图片的HTML邮件" class="headerlink" title="发送内嵌图片的HTML邮件"></a>发送内嵌图片的HTML邮件</h3><p>有些童鞋可能注意到，HTML邮件中可以内嵌图片，这是怎么做到的？</p>
<p>如果给一个<code>&lt;img src=&quot;http://example.com/test.jpg&quot;&gt;</code>，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。</p>
<p>内嵌图片实际上也是一个附件，即邮件本身也是<code>Multipart</code>，但需要做一点额外的处理：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Multipart multipart = <span class="keyword">new</span> <span class="constructor">MimeMultipart()</span>;</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="keyword">new</span> <span class="constructor">MimeBodyPart()</span>;</span><br><span class="line">textpart.set<span class="constructor">Content(<span class="string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;&lt;img src=\&quot;cid:img01\&quot;&gt;&lt;/p&gt;&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>)</span>;</span><br><span class="line">multipart.add<span class="constructor">BodyPart(<span class="params">textpart</span>)</span>;</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="keyword">new</span> <span class="constructor">MimeBodyPart()</span>;</span><br><span class="line">imagepart.set<span class="constructor">FileName(<span class="params">fileName</span>)</span>;</span><br><span class="line">imagepart.set<span class="constructor">DataHandler(<span class="params">new</span> DataHandler(<span class="params">new</span> ByteArrayDataSource(<span class="params">input</span>, <span class="string">&quot;image/jpeg&quot;</span>)</span>));</span><br><span class="line"><span class="comment">// 与HTML的&lt;img src=&quot;cid:img01&quot;&gt;关联:</span></span><br><span class="line">imagepart.set<span class="constructor">Header(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">&quot;&lt;img01&gt;&quot;</span>)</span>;</span><br><span class="line">multipart.add<span class="constructor">BodyPart(<span class="params">imagepart</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>在HTML邮件中引用图片时，需要设定一个ID，用类似<code>&lt;img src=\&quot;cid:img01\&quot;&gt;</code>引用，然后，在添加图片作为BodyPart时，除了要正确设置MIME类型（根据图片类型使用<code>image/jpeg</code>或<code>image/png</code>），还需要设置一个Header：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">imagepart</span><span class="selector-class">.setHeader</span>(<span class="string">&quot;Content-ID&quot;</span>, <span class="string">&quot;&lt;img01&gt;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个ID和HTML中引用的ID对应起来，邮件客户端就可以正常显示内嵌图片：</p>
<p><img src="/2.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.assets/l-16418952713685.png" alt="javamail-inline"></p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>如果用户名或口令错误，会导致<code>535</code>登录失败：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">DEBUG</span> SMTP: AUTH LOGIN failed</span><br><span class="line"><span class="attribute">Exception</span> in thread <span class="string">&quot;main&quot;</span> javax.mail.AuthenticationFailedException: <span class="number">535</span> <span class="number">5</span>.<span class="number">7</span>.<span class="number">3</span> Authentication unsuccessful<span class="meta"> [HK0PR03CA0105.apcprd03.prod.outlook.com]</span></span><br></pre></td></tr></table></figure>

<p>如果登录用户和发件人不一致，会导致<code>554</code>拒绝发送错误：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">DEBUG</span> SMTP: MessagingException while sending, THROW: </span><br><span class="line"><span class="attribute">com</span>.sun.mail.smtp.SMTPSendFailedException: <span class="number">554</span> <span class="number">5</span>.<span class="number">2</span>.<span class="number">0</span> STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;</span><br></pre></td></tr></table></figure>

<p>有些时候，如果邮件主题和正文过于简单，会导致<code>554</code>被识别为垃圾邮件的错误：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DEBUG SMTP: MessagingException while sending, THROW: </span><br><span class="line">com<span class="selector-class">.sun</span><span class="selector-class">.mail</span><span class="selector-class">.smtp</span><span class="selector-class">.SMTPSendFailedException</span>: <span class="number">554</span> DT:SPM</span><br></pre></td></tr></table></figure>

<h1 id="接收Email"><a href="#接收Email" class="headerlink" title="接收Email"></a>接收Email</h1><p>发送Email的过程我们在上一节已经讲过了，客户端总是通过SMTP协议把邮件发送给MTA。</p>
<p>接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p>
<p>接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。</p>
<p>另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口143和加密端口993。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p>
<p>JavaMail也提供了IMAP协议的支持。因为POP3和IMAP的使用方式非常类似，因此我们只介绍POP3的用法。</p>
<p>使用POP3收取Email时，我们无需关心POP3协议底层，因为JavaMail提供了高层接口。首先需要连接到Store对象：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 准备登录信息:</span></span><br><span class="line">String host = <span class="string">&quot;pop3.example.com&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> port = <span class="number">995</span>;</span><br><span class="line">String username = <span class="string">&quot;bob@example.com&quot;</span>;</span><br><span class="line">String password = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">props.set<span class="constructor">Property(<span class="string">&quot;mail.store.protocol&quot;</span>, <span class="string">&quot;pop3&quot;</span>)</span>; <span class="comment">// 协议名称</span></span><br><span class="line">props.set<span class="constructor">Property(<span class="string">&quot;mail.pop3.host&quot;</span>, <span class="params">host</span>)</span>;<span class="comment">// POP3主机名</span></span><br><span class="line">props.set<span class="constructor">Property(<span class="string">&quot;mail.pop3.port&quot;</span>, String.<span class="params">valueOf</span>(<span class="params">port</span>)</span>); <span class="comment">// 端口号</span></span><br><span class="line"><span class="comment">// 启动SSL:</span></span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class="string">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;mail.smtp.socketFactory.port&quot;</span>, <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>value<span class="constructor">Of(<span class="params">port</span>)</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接到Store:</span></span><br><span class="line">URLName url = <span class="keyword">new</span> <span class="constructor">URLName(<span class="string">&quot;pop3&quot;</span>, <span class="params">host</span>, <span class="params">post</span>, <span class="string">&quot;&quot;</span>, <span class="params">username</span>, <span class="params">password</span>)</span>;</span><br><span class="line">Session session = <span class="module-access"><span class="module"><span class="identifier">Session</span>.</span></span>get<span class="constructor">Instance(<span class="params">props</span>, <span class="params">null</span>)</span>;</span><br><span class="line">session.set<span class="constructor">Debug(<span class="params">true</span>)</span>; <span class="comment">// 显示调试信息</span></span><br><span class="line">Store store = <span class="keyword">new</span> <span class="constructor">POP3SSLStore(<span class="params">session</span>, <span class="params">url</span>)</span>;</span><br><span class="line">store.connect<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<p>一个<code>Store</code>对象表示整个邮箱的存储，要收取邮件，我们需要通过<code>Store</code>访问指定的<code>Folder</code>（文件夹），通常是<code>INBOX</code>表示收件箱：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取收件箱:</span></span><br><span class="line">Folder folder = store.get<span class="constructor">Folder(<span class="string">&quot;INBOX&quot;</span>)</span>;</span><br><span class="line"><span class="comment">// 以读写方式打开:</span></span><br><span class="line">folder.<span class="keyword">open</span>(Folder.READ_WRITE);</span><br><span class="line"><span class="comment">// 打印邮件总数/新邮件数量/未读数量/已删除数量:</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Total messages: &quot;</span> + folder.get<span class="constructor">MessageCount()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;New messages: &quot;</span> + folder.get<span class="constructor">NewMessageCount()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Unread messages: &quot;</span> + folder.get<span class="constructor">UnreadMessageCount()</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Deleted messages: &quot;</span> + folder.get<span class="constructor">DeletedMessageCount()</span>);</span><br><span class="line"><span class="comment">// 获取每一封邮件:</span></span><br><span class="line">Message<span class="literal">[]</span> messages = folder.get<span class="constructor">Messages()</span>;</span><br><span class="line"><span class="keyword">for</span> (Message message : messages) &#123;</span><br><span class="line">    <span class="comment">// 打印每一封邮件:</span></span><br><span class="line">    print<span class="constructor">Message((MimeMessage)</span> message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们获取到一个<code>Message</code>对象时，可以强制转型为MimeMessage，然后打印出邮件主题、发件人、收件人等信息：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void print<span class="constructor">Message(MimeMessage <span class="params">msg</span>)</span> throws IOException, MessagingException &#123;</span><br><span class="line">    <span class="comment">// 邮件主题:</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Subject: &quot;</span> + <span class="module-access"><span class="module"><span class="identifier">MimeUtility</span>.</span></span>decode<span class="constructor">Text(<span class="params">msg</span>.<span class="params">getSubject</span>()</span>));</span><br><span class="line">    <span class="comment">// 发件人:</span></span><br><span class="line">    Address<span class="literal">[]</span> froms = msg.get<span class="constructor">From()</span>;</span><br><span class="line">    InternetAddress address = (InternetAddress) froms<span class="literal">[<span class="number">0</span>]</span>;</span><br><span class="line">    String personal = address.get<span class="constructor">Personal()</span>;</span><br><span class="line">    String from = personal<span class="operator"> == </span>null ? address.get<span class="constructor">Address()</span> : (<span class="module-access"><span class="module"><span class="identifier">MimeUtility</span>.</span></span>decode<span class="constructor">Text(<span class="params">personal</span>)</span> + <span class="string">&quot; &lt;&quot;</span> + address.get<span class="constructor">Address()</span> + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;From: &quot;</span> + from);</span><br><span class="line">    <span class="comment">// 继续打印收件人:</span><span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>

<p>比较麻烦的是获取邮件的正文。一个<code>MimeMessage</code>对象也是一个<code>Part</code>对象，它可能只包含一个文本，也可能是一个<code>Multipart</code>对象，即由几个<code>Part</code>构成，因此，需要递归地解析出完整的正文：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String get<span class="constructor">Body(Part <span class="params">part</span>)</span> throws MessagingException, IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (part.is<span class="constructor">MimeType(<span class="string">&quot;text/*&quot;</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// Part是文本:</span></span><br><span class="line">        return part.get<span class="constructor">Content()</span>.<span class="keyword">to</span><span class="constructor">String()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (part.is<span class="constructor">MimeType(<span class="string">&quot;multipart/*&quot;</span>)</span>) &#123;</span><br><span class="line">        <span class="comment">// Part是一个Multipart对象:</span></span><br><span class="line">        Multipart multipart = (Multipart) part.get<span class="constructor">Content()</span>;</span><br><span class="line">        <span class="comment">// 循环解析每个子Part:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; multipart.get<span class="constructor">Count()</span>; i++) &#123;</span><br><span class="line">            BodyPart bodyPart = multipart.get<span class="constructor">BodyPart(<span class="params">i</span>)</span>;</span><br><span class="line">            String body = get<span class="constructor">Body(<span class="params">bodyPart</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span> (!body.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">                return body;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后记得关闭<code>Folder</code>和<code>Store</code>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">folder.<span class="built_in">close</span>(<span class="literal">true</span>); <span class="comment">// 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）</span></span><br><span class="line">store.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<h1 id="HTTP编程"><a href="#HTTP编程" class="headerlink" title="HTTP编程"></a>HTTP编程</h1><p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p>
<p>HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p>
<p>我们来看一下浏览器请求访问某个网站时发送的HTTP请求-响应。当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用<code>80</code>端口和加密端口<code>443</code>，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。一个完整的HTTP请求-响应如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">            GET / HTTP/1.1</span><br><span class="line">            Host: www.sina.com.cn</span><br><span class="line">            User-Agent: Mozilla/5 MSIE</span><br><span class="line">            Accept: */*                ┌────────┐</span><br><span class="line">┌─────────┐ Accept-Language: zh-CN,en  │░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│───────────────────────────&gt;├────────┤</span><br><span class="line">├─────────┤&lt;───────────────────────────│░░░░░░░░│</span><br><span class="line">│         │ HTTP/1.1 200 OK            ├────────┤</span><br><span class="line">│         │ Content-Type: text/html    │░░░░░░░░│</span><br><span class="line">└─────────┘ Content-Length: 133251     └────────┘</span><br><span class="line">  Browser   &lt;!DOCTYPE html&gt;              Server</span><br><span class="line">            &lt;html&gt;&lt;body&gt;</span><br><span class="line">            &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是<code>请求方法 路径 HTTP版本</code>，例如，<code>GET / HTTP/1.1</code>表示使用<code>GET</code>请求，路径是<code>/</code>，版本是<code>HTTP/1.1</code>。</p>
<p>后续的每一行都是固定的<code>Header: Value</code>格式，我们称为HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p>
<ul>
<li>Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别请求是发给哪个网站的；</li>
<li>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型是IE还是Chrome，是Firefox还是一个Python爬虫；</li>
<li>Accept：表示客户端能处理的HTTP响应格式，<code>*/*</code>表示任意格式，<code>text/*</code>表示任意文本，<code>image/png</code>表示PNG格式的图片；</li>
<li>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li>
</ul>
<p>如果是<code>GET</code>请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是<code>POST</code>请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>30</span><br><span class="line"></span><br><span class="line"><span class="ini"><span class="attr">username</span>=hello&amp;password=<span class="number">123456</span></span></span><br></pre></td></tr></table></figure>

<p><code>POST</code>请求通常要设置<code>Content-Type</code>表示Body的类型，<code>Content-Length</code>表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p>
<p>此外，<code>GET</code>请求的参数必须附加在URL上，并以URLEncode方式编码，例如：<code>http://www.example.com/?a=1&amp;b=K%26R</code>，参数分别是<code>a=1</code>和<code>b=K&amp;R</code>。因为URL的长度限制，<code>GET</code>请求的参数不能太多，而<code>POST</code>请求的参数就没有长度限制，因为<code>POST</code>请求的参数必须放到Body中。并且，<code>POST</code>请求的参数不一定是URL编码，可以按任意格式编码，只需要在<code>Content-Type</code>中正确设置即可。常见的发送JSON的<code>POST</code>请求如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/login</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>38</span><br><span class="line"></span><br><span class="line"><span class="json">&#123;<span class="attr">&quot;username&quot;</span>:<span class="string">&quot;bob&quot;</span>,<span class="attr">&quot;password&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;</span></span><br></pre></td></tr></table></figure>

<p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>133251</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">...</span></span><br></pre></td></tr></table></figure>

<p>响应的第一行总是<code>HTTP版本 响应代码 响应说明</code>，例如，<code>HTTP/1.1 200 OK</code>表示版本是<code>HTTP/1.1</code>，响应代码是<code>200</code>，响应说明是<code>OK</code>。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：</p>
<ul>
<li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接；</li>
<li>2xx：表示一个成功的响应，例如200表示成功，206表示只发送了部分内容；</li>
<li>3xx：表示一个重定向的响应，例如301表示永久重定向，303表示客户端应该按指定路径重新发送请求；</li>
<li>4xx：表示一个因为客户端问题导致的错误响应，例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在；</li>
<li>5xx：表示一个因为服务器问题导致的错误响应，例如500表示服务器内部故障，503表示服务器暂时无法响应。</li>
</ul>
<p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，<code>GET /logo.jpg HTTP/1.1</code>请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>image/jpeg</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>18391</span><br><span class="line"></span><br><span class="line"><span class="ruby"><span class="string">??</span><span class="string">??</span>JFIFHH?<span class="string">?X</span>ExifMM?i&amp;<span class="string">??</span>X?...(二进制的JPEG图片)</span></span><br></pre></td></tr></table></figure>

<p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。</p>
<p>对于最早期的HTTP&#x2F;1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP&#x2F;1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                       ┌─────────┐</span><br><span class="line">┌─────────┐            │░░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│            ├─────────┤</span><br><span class="line">├─────────┤            │░░░░░░░░░│</span><br><span class="line">│         │            ├─────────┤</span><br><span class="line">│         │            │░░░░░░░░░│</span><br><span class="line">└─────────┘            └─────────┘</span><br><span class="line">     │      request 1       │</span><br><span class="line">     │─────────────────────&gt;│</span><br><span class="line">     │      response 1      │</span><br><span class="line">     │&lt;─────────────────────│</span><br><span class="line">     │      request 2       │</span><br><span class="line">     │─────────────────────&gt;│</span><br><span class="line">     │      response 2      │</span><br><span class="line">     │&lt;─────────────────────│</span><br><span class="line">     │      request 3       │</span><br><span class="line">     │─────────────────────&gt;│</span><br><span class="line">     │      response 3      │</span><br><span class="line">     │&lt;─────────────────────│</span><br><span class="line">     ▼                      ▼</span><br></pre></td></tr></table></figure>

<p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p>
<p>所以，为了进一步提速，HTTP&#x2F;2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                       ┌─────────┐</span><br><span class="line">┌─────────┐            │░░░░░░░░░│</span><br><span class="line">│O ░░░░░░░│            ├─────────┤</span><br><span class="line">├─────────┤            │░░░░░░░░░│</span><br><span class="line">│         │            ├─────────┤</span><br><span class="line">│         │            │░░░░░░░░░│</span><br><span class="line">└─────────┘            └─────────┘</span><br><span class="line">     │      request 1       │</span><br><span class="line">     │─────────────────────&gt;│</span><br><span class="line">     │      request 2       │</span><br><span class="line">     │─────────────────────&gt;│</span><br><span class="line">     │      response 1      │</span><br><span class="line">     │&lt;─────────────────────│</span><br><span class="line">     │      request 3       │</span><br><span class="line">     │─────────────────────&gt;│</span><br><span class="line">     │      response 3      │</span><br><span class="line">     │&lt;─────────────────────│</span><br><span class="line">     │      response 2      │</span><br><span class="line">     │&lt;─────────────────────│</span><br><span class="line">     ▼                      ▼</span><br></pre></td></tr></table></figure>

<p>可见，HTTP&#x2F;2.0进一步提高了效率。</p>
<h3 id="HTTP编程-1"><a href="#HTTP编程-1" class="headerlink" title="HTTP编程"></a>HTTP编程</h3><p>既然HTTP涉及到客户端和服务器端，和TCP类似，我们也需要针对客户端编程和针对服务器端编程。</p>
<p>本节我们不讨论服务器端的HTTP编程，因为服务器端的HTTP编程本质上就是编写Web服务器，这是一个非常复杂的体系，也是JavaEE开发的核心内容，我们在后面的章节再仔细研究。</p>
<p>本节我们只讨论作为客户端的HTTP编程。</p>
<p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而我们使用Java进行HTTP客户端编程仅限于获得响应内容。</p>
<p>我们来看一下Java如何使用HTTP客户端编程。</p>
<p>Java标准库提供了基于HTTP的包，但是要注意，早期的JDK版本是通过<code>HttpURLConnection</code>访问HTTP，典型代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> <span class="constructor">URL(<span class="string">&quot;http://www.example.com/path/to/target?a=1&amp;b=2&quot;</span>)</span>;</span><br><span class="line">HttpURLConnection conn = (HttpURLConnection) url.<span class="keyword">open</span><span class="constructor">Connection()</span>;</span><br><span class="line">conn.set<span class="constructor">RequestMethod(<span class="string">&quot;GET&quot;</span>)</span>;</span><br><span class="line">conn.set<span class="constructor">UseCaches(<span class="params">false</span>)</span>;</span><br><span class="line">conn.set<span class="constructor">ConnectTimeout(5000)</span>; <span class="comment">// 请求超时5秒</span></span><br><span class="line"><span class="comment">// 设置HTTP头:</span></span><br><span class="line">conn.set<span class="constructor">RequestProperty(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span>;</span><br><span class="line">conn.set<span class="constructor">RequestProperty(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)&quot;</span>)</span>;</span><br><span class="line"><span class="comment">// 连接并发送HTTP请求:</span></span><br><span class="line">conn.connect<span class="literal">()</span>;</span><br><span class="line"><span class="comment">// 判断HTTP响应是否200:</span></span><br><span class="line"><span class="keyword">if</span> (conn.get<span class="constructor">ResponseCode()</span> != <span class="number">200</span>) &#123;</span><br><span class="line">    throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="string">&quot;bad response&quot;</span>)</span>;</span><br><span class="line">&#125;		</span><br><span class="line"><span class="comment">// 获取所有响应Header:</span></span><br><span class="line">Map&lt;String, List&lt;String&gt;&gt; map = conn.get<span class="constructor">HeaderFields()</span>;</span><br><span class="line"><span class="keyword">for</span> (String key : map.key<span class="constructor">Set()</span>) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(key + <span class="string">&quot;: &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取响应内容:</span></span><br><span class="line">InputStream input = conn.get<span class="constructor">InputStream()</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上述代码编写比较繁琐，并且需要手动处理<code>InputStream</code>，所以用起来很麻烦。</p>
<p>从Java 11开始，引入了新的<code>HttpClient</code>，它使用链式调用的API，能大大简化HTTP的处理。</p>
<p>我们来看一下如何使用新版的<code>HttpClient</code>。首先需要创建一个全局<code>HttpClient</code>实例，因为<code>HttpClient</code>内部使用线程池优化多个HTTP连接，可以复用：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static HttpClient httpClient = <span class="module-access"><span class="module"><span class="identifier">HttpClient</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder()</span>.build<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<p>使用<code>GET</code>请求获取文本内容代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.http.*;</span><br><span class="line"><span class="keyword">import</span> java.net.http.<span class="built_in">HttpClient</span>.Version;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> &#123;</span></span><br><span class="line">    <span class="comment">// 全局HttpClient:</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">HttpClient</span> httpClient = <span class="built_in">HttpClient</span>.<span class="built_in">newBuilder</span>().<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> throws Exception </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> url = <span class="string">&quot;https://www.sina.com.cn/&quot;</span>;</span><br><span class="line">        HttpRequest request = HttpRequest.<span class="built_in">newBuilder</span>(<span class="keyword">new</span> <span class="built_in">URI</span>(url))</span><br><span class="line">            <span class="comment">// 设置Header:</span></span><br><span class="line">            .<span class="built_in">header</span>(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Java HttpClient&quot;</span>).<span class="built_in">header</span>(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span><br><span class="line">            <span class="comment">// 设置超时:</span></span><br><span class="line">            .<span class="built_in">timeout</span>(Duration.<span class="built_in">ofSeconds</span>(<span class="number">5</span>))</span><br><span class="line">            <span class="comment">// 设置版本:</span></span><br><span class="line">            .<span class="built_in">version</span>(Version.HTTP_2).<span class="built_in">build</span>();</span><br><span class="line">        HttpResponse&lt;<span class="keyword">String</span>&gt; response = httpClient.<span class="built_in">send</span>(request, HttpResponse.BodyHandlers.<span class="built_in">ofString</span>());</span><br><span class="line">        <span class="comment">// HTTP允许重复的Header，因此一个Header可对应多个Value:</span></span><br><span class="line">        Map&lt;<span class="keyword">String</span>, List&lt;<span class="keyword">String</span>&gt;&gt; headers = response.<span class="built_in">headers</span>().<span class="built_in">map</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> header : headers.<span class="built_in">keySet</span>()) &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(header + <span class="string">&quot;: &quot;</span> + headers.<span class="built_in">get</span>(header).<span class="built_in">get</span>(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="built_in">println</span>(response.<span class="built_in">body</span>().<span class="built_in">substring</span>(<span class="number">0</span>, <span class="number">1024</span>) + <span class="string">&quot;...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要获取图片这样的二进制内容，只需要把<code>HttpResponse.BodyHandlers.ofString()</code>换成<code>HttpResponse.BodyHandlers.ofByteArray()</code>，就可以获得一个<code>HttpResponse&lt;byte[]&gt;</code>对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用<code>HttpResponse.BodyHandlers.ofInputStream()</code>获取一个<code>InputStream</code>流。</p>
<p>要使用<code>POST</code>请求，我们要准备好发送的Body数据并正确设置<code>Content-Type</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="string">&quot;http://www.example.com/login&quot;</span>;</span><br><span class="line">String body = <span class="string">&quot;username=bob&amp;password=123456&quot;</span>;</span><br><span class="line">HttpRequest request = <span class="module-access"><span class="module"><span class="identifier">HttpRequest</span>.</span></span><span class="keyword">new</span><span class="constructor">Builder(<span class="params">new</span> URI(<span class="params">url</span>)</span>)</span><br><span class="line">    <span class="comment">// 设置Header:</span></span><br><span class="line">    .header(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;*/*&quot;</span>)</span><br><span class="line">    .header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)</span><br><span class="line">    <span class="comment">// 设置超时:</span></span><br><span class="line">    .timeout(<span class="module-access"><span class="module"><span class="identifier">Duration</span>.</span></span><span class="keyword">of</span><span class="constructor">Seconds(5)</span>)</span><br><span class="line">    <span class="comment">// 设置版本:</span></span><br><span class="line">    .version(Version.HTTP_2)</span><br><span class="line">    <span class="comment">// 使用POST并设置Body:</span></span><br><span class="line">    .<span class="constructor">POST(BodyPublishers.<span class="params">ofString</span>(<span class="params">body</span>, StandardCharsets.UTF_8)</span>).build<span class="literal">()</span>;</span><br><span class="line">HttpResponse&lt;String&gt; response = httpClient.send(request, <span class="module-access"><span class="module"><span class="identifier">HttpResponse</span>.</span><span class="module"><span class="identifier">BodyHandlers</span>.</span></span><span class="keyword">of</span><span class="constructor">String()</span>);</span><br><span class="line">String s = response.body<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<p>可见发送<code>POST</code>数据也十分简单。</p>
<h1 id="RMI远程调用"><a href="#RMI远程调用" class="headerlink" title="RMI远程调用"></a>RMI远程调用</h1><p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p>
<p>提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。</p>
<p>我们先来实现一个最简单的RMI：服务器会提供一个<code>WorldClock</code>服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LocalDateTime <span class="title">getLocalDateTime</span><span class="params">(<span class="keyword">String</span> zoneId)</span></span>;</span><br></pre></td></tr></table></figure>

<p>要实现RMI，服务器和客户端必须共享同一个接口。我们定义一个<code>WorldClock</code>接口，代码如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WorldClock</span> <span class="keyword"><span class="keyword">extends</span> <span class="type">Remote</span></span> </span>&#123;</span><br><span class="line">    LocalDateTime getLocalDateTime(<span class="keyword">String</span> zoneId) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java的RMI规定此接口必须派生自<code>java.rmi.Remote</code>，并在每个方法声明抛出<code>RemoteException</code>。</p>
<p>下一步是编写服务器的实现类，因为客户端请求的调用方法<code>getLocalDateTime()</code>最终会通过这个实现类返回结果。实现类<code>WorldClockService</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorldClockService</span> <span class="keyword">implements</span> <span class="title">WorldClock</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDateTime <span class="title">getLocalDateTime</span><span class="params">(String zoneId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now(ZoneId.of(zoneId)).withNano(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，服务器端的服务相关代码就编写完毕。我们需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Server &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) throws RemoteException &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;create World clock remote service...&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化一个WorldClock:</span></span><br><span class="line">        WorldClock worldClock = <span class="keyword">new</span> <span class="constructor">WorldClockService()</span>;</span><br><span class="line">        <span class="comment">// 将此服务转换为远程服务接口:</span></span><br><span class="line">        WorldClock skeleton = (WorldClock) <span class="module-access"><span class="module"><span class="identifier">UnicastRemoteObject</span>.</span></span>export<span class="constructor">Object(<span class="params">worldClock</span>, 0)</span>;</span><br><span class="line">        <span class="comment">// 将RMI服务注册到1099端口:</span></span><br><span class="line">        Registry registry = <span class="module-access"><span class="module"><span class="identifier">LocateRegistry</span>.</span></span>create<span class="constructor">Registry(1099)</span>;</span><br><span class="line">        <span class="comment">// 注册此服务，服务名为&quot;WorldClock&quot;:</span></span><br><span class="line">        registry.rebind(<span class="string">&quot;WorldClock&quot;</span>, skeleton);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码主要目的是通过RMI提供的相关类，将我们自己的<code>WorldClock</code>实例注册到RMI服务上。RMI的默认端口是<code>1099</code>，最后一步注册服务时通过<code>rebind()</code>指定服务名称为<code>&quot;WorldClock&quot;</code>。</p>
<p>下一步我们就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此我们要把<code>WorldClock.java</code>这个接口文件复制到客户端，然后在客户端实现RMI调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 连接到服务器localhost，端口1099:</span></span><br><span class="line">        Registry registry = LocateRegistry.getRegistry(<span class="string">&quot;localhost&quot;</span>, <span class="number">1099</span>);</span><br><span class="line">        <span class="comment">// 查找名称为&quot;WorldClock&quot;的服务并强制转型为WorldClock接口:</span></span><br><span class="line">        WorldClock worldClock = (WorldClock) registry.lookup(<span class="string">&quot;WorldClock&quot;</span>);</span><br><span class="line">        <span class="comment">// 正常调用接口方法:</span></span><br><span class="line">        LocalDateTime now = worldClock.getLocalDateTime(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印调用结果:</span></span><br><span class="line">        System.out.println(now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。整个过程实际上非常简单，对客户端来说，客户端持有的<code>WorldClock</code>接口实际上对应了一个“实现类”，它是由<code>Registry</code>内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的<code>WorldClockService</code>，而是<code>Registry</code>自动生成的代码。我们把客户端的“实现类”称为<code>stub</code>，而服务器端的网络服务类称为<code>skeleton</code>，它会真正调用服务器端的<code>WorldClockService</code>，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">  ┌─────────────┐                                 ┌─────────────┐</span><br><span class="line">│ │   Service   │ │         │                     │   Service   │ │</span><br><span class="line">  └─────────────┘                                 └─────────────┘</span><br><span class="line">│        ▲        │         │                            ▲        │</span><br><span class="line">         │                                               │</span><br><span class="line">│        │        │         │                            │        │</span><br><span class="line">  ┌─────────────┐   Network   ┌───────────────┐   ┌─────────────┐</span><br><span class="line">│ │ Client Stub ├─┼─────────┼&gt;│Server Skeleton│──&gt;│Service Impl │ │</span><br><span class="line">  └─────────────┘             └───────────────┘   └─────────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>

<p>Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>
<p>此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如<a target="_blank" rel="noopener" href="https://grpc.io/">gRPC</a>。</p>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_1.Maven%E3%80%81Gradle/" rel="prev" title="1.Maven、Gradle">
                  <i class="fa fa-chevron-left"></i> 1.Maven、Gradle
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_3.Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="next" title="3.Netty网络编程">
                  3.Netty网络编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
