<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="I&#x2F;O管理概述I&#x2F;O设备的基本概念与分类 什么是I&#x2F;O设备  可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件  UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作  Write操作：向外部设备写出数据  Read操作：从外部设备读入数据    按使用特性分类  人机交互类外部设备：数据传">
<meta property="og:type" content="article">
<meta property="og:title" content="输入输出管理">
<meta property="og:url" content="https://2673747024.github.io/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="I&#x2F;O管理概述I&#x2F;O设备的基本概念与分类 什么是I&#x2F;O设备  可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件  UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作  Write操作：向外部设备写出数据  Read操作：从外部设备读入数据    按使用特性分类  人机交互类外部设备：数据传">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/b91e3406-21a6-40cd-8998-81487d0695d5-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/ed4c44d3-5177-4da8-b5ca-3ded661ed869-3224585.jpg">
<meta property="article:published_time" content="2022-02-04T11:26:23.736Z">
<meta property="article:modified_time" content="2022-02-04T16:10:24.184Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api2.mubu.com/v3/document_image/b91e3406-21a6-40cd-8998-81487d0695d5-3224585.jpg">


<link rel="canonical" href="https://2673747024.github.io/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/","path":"2022/02/04/2-计算机408_2.操作系统_5.输入输出管理/","title":"输入输出管理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>输入输出管理 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#I-x2F-O%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">I&#x2F;O管理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-x2F-O%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">I&#x2F;O设备的基本概念与分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-number">1.2.</span> <span class="nav-text">IO控制器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-x2F-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">I&#x2F;O控制方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-x2F-O%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.</span> <span class="nav-text">I&#x2F;O子系统的层次结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#I-x2F-O%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">2.</span> <span class="nav-text">I&#x2F;O核心子系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#I-x2F-O%E6%A0%B8%E5%BF%83%E5%AD%90%E7%B3%BB%E7%BB%9F-1"><span class="nav-number">2.1.</span> <span class="nav-text">I&#x2F;O核心子系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPOOLING%E6%8A%80%E6%9C%AF%EF%BC%88%E5%81%87%E8%84%B1%E6%9C%BA%E6%8A%80%E6%9C%AF%EF%BC%89"><span class="nav-number">2.2.</span> <span class="nav-text">SPOOLING技术（假脱机技术）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-number">2.3.</span> <span class="nav-text">设备分配与回收</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%AE%A1%E7%90%86%EF%BC%88%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">缓冲区管理（高速缓存与缓冲区）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">112</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_5.%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          输入输出管理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-04 19:26:23" itemprop="dateCreated datePublished" datetime="2022-02-04T19:26:23+08:00">2022-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-05 00:10:24" itemprop="dateModified" datetime="2022-02-05T00:10:24+08:00">2022-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/" itemprop="url" rel="index"><span itemprop="name">计算机408</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">2.操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/5-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">5.输入输出管理</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：8.2k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈28 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="I-x2F-O管理概述"><a href="#I-x2F-O管理概述" class="headerlink" title="I&#x2F;O管理概述"></a>I&#x2F;O管理概述</h1><h2 id="I-x2F-O设备的基本概念与分类"><a href="#I-x2F-O设备的基本概念与分类" class="headerlink" title="I&#x2F;O设备的基本概念与分类"></a>I&#x2F;O设备的基本概念与分类</h2><ul>
<li><p>什么是I&#x2F;O设备</p>
<ul>
<li><p>可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件</p>
</li>
<li><p>UNIX系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作</p>
</li>
<li><p>Write操作：向外部设备写出数据</p>
</li>
<li><p>Read操作：从外部设备读入数据</p>
</li>
</ul>
</li>
<li><p>按使用特性分类</p>
<ul>
<li><p>人机交互类外部设备：数据传输速度慢（打印机，鼠标，键盘）</p>
</li>
<li><p>存储设备：数据传输速度快（移动硬盘，光盘）</p>
</li>
<li><p>网络通信设备：数据传输速度介于上述二者之间（调制解调器）</p>
</li>
</ul>
</li>
<li><p>按传输速率分类</p>
<ul>
<li><p>低速设备（鼠标，键盘）</p>
</li>
<li><p>中速设备（激光打印机）</p>
</li>
<li><p>高速设备（磁盘）</p>
</li>
</ul>
</li>
<li><p>按信息交换的单元分类</p>
<ul>
<li><p>块设备：传输速率较高，可寻址，即对它可随机地读&#x2F;写任一块（磁盘）</p>
</li>
<li><p>字符设备：传输速率较慢，不可寻址，在输入&#x2F;输出时常采用中断驱动方式（鼠标、键盘）</p>
</li>
</ul>
</li>
<li><p>I&#x2F;O设备：</p>
<ul>
<li><p>机械部件</p>
<ul>
<li><p>看得见摸得着的</p>
</li>
<li><p>主要用来执行具体I&#x2F;O操作</p>
</li>
</ul>
</li>
<li><p>电子部件（I&#x2F;O控制器、设备控制器）</p>
<ul>
<li>通常是一块插入主板扩充槽的印刷电路板</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h2><ul>
<li><p>定义</p>
<ul>
<li><p>CPU无法直接控制I&#x2F;O设备的机械部件，作为中介，用于实现CPU对设备的控制</p>
</li>
<li><p>I&#x2F;O控制器，又称设备控制器</p>
</li>
<li><p>CPU可控制I&#x2F;O控制器，又由I&#x2F;O控制器来控制设备的机械部件</p>
</li>
</ul>
</li>
<li><p>功能</p>
<ul>
<li><p>接收和识别CPU发出的命令</p>
<ul>
<li>I&#x2F;O控制器中有控制寄存器，用于存放命令和参数</li>
</ul>
</li>
<li><p>向CPU报告设备的状态</p>
<ul>
<li>I&#x2F;O控制器中有状态寄存器，用于记录I&#x2F;O设备的当前状态</li>
</ul>
</li>
<li><p>数据交换</p>
<ul>
<li><p>I&#x2F;O控制器中有数据寄存器</p>
<ul>
<li><p>输出时，数据寄存器用于暂存CPU发来的数据，之后再通过控制器传送给设备</p>
</li>
<li><p>输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取出数据</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>地址识别</p>
<ul>
<li><p>类似于内存的地址，为了区分设备控制器中的各个寄存器，给各个寄存器设置一个地址</p>
</li>
<li><p>I&#x2F;O控制器通过CPU提供的地址来查找寄存器</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li><p>CPU与控制器的接口</p>
<ul>
<li><p>用于实现CPU与控制器之间的通信</p>
</li>
<li><p>CPU通过控制线发出命令</p>
</li>
<li><p>通过地址线指明要操作的设备</p>
</li>
<li><p>通过数据线来取出（输入）数据，或放入（输出）数据</p>
</li>
</ul>
</li>
<li><p>I&#x2F;O逻辑</p>
<ul>
<li>负责接收和识别CPU的各种命令（如地址译码），并负责对设备发出命令</li>
</ul>
</li>
<li><p>控制器与设备的接口</p>
<ul>
<li>用于实现控制器与设备之间的通信</li>
</ul>
</li>
<li><p>值得注意的小细节：</p>
<ul>
<li><p>一个I&#x2F;O控制器可能会对应多个设备</p>
</li>
<li><p>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制&#x2F;状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两种寄存器编址方式</p>
<ul>
<li><p>内存映像I&#x2F;O：控制器中的寄存器与内存地址统一编址</p>
<ul>
<li>优点：简化了指令，可以采用对内存进行操作的指令来对控制器进行操作</li>
</ul>
</li>
<li><p>寄存器独立编址：控制器中的寄存器使用单独的地址</p>
<ul>
<li>缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><ul>
<li><p>用什么样的方式控制I&#x2F;O设备的数据读&#x2F;写</p>
</li>
<li><p>程序直接控制方式</p>
<ul>
<li><p>完成一次读&#x2F;写操作的流程</p>
<ul>
<li><p>CPU向控制器发出命令</p>
<ul>
<li>CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪）</li>
</ul>
</li>
<li><p>将I&#x2F;O状态信息读入CPU寄存器</p>
</li>
<li><p>检查状态</p>
<ul>
<li>轮询检查控制器的状态（其实就是在不断地执行程序的循环，若状态位一直是1，说明设备还没准备好要输入的数据，于是CPU会不断地轮询）</li>
</ul>
</li>
<li><p>输入设备准备好数据后将数据传给控制器，并报告自身状态</p>
</li>
<li><p>控制器将输入的数据放到数据寄存器中，并将状态改为0（已就绪）</p>
</li>
<li><p>将数据寄存器中的内容读入CPU寄存器</p>
<ul>
<li>CPU发现设备已就绪，即可将数据寄存器中的内容读入CPU的寄存器</li>
</ul>
</li>
<li><p>把CPU寄存器中的内容放入内存</p>
</li>
<li><p>若还要继续读入数据，则CPU继续发出读指令</p>
</li>
</ul>
</li>
<li><p>流程图<img src="https://api2.mubu.com/v3/document_image/b91e3406-21a6-40cd-8998-81487d0695d5-3224585.jpg" alt="img"></p>
</li>
<li><p>CPU干预频率：频繁</p>
<ul>
<li><p>I&#x2F;O操作开始之前、完成之后需要CPU介入</p>
</li>
<li><p>并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查</p>
</li>
</ul>
</li>
<li><p>数据传送的单元：每次读&#x2F;写一个字</p>
</li>
<li><p>数据的流向</p>
<ul>
<li><p>读操作（数据输入）：I&#x2F;O设备—&gt;CPU寄存器—&gt;内存</p>
</li>
<li><p>写操作（数据输出）：内存—&gt;CPU寄存器—&gt;I&#x2F;O设备</p>
</li>
<li><p>每个字的读&#x2F;写都需要CPU的帮助</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>实现简单，在读&#x2F;写指令之后，加上实现循环检查的一系列指令即可</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态 ，CPU利用率低</li>
</ul>
</li>
</ul>
</li>
<li><p>中断驱动方式</p>
<ul>
<li><p>背景：</p>
<ul>
<li><p>引入中断机制</p>
</li>
<li><p>由于I&#x2F;O设备速度很慢，因此在CPU发出读&#x2F;写命令后，可将等待I&#x2F;O的进程阻塞，先切换到别的进程执行</p>
</li>
<li><p>当I&#x2F;O完成后，控制器会向CPU发出一个中断信号</p>
</li>
<li><p>CPU检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断</p>
</li>
<li><p>中断程序：CPU从I&#x2F;O控制器读一个字的数据传送到CPU寄存器，再写入主存</p>
</li>
<li><p>CPU恢复等待I&#x2F;O的进程（或其他进程）的运行环境，然后继续执行</p>
</li>
</ul>
</li>
<li><p>完成一次读&#x2F;写操作的流程</p>
<ul>
<li><p>CPU向控制器发出命令，且将该I&#x2F;O进程阻塞</p>
<ul>
<li>CPU向控制器发出读指令。于是设备启动，并且状态寄存器设为1（未就绪）</li>
</ul>
</li>
<li><p>检查I&#x2F;O控制器的I&#x2F;O状态信息</p>
</li>
<li><p>检查状态</p>
<ul>
<li>若状态位是0，I&#x2F;O操作完成，控制器会向CPU发出一个中断信号</li>
</ul>
</li>
<li><p>注意：中断处理带来的影响</p>
<ul>
<li><p>CPU会在每个指令周期的末尾检查中断</p>
</li>
<li><p>如果中断发生的频率太高，也会降低系统性能。</p>
<ul>
<li>中断处理过程中需要保存、恢复进程的运行环境，需要一定时间开销的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CPU干预频率</p>
<ul>
<li><p>每次I&#x2F;O操作开始之前、完成之后需要CPU介入</p>
</li>
<li><p>等待I&#x2F;O完成的过程中CPU可以切换到别的进程执行，CPU不再进行轮询检查</p>
</li>
</ul>
</li>
<li><p>数据传送的单元：每次读&#x2F;写一个字</p>
</li>
<li><p>数据的流向</p>
<ul>
<li><p>读操作（数据输入）：I&#x2F;O设备—&gt;CPU寄存器—&gt;内存</p>
</li>
<li><p>写操作（数据输出）：内存—&gt;CPU寄存器—&gt;I&#x2F;O设备</p>
</li>
<li><p>每个字的读&#x2F;写都需要CPU的帮助</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>I&#x2F;O控制器会通过中断信号主动报告I&#x2F;O已完成，CPU不再需要不停地轮询</p>
</li>
<li><p>CPU和I&#x2F;O设备可并行工作，CPU利用率得到明显提升</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>每个字在I&#x2F;O设备与内存之间的传输，都需要经过CPU，频繁的中断处理会消耗较多的CPU时间</li>
</ul>
</li>
</ul>
</li>
<li><p>DMA方式（直接存储器存取）</p>
<ul>
<li><p>背景：</p>
<ul>
<li><p>数据的传送单位是块</p>
</li>
<li><p>数据的流向是从设备直接放入内存，或者从内存直接到设备，不再需要CPU作为中介</p>
</li>
<li><p>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</p>
</li>
</ul>
</li>
<li><p>完成一次读&#x2F;写操作的流程</p>
<ul>
<li><p>CPU向DMA控制器发出命令，且将该I&#x2F;O进程阻塞</p>
<ul>
<li>CPU指明此次要进行的操作（如：读操作），并说明要读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）</li>
</ul>
</li>
<li><p>DMA控制器会根据CPU提出的要求完成数据的读&#x2F;写工作，整块数据的传输完成后，向CPU发出中断信号</p>
</li>
</ul>
</li>
<li><p>DMA控制器</p>
<ul>
<li><p>数据寄存器（DR）：用于暂存从设备到内存或者从内存到设备的数据</p>
</li>
<li><p>内存地址寄存器（MAR）：</p>
<ul>
<li><p>在输入时，MAR 表示数据应放到内存中的什么位置</p>
</li>
<li><p>输出时， MAR 表示要输出的数据放在内存中的什么位置</p>
</li>
</ul>
</li>
<li><p>数据计数器（DC）：表示剩余要读&#x2F;写的字节数</p>
</li>
<li><p>命令&#x2F;状态寄存器（CR）：用于存放CPU发来的I&#x2F;O命令，或设备的状态信息</p>
</li>
</ul>
</li>
<li><p>CPU干预频率</p>
<ul>
<li>仅在传送一个或多个数据块的开始和结束时，才需要CPU干预</li>
</ul>
</li>
<li><p>数据传送的单元</p>
<ul>
<li>每次读&#x2F;写一个或多个连续的块（读写前在磁盘中是连续的，且读入内存后在内存中也是连续的）</li>
</ul>
</li>
<li><p>数据的流向（不再需要经过CPU）</p>
<ul>
<li><p>读操作（数据输入）：I&#x2F;O设备—&gt;内存</p>
</li>
<li><p>写操作（数据输出）：内存—&gt;I&#x2F;O设备</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>数据传输以块为单位</p>
</li>
<li><p>CPU介入频率进一步降低</p>
<ul>
<li>数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加</li>
</ul>
</li>
<li><p>CPU和I&#x2F;O设备的并行性得到提升</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>CPU每发出一条I&#x2F;O指令，只能读&#x2F;写一个或多个连续的数据块</p>
</li>
<li><p>如果要读&#x2F;写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I&#x2F;O指令，进行多次中断处理才能完成</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通道控制方式</p>
<ul>
<li><p>完成一次读&#x2F;写操作的流程</p>
<ul>
<li><p>CPU向通道发出I&#x2F;O指令，CPU切换到其他进程</p>
<ul>
<li>指明通道程序在内存中的位置，并指明要操作的是哪个I&#x2F;O设备</li>
</ul>
</li>
<li><p>通道执行内存中的通道程序</p>
<ul>
<li>其中指明了要读入&#x2F;写出多少数据，读&#x2F;写的数据应放在内存的什么位置等信息</li>
</ul>
</li>
<li><p>通道执行完规定的任务后，向CPU发出中断信号，之后CPU对中断进行处理</p>
</li>
</ul>
</li>
<li><p>通道</p>
<ul>
<li><p>一种硬件，可以理解为是削弱版的CPU</p>
</li>
<li><p>通道可以识别并执行一系列通道指令</p>
</li>
</ul>
</li>
<li><p>CPU干预频率：极低</p>
<ul>
<li>通道会根据CPU的指示执行相应的通道程序，只有完成一组数据块的读&#x2F;写后才需要发出中断信号，请求CPU干预</li>
</ul>
</li>
<li><p>数据传送的单元</p>
<ul>
<li>每次读&#x2F;写一组数据块</li>
</ul>
</li>
<li><p>数据的流向（在通道的控制下进行）</p>
<ul>
<li><p>读操作（数据输入）：I&#x2F;O设备—&gt;内存</p>
</li>
<li><p>写操作（数据输出）：内存—&gt;I&#x2F;O设备</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>实现复杂，需要专门的通道硬件支持</li>
</ul>
</li>
<li><p>DMA与通道的区别</p>
<ul>
<li><p>DMA需要CPU来控制传输的数据块大小、传输的内存位置、而通道方式中这些信息是由通道控制的</p>
</li>
<li><p>DMA控制器对应一台设备与内存传递数据，通道可以控制多台设备与内存的数据交换</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="I-x2F-O子系统的层次结构"><a href="#I-x2F-O子系统的层次结构" class="headerlink" title="I&#x2F;O子系统的层次结构"></a>I&#x2F;O子系统的层次结构</h2><ul>
<li><p>层次划分</p>
<ul>
<li><p>用户层I&#x2F;O软件：</p>
<ul>
<li><p>实现与用户交互的接口，用户可以直接调用在用户层提供的，与I&#x2F;O操作有关的库函数，对设备进行操作</p>
</li>
<li><p>用户层软件将用户请求翻译成格式化的I&#x2F;O请求，并通过“系统调用”请求操作系统内核的服务</p>
</li>
<li><p>注：Windows 操作系统向外提供的一系列系统调用，但是由于系统调用的格式严格，使用麻烦，因此在用户层上封装了一系列更方便的库函数接口供用户使用（Windows API）</p>
</li>
</ul>
</li>
<li><p>设备独立性软件（设备无关性软件）</p>
<ul>
<li><p>向上层提供统一的调用接口</p>
</li>
<li><p>设备的保护：不同用户对设备的访问权限不一样</p>
</li>
<li><p>差错处理：对一些设备的错误进行处理</p>
</li>
<li><p>设备的分配与回收</p>
</li>
<li><p>数据缓冲区管理：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异</p>
</li>
<li><p>建立逻辑设备名到物理设备名的映射关系：逻辑设备名&#x3D;设备类型</p>
<ul>
<li><p>用户或用户层软件发出I&#x2F;O操作系统调用的系统调用时，需要指明此次要操作的I&#x2F;O设备的逻辑设备名</p>
</li>
<li><p>设备独立性软件需要通过“逻辑设备表（LUT）”来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序</p>
</li>
<li><p>逻辑设备表（LUT）</p>
<ul>
<li><p>管理逻辑设备表（LUT）的两种方式</p>
<ul>
<li><p>整个系统只设置一张LUT</p>
<ul>
<li>所有用户不能使用相同的逻辑设备名，因此只适用于单用户操作系统</li>
</ul>
</li>
<li><p>为每个用户设置一张LUT</p>
<ul>
<li><p>各个用户使用的逻辑设备名可以重复，适用于多用户操作系统</p>
</li>
<li><p>系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>不同类型的I&#x2F;O设备需要有不同的驱动程序处理</p>
<ul>
<li>内部的电子部件（I&#x2F;O控制器）有可能不同</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注：没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的</p>
</li>
</ul>
</li>
<li><p>设备驱动程序</p>
<ul>
<li><p>与硬件直接相关，负责实现系统对设备发出的操作命令，驱动I&#x2F;0设备工作的驱动程序</p>
</li>
<li><p>主要负责对硬件设备的具体控制，将上层发出的一系列命令转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器；检查设备状态等</p>
</li>
<li><p>注：直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的</p>
</li>
</ul>
</li>
<li><p>中断处理程序</p>
<ul>
<li><p>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行</p>
</li>
<li><p>使用过程：</p>
<ul>
<li><p>用户通过调用用户层软件提供的库函数发出的I&#x2F;O请求</p>
</li>
<li><p>—&gt;用户层软件通过“系统调用”请求设备独立性软件层的服务</p>
</li>
<li><p>—&gt;设备独立性软件层根据LUT调用设备对应的驱动程序</p>
</li>
<li><p>—&gt;驱动程序向I&#x2F;O控制器发出具体命令</p>
</li>
<li><p>—&gt;等待I&#x2F;O完成的进程应该被阻塞，因此需要进程切换，而进程切换必然需要中断处理</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>硬件设备</p>
<ul>
<li>执行I&#x2F;O操作，I&#x2F;O设备通常包括一个机械部件和一个电子部件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="I-x2F-O核心子系统"><a href="#I-x2F-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h1><h2 id="I-x2F-O核心子系统-1"><a href="#I-x2F-O核心子系统-1" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h2><ul>
<li><p>包括的层次</p>
<ul>
<li><p>设备独立性软件</p>
<ul>
<li><p>I&#x2F;O调度</p>
<ul>
<li>用某种算法确定处理各个I&#x2F;O请求的顺序</li>
</ul>
</li>
<li><p>设备保护</p>
<ul>
<li><p>不同的用户对各个文件有不同的访问权限</p>
<ul>
<li><p>在UNIX系统中，设备被看做是一种特殊的文件，每个设备也会有对应的FCB</p>
</li>
<li><p>当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>假脱机（SPOOLing技术）：一般来说在用户层软件实现</p>
</li>
<li><p>设备分配与回收</p>
</li>
<li><p>缓冲区管理（缓冲与高速缓存）</p>
</li>
</ul>
</li>
<li><p>设备驱动程序</p>
</li>
<li><p>中断处理程序</p>
</li>
</ul>
</li>
</ul>
<h2 id="SPOOLING技术（假脱机技术）"><a href="#SPOOLING技术（假脱机技术）" class="headerlink" title="SPOOLING技术（假脱机技术）"></a>SPOOLING技术（假脱机技术）</h2><ul>
<li><p>目的</p>
<ul>
<li>缓解CPU与I&#x2F;O的速度差异矛盾</li>
</ul>
</li>
<li><p>是什么</p>
<ul>
<li><p>通俗解释：如果设备被占用，我们就先把数据暂存一下，等到设备空闲了就把这些数据输送到设备中</p>
<ul>
<li><p>即使CPU在忙碌，也可以提前将数据输入到磁带</p>
</li>
<li><p>即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带</p>
</li>
</ul>
</li>
<li><p>脱机：脱离主机的控制进行的输入&#x2F;输出操作</p>
</li>
<li><p>假脱机：用软件的方式模拟脱机技术</p>
</li>
</ul>
</li>
<li><p>实现原理</p>
<ul>
<li><p>输入井和输出井——在磁盘上</p>
<ul>
<li><p>输入井，模拟脱机输入时的磁带，用来收容I&#x2F;O设备的数据</p>
</li>
<li><p>输出井，模拟输出时的磁盘，用于收容用户进程输出的数据</p>
</li>
</ul>
</li>
<li><p>输入缓冲区和输出缓冲区——在内存上</p>
<ul>
<li><p>输入缓冲区：在输入进程的控制下，暂存由输入设备送来的数据</p>
</li>
<li><p>输出缓冲区：在输出进程的控制下，暂存从输出井送来的设备</p>
</li>
</ul>
</li>
<li><p>输入进程和输出进程</p>
<ul>
<li><p>输入进程：</p>
<ul>
<li><p>模拟脱机输入时的外围控制机</p>
</li>
<li><p>将用户要求的数据从输入设备通过输入缓冲区送到输入井中，当CPU空闲时，直接将输出井中的数据送入内存</p>
</li>
</ul>
</li>
<li><p>输出进程：</p>
<ul>
<li><p>模拟脱机输出时的外围控制机</p>
</li>
<li><p>把用户要求输出的数据先从内存送到输出井中，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注：要实现SPOOLing技术，必须要有多道程序技术的支持</p>
</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li><p>提高了I&#x2F;O速度</p>
</li>
<li><p>独占设备变成了共享设备</p>
</li>
<li><p>实现了虚拟设备功能</p>
</li>
</ul>
</li>
<li><p>共享打印机的原理分析</p>
<ul>
<li><p>设备分类</p>
<ul>
<li><p>独占设备：一个时段只能分配给一个进程（如打印机）</p>
</li>
<li><p>共享设备：可同时分配给多个进程使用（如磁盘），各进程往往是宏观上同时共享使用设备，而微观上交替使用</p>
</li>
<li><p>虚拟设备：采用SPOOLing技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机）</p>
</li>
</ul>
</li>
<li><p>假脱机管理进程为每个进程做的两件事：</p>
<ul>
<li><p>在磁盘输出井中为进程申请一个空闲缓冲区（在磁盘上的），并将要打印的数据送入其中</p>
</li>
<li><p>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（存放空闲缓冲区的地址，即用户打印数据存放位置），再将该表挂到假脱机文件队列上</p>
</li>
<li><p>注：</p>
<ul>
<li><p>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印</p>
</li>
<li><p>依次处理完全部的打印任务</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h2><ul>
<li><p>设备分配时应考虑的因素</p>
<ul>
<li><p>设备的具有属性</p>
<ul>
<li><p>独占式使用设备</p>
<ul>
<li>一个时段只能分配给一个进程（如打印机）</li>
</ul>
</li>
<li><p>分时共享使用设备</p>
<ul>
<li><p>可同时分配给多个进程使用（如磁盘）</p>
</li>
<li><p>各进程往往是宏观上同时共享使用设备，而微观上交替使用</p>
</li>
</ul>
</li>
<li><p>SPOOLing方式使用设备</p>
<ul>
<li>采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）</li>
</ul>
</li>
</ul>
</li>
<li><p>设备分配算法</p>
<ul>
<li><p>先来先服务</p>
</li>
<li><p>优先级高者优先</p>
</li>
<li><p>短任务优先</p>
</li>
</ul>
</li>
<li><p>设备分配中的安全性</p>
<ul>
<li><p>安全分配方式</p>
<ul>
<li><p>为进程分配一个设备后就将进程阻塞，本次I&#x2F;O完成后才将进程唤醒</p>
</li>
<li><p>即一个时段内每个进程只能使用一个设备</p>
</li>
<li><p>优点：破坏了“请求和保持”条件，不会死锁</p>
</li>
<li><p>缺点：CPU和I&#x2F;O设备串行工作</p>
</li>
</ul>
</li>
<li><p>不安全分配方式</p>
<ul>
<li><p>进程发出I&#x2F;O请求后，系统为其分配I&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求</p>
</li>
<li><p>只有某个I&#x2F;O请求得不到满足时才将进程阻塞</p>
</li>
<li><p>即一个进程可以同时使用多个设备</p>
</li>
<li><p>优点：进程的计算任务和I&#x2F;O任务可以并行处理，使进程迅速推进</p>
</li>
<li><p>缺点：可能产生死锁（需要使用死锁避免、死锁的检测和解除）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>静态分配与动态分配</p>
<ul>
<li><p>进程运行前为其分配全部所需资源，运行结束后归还资源</p>
<ul>
<li>破坏了“请求和保持”条件，不会发生死锁</li>
</ul>
</li>
<li><p>进程运行过程中动态申请设备资源</p>
</li>
</ul>
</li>
<li><p>设备分配管理中的数据结构</p>
<ul>
<li><p>通道、控制器、设备之间的关系：一个通道可控制多个设备控制器，每个设备控制器可控制多个设备</p>
</li>
<li><p>设备控制表（DCT）：系统为每个设备配置一张DCT，用于记录设备情况</p>
<ul>
<li><p>设备类型：打印机、扫描仪、键盘</p>
</li>
<li><p>设备标识符：即物理设备名，系统中的每个设备的物理设备名唯一</p>
</li>
<li><p>设备状态：忙碌&#x2F;空闲&#x2F;故障</p>
</li>
<li><p>指向控制器表的指针：每个设备由一个控制器控制，该指针可找到相应控制器的信息</p>
</li>
<li><p>重复执行次数或时间：当重复执行多次I&#x2F;O操作后仍不成功，才认为此次I&#x2F;O失败</p>
</li>
<li><p>设备队列的队首指针：指向正在等待该设备的进程队列（由进程PCB组成队列）</p>
<ul>
<li>阻塞原因不同，阻塞队列不同</li>
</ul>
</li>
</ul>
</li>
<li><p>控制器控制表（COCT）：每个设备控制器都会对应一张COCT，操作系统根据COCT的信息对控制器进行操作和管理</p>
<ul>
<li><p>通道标识符：各个控制器的唯一ID</p>
</li>
<li><p>通道状态：忙碌&#x2F;空闲&#x2F;故障</p>
</li>
<li><p>与通道连接的控制器表首址：可通过该指针找到该通道管理的所有控制器相关信息（COCT）</p>
</li>
<li><p>通道队列的队首指针：指向正在等待该通道的进程队列（由进程PCB组成队列）</p>
</li>
<li><p>通道队列的队尾指针：</p>
</li>
</ul>
</li>
<li><p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目</p>
<ul>
<li><p>表目：</p>
<ul>
<li><p>设备类型：打印机、扫描仪、键盘</p>
</li>
<li><p>设备标识符：即物理设备名</p>
</li>
<li><p>DCT（设备控制表）</p>
</li>
<li><p>驱动程序入口</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设备分配的步骤</p>
<ul>
<li><p>根据进程请求的物理设备名查找SDT（系统设备表）</p>
</li>
<li><p>根据SDT找到DCT（设备控制表）</p>
<ul>
<li><p>若设备忙碌则将进程PCB挂到设备等待队列中</p>
</li>
<li><p>不忙碌则将设备分配给进程</p>
</li>
</ul>
</li>
<li><p>根据DCT找到COCT（控制器控制表）</p>
<ul>
<li><p>若控制器忙碌则将进程PCB挂到控制器等待队列中</p>
</li>
<li><p>不忙碌则将控制器分配给进程</p>
</li>
</ul>
</li>
<li><p>根据COCT找到CHCT（通道控制表）</p>
<ul>
<li><p>若通道忙碌则将进程PCB挂到通道等待队列中</p>
</li>
<li><p>不忙碌则将通道分配给进程</p>
</li>
</ul>
</li>
<li><p>注：只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后便可启动I&#x2F;O设备进行数据传送</p>
</li>
</ul>
</li>
<li><p>设备分配步骤的改进方法</p>
<ul>
<li><p>缺点：使用物理设备名</p>
<ul>
<li><p>底层细节对用户不透明，不方便编程</p>
</li>
<li><p>若该物理设备更换，则程序无法运行</p>
</li>
<li><p>若进程请求的物理设备正在忙碌，无法请求同类型的设备</p>
</li>
</ul>
</li>
<li><p>改进：</p>
<ul>
<li><p>建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p>
</li>
<li><p>步骤：</p>
<ul>
<li><p>根据进程请求的逻辑设备名（设备类型）查找SDT（系统设备表）</p>
</li>
<li><p>查找SDT，找到用户进程指定类型的、并且空闲的设备的DCT，将其分配给该进程</p>
<ul>
<li><p>操作系统在逻辑设备表（LUT）中新增一个表项</p>
</li>
<li><p>逻辑设备表：</p>
<ul>
<li><p>建立了逻辑设备名与物理设备名之间的映射关系</p>
</li>
<li><p>若用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统直接查找LUT表（若查找到，不再需要查找SDT），即可将空闲的物理设备分配给该进程，并且也能知道该设备的驱动程序入口地址</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>根据DCT（设备控制表）找到COCT（控制器控制表）</p>
<ul>
<li><p>若控制器忙碌则将进程PCB挂到控制器等待队列中</p>
</li>
<li><p>不忙碌则将控制器分配给进程</p>
</li>
</ul>
</li>
<li><p>根据COCT找到CHCT（通道控制表）</p>
<ul>
<li><p>若通道忙碌则将进程PCB挂到通道等待队列中</p>
</li>
<li><p>不忙碌则将通道分配给进程</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="缓冲区管理（高速缓存与缓冲区）"><a href="#缓冲区管理（高速缓存与缓冲区）" class="headerlink" title="缓冲区管理（高速缓存与缓冲区）"></a>缓冲区管理（高速缓存与缓冲区）</h2><ul>
<li><p>缓冲区是什么</p>
<ul>
<li><p>一个存储区域</p>
</li>
<li><p>分类</p>
<ul>
<li><p>由专门的硬件寄存器组成</p>
<ul>
<li>成本较高，容量也较小，一般仅用在对速度要求非常高的场合</li>
</ul>
</li>
<li><p>利用内存作为缓冲区</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存区的作用</p>
<ul>
<li><p>缓和CPU与I&#x2F;O之间的速度差异矛盾</p>
<ul>
<li>CPU速度比I&#x2F;O速度快的多</li>
</ul>
</li>
<li><p>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</p>
<ul>
<li><p>没有缓存区：如果是字符型设备，每输出一个字符，就要向CPU发送一次中断信号</p>
</li>
<li><p>有缓冲区：每输出一块字符，才向CPU发送一次中断信号</p>
</li>
</ul>
</li>
<li><p>解决基本数据单元大小（数据粒度）不匹配的问题</p>
<ul>
<li>输出进程每次可以生成一块数据，I&#x2F;O设备每次只能输出一个字符</li>
</ul>
</li>
<li><p>提高CPU和I&#x2F;O设备之间的并行性</p>
<ul>
<li><p>CPU可以把要输出的数据快速地放入缓冲区，之后就可以做别的事</p>
</li>
<li><p>慢速的I&#x2F;O设备可以慢慢从缓冲区取走数据</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>单缓冲</p>
<ul>
<li><p>缓冲区只有一个，用户进程的工作区（在内存中）用于接收输入&#x2F;输出数据（一般也默认工作区大小与缓冲区相同）<img src="https://api2.mubu.com/v3/document_image/ed4c44d3-5177-4da8-b5ca-3ded661ed869-3224585.jpg" alt="img"></p>
</li>
<li><p>缓冲区的使用</p>
<ul>
<li><p>当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出</p>
</li>
<li><p>当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出</p>
</li>
</ul>
</li>
<li><p>题型：</p>
<ul>
<li><p>计算每处理一块数据平均需要多久？</p>
</li>
<li><p>技巧：</p>
<ul>
<li>假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均所需时间</li>
</ul>
</li>
<li><p>做法：假设初始状态为工作区满，缓冲区空</p>
</li>
<li><p>若T&gt;C，平均用时&#x3D; T+M</p>
<ul>
<li>CPU处理完数据后，需要等待缓冲区中冲满数据，然后将缓存区中的数据传送到工作区</li>
</ul>
</li>
<li><p>若T&lt;C，平均用时&#x3D; C+M</p>
<ul>
<li>缓冲区中冲满数据后，需要CPU处理完数据，然后将缓存区中的数据传送到工作区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>双缓冲</p>
<ul>
<li><p>缓冲区有两个</p>
</li>
<li><p>题型：</p>
<ul>
<li><p>计算每处理一块数据平均需要多久？</p>
</li>
<li><p>做法：假设工作区空，其中一个缓冲区满，另一个缓冲区空</p>
</li>
<li><p>若T&gt;C+M，平均用时&#x3D; T</p>
<ul>
<li>将满缓冲区1中的数据传送到工作区，同时开始向空缓冲区2中输入数据，缓冲区1中为空时，CPU处理数据，此时缓存区2仍未充满，直到T时，缓存区2才充满数据</li>
</ul>
</li>
<li><p>若T&lt;C+M，平均用时&#x3D; C+M，不适用假设</p>
<ul>
<li>CPU处理完一个缓冲区数据的时间（传输M+处理C）足够向另一个缓冲区输入数据，所以每处理一个数据块平均耗时C+M</li>
</ul>
</li>
</ul>
</li>
<li><p>单缓冲区和双缓冲区的区别</p>
<ul>
<li><p>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输</p>
<ul>
<li>A的缓冲区用于存放要发送的数据，B的缓冲区就只能存放要接收的数据</li>
</ul>
</li>
<li><p>若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输</p>
<ul>
<li>管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>循环缓冲</p>
<ul>
<li><p>将多个大小相等的缓冲区链接成一个循环队列</p>
<ul>
<li><p>橙色表示已充满数据的缓冲区，绿色表示空缓冲区</p>
</li>
<li><p>in 指针，指向第一个可以冲入数据的空缓冲区</p>
</li>
<li><p>out 指针，指向第一个可以取出数据的满缓冲区</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缓冲池</p>
<ul>
<li><p>由系统中共用的缓冲区组成</p>
</li>
<li><p>缓冲池中的缓冲区分类</p>
<ul>
<li><p>按使用状况分类</p>
<ul>
<li><p>空缓冲队列</p>
</li>
<li><p>输入队列：装满输入数据的缓冲队列</p>
</li>
<li><p>输出队列：装满输出数据的缓冲队列</p>
</li>
</ul>
</li>
<li><p>按功能分类</p>
<ul>
<li><p>hin</p>
<ul>
<li>用于收容输入数据的工作缓冲区</li>
</ul>
</li>
<li><p>sout</p>
<ul>
<li>用于提取输出数据的工作缓冲区</li>
</ul>
</li>
<li><p>sin</p>
<ul>
<li>用于提取输入数据的工作缓冲区</li>
</ul>
</li>
<li><p>hout</p>
<ul>
<li>用于收容输出数据的工作缓冲区</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程请求数据的过程</p>
<ul>
<li><p>输入进程请求输入数据</p>
<ul>
<li><p>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）</p>
</li>
<li><p>冲满数据后将缓冲区挂到输入队列队尾</p>
</li>
</ul>
</li>
<li><p>计算进程想要取得一块输入数据</p>
<ul>
<li><p>从输入队列中取得一块冲满输入数据的缓冲区作为“提取输入数据的工作缓冲区（sin）”</p>
</li>
<li><p>缓冲区读空后挂到空缓冲区队列</p>
</li>
</ul>
</li>
<li><p>计算进程想要将准备好的数据冲入缓冲区</p>
<ul>
<li><p>从空缓冲队列中取出一块作为“收容输出数据的工作缓冲区（hout）”</p>
</li>
<li><p>数据冲满后将缓冲区挂到输出队列队尾</p>
</li>
</ul>
</li>
<li><p>输出进程请求输出数据</p>
<ul>
<li><p>从输出队列中取得一块冲满输出数据的缓冲区作为“提取输出数据的工作缓冲区（sout）”</p>
</li>
<li><p>缓冲区读空后挂到空缓冲区队列</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>磁盘高速缓存</p>
<ul>
<li><p>使用磁盘高速缓存技术可以提高磁盘的I&#x2F;O速度，对高速缓存复制的访问要比原始数据访问更高效</p>
</li>
<li><p>磁盘高速缓存，逻辑上属于磁盘，物理上属于驻留在内存中的盘块</p>
</li>
<li><p>在内存中的两种形式</p>
<ul>
<li><p>在内存中开辟一个单独的存储空间作为磁盘高速缓存，大小固定</p>
</li>
<li><p>把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I&#x2F;O时共享</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>高速缓存与缓冲区对比</p>
<ul>
<li><p>相同点</p>
<ul>
<li>都介于高速设备和低速设备之间</li>
</ul>
</li>
<li><p>不同</p>
<ul>
<li><p>存放数据</p>
<ul>
<li><p>高速缓存：存放的是低速设备上的某些数据的复制数据</p>
</li>
<li><p>缓冲区：存放的是低速设备传递给高速设备的数据，这些数据在低速设备上不一定有备份，这些数据再从缓冲区传送到高速设备</p>
</li>
</ul>
</li>
<li><p>目的</p>
<ul>
<li><p>高速缓存：高速缓存存放的是高速设备经常要访问的数据，如高速缓存中数据不在，高速设备就要访问低速设备</p>
</li>
<li><p>高速设备和低速设备的通信都要经过缓冲区，高速设备永远不会去直接访问低速设备</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_4.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="prev" title="文件管理">
                  <i class="fa fa-chevron-left"></i> 文件管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_4.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" rel="next" title="计算机网络体系结构">
                  计算机网络体系结构 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
