<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="定义设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。 设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本Design Patterns的书。这四人也被称为四人帮（">
<meta property="og:type" content="article">
<meta property="og:title" content="6.设计模式">
<meta property="og:url" content="https://2673747024.github.io/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="定义设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。 设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本Design Patterns的书。这四人也被称为四人帮（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://2673747024.github.io/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l.jpeg">
<meta property="og:image" content="https://2673747024.github.io/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189618389718.png">
<meta property="og:image" content="https://2673747024.github.io/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189632185020.jpeg">
<meta property="og:image" content="https://2673747024.github.io/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189660629622.png">
<meta property="article:published_time" content="2022-02-04T14:30:57.834Z">
<meta property="article:modified_time" content="2022-02-05T06:07:41.158Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://2673747024.github.io/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l.jpeg">


<link rel="canonical" href="https://2673747024.github.io/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","path":"2022/02/04/4-Java_5.JavaEE进阶_6.设计模式/","title":"6.设计模式"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>6.设计模式 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99"><span class="nav-number">1.0.1.</span> <span class="nav-text">开闭原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="nav-number">1.0.2.</span> <span class="nav-text">里氏替换原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">创建型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.</span> <span class="nav-text">工厂方法模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82"><span class="nav-number">2.2.</span> <span class="nav-text">抽象工厂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E6%88%90%E5%99%A8-x2F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">生成器&#x2F;建造者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">原型模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.5.</span> <span class="nav-text">单例模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">适配器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">组合模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">装饰器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.5.</span> <span class="nav-text">外观模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">享元模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.7.</span> <span class="nav-text">代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%90%86"><span class="nav-number">3.7.1.</span> <span class="nav-text">远程代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E4%BB%A3%E7%90%86"><span class="nav-number">3.7.2.</span> <span class="nav-text">虚代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4%E4%BB%A3%E7%90%86"><span class="nav-number">3.7.3.</span> <span class="nav-text">保护代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%BC%95%E7%94%A8"><span class="nav-number">3.7.4.</span> <span class="nav-text">智能引用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">行为型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">责任链模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">命令模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">解释器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.4.</span> <span class="nav-text">迭代器模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.5.</span> <span class="nav-text">中介模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.6.</span> <span class="nav-text">备忘录模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.7.</span> <span class="nav-text">观察者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.8.</span> <span class="nav-text">状态模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.9.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E6%96%B9%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="nav-number">4.10.</span> <span class="nav-text">模式方法模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.11.</span> <span class="nav-text">3.11 访问者模式</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">112</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.设计模式
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-04 22:30:57" itemprop="dateCreated datePublished" datetime="2022-02-04T22:30:57+08:00">2022-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-05 14:07:41" itemprop="dateModified" datetime="2022-02-05T14:07:41+08:00">2022-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/5-JavaEE%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">5.JavaEE进阶</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/5-JavaEE%E8%BF%9B%E9%98%B6/6-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">6.设计模式</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：21.1k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈87 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p>
<p>设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Design_Patterns">Design Patterns</a>的书。这四人也被称为四人帮（GoF）。</p>
<p>为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：</p>
<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>由Bertrand Meyer提出的开闭原则（Open Closed Principle）是指，软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p>
<p>设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为创建型模式、结构型模式和行为型模式三类，我们后续会一一讲解。</p>
<p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性，并意识到设计模式也并不是万能的。</p>
<p><img src="/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l.jpeg" alt="designpatterns"></p>
<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>对象实例化的模式，创建型模式用于解耦对象的实例化过程</p>
<p>创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>
<p>创建型模式包括：</p>
<ul>
<li>工厂方法：Factory Method</li>
<li>抽象工厂：Abstract Factory</li>
<li>建造者：Builder</li>
<li>原型：Prototype</li>
<li>单例：Singleton</li>
</ul>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote>
<p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。</p>
</blockquote>
<p>工厂方法即Factory Method，是一种对象创建型模式。</p>
<p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│   Product   │      │   Factory   │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br><span class="line">       ▲                    ▲</span><br><span class="line">       │                    │</span><br><span class="line">┌─────────────┐      ┌─────────────┐</span><br><span class="line">│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │</span><br><span class="line">└─────────────┘      └─────────────┘</span><br></pre></td></tr></table></figure>

<p>我们以具体的例子来说：假设我们希望实现一个解析字符串到<code>Number</code>的<code>Factory</code>，可以定义如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NumberFactory</span> </span>&#123;</span><br><span class="line">    Number parse(<span class="keyword">String</span> s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了工厂接口，再编写一个工厂的实现类：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFactoryImpl</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">NumberFactory</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Number parse(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">BigDecimal</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而产品接口是<code>Number</code>，<code>NumberFactoryImpl</code>返回的实际产品是<code>BigDecimal</code>。</p>
<p>那么客户端如何创建<code>NumberFactoryImpl</code>呢？通常我们会在接口<code>Factory</code>中定义一个静态方法<code>getFactory()</code>来返回真正的子类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> NumberFactory &#123;</span><br><span class="line">    <span class="comment">// 创建方法:</span></span><br><span class="line">    <span class="built_in">Number</span> parse(<span class="built_in">String</span> s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取工厂实例:</span></span><br><span class="line">    <span class="keyword">static</span> NumberFactory <span class="function"><span class="title">getFactory</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> NumberFactory impl = <span class="keyword">new</span> NumberFactoryImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端中，我们只需要和工厂接口<code>NumberFactory</code>以及抽象产品<code>Number</code>打交道：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NumberFactory factory = <span class="module-access"><span class="module"><span class="identifier">NumberFactory</span>.</span></span>get<span class="constructor">Factory()</span>;</span><br><span class="line">Number result = factory.parse(<span class="string">&quot;123.456&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>调用方可以完全忽略真正的工厂<code>NumberFactoryImpl</code>和实际的产品<code>BigDecimal</code>，这样做的好处是允许创建产品的代码独立地变换，而不会影响到调用方。</p>
<p>有的童鞋会问：一个简单的<code>parse()</code>需要写这么复杂的工厂吗？实际上大多数情况下我们并不需要抽象工厂，而是通过静态方法直接返回产品，即：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">Number</span> <span class="function"><span class="title">parse</span>(<span class="params"><span class="built_in">String</span> s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种简化的使用静态方法创建产品的方式称为静态工厂方法（Static Factory Method）。静态工厂方法广泛地应用在Java标准库中。例如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="module-access"><span class="module"><span class="identifier">Integer</span>.</span></span>value<span class="constructor">Of(100)</span>;</span><br></pre></td></tr></table></figure>

<p><code>Integer</code>既是产品又是静态工厂。它提供了静态方法<code>valueOf()</code>来创建<code>Integer</code>。那么这种方式和直接写<code>new Integer(100)</code>有何区别呢？我们观察<code>valueOf()</code>方法：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final <span class="keyword">class</span> Integer &#123;</span><br><span class="line">    public static Integer value<span class="constructor">Of(<span class="params">int</span> <span class="params">i</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="module-access"><span class="module"><span class="identifier">IntegerCache</span>.</span></span>low<span class="operator"> &amp;&amp; </span>i &lt;= <span class="module-access"><span class="module"><span class="identifier">IntegerCache</span>.</span></span>high)</span><br><span class="line">            return <span class="module-access"><span class="module"><span class="identifier">IntegerCache</span>.</span></span>cache<span class="literal">[<span class="identifier">i</span> + (-I<span class="identifier">ntegerCache</span>.<span class="identifier">low</span>)]</span>;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">Integer(<span class="params">i</span>)</span>;</span><br><span class="line">    &#125;<span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>

<p>它的好处在于，<code>valueOf()</code>内部可能会使用<code>new</code>创建一个新的<code>Integer</code>实例，但也可能直接返回一个缓存的<code>Integer</code>实例。对于调用方来说，没必要知道<code>Integer</code>创建的细节。</p>
<p> 工厂方法可以隐藏创建产品的细节，且不一定每次都会真正创建产品，完全可以返回缓存的产品，从而提升速度并减少内存消耗。</p>
<p>如果调用方直接使用<code>Integer n = new Integer(100)</code>，那么就失去了使用缓存优化的可能性。</p>
<p>我们经常使用的另一个静态工厂方法是<code>List.of()</code>：</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span><span class="operator">&lt;</span><span class="built_in">String</span><span class="operator">&gt;</span> <span class="variable">list</span> <span class="operator">=</span> <span class="built_in">List</span><span class="operator">.</span><span class="variable">of</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span><span class="operator">,</span> <span class="string">&quot;B&quot;</span><span class="operator">,</span> <span class="string">&quot;C&quot;</span><span class="punctuation">)</span><span class="operator">;</span></span><br></pre></td></tr></table></figure>

<p>这个静态工厂方法接收可变参数，然后返回<code>List</code>接口。需要注意的是，调用方获取的产品总是<code>List</code>接口，而且并不关心它的实际类型。即使调用方知道<code>List</code>产品的实际类型是<code>java.util.ImmutableCollections$ListN</code>，也不要去强制转型为子类，因为静态工厂方法<code>List.of()</code>保证返回<code>List</code>，但也完全可以修改为返回<code>java.util.ArrayList</code>。这就是里氏替换原则：返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。</p>
<p> 总是引用接口而非实现类，能允许变换子类而不影响调用方，即尽可能面向抽象编程。</p>
<p>和<code>List.of()</code>类似，我们使用<code>MessageDigest</code>时，为了创建某个摘要算法，总是使用静态工厂方法<code>getInstance(String)</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageDigest md5 = <span class="module-access"><span class="module"><span class="identifier">MessageDigest</span>.</span></span>get<span class="constructor">Instance(<span class="string">&quot;MD5&quot;</span>)</span>;</span><br><span class="line">MessageDigest sha1 = <span class="module-access"><span class="module"><span class="identifier">MessageDigest</span>.</span></span>get<span class="constructor">Instance(<span class="string">&quot;SHA-1&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>调用方通过产品名称获得产品实例，不但调用简单，而且获得的引用仍然是<code>MessageDigest</code>这个抽象类。</p>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
</blockquote>
<p>抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。</p>
<p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                                ┌────────┐</span><br><span class="line">                             ─ &gt;│ProductA│</span><br><span class="line">┌────────┐    ┌─────────┐   │   └────────┘</span><br><span class="line">│ Client │─ ─&gt;│ Factory │─ ─</span><br><span class="line">└────────┘    └─────────┘   │   ┌────────┐</span><br><span class="line">                   ▲         ─ &gt;│ProductB│</span><br><span class="line">           ┌───────┴───────┐    └────────┘</span><br><span class="line">           │               │</span><br><span class="line">      ┌─────────┐     ┌─────────┐</span><br><span class="line">      │Factory1 │     │Factory2 │</span><br><span class="line">      └─────────┘     └─────────┘</span><br><span class="line">           │   ┌─────────┐ │   ┌─────────┐</span><br><span class="line">            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│</span><br><span class="line">           │   └─────────┘ │   └─────────┘</span><br><span class="line">               ┌─────────┐     ┌─────────┐</span><br><span class="line">           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│</span><br><span class="line">               └─────────┘     └─────────┘</span><br></pre></td></tr></table></figure>

<p>这种模式有点类似于多个供应商负责提供一系列类型的产品。我们举个例子：</p>
<p>假设我们希望为用户提供一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MarkDown">Markdown</a>文本转换为HTML和Word的服务，它的接口定义如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface AbstractFactory &#123;</span><br><span class="line">    <span class="comment">// 创建Html文档:</span></span><br><span class="line">    <span class="function">HtmlDocument <span class="title">createHtml</span><span class="params">(<span class="keyword">String</span> md)</span></span>;</span><br><span class="line">    <span class="comment">// 创建Word文档:</span></span><br><span class="line">    <span class="function">WordDocument <span class="title">createWord</span><span class="params">(<span class="keyword">String</span> md)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面的抽象工厂仅仅是一个接口，没有任何代码。同样的，因为<code>HtmlDocument</code>和<code>WordDocument</code>都比较复杂，现在我们并不知道如何实现它们，所以只有接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Html文档接口:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HtmlDocument</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">toHtml</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Word文档接口:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WordDocument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就定义好了抽象工厂（<code>AbstractFactory</code>）以及两个抽象产品（<code>HtmlDocument</code>和<code>WordDocument</code>）。因为实现它们比较困难，我们决定让供应商来完成。</p>
<p>现在市场上有两家供应商：FastDoc Soft的产品便宜，并且转换速度快，而GoodDoc Soft的产品贵，但转换效果好。我们决定同时使用这两家供应商的产品，以便给免费用户和付费用户提供不同的服务。</p>
<p>我们先看看FastDoc Soft的产品是如何实现的。首先，FastDoc Soft必须要有实际的产品，即<code>FastHtmlDocument</code>和<code>FastWordDocument</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastHtmlDocument</span> <span class="keyword">implements</span> <span class="title">HtmlDocument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHtml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastWordDocument</span> <span class="keyword">implements</span> <span class="title">WordDocument</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，FastDoc Soft必须提供一个实际的工厂来生产这两种产品，即<code>FastFactory</code>：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">AbstractFactory</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HtmlDocument createHtml(<span class="keyword">String</span> md) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FastHtmlDocument</span>(md);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> WordDocument createWord(<span class="keyword">String</span> md) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FastWordDocument</span>(md);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就可以使用FastDoc Soft的服务了。客户端编写代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建AbstractFactory，实际类型是FastFactory:</span></span><br><span class="line">AbstractFactory factory = <span class="keyword">new</span> <span class="constructor">FastFactory()</span>;</span><br><span class="line"><span class="comment">// 生成Html文档:</span></span><br><span class="line">HtmlDocument html = factory.create<span class="constructor">Html(<span class="string">&quot;#Hello\nHello, world!&quot;</span>)</span>;</span><br><span class="line">html.save(<span class="module-access"><span class="module"><span class="identifier">Paths</span>.</span></span>get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;fast.html&quot;</span>));</span><br><span class="line"><span class="comment">// 生成Word文档:</span></span><br><span class="line">WordDocument word = factory.create<span class="constructor">Word(<span class="string">&quot;#Hello\nHello, world!&quot;</span>)</span>;</span><br><span class="line">word.save(<span class="module-access"><span class="module"><span class="identifier">Paths</span>.</span></span>get(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;fast.doc&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>如果我们要同时使用GoodDoc Soft的服务怎么办？因为用了抽象工厂模式，GoodDoc Soft只需要根据我们定义的抽象工厂和抽象产品接口，实现自己的实际工厂和实际产品即可：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际工厂:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodFactory</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">AbstractFactory</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HtmlDocument createHtml(<span class="keyword">String</span> md) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">GoodHtmlDocument</span>(md);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> WordDocument createWord(<span class="keyword">String</span> md) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">GoodWordDocument</span>(md);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际产品:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodHtmlDocument</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">HtmlDocument</span></span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodWordDocument</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">HtmlDocument</span></span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端要使用GoodDoc Soft的服务，只需要把原来的<code>new FastFactory()</code>切换为<code>new GoodFactory()</code>即可。</p>
<p>注意到客户端代码除了通过<code>new</code>创建了<code>FastFactory</code>或<code>GoodFactory</code>外，其余代码只引用了产品接口，并未引用任何实际产品（例如，<code>FastHtmlDocument</code>），如果把创建工厂的代码放到<code>AbstractFactory</code>中，就可以连实际工厂也屏蔽了：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory createFactory(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">&quot;fast&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">FastFactory</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equalsIgnoreCase(<span class="string">&quot;good&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">GoodFactory</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;Invalid factory name&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看看<code>FastFactory</code>和<code>GoodFactory</code>创建的<code>WordDocument</code>的实际效果：</p>
<p><img src="/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189618389718.png" alt="worddoc"></p>
<p>注意：出于简化代码的目的，我们只支持两种Markdown语法：以<code>#</code>开头的标题以及普通正文。</p>
<h2 id="生成器-x2F-建造者模式"><a href="#生成器-x2F-建造者模式" class="headerlink" title="生成器&#x2F;建造者模式"></a>生成器&#x2F;建造者模式</h2><blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<p>我们仍然以Markdown转HTML为例，因为直接编写一个完整的转换器比较困难，但如果针对类似下面的一行文本：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">this</span> <span class="keyword">is</span> a heading</span><br></pre></td></tr></table></figure>

<p>转换成HTML就很简单：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span>&gt;this is <span class="selector-tag">a</span> heading&lt;/<span class="selector-tag">h1</span>&gt;</span><br></pre></td></tr></table></figure>

<p>因此，我们把Markdown转HTML看作一行一行的转换，每一行根据语法，使用不同的转换器：</p>
<ul>
<li>如果以<code>#</code>开头，使用<code>HeadingBuilder</code>转换；</li>
<li>如果以<code>&gt;</code>开头，使用<code>QuoteBuilder</code>转换；</li>
<li>如果以<code>---</code>开头，使用<code>HrBuilder</code>转换；</li>
<li>其余使用<code>ParagraphBuilder</code>转换。</li>
</ul>
<p>这个<code>HtmlBuilder</code>写出来如下：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlBuilder</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> HeadingBuilder headingBuilder = <span class="keyword">new</span> <span class="built_in">HeadingBuilder</span>();</span><br><span class="line">    <span class="keyword">private</span> HrBuilder hrBuilder = <span class="keyword">new</span> <span class="built_in">HrBuilder</span>();</span><br><span class="line">    <span class="keyword">private</span> ParagraphBuilder paragraphBuilder = <span class="keyword">new</span> <span class="built_in">ParagraphBuilder</span>();</span><br><span class="line">    <span class="keyword">private</span> QuoteBuilder quoteBuilder = <span class="keyword">new</span> <span class="built_in">QuoteBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toHtml</span><span class="params">(<span class="keyword">String</span> markdown)</span> </span>&#123;</span><br><span class="line">        StringBuilder buffer = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line">        markdown.<span class="built_in">lines</span>().forEach(line -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.<span class="built_in">startsWith</span>(<span class="string">&quot;#&quot;</span>)) &#123;</span><br><span class="line">                buffer.<span class="built_in">append</span>(headingBuilder.<span class="built_in">buildHeading</span>(line)).<span class="built_in">append</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">startsWith</span>(<span class="string">&quot;&gt;&quot;</span>)) &#123;</span><br><span class="line">                buffer.<span class="built_in">append</span>(quoteBuilder.<span class="built_in">buildQuote</span>(line)).<span class="built_in">append</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.<span class="built_in">startsWith</span>(<span class="string">&quot;---&quot;</span>)) &#123;</span><br><span class="line">                buffer.<span class="built_in">append</span>(hrBuilder.<span class="built_in">buildHr</span>(line)).<span class="built_in">append</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buffer.<span class="built_in">append</span>(paragraphBuilder.<span class="built_in">buildParagraph</span>(line)).<span class="built_in">append</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> buffer.<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意观察上述代码，<code>HtmlBuilder</code>并不是一次性把整个Markdown转换为HTML，而是一行一行转换，并且，它自己并不会将某一行转换为特定的HTML，而是根据特性把每一行都“委托”给一个<code>XxxBuilder</code>去转换，最后，把所有转换的结果组合起来，返回给客户端。</p>
<p>这样一来，我们只需要针对每一种类型编写不同的Builder。例如，针对以<code>#</code>开头的行，需要<code>HeadingBuilder</code>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadingBuilder</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">buildHeading</span><span class="params">(<span class="keyword">String</span> line)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (line.<span class="built_in">charAt</span>(<span class="number">0</span>) == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            n++;</span><br><span class="line">            line = line.<span class="built_in">substring</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">String</span>.format(<span class="string">&quot;&lt;h%d&gt;%s&lt;/h%d&gt;&quot;</span>, n, line.<span class="built_in">strip</span>(), n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 注意：实际解析Markdown是带有状态的，即下一行的语义可能与上一行相关。这里我们简化了语法，把每一行视为可以独立转换。</p>
<p>可见，使用Builder模式时，适用于创建的对象比较复杂，最好一步一步创建出“零件”，最后再装配起来。</p>
<p>JavaMail的<code>MimeMessage</code>就可以看作是一个Builder模式，只不过Builder和最终产品合二为一，都是<code>MimeMessage</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Multipart multipart = <span class="keyword">new</span> <span class="constructor">MimeMultipart()</span>;</span><br><span class="line"><span class="comment">// 添加text:</span></span><br><span class="line">BodyPart textpart = <span class="keyword">new</span> <span class="constructor">MimeBodyPart()</span>;</span><br><span class="line">textpart.set<span class="constructor">Content(<span class="params">body</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>)</span>;</span><br><span class="line">multipart.add<span class="constructor">BodyPart(<span class="params">textpart</span>)</span>;</span><br><span class="line"><span class="comment">// 添加image:</span></span><br><span class="line">BodyPart imagepart = <span class="keyword">new</span> <span class="constructor">MimeBodyPart()</span>;</span><br><span class="line">imagepart.set<span class="constructor">FileName(<span class="params">fileName</span>)</span>;</span><br><span class="line">imagepart.set<span class="constructor">DataHandler(<span class="params">new</span> DataHandler(<span class="params">new</span> ByteArrayDataSource(<span class="params">input</span>, <span class="string">&quot;application/octet-stream&quot;</span>)</span>));</span><br><span class="line">multipart.add<span class="constructor">BodyPart(<span class="params">imagepart</span>)</span>;</span><br><span class="line"></span><br><span class="line">MimeMessage message = <span class="keyword">new</span> <span class="constructor">MimeMessage(<span class="params">session</span>)</span>;</span><br><span class="line"><span class="comment">// 设置发送方地址:</span></span><br><span class="line">message.set<span class="constructor">From(<span class="params">new</span> InternetAddress(<span class="string">&quot;me@example.com&quot;</span>)</span>);</span><br><span class="line"><span class="comment">// 设置接收方地址:</span></span><br><span class="line">message.set<span class="constructor">Recipient(Message.RecipientType.TO, <span class="params">new</span> InternetAddress(<span class="string">&quot;xiaoming@somewhere.com&quot;</span>)</span>);</span><br><span class="line"><span class="comment">// 设置邮件主题:</span></span><br><span class="line">message.set<span class="constructor">Subject(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line"><span class="comment">// 设置邮件内容为multipart:</span></span><br><span class="line">message.set<span class="constructor">Content(<span class="params">multipart</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>很多时候，我们可以简化Builder模式，以链式调用的方式来创建对象。例如，我们经常编写这样的代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">builder.<span class="built_in">append</span>(secure ? <span class="string">&quot;https://&quot;</span> : <span class="string">&quot;http://&quot;</span>)</span><br><span class="line">       .<span class="built_in">append</span>(<span class="string">&quot;www.liaoxuefeng.com&quot;</span>)</span><br><span class="line">       .<span class="built_in">append</span>(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">       .<span class="built_in">append</span>(<span class="string">&quot;?t=0&quot;</span>);</span><br><span class="line"><span class="keyword">String</span> url = builder.toString();</span><br></pre></td></tr></table></figure>

<p>由于我们经常需要构造URL字符串，可以使用Builder模式编写一个URLBuilder，调用方式如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String url = <span class="module-access"><span class="module"><span class="identifier">URLBuilder</span>.</span></span>builder<span class="literal">()</span> <span class="comment">// 创建Builder</span></span><br><span class="line">        .set<span class="constructor">Domain(<span class="string">&quot;www.liaoxuefeng.com&quot;</span>)</span> <span class="comment">// 设置domain</span></span><br><span class="line">        .set<span class="constructor">Scheme(<span class="string">&quot;https&quot;</span>)</span> <span class="comment">// 设置scheme</span></span><br><span class="line">        .set<span class="constructor">Path(<span class="string">&quot;/&quot;</span>)</span> <span class="comment">// 设置路径</span></span><br><span class="line">        .set<span class="constructor">Query(Map.<span class="params">of</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;K&amp;R&quot;</span>)</span>) <span class="comment">// 设置query</span></span><br><span class="line">        .build<span class="literal">()</span>; <span class="comment">// 完成build</span></span><br></pre></td></tr></table></figure>

<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><blockquote>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
</blockquote>
<p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p>
<p>我们举个例子：如果我们已经有了一个<code>String[]</code>数组，想再创建一个一模一样的<code>String[]</code>数组，怎么写？</p>
<p>实际上创建过程很简单，就是把现有数组的元素复制到新数组。如果我们把这个创建过程封装一下，就成了原型模式。用代码实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型:</span></span><br><span class="line">String<span class="literal">[]</span> original = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Banana&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 新对象:</span></span><br><span class="line">String<span class="literal">[]</span> copy = <span class="module-access"><span class="module"><span class="identifier">Arrays</span>.</span></span>copy<span class="constructor">Of(<span class="params">original</span>, <span class="params">original</span>.<span class="params">length</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>对于普通类，我们如何实现原型拷贝？Java的<code>Object</code>提供了一个<code>clone()</code>方法，它的意图就是复制一个新的对象出来，我们需要实现一个<code>Cloneable</code>接口来标识一个对象是“可复制”的：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="title">implements</span> <span class="title">Cloneable</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制新对象并返回:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student std = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">        std.id = <span class="keyword">this</span>.id;</span><br><span class="line">        std.name = <span class="keyword">this</span>.name;</span><br><span class="line">        std.score = <span class="keyword">this</span>.score;</span><br><span class="line">        <span class="keyword">return</span> std;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，因为<code>clone()</code>的方法签名是定义在<code>Object</code>中，返回类型也是<code>Object</code>，所以要强制转型，比较麻烦：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Student std1 = <span class="keyword">new</span> <span class="constructor">Student()</span>;</span><br><span class="line">std1.set<span class="constructor">Id(123)</span>;</span><br><span class="line">std1.set<span class="constructor">Name(<span class="string">&quot;Bob&quot;</span>)</span>;</span><br><span class="line">std1.set<span class="constructor">Score(88)</span>;</span><br><span class="line"><span class="comment">// 复制新对象:</span></span><br><span class="line">Student std2 = (Student) std1.clone<span class="literal">()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(std1);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(std2);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(std1<span class="operator"> == </span>std2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>实际上，使用原型模式更好的方式是定义一个<code>copy()</code>方法，返回明确的类型：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student std = <span class="keyword">new</span> <span class="built_in">Student</span>();</span><br><span class="line">        std.id = <span class="keyword">this</span>.id;</span><br><span class="line">        std.name = <span class="keyword">this</span>.name;</span><br><span class="line">        std.score = <span class="keyword">this</span>.score;</span><br><span class="line">        <span class="keyword">return</span> std;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原型模式应用不是很广泛，因为很多实例会持有类似文件、Socket这样的资源，而这些资源是无法复制给另一个对象共享的，只有存储简单类型的“值”对象可以复制。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
</blockquote>
<p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p>
<p>因为这个类只有一个实例，因此，自然不能让调用方使用<code>new Xyz()</code>来创建实例了。所以，单例的构造方法必须是<code>private</code>，这样就防止了调用方自己创建实例，但是在类的内部，是可以用一个静态字段来引用唯一创建的实例的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，外部调用方如何获得这个唯一实例？</p>
<p>答案是提供一个静态方法，直接返回实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过静态方法返回实例:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接把<code>static</code>变量暴露给外部：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态字段引用唯一实例:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private构造方法保证外部无法实例化:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，单例模式的实现方式很简单：</p>
<ol>
<li>只有<code>private</code>构造方法，确保外部无法实例化；</li>
<li>通过<code>private static</code>变量持有唯一实例，保证全局唯一性；</li>
<li>通过<code>public static</code>方法返回此唯一实例，使外部调用方能获取到实例。</li>
</ol>
<p>Java标准库有一些类就是单例，例如<code>Runtime</code>这个类：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Runtime</span> <span class="keyword">runtime</span> = <span class="keyword">Runtime</span>.getRuntime();</span><br></pre></td></tr></table></figure>

<p>有些童鞋可能听说过延迟加载，即在调用方第一次调用<code>getInstance()</code>时才初始化全局唯一实例，类似这样：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="function"><span class="title">getInstance</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="title">Singleton</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗憾的是，这种写法在多线程中是错误的，在竞争条件下会创建出多个实例。必须对整个方法进行加锁：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但加锁会严重影响并发性能。还有些童鞋听说过双重检查，类似这样：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，由于Java的内存模型，双重检查在这里不成立。要真正实现延迟加载，只能通过Java的ClassLoader机制完成。如果没有特殊的需求，使用Singleton模式的时候，最好不要延迟加载，这样会使代码更简单。</p>
<p>另一种实现Singleton的方式是利用Java的<code>enum</code>，因为Java保证枚举类的每个枚举都是单例，所以我们只需要编写一个只有一个枚举的类即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> World &#123;</span><br><span class="line">    <span class="comment">// 唯一枚举:</span></span><br><span class="line">	INSTANCE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">String</span> name = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">setName</span>(<span class="params"><span class="built_in">String</span> name</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类也完全可以像其他类那样定义自己的字段、方法，这样上面这个<code>World</code>类在调用方看来就可以这么用：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="module-access"><span class="module"><span class="identifier">World</span>.</span><span class="module"><span class="identifier">INSTANCE</span>.</span></span>get<span class="constructor">Name()</span>;</span><br></pre></td></tr></table></figure>

<p>使用枚举实现Singleton还避免了第一种方式实现Singleton的一个潜在问题：即序列化和反序列化会绕过普通类的<code>private</code>构造方法从而创建出多个实例，而枚举类就没有这个问题。</p>
<p>那我们什么时候应该用Singleton呢？实际上，很多程序，尤其是Web程序，大部分服务类都应该被视作Singleton，如果全部按Singleton的写法写，会非常麻烦，所以，通常是通过约定让框架（例如Spring）来实例化这些类，保证只有一个实例，调用方自觉通过框架获取实例而不是<code>new</code>操作符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 表示一个单例组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，除非确有必要，否则Singleton模式一般以“约定”为主，不会刻意实现它。</p>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>把类或对象结合在一起形成一个更大的结构</p>
<p>结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p>
<p>结构型模式有：</p>
<ul>
<li>适配器</li>
<li>桥接</li>
<li>组合</li>
<li>装饰器</li>
<li>外观</li>
<li>享元</li>
<li>代理</li>
</ul>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</blockquote>
<p>适配器模式是Adapter，也称Wrapper，是指如果一个接口需要B接口，但是待传入的对象却是A接口，怎么办？</p>
<p>我们举个例子。如果去美国，我们随身带的电器是无法直接使用的，因为美国的插座标准和中国不同，所以，我们需要一个适配器：</p>
<p><img src="/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189632185020.jpeg" alt="adapter"></p>
<p>在程序设计中，适配器也是类似的。我们已经有一个<code>Task</code>类，实现了<code>Callable</code>接口：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="keyword">Task</span> <span class="keyword">implements</span> Callable&lt;<span class="keyword">Long</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> num;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Task</span>(<span class="keyword">long</span> num) &#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Long</span> <span class="keyword">call</span>() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> n = <span class="number">1</span>; n &lt;= <span class="keyword">this</span>.num; n++) &#123;</span><br><span class="line">            r = r + n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">&quot;Result: &quot;</span> + r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们想通过一个线程去执行它：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Long&gt; callable = <span class="literal">new</span> Task(<span class="number">123450000</span>L);</span><br><span class="line"><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="literal">new</span> <span class="keyword">Thread</span>(callable); <span class="comment">// compile error!</span></span><br><span class="line"><span class="keyword">thread</span>.start();</span><br></pre></td></tr></table></figure>

<p>发现编译不过！因为<code>Thread</code>接收<code>Runnable</code>接口，但不接收<code>Callable</code>接口，肿么办？</p>
<p>一个办法是改写<code>Task</code>类，把实现的<code>Callable</code>改为<code>Runnable</code>，但这样做不好，因为<code>Task</code>很可能在其他地方作为<code>Callable</code>被引用，改写<code>Task</code>的接口，会导致其他正常工作的代码无法编译。</p>
<p>另一个办法不用改写<code>Task</code>类，而是用一个Adapter，把这个<code>Callable</code>接口“变成”<code>Runnable</code>接口，这样，就可以正常编译：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Long&gt; callable = <span class="keyword">new</span> Task(<span class="number">123450000</span>L)<span class="comment">;</span></span><br><span class="line"><span class="keyword">Thread</span> <span class="keyword">thread</span> = <span class="keyword">new</span> <span class="keyword">Thread</span>(<span class="keyword">new</span> RunnableAdapter(callable))<span class="comment">;</span></span><br><span class="line"><span class="keyword">thread</span>.start()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这个<code>RunnableAdapter</code>类就是Adapter，它接收一个<code>Callable</code>，输出一个<code>Runnable</code>。怎么实现这个<code>RunnableAdapter</code>呢？我们先看完整的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用待转换接口:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">Callable</span><span class="meta">&lt;?</span>&gt; <span class="keyword">callable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RunnableAdapter(<span class="keyword">Callable</span><span class="meta">&lt;?</span>&gt; <span class="keyword">callable</span>) &#123;</span><br><span class="line">        this.<span class="keyword">callable</span> = <span class="keyword">callable</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现指定接口:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">        <span class="comment">// 将指定接口调用委托给转换接口调用:</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">callable</span>.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="built_in">Exception</span> e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写一个Adapter的步骤如下：</p>
<ol>
<li>实现目标接口，这里是<code>Runnable</code>；</li>
<li>内部持有一个待转换接口的引用，这里是通过字段持有<code>Callable</code>接口；</li>
<li>在目标接口的实现方法内部，调用待转换接口的方法。</li>
</ol>
<p>这样一来，Thread就可以接收这个<code>RunnableAdapter</code>，因为它实现了<code>Runnable</code>接口。<code>Thread</code>作为调用方，它会调用<code>RunnableAdapter</code>的<code>run()</code>方法，在这个<code>run()</code>方法内部，又调用了<code>Callable</code>的<code>call()</code>方法，相当于<code>Thread</code>通过一层转换，间接调用了<code>Callable</code>的<code>call()</code>方法。</p>
<p>适配器模式在Java标准库中有广泛应用。比如我们持有数据类型是<code>String[]</code>，但是需要<code>List</code>接口时，可以用一个Adapter：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>[] exist = <span class="keyword">new</span> <span class="built_in">String</span>[] &#123;<span class="string">&quot;Good&quot;</span>, <span class="string">&quot;morning&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;and&quot;</span>, <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; <span class="keyword">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(exist));</span><br></pre></td></tr></table></figure>

<p>注意到<code>List&lt;T&gt; Arrays.asList(T[])</code>就相当于一个转换器，它可以把数组转换为<code>List</code>。</p>
<p>我们再看一个例子：假设我们持有一个<code>InputStream</code>，希望调用<code>readText(Reader)</code>方法，但它的参数类型是<code>Reader</code>而不是<code>InputStream</code>，怎么办？</p>
<p>当然是使用适配器，把<code>InputStream</code>“变成”<code>Reader</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="module-access"><span class="module"><span class="identifier">Files</span>.</span></span><span class="keyword">new</span><span class="constructor">InputStream(Paths.<span class="params">get</span>(<span class="string">&quot;/path/to/file&quot;</span>)</span>);</span><br><span class="line">Reader reader = <span class="keyword">new</span> <span class="constructor">InputStreamReader(<span class="params">input</span>, <span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">read<span class="constructor">Text(<span class="params">reader</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><code>InputStreamReader</code>就是Java标准库提供的<code>Adapter</code>，它负责把一个<code>InputStream</code>适配为<code>Reader</code>。类似的还有<code>OutputStreamWriter</code>。</p>
<p>如果我们把<code>readText(Reader)</code>方法参数从<code>Reader</code>改为<code>FileReader</code>，会有什么问题？这个时候，因为我们需要一个<code>FileReader</code>类型，就必须把<code>InputStream</code>适配为<code>FileReader</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileReader reader = <span class="keyword">new</span> <span class="constructor">InputStreamReader(<span class="params">input</span>, <span class="string">&quot;UTF-8&quot;</span>)</span>; <span class="comment">// compile error!</span></span><br></pre></td></tr></table></figure>

<p>直接使用<code>InputStreamReader</code>这个Adapter是不行的，因为它只能转换出<code>Reader</code>接口。事实上，要把<code>InputStream</code>转换为<code>FileReader</code>也不是不可能，但需要花费十倍以上的功夫。这时，面向抽象编程这一原则就体现出了威力：持有高层接口不但代码更灵活，而且把各种接口组合起来也更容易。一旦持有某个具体的子类类型，要想做一些改动就非常困难。</p>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
</blockquote>
<p>桥接模式的定义非常玄乎，直接理解不太容易，所以我们还是举例子。</p>
<p>假设某个汽车厂商生产三种品牌的汽车：Big、Tiny和Boss，每种品牌又可以选择燃油、纯电和混合动力。如果用传统的继承来表示各个最终车型，一共有3个抽象类加9个最终子类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                   ┌───────┐</span><br><span class="line">                   │  Car  │</span><br><span class="line">                   └───────┘</span><br><span class="line">                       ▲</span><br><span class="line">    ┌──────────────────┼───────────────────┐</span><br><span class="line">    │                  │                   │</span><br><span class="line">┌───────┐          ┌───────┐          ┌───────┐</span><br><span class="line">│BigCar │          │TinyCar│          │BossCar│</span><br><span class="line">└───────┘          └───────┘          └───────┘</span><br><span class="line">    ▲                  ▲                  ▲</span><br><span class="line">    │                  │                  │</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    ├─│  BigFuelCar   │├─│  TinyFuelCar  │├─│  BossFuelCar  │</span><br><span class="line">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    ├─│BigElectricCar │├─│TinyElectricCar│├─│BossElectricCar│</span><br><span class="line">    │ └───────────────┘│ └───────────────┘│ └───────────────┘</span><br><span class="line">    │ ┌───────────────┐│ ┌───────────────┐│ ┌───────────────┐</span><br><span class="line">    └─│ BigHybridCar  │└─│ TinyHybridCar │└─│ BossHybridCar │</span><br><span class="line">      └───────────────┘  └───────────────┘  └───────────────┘</span><br></pre></td></tr></table></figure>

<p>如果要新增一个品牌，或者加一个新的引擎（比如核动力），那么子类的数量增长更快。</p>
<p>所以，桥接模式就是为了避免直接继承带来的子类爆炸。</p>
<p>我们来看看桥接模式如何解决上述问题。</p>
<p>在桥接模式中，首先把<code>Car</code>按品牌进行子类化，但是，每个品牌选择什么发动机，不再使用子类扩充，而是通过一个抽象的“修正”类，以组合的形式引入。我们来看看具体的实现。</p>
<p>首先定义抽象类<code>Car</code>，它引用一个<code>Engine</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用Engine:</span></span><br><span class="line">    <span class="keyword">protected</span> Engine engine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Engine</code>的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Engine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着，在一个“修正”的抽象类<code>RefinedCar</code>中定义一些额外操作：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedCar</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    public <span class="type">RefinedCar</span>(<span class="type">Engine</span> engine) &#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void drive() &#123;</span><br><span class="line">        <span class="keyword">this</span>.engine.start();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;Drive &quot;</span> + getBrand() + <span class="string">&quot; car...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">abstract</span> <span class="type">String</span> getBrand();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，最终的不同品牌继承自<code>RefinedCar</code>，例如<code>BossCar</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BossCar</span> <span class="keyword">extends</span> <span class="title">RefinedCar</span> </span>&#123;</span><br><span class="line">    public <span class="type">BossCar</span>(<span class="type">Engine</span> engine) &#123;</span><br><span class="line">        <span class="keyword">super</span>(engine);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">String</span> getBrand() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Boss&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而针对每一种引擎，继承自<code>Engine</code>，例如<code>HybridEngine</code>：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">HybridEngine</span> <span class="symbol">implements</span> <span class="symbol">Engine</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> start() &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;Start Hybrid Engine...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端通过自己选择一个品牌，再配合一种引擎，得到最终的Car：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RefinedCar car = <span class="keyword">new</span> <span class="type">BossCar</span>(<span class="keyword">new</span> <span class="type">HybridEngine</span>());</span><br><span class="line">car.drive();</span><br></pre></td></tr></table></figure>

<p>使用桥接模式的好处在于，如果要增加一种引擎，只需要针对<code>Engine</code>派生一个新的子类，如果要增加一个品牌，只需要针对<code>RefinedCar</code>派生一个子类，任何<code>RefinedCar</code>的子类都可以和任何一种<code>Engine</code>自由组合，即一辆汽车的两个维度：品牌和引擎都可以独立地变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">       ┌───────────┐</span><br><span class="line">       │    Car    │</span><br><span class="line">       └───────────┘</span><br><span class="line">             ▲</span><br><span class="line">             │</span><br><span class="line">       ┌───────────┐       ┌─────────┐</span><br><span class="line">       │RefinedCar │ ─ ─ ─&gt;│ Engine  │</span><br><span class="line">       └───────────┘       └─────────┘</span><br><span class="line">             ▲                  ▲</span><br><span class="line">    ┌────────┼────────┐         │ ┌──────────────┐</span><br><span class="line">    │        │        │         ├─│  FuelEngine  │</span><br><span class="line">┌───────┐┌───────┐┌───────┐     │ └──────────────┘</span><br><span class="line">│BigCar ││TinyCar││BossCar│     │ ┌──────────────┐</span><br><span class="line">└───────┘└───────┘└───────┘     ├─│ElectricEngine│</span><br><span class="line">                                │ └──────────────┘</span><br><span class="line">                                │ ┌──────────────┐</span><br><span class="line">                                └─│ HybridEngine │</span><br><span class="line">                                  └──────────────┘</span><br></pre></td></tr></table></figure>

<p>桥接模式实现比较复杂，实际应用也非常少，但它提供的设计思想值得借鉴，即不要过度使用继承，而是优先拆分某些部件，使用组合的方式来扩展功能。</p>
<h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p>组合模式（Composite）经常用于树形结构，为了简化代码，使用Composite可以把一个叶子节点与一个父节点统一起来处理。</p>
<p>我们来看一个具体的例子。在XML或HTML中，从根节点开始，每个节点都可能包含任意个其他节点，这些层层嵌套的节点就构成了一颗树。</p>
<p>要以树的结构表示XML，我们可以先抽象出节点类型<code>Node</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个节点为子节点:</span></span><br><span class="line">    <span class="function">Node <span class="title">add</span><span class="params">(Node node)</span></span>;</span><br><span class="line">    <span class="comment">// 获取子节点:</span></span><br><span class="line">    <span class="function">List&lt;Node&gt; <span class="title">children</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 输出为XML:</span></span><br><span class="line">    <span class="function">String <span class="title">toXml</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于一个<code>&lt;abc&gt;</code>这样的节点，我们称之为<code>ElementNode</code>，它可以作为容器包含多个子节点：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElementNode</span> <span class="title">implements</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Node&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">ElementNode</span>(<span class="params"><span class="built_in">String</span> name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="function"><span class="title">add</span>(<span class="params">Node node</span>)</span> &#123;</span><br><span class="line">        list.add(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Node&gt; <span class="function"><span class="title">children</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">toXml</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">String</span> start = <span class="string">&quot;&lt;&quot;</span> + name + <span class="string">&quot;&gt;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">String</span> end = <span class="string">&quot;&lt;/&quot;</span> + name + <span class="string">&quot;&gt;\n&quot;</span>;</span><br><span class="line">        StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;&quot;</span>, start, end);</span><br><span class="line">        list.forEach(node -&gt; &#123;</span><br><span class="line">            sj.add(node.toXml() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> sj.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于普通文本，我们把它看作<code>TextNode</code>，它没有子节点：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextNode</span> <span class="title">implements</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> text;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TextNode</span><span class="params">(<span class="keyword">String</span> text)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.text = text;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">UnsupportedOperationException</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> List.<span class="built_in">of</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> text;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还可以有注释节点：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommentNode</span> <span class="title">implements</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">String</span> text;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CommentNode</span><span class="params">(<span class="keyword">String</span> text)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.text = text;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Node <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">UnsupportedOperationException</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Node&gt; <span class="title">children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> List.<span class="built_in">of</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">toXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&lt;!-- &quot;</span> + text + <span class="string">&quot; --&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>ElementNode</code>、<code>TextNode</code>和<code>CommentNode</code>，我们就可以构造出一颗树：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Node root = <span class="keyword">new</span> <span class="constructor">ElementNode(<span class="string">&quot;school&quot;</span>)</span>;</span><br><span class="line">root.add(<span class="keyword">new</span> <span class="constructor">ElementNode(<span class="string">&quot;classA&quot;</span>)</span></span><br><span class="line">        .add(<span class="keyword">new</span> <span class="constructor">TextNode(<span class="string">&quot;Tom&quot;</span>)</span>)</span><br><span class="line">        .add(<span class="keyword">new</span> <span class="constructor">TextNode(<span class="string">&quot;Alice&quot;</span>)</span>));</span><br><span class="line">root.add(<span class="keyword">new</span> <span class="constructor">ElementNode(<span class="string">&quot;classB&quot;</span>)</span></span><br><span class="line">        .add(<span class="keyword">new</span> <span class="constructor">TextNode(<span class="string">&quot;Bob&quot;</span>)</span>)</span><br><span class="line">        .add(<span class="keyword">new</span> <span class="constructor">TextNode(<span class="string">&quot;Grace&quot;</span>)</span>)</span><br><span class="line">        .add(<span class="keyword">new</span> <span class="constructor">CommentNode(<span class="string">&quot;comment...&quot;</span>)</span>));</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(root.<span class="keyword">to</span><span class="constructor">Xml()</span>);</span><br></pre></td></tr></table></figure>

<p>最后通过<code>root</code>节点输出的XML如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">school</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">classA</span>&gt;</span></span><br><span class="line">Tom</span><br><span class="line">Alice</span><br><span class="line"><span class="tag">&lt;/<span class="name">classA</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">classB</span>&gt;</span></span><br><span class="line">Bob</span><br><span class="line">Grace</span><br><span class="line"><span class="comment">&lt;!-- comment... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">classB</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">school</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可见，使用Composite模式时，需要先统一单个节点以及“容器”节点的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │   Node    │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼────────────┐</span><br><span class="line">      │            │            │</span><br><span class="line">┌───────────┐┌───────────┐┌───────────┐</span><br><span class="line">│ElementNode││ TextNode  ││CommentNode│</span><br><span class="line">└───────────┘└───────────┘└───────────┘</span><br></pre></td></tr></table></figure>

<p>作为容器节点的<code>ElementNode</code>又可以添加任意个<code>Node</code>，这样就可以构成层级结构。</p>
<p>类似的，像文件夹和文件、GUI窗口的各种组件，都符合Composite模式的定义，因为它们的结构天生就是层级结构。</p>
<h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><blockquote>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，相比生成子类更为灵活。</p>
</blockquote>
<p>装饰器（Decorator）模式，是一种在运行期动态给某个对象的实例增加功能的方法。</p>
<p>我们在IO的<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1298364142452770">Filter模式</a>一节中其实已经讲过装饰器模式了。在Java标准库中，<code>InputStream</code>是抽象类，<code>FileInputStream</code>、<code>ServletInputStream</code>、<code>Socket.getInputStream()</code>这些<code>InputStream</code>都是最终数据源。</p>
<p>现在，如果要给不同的最终数据源增加缓冲功能、计算签名功能、加密解密功能，那么，3个最终数据源、3种功能一共需要9个子类。如果继续增加最终数据源，或者增加新功能，子类会爆炸式增长，这种设计方式显然是不可取的。</p>
<p>Decorator模式的目的就是把一个一个的附加功能，用Decorator的方式给一层一层地累加到原始数据源上，最终，通过组合获得我们想要的功能。</p>
<p>例如：给<code>FileInputStream</code>增加缓冲和解压缩功能，用Decorator模式写出来如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建原始的数据源:</span></span><br><span class="line">InputStream fis = <span class="keyword">new</span> <span class="constructor">FileInputStream(<span class="string">&quot;test.gz&quot;</span>)</span>;</span><br><span class="line"><span class="comment">// 增加缓冲功能:</span></span><br><span class="line">InputStream bis = <span class="keyword">new</span> <span class="constructor">BufferedInputStream(<span class="params">fis</span>)</span>;</span><br><span class="line"><span class="comment">// 增加解压缩功能:</span></span><br><span class="line">InputStream gis = <span class="keyword">new</span> <span class="constructor">GZIPInputStream(<span class="params">bis</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>或者一次性写成这样：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> <span class="type">GZIPInputStream</span>( <span class="comment">// 第二层装饰</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="type">BufferedInputStream</span>( <span class="comment">// 第一层装饰</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="type">FileInputStream</span>(<span class="string">&quot;test.gz&quot;</span>) <span class="comment">// 核心功能</span></span><br><span class="line">                        ));</span><br></pre></td></tr></table></figure>

<p>观察<code>BufferedInputStream</code>和<code>GZIPInputStream</code>，它们实际上都是从<code>FilterInputStream</code>继承的，这个<code>FilterInputStream</code>就是一个抽象的Decorator。我们用图把Decorator模式画出来如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">             ┌───────────┐</span><br><span class="line">             │ Component │</span><br><span class="line">             └───────────┘</span><br><span class="line">                   ▲</span><br><span class="line">      ┌────────────┼─────────────────┐</span><br><span class="line">      │            │                 │</span><br><span class="line">┌───────────┐┌───────────┐     ┌───────────┐</span><br><span class="line">│ComponentA ││ComponentB │...  │ Decorator │</span><br><span class="line">└───────────┘└───────────┘     └───────────┘</span><br><span class="line">                                     ▲</span><br><span class="line">                              ┌──────┴──────┐</span><br><span class="line">                              │             │</span><br><span class="line">                        ┌───────────┐ ┌───────────┐</span><br><span class="line">                        │DecoratorA │ │DecoratorB │...</span><br><span class="line">                        └───────────┘ └───────────┘</span><br></pre></td></tr></table></figure>

<p>最顶层的Component是接口，对应到IO的就是<code>InputStream</code>这个抽象类。ComponentA、ComponentB是实际的子类，对应到IO的就是<code>FileInputStream</code>、<code>ServletInputStream</code>这些数据源。Decorator是用于实现各个附加功能的抽象装饰器，对应到IO的就是<code>FilterInputStream</code>。而从Decorator派生的就是一个一个的装饰器，它们每个都有独立的功能，对应到IO的就是<code>BufferedInputStream</code>、<code>GZIPInputStream</code>等。</p>
<p>Decorator模式有什么好处？它实际上把核心功能和附加功能给分开了。核心功能指<code>FileInputStream</code>这些真正读数据的源头，附加功能指加缓冲、压缩、解密这些功能。如果我们要新增核心功能，就增加Component的子类，例如<code>ByteInputStream</code>。如果我们要增加附加功能，就增加Decorator的子类，例如<code>CipherInputStream</code>。两部分都可以独立地扩展，而具体如何附加功能，由调用方自由组合，从而极大地增强了灵活性。</p>
<p>如果我们要自己设计完整的Decorator模式，应该如何设计？</p>
<p>我们还是举个栗子：假设我们需要渲染一个HTML的文本，但是文本还可以附加一些效果，比如加粗、变斜体、加下划线等。为了实现动态附加效果，可以采用Decorator模式。</p>
<p>首先，仍然需要定义顶层接口<code>TextNode</code>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface TextNode &#123;</span><br><span class="line">    <span class="comment">// 设置text:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(<span class="keyword">String</span> text)</span></span>;</span><br><span class="line">    <span class="comment">// 获取text:</span></span><br><span class="line">    <span class="function"><span class="keyword">String</span> <span class="title">getText</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于核心节点，例如<code>&lt;span&gt;</code>，它需要从<code>TextNode</code>直接继承：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpanNode</span> <span class="title">implements</span> <span class="title">TextNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(<span class="keyword">String</span> text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getText</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;span&gt;&quot;</span> + text + <span class="string">&quot;&lt;/span&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着，为了实现Decorator模式，需要有一个抽象的Decorator类：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeDecorator</span> <span class="keyword">implements</span> <span class="title">TextNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> TextNode <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">NodeDecorator</span><span class="params">(TextNode <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span>.setText(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>NodeDecorator</code>类的核心是持有一个<code>TextNode</code>，即将要把功能附加到的<code>TextNode</code>实例。接下来就可以写一个加粗功能：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">BoldDecorator</span> <span class="keyword">extends</span> <span class="title">NodeDecorator</span> </span>&#123;</span><br><span class="line">    public <span class="type">BoldDecorator</span>(<span class="type">TextNode</span> target) &#123;</span><br><span class="line">        <span class="keyword">super</span>(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">String</span> getText() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&lt;b&gt;&quot;</span> + target.getText() + <span class="string">&quot;&lt;/b&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，可以继续加<code>ItalicDecorator</code>、<code>UnderlineDecorator</code>等。客户端可以自由组合这些Decorator：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TextNode n1 = <span class="keyword">new</span> <span class="constructor">SpanNode()</span>;</span><br><span class="line">TextNode n2 = <span class="keyword">new</span> <span class="constructor">BoldDecorator(<span class="params">new</span> UnderlineDecorator(<span class="params">new</span> SpanNode()</span>));</span><br><span class="line">TextNode n3 = <span class="keyword">new</span> <span class="constructor">ItalicDecorator(<span class="params">new</span> BoldDecorator(<span class="params">new</span> SpanNode()</span>));</span><br><span class="line">n1.set<span class="constructor">Text(<span class="string">&quot;Hello&quot;</span>)</span>;</span><br><span class="line">n2.set<span class="constructor">Text(<span class="string">&quot;Decorated&quot;</span>)</span>;</span><br><span class="line">n3.set<span class="constructor">Text(<span class="string">&quot;World&quot;</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(n1.get<span class="constructor">Text()</span>);</span><br><span class="line"><span class="comment">// 输出&lt;span&gt;Hello&lt;/span&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(n2.get<span class="constructor">Text()</span>);</span><br><span class="line"><span class="comment">// 输出&lt;b&gt;&lt;u&gt;&lt;span&gt;Decorated&lt;/span&gt;&lt;/u&gt;&lt;/b&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(n3.get<span class="constructor">Text()</span>);</span><br><span class="line"><span class="comment">// 输出&lt;i&gt;&lt;b&gt;&lt;span&gt;World&lt;/span&gt;&lt;/b&gt;&lt;/i&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p>为子系统中的一组接口提供一个一致的界面。Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
</blockquote>
<p>外观模式，即Facade，是一个比较简单的模式。它的基本思想如下：</p>
<p>如果客户端要跟许多子系统打交道，那么客户端需要了解各个子系统的接口，比较麻烦。如果有一个统一的“中介”，让客户端只跟中介打交道，中介再去跟各个子系统打交道，对客户端来说就比较简单。所以Facade就相当于搞了一个中介。</p>
<p>我们以注册公司为例，假设注册公司需要三步：</p>
<ol>
<li>向工商局申请公司营业执照；</li>
<li>在银行开设账户；</li>
<li>在税务局开设纳税号。</li>
</ol>
<p>以下是三个系统的接口：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工商注册:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminOfIndustry</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Company <span class="function"><span class="title">register</span>(<span class="params"><span class="built_in">String</span> name</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 银行开户:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">openAccount</span>(<span class="params"><span class="built_in">String</span> companyId</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纳税登记:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Taxation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">applyTaxCode</span>(<span class="params"><span class="built_in">String</span> companyId</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果子系统比较复杂，并且客户对流程也不熟悉，那就把这些流程全部委托给中介：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Facade &#123;</span><br><span class="line">    public Company <span class="keyword">open</span><span class="constructor">Company(String <span class="params">name</span>)</span> &#123;</span><br><span class="line">        Company c = this.admin.register(name);</span><br><span class="line">        String bankAccount = this.bank.<span class="keyword">open</span><span class="constructor">Account(<span class="params">c</span>.<span class="params">getId</span>()</span>);</span><br><span class="line">        c.set<span class="constructor">BankAccount(<span class="params">bankAccount</span>)</span>;</span><br><span class="line">        String taxCode = this.taxation.apply<span class="constructor">TaxCode(<span class="params">c</span>.<span class="params">getId</span>()</span>);</span><br><span class="line">        c.set<span class="constructor">TaxCode(<span class="params">taxCode</span>)</span>;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，客户端只跟Facade打交道，一次完成公司注册的所有繁琐流程：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Company c = facade.<span class="keyword">open</span><span class="constructor">Company(<span class="string">&quot;Facade Software Ltd.&quot;</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>很多Web程序，内部有多个子系统提供服务，经常使用一个统一的Facade入口，例如一个<code>RestApiController</code>，使得外部用户调用的时候，只关心Facade提供的接口，不用管内部到底是哪个子系统处理的。</p>
<p>更复杂的Web程序，会有多个Web服务，这个时候，经常会使用一个统一的网关入口来自动转发到不同的Web服务，这种提供统一入口的网关就是Gateway，它本质上也是一个Facade，但可以附加一些用户认证、限流限速的额外服务。</p>
<h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><blockquote>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
</blockquote>
<p>享元（Flyweight）的核心思想很简单：如果一个对象实例一经创建就不可变，那么反复创建相同的实例就没有必要，直接向调用方返回一个共享的实例就行，这样即节省内存，又可以减少创建对象的过程，提高运行速度。</p>
<p>享元模式在Java标准库中有很多应用。我们知道，包装类型如<code>Byte</code>、<code>Integer</code>都是不变类，因此，反复创建同一个值相同的包装类型是没有必要的。以<code>Integer</code>为例，如果我们通过<code>Integer.valueOf()</code>这个静态工厂方法创建<code>Integer</code>实例，当传入的<code>int</code>范围在<code>-128</code>~&#96;+127<code>之间时，会直接返回缓存的</code>Integer&#96;实例：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 享元模式</span><br></pre></td></tr></table></figure>

<p> Run</p>
<p>对于<code>Byte</code>来说，因为它一共只有256个状态，所以，通过<code>Byte.valueOf()</code>创建的<code>Byte</code>实例，全部都是缓存对象。</p>
<p>因此，享元模式就是通过工厂方法创建对象，在工厂方法内部，很可能返回缓存的实例，而不是新创建实例，从而实现不可变实例的复用。</p>
<p> 总是使用工厂方法而不是new操作符创建实例，可获得享元模式的好处。</p>
<p>在实际应用中，享元模式主要应用于缓存，即客户端如果重复请求某些对象，不必每次查询数据库或者读取文件，而是直接返回内存中缓存的数据。</p>
<p>我们以<code>Student</code>为例，设计一个静态工厂方法，它在内部可以返回缓存的对象：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="comment">// 持有缓存:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, Student&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态工厂方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">create</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> key = id + <span class="string">&quot;\n&quot;</span> + name;</span><br><span class="line">        <span class="comment">// 先查找缓存:</span></span><br><span class="line">        Student std = cache.<span class="built_in">get</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (std == null) &#123;</span><br><span class="line">            <span class="comment">// 未找到,创建新对象:</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">&quot;create new Student(%s, %s)&quot;</span>, id, name));</span><br><span class="line">            std = <span class="keyword">new</span> <span class="built_in">Student</span>(id, name);</span><br><span class="line">            <span class="comment">// 放入缓存:</span></span><br><span class="line">            cache.<span class="built_in">put</span>(key, std);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存中存在:</span></span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="keyword">String</span>.format(<span class="string">&quot;return cached Student(%s, %s)&quot;</span>, std.id, std.name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">String</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">String</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实际应用中，我们经常使用成熟的缓存库，例如<a target="_blank" rel="noopener" href="https://github.com/google/guava">Guava</a>的<a target="_blank" rel="noopener" href="https://github.com/google/guava/blob/master/guava/src/com/google/common/cache/Cache.java">Cache</a>，因为它提供了最大缓存数量限制、定时过期等实用功能。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
</blockquote>
<p>代理模式，即Proxy，它和Adapter模式很类似。我们先回顾Adapter模式，它用于把A接口转换为B接口：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BAdapter <span class="keyword">implements</span> B <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    private A a;</span></span><br><span class="line"><span class="comment">    public BAdapter(A a) &#123;</span></span><br><span class="line"><span class="comment">        this.a = a;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">    <span class="keyword">public</span> void b() <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">        a.a();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而Proxy模式不是把A接口转换成B接口，它还是转换成A接口：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AProxy <span class="keyword">implements</span> A &#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">AProxy</span>(<span class="params">A a</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合着Proxy就是为了给A接口再包一层，这不是脱了裤子放屁吗？</p>
<p>当然不是。我们观察Proxy的实现A接口的方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a.a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样写当然没啥卵用。但是，如果我们在调用<code>a.a()</code>的前后，加一些额外的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">a</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getCurrentUser().isRoot()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.a.a();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">&quot;Forbidden&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们就实现了权限检查，只有符合要求的用户，才会真正调用目标方法，否则，会直接抛出异常。</p>
<p>有的童鞋会问，为啥不把权限检查的功能直接写到目标实例A的内部？</p>
<p>因为我们编写代码的原则有：</p>
<ul>
<li>职责清晰：一个类只负责一件事；</li>
<li>易于测试：一次只测一个功能。</li>
</ul>
<p>用Proxy实现这个权限检查，我们可以获得更清晰、更简洁的代码：</p>
<ul>
<li>A接口：只定义接口；</li>
<li>ABusiness类：只实现A接口的业务逻辑；</li>
<li>APermissionProxy类：只实现A接口的权限检查代理。</li>
</ul>
<p>如果我们希望编写其他类型的代理，可以继续增加类似ALogProxy，而不必对现有的A接口、ABusiness类进行修改。</p>
<p>实际上权限检查只是代理模式的一种应用。Proxy还广泛应用在：</p>
<h3 id="远程代理"><a href="#远程代理" class="headerlink" title="远程代理"></a>远程代理</h3><p>远程代理即Remote Proxy，本地的调用者持有的接口实际上是一个代理，这个代理负责把对接口的方法访问转换成远程调用，然后返回结果。Java内置的RMI机制就是一个完整的远程代理模式。</p>
<h3 id="虚代理"><a href="#虚代理" class="headerlink" title="虚代理"></a>虚代理</h3><p>虚代理即Virtual Proxy，它让调用者先持有一个代理对象，但真正的对象尚未创建。如果没有必要，这个真正的对象是不会被创建的，直到客户端需要真的必须调用时，才创建真正的对象。JDBC的连接池返回的JDBC连接（Connection对象）就可以是一个虚代理，即获取连接时根本没有任何实际的数据库连接，直到第一次执行JDBC查询或更新操作时，才真正创建实际的JDBC连接。</p>
<h3 id="保护代理"><a href="#保护代理" class="headerlink" title="保护代理"></a>保护代理</h3><p>保护代理即Protection Proxy，它用代理对象控制对原始对象的访问，常用于鉴权。</p>
<h3 id="智能引用"><a href="#智能引用" class="headerlink" title="智能引用"></a>智能引用</h3><p>智能引用即Smart Reference，它也是一种代理对象，如果有很多客户端对它进行访问，通过内部的计数器可以在外部调用者都不使用后自动释放它。</p>
<p>我们来看一下如何应用代理模式编写一个JDBC连接池（<code>DataSource</code>）。我们首先来编写一个虚代理，即如果调用者获取到<code>Connection</code>后，并没有执行任何SQL操作，那么这个Connection Proxy实际上并不会真正打开JDBC连接。调用者代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DataSource lazyDataSource = <span class="keyword">new</span> <span class="constructor">LazyDataSource(<span class="params">jdbcUrl</span>, <span class="params">jdbcUsername</span>, <span class="params">jdbcPassword</span>)</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;get lazy connection...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (Connection conn1 = lazyDataSource.get<span class="constructor">Connection()</span>) &#123;</span><br><span class="line">    <span class="comment">// 并没有实际打开真正的Connection</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;get lazy connection...&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> (Connection conn2 = lazyDataSource.get<span class="constructor">Connection()</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn2.prepare<span class="constructor">Statement(<span class="string">&quot;SELECT * FROM students&quot;</span>)</span>) &#123; <span class="comment">// 打开了真正的Connection</span></span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = ps.execute<span class="constructor">Query()</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next<span class="literal">()</span>) &#123;</span><br><span class="line">                <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(rs.get<span class="constructor">String(<span class="string">&quot;name&quot;</span>)</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们来思考如何实现这个<code>LazyConnectionProxy</code>。为了简化代码，我们首先针对<code>Connection</code>接口做一个抽象的代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractConnectionProxy</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法获取实际的Connection:</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Connection <span class="title">getRealConnection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现Connection接口的每一个方法:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRealConnection().createStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRealConnection().prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...其他代理方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>AbstractConnectionProxy</code>代理类的作用是把<code>Connection</code>接口定义的方法全部实现一遍，因为<code>Connection</code>接口定义的方法太多了，后面我们要编写的<code>LazyConnectionProxy</code>只需要继承<code>AbstractConnectionProxy</code>，就不必再把<code>Connection</code>接口方法挨个实现一遍。</p>
<p><code>LazyConnectionProxy</code>实现如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyConnectionProxy</span> <span class="keyword">extends</span> <span class="title">AbstractConnectionProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Supplier&lt;Connection&gt; supplier;</span><br><span class="line">    <span class="keyword">private</span> Connection <span class="keyword">target</span> = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LazyConnectionProxy</span><span class="params">(Supplier&lt;Connection&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.supplier = supplier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆写close方法：只有target不为null时才需要关闭:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">target</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Close connection: &quot;</span> + <span class="keyword">target</span>);</span><br><span class="line">            <span class="keyword">super</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">Connection <span class="title">getRealConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">target</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">target</span> = supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用者没有执行任何SQL语句，那么<code>target</code>字段始终为<code>null</code>。只有第一次执行SQL语句时（即调用任何类似<code>prepareStatement()</code>方法时，触发<code>getRealConnection()</code>调用），才会真正打开实际的JDBC Connection。</p>
<p>最后，我们还需要编写一个<code>LazyDataSource</code>来支持这个<code>LazyConnecitonProxy</code>：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDataSource</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">DataSource</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LazyDataSource(<span class="keyword">String</span> url, <span class="keyword">String</span> username, <span class="keyword">String</span> password) &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Connection getConnection(<span class="keyword">String</span> username, <span class="keyword">String</span> password) throws SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">LazyConnectionProxy</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">                System.out.println(<span class="string">&quot;Open connection: &quot;</span> + conn);</span><br><span class="line">                <span class="keyword">return</span> conn;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行代码，输出如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get</span> lazy connection...</span><br><span class="line"><span class="keyword">get</span> lazy connection...</span><br><span class="line"><span class="keyword">Open</span> connection: com.mysql.jdbc.JDBC4Connection<span class="variable">@7a36aefa</span></span><br><span class="line">小明</span><br><span class="line">小红</span><br><span class="line">小军</span><br><span class="line">小白</span><br><span class="line">...</span><br><span class="line"><span class="keyword">Close</span> connection: com.mysql.jdbc.JDBC4Connection<span class="variable">@7a36aefa</span></span><br></pre></td></tr></table></figure>

<p>可见第一个<code>getConnection()</code>调用获取到的<code>LazyConnectionProxy</code>并没有实际打开真正的JDBC Connection。</p>
<p>使用连接池的时候，我们更希望能重复使用连接。如果调用方编写这样的代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataSource pooledDataSource = <span class="keyword">new</span> <span class="constructor">PooledDataSource(<span class="params">jdbcUrl</span>, <span class="params">jdbcUsername</span>, <span class="params">jdbcPassword</span>)</span>;</span><br><span class="line"><span class="keyword">try</span> (Connection conn = pooledDataSource.get<span class="constructor">Connection()</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (Connection conn = pooledDataSource.get<span class="constructor">Connection()</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取到的是同一个Connection</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> (Connection conn = pooledDataSource.get<span class="constructor">Connection()</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取到的是同一个Connection</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方并不关心是否复用了<code>Connection</code>，但从<code>PooledDataSource</code>获取的<code>Connection</code>确实自带这个优化功能。如何实现可复用<code>Connection</code>的连接池？答案仍然是使用代理模式。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledConnectionProxy</span> <span class="keyword">extends</span> <span class="title">AbstractConnectionProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实际的Connection:</span></span><br><span class="line">    Connection <span class="keyword">target</span>;</span><br><span class="line">    <span class="comment">// 空闲队列:</span></span><br><span class="line">    Queue&lt;PooledConnectionProxy&gt; idleQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PooledConnectionProxy</span><span class="params">(Queue&lt;PooledConnectionProxy&gt; idleQueue, Connection <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.idleQueue = idleQueue;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Fake close and released to idle queue for future reuse: &quot;</span> + <span class="keyword">target</span>);</span><br><span class="line">        <span class="comment">// 并没有调用实际Connection的close()方法,</span></span><br><span class="line">        <span class="comment">// 而是把自己放入空闲队列:</span></span><br><span class="line">        idleQueue.offer(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function">Connection <span class="title">getRealConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复用连接的关键在于覆写<code>close()</code>方法，它并没有真正关闭底层JDBC连接，而是把自己放回一个空闲队列，以便下次使用。</p>
<p>空闲队列由<code>PooledDataSource</code>负责维护：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> PooledDataSource implements DataSource &#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护一个空闲队列:</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;PooledConnectionProxy&gt; idleQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">PooledDataSource(String <span class="params">url</span>, String <span class="params">username</span>, String <span class="params">password</span>)</span> &#123;</span><br><span class="line">        this.url = url;</span><br><span class="line">        this.username = username;</span><br><span class="line">        this.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Connection get<span class="constructor">Connection(String <span class="params">username</span>, String <span class="params">password</span>)</span> throws SQLException &#123;</span><br><span class="line">        <span class="comment">// 首先试图获取一个空闲连接:</span></span><br><span class="line">        PooledConnectionProxy conn = idleQueue.poll<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">if</span> (conn<span class="operator"> == </span>null) &#123;</span><br><span class="line">            <span class="comment">// 没有空闲连接时，打开一个新连接:</span></span><br><span class="line">            conn = <span class="keyword">open</span><span class="constructor">NewConnection()</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Return pooled connection: &quot;</span> + conn.target);</span><br><span class="line">        &#125;</span><br><span class="line">        return conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PooledConnectionProxy <span class="keyword">open</span><span class="constructor">NewConnection()</span> throws SQLException &#123;</span><br><span class="line">        Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(<span class="params">url</span>, <span class="params">username</span>, <span class="params">password</span>)</span>;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;Open new connection: &quot;</span> + conn);</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">PooledConnectionProxy(<span class="params">idleQueue</span>, <span class="params">conn</span>)</span>;</span><br><span class="line">    &#125;<span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行调用方代码，输出如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Open</span> new connection: com.mysql.jdbc.JDBC<span class="number">4</span>Connection@<span class="number">61</span>ca<span class="number">2</span>dfa</span><br><span class="line"><span class="attribute">Fake</span> close and released to idle queue for future reuse: com.mysql.jdbc.JDBC<span class="number">4</span>Connection@<span class="number">61</span>ca<span class="number">2</span>dfa</span><br><span class="line"><span class="attribute">Return</span> pooled connection: com.mysql.jdbc.JDBC<span class="number">4</span>Connection@<span class="number">61</span>ca<span class="number">2</span>dfa</span><br><span class="line"><span class="attribute">Fake</span> close and released to idle queue for future reuse: com.mysql.jdbc.JDBC<span class="number">4</span>Connection@<span class="number">61</span>ca<span class="number">2</span>dfa</span><br><span class="line"><span class="attribute">Return</span> pooled connection: com.mysql.jdbc.JDBC<span class="number">4</span>Connection@<span class="number">61</span>ca<span class="number">2</span>dfa</span><br><span class="line"><span class="attribute">Fake</span> close and released to idle queue for future reuse: com.mysql.jdbc.JDBC<span class="number">4</span>Connection@<span class="number">61</span>ca<span class="number">2</span>dfa</span><br></pre></td></tr></table></figure>

<p>除了第一次打开了一个真正的JDBC Connection，后续获取的<code>Connection</code>实际上是同一个JDBC Connection。但是，对于调用方来说，完全不需要知道底层做了哪些优化。</p>
<p>我们实际使用的DataSource，例如HikariCP，都是基于代理模式实现的，原理同上，但增加了更多的如动态伸缩的功能（一个连接空闲一段时间后自动关闭）。</p>
<p>有的童鞋会发现Proxy模式和Decorator模式有些类似。确实，这两者看起来很像，但区别在于：Decorator模式让调用者自己创建核心类，然后组合各种功能，而Proxy模式决不能让调用者自己创建再组合，否则就失去了代理的功能。Proxy模式让调用者认为获取到的是核心类接口，但实际上是代理类。</p>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><p>类和对象如何交互，及划分责任和算法</p>
<p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p>
<p>行为型模式有：</p>
<ul>
<li>责任链</li>
<li>命令</li>
<li>解释器</li>
<li>迭代器</li>
<li>中介</li>
<li>备忘录</li>
<li>观察者</li>
<li>状态</li>
<li>策略</li>
<li>模板方法</li>
<li>访问者</li>
</ul>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><blockquote>
<p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p>
</blockquote>
<p>责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">     ┌─────────┐</span><br><span class="line">     │ Request │</span><br><span class="line">     └─────────┘</span><br><span class="line">          │</span><br><span class="line">┌ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┐</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorA  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">          │</span><br><span class="line">│         ▼         │</span><br><span class="line">   ┌─────────────┐</span><br><span class="line">│  │ ProcessorB  │  │</span><br><span class="line">   └─────────────┘</span><br><span class="line">│         │         │</span><br><span class="line">          ▼</span><br><span class="line">│  ┌─────────────┐  │</span><br><span class="line">   │ ProcessorC  │</span><br><span class="line">│  └─────────────┘  │</span><br><span class="line">          │</span><br><span class="line">└ ─ ─ ─ ─ ┼ ─ ─ ─ ─ ┘</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br></pre></td></tr></table></figure>

<p>在实际场景中，财务审批就是一个责任链模式。假设某个员工需要报销一笔费用，审核者可以分为：</p>
<ul>
<li>Manager：只能审核1000元以下的报销；</li>
<li>Director：只能审核10000元以下的报销；</li>
<li>CEO：可以审核任意额度。</li>
</ul>
<p>用责任链模式设计此报销流程时，每个审核者只关心自己责任范围内的请求，并且处理它。对于超出自己责任范围的，扔给下一个审核者处理，这样，将来继续添加审核者的时候，不用改动现有逻辑。</p>
<p>我们来看看如何实现责任链模式。</p>
<p>首先，我们要抽象出请求对象，它将在责任链上传递：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">Request</span>(<span class="params"><span class="built_in">String</span> name, BigDecimal amount</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="function"><span class="title">getAmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，我们要抽象出处理器：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> interface <span class="keyword">Handler</span> &#123;</span><br><span class="line">    // 返回<span class="type">Boolean</span>.<span class="keyword">TRUE</span> = 成功</span><br><span class="line">    // 返回<span class="type">Boolean</span>.<span class="keyword">FALSE</span> = 拒绝</span><br><span class="line">    // 返回<span class="keyword">null</span> = 交下一个处理</span><br><span class="line">	<span class="type">Boolean</span> process(Request request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且做好约定：如果返回<code>Boolean.TRUE</code>，表示处理成功，如果返回<code>Boolean.FALSE</code>，表示处理失败（请求被拒绝），如果返回<code>null</code>，则交由下一个<code>Handler</code>处理。</p>
<p>然后，依次编写ManagerHandler、DirectorHandler和CEOHandler。以ManagerHandler为例：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ManagerHandler <span class="keyword">implements</span> Handler &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">Boolean</span> process(Request request) &#123;</span><br><span class="line">        <span class="comment">// 如果超过1000元，处理不了，交下一个处理:</span></span><br><span class="line">        <span class="keyword">if</span> (request.getAmount().<span class="keyword">compareTo</span>(BigDecimal.valueOf(<span class="number">1000</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对Bob有偏见:</span></span><br><span class="line">        <span class="keyword">return</span> !request.getName().equalsIgnoreCase(<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了不同的<code>Handler</code>后，我们还要把这些<code>Handler</code>组合起来，变成一个链，并通过一个统一入口处理：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有所有Handler:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(Handler <span class="keyword">handler</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handlers.add(<span class="keyword">handler</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 依次调用每个Handler:</span></span><br><span class="line">        <span class="keyword">for</span> (Handler <span class="keyword">handler</span> : handlers) &#123;</span><br><span class="line">            Boolean r = <span class="keyword">handler</span>.process(request);</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果返回TRUE或FALSE，处理结束:</span></span><br><span class="line">                System.out.println(request + <span class="string">&quot; &quot;</span> + (r ? <span class="string">&quot;Approved by &quot;</span> : <span class="string">&quot;Denied by &quot;</span>) + <span class="keyword">handler</span>.getClass().getSimpleName());</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Could not handle request: &quot;</span> + request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们就可以在客户端组装出责任链，然后用责任链来处理请求：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造责任链:</span></span><br><span class="line">HandlerChain chain = <span class="keyword">new</span> <span class="type">HandlerChain</span>();</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="type">ManagerHandler</span>());</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="type">DirectorHandler</span>());</span><br><span class="line">chain.addHandler(<span class="keyword">new</span> <span class="type">CEOHandler</span>());</span><br><span class="line"><span class="comment">// 处理请求:</span></span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="type">Request</span>(<span class="string">&quot;Bob&quot;</span>, <span class="keyword">new</span> <span class="type">BigDecimal</span>(<span class="string">&quot;123.45&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="type">Request</span>(<span class="string">&quot;Alice&quot;</span>, <span class="keyword">new</span> <span class="type">BigDecimal</span>(<span class="string">&quot;1234.56&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="type">Request</span>(<span class="string">&quot;Bill&quot;</span>, <span class="keyword">new</span> <span class="type">BigDecimal</span>(<span class="string">&quot;12345.67&quot;</span>)));</span><br><span class="line">chain.process(<span class="keyword">new</span> <span class="type">Request</span>(<span class="string">&quot;John&quot;</span>, <span class="keyword">new</span> <span class="type">BigDecimal</span>(<span class="string">&quot;123456.78&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>责任链模式本身很容易理解，需要注意的是，<code>Handler</code>添加的顺序很重要，如果顺序不对，处理的结果可能就不是符合要求的。</p>
<p>此外，责任链模式有很多变种。有些责任链的实现方式是通过某个<code>Handler</code>手动调用下一个<code>Handler</code>来传递<code>Request</code>，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">AHandler</span> <span class="symbol">implements</span> <span class="symbol">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> process(Request request) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!canProcess(request)) &#123;</span><br><span class="line">            <span class="comment">// 手动交给下一个Handler处理:</span></span><br><span class="line">            next.process(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些责任链模式，每个<code>Handler</code>都有机会处理<code>Request</code>，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个<code>Handler</code>处理掉<code>Request</code>，而是每个<code>Handler</code>都做一些工作，比如：</p>
<ul>
<li>记录日志；</li>
<li>检查权限；</li>
<li>准备相关资源；</li>
<li>…</li>
</ul>
<p>例如，JavaEE的Servlet规范定义的<code>Filter</code>就是一种责任链模式，它不但允许每个<code>Filter</code>都有机会处理请求，还允许每个<code>Filter</code>决定是否将请求“放行”给下一个<code>Filter</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> AuditFilter implements Filter &#123;</span><br><span class="line">    public void <span class="keyword">do</span><span class="constructor">Filter(ServletRequest <span class="params">req</span>, ServletResponse <span class="params">resp</span>, FilterChain <span class="params">chain</span>)</span> throws IOException, ServletException &#123;</span><br><span class="line">        log(req);</span><br><span class="line">        <span class="keyword">if</span> (check(req)) &#123;</span><br><span class="line">            <span class="comment">// 放行:</span></span><br><span class="line">            chain.<span class="keyword">do</span><span class="constructor">Filter(<span class="params">req</span>, <span class="params">resp</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拒绝:</span></span><br><span class="line">            send<span class="constructor">Error(<span class="params">resp</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式不但允许一个<code>Filter</code>自行决定处理<code>ServletRequest</code>和<code>ServletResponse</code>，还可以“伪造”<code>ServletRequest</code>和<code>ServletResponse</code>以便让下一个<code>Filter</code>处理，能实现非常复杂的功能。</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。</p>
</blockquote>
<p>命令模式（Command）是指，把请求封装成一个命令，然后执行该命令。</p>
<p>在使用命令模式前，我们先以一个编辑器为例子，看看如何实现简单的编辑操作：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder buffer = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">paste</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">String</span> text = <span class="built_in">getFromClipBoard</span>();</span><br><span class="line">        <span class="built_in">add</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        buffer.<span class="built_in">append</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.<span class="built_in">length</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.<span class="built_in">deleteCharAt</span>(buffer.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用一个<code>StringBuilder</code>模拟一个文本编辑器，它支持<code>copy()</code>、<code>paste()</code>、<code>add()</code>、<code>delete()</code>等方法。</p>
<p>正常情况，我们像这样调用<code>TextEditor</code>：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TextEditor editor = new TextEditor()<span class="comment">;</span></span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>)<span class="comment">;</span></span><br><span class="line">editor.copy()<span class="comment">;</span></span><br><span class="line">editor.paste()<span class="comment">;</span></span><br><span class="line">System.out.println(editor.getState())<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这是直接调用方法，调用方需要了解<code>TextEditor</code>的所有接口信息。</p>
<p>如果改用命令模式，我们就要把调用方发送命令和执行方执行命令分开。怎么分？</p>
<p>解决方案是引入一个<code>Command</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方创建一个对应的<code>Command</code>，然后执行，并不关心内部是如何具体执行的。</p>
<p>为了支持<code>CopyCommand</code>和<code>PasteCommand</code>这两个命令，我们从<code>Command</code>接口派生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有执行者对象:</span></span><br><span class="line">    <span class="keyword">private</span> TextEditor receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CopyCommand</span><span class="params">(TextEditor receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.copy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextEditor receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PasteCommand</span><span class="params">(TextEditor receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.paste();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后我们把<code>Command</code>和<code>TextEditor</code>组装一下，客户端这么写：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TextEditor editor = <span class="keyword">new</span> <span class="constructor">TextEditor()</span>;</span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>);</span><br><span class="line"><span class="comment">// 执行一个CopyCommand:</span></span><br><span class="line">Command copy = <span class="keyword">new</span> <span class="constructor">CopyCommand(<span class="params">editor</span>)</span>;</span><br><span class="line">copy.execute<span class="literal">()</span>;</span><br><span class="line">editor.add(<span class="string">&quot;----\n&quot;</span>);</span><br><span class="line"><span class="comment">// 执行一个PasteCommand:</span></span><br><span class="line">Command paste = <span class="keyword">new</span> <span class="constructor">PasteCommand(<span class="params">editor</span>)</span>;</span><br><span class="line">paste.execute<span class="literal">()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(editor.get<span class="constructor">State()</span>);</span><br></pre></td></tr></table></figure>

<p>这就是命令模式的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌──────┐      ┌───────┐</span><br><span class="line">│Client│─ ─ ─&gt;│Command│</span><br><span class="line">└──────┘      └───────┘</span><br><span class="line">                  │  ┌──────────────┐</span><br><span class="line">                  ├─&gt;│ CopyCommand  │</span><br><span class="line">                  │  ├──────────────┤</span><br><span class="line">                  │  │editor.copy() │─ ┐</span><br><span class="line">                  │  └──────────────┘</span><br><span class="line">                  │                    │  ┌────────────┐</span><br><span class="line">                  │  ┌──────────────┐   ─&gt;│ TextEditor │</span><br><span class="line">                  └─&gt;│ PasteCommand │  │  └────────────┘</span><br><span class="line">                     ├──────────────┤</span><br><span class="line">                     │editor.paste()│─ ┘</span><br><span class="line">                     └──────────────┘</span><br></pre></td></tr></table></figure>

<p>有的童鞋会有疑问：搞了一大堆<code>Command</code>，多了好几个类，还不如直接这么写简单：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TextEditor editor = new TextEditor()<span class="comment">;</span></span><br><span class="line">editor.add(<span class="string">&quot;Command pattern in text editor.\n&quot;</span>)<span class="comment">;</span></span><br><span class="line">editor.copy()<span class="comment">;</span></span><br><span class="line">editor.paste()<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>实际上，使用命令模式，确实增加了系统的复杂度。如果需求很简单，那么直接调用显然更直观而且更简单。</p>
<p>那么我们还需要命令模式吗？</p>
<p>答案是视需求而定。如果<code>TextEditor</code>复杂到一定程度，并且需要支持Undo、Redo的功能时，就需要使用命令模式，因为我们可以给每个命令增加<code>undo()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后把执行的一系列命令用<code>List</code>保存起来，就既能支持Undo，又能支持Redo。这个时候，我们又需要一个<code>Invoker</code>对象，负责执行命令并保存历史命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│   Client    │</span><br><span class="line">└─────────────┘</span><br><span class="line">       │</span><br><span class="line"></span><br><span class="line">       │</span><br><span class="line">       ▼</span><br><span class="line">┌─────────────┐</span><br><span class="line">│   Invoker   │</span><br><span class="line">├─────────────┤    ┌───────┐</span><br><span class="line">│List commands│─ ─&gt;│Command│</span><br><span class="line">│invoke(c)    │    └───────┘</span><br><span class="line">│undo()       │        │  ┌──────────────┐</span><br><span class="line">└─────────────┘        ├─&gt;│ CopyCommand  │</span><br><span class="line">                       │  ├──────────────┤</span><br><span class="line">                       │  │editor.copy() │─ ┐</span><br><span class="line">                       │  └──────────────┘</span><br><span class="line">                       │                    │  ┌────────────┐</span><br><span class="line">                       │  ┌──────────────┐   ─&gt;│ TextEditor │</span><br><span class="line">                       └─&gt;│ PasteCommand │  │  └────────────┘</span><br><span class="line">                          ├──────────────┤</span><br><span class="line">                          │editor.paste()│─ ┘</span><br><span class="line">                          └──────────────┘</span><br></pre></td></tr></table></figure>

<p>可见，模式带来的设计复杂度的增加是随着需求而增加的，它减少的是系统各组件的耦合度。</p>
<h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。</p>
</blockquote>
<p>解释器模式（Interpreter）是一种针对特定问题设计的一种解决方案。例如，匹配字符串的时候，由于匹配条件非常灵活，使得通过代码来实现非常不灵活。举个例子，针对以下的匹配条件：</p>
<ul>
<li>以<code>+</code>开头的数字表示的区号和电话号码，如<code>+861012345678</code>；</li>
<li>以英文开头，后接英文和数字，并以.分隔的域名，如<code>www.liaoxuefeng.com</code>；</li>
<li>以<code>/</code>开头的文件路径，如<code>/path/to/file.txt</code>；</li>
<li>…</li>
</ul>
<p>因此，需要一种通用的表示方法——正则表达式来进行匹配。正则表达式就是一个字符串，但要把正则表达式解析为语法树，然后再匹配指定的字符串，就需要一个解释器。</p>
<p>实现一个完整的正则表达式的解释器非常复杂，但是使用解释器模式却很简单：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;+861012345678&quot;</span><span class="comment">;</span></span><br><span class="line">System.out.println(s.matches(<span class="string">&quot;^\\+\\d+$&quot;</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>类似的，当我们使用JDBC时，执行的SQL语句虽然是字符串，但最终需要数据库服务器的SQL解释器来把SQL“翻译”成数据库服务器能执行的代码，这个执行引擎也非常复杂，但对于使用者来说，仅仅需要写出SQL字符串即可。</p>
<h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p>
</blockquote>
<p>迭代器模式（Iterator）实际上在Java的集合类中已经广泛使用了。我们以<code>List</code>为例，要遍历<code>ArrayList</code>，即使我们知道它的内部存储了一个<code>Object[]</code>数组，也不应该直接使用数组索引去遍历，因为这样需要了解集合内部的存储结构。如果使用<code>Iterator</code>遍历，那么，<code>ArrayList</code>和<code>LinkedList</code>都可以以一种统一的接口来遍历：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; <span class="keyword">list</span> = ...</span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;<span class="built_in">String</span>&gt; <span class="literal">it</span> = <span class="keyword">list</span>.iterator(); <span class="literal">it</span>.hasNext(); ) &#123;</span><br><span class="line">    <span class="built_in">String</span> s = <span class="literal">it</span>.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上，因为Iterator模式十分有用，因此，Java允许我们直接把任何支持<code>Iterator</code>的集合对象用<code>foreach</code>循环写出来：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; <span class="built_in">list</span> = <span class="params">...</span></span><br><span class="line">for (<span class="built_in">String</span> s : <span class="built_in">list</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后由Java编译器完成Iterator模式的所有循环代码。</p>
<p>虽然我们对如何使用Iterator有了一定了解，但如何实现一个Iterator模式呢？我们以一个自定义的集合为例，通过Iterator模式实现倒序遍历：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ReverseArrayCollection</span>&lt;<span class="symbol">T</span>&gt; <span class="symbol">implements</span> <span class="symbol">Iterable</span>&lt;<span class="symbol">T</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 以数组形式持有集合:</span></span><br><span class="line">    <span class="keyword">private</span> T[] <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReverseArrayCollection(T... objs) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">array</span> = Arrays.copyOfRange(objs, <span class="number">0</span>, objs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> ???;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现Iterator模式的关键是返回一个<code>Iterator</code>对象，该对象知道集合的内部结构，因为它可以实现倒序遍历。我们使用Java的内部类实现这个<code>Iterator</code>：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ReverseArrayCollection</span>&lt;<span class="symbol">T</span>&gt; <span class="symbol">implements</span> <span class="symbol">Iterable</span>&lt;<span class="symbol">T</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T[] <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ReverseArrayCollection(T... objs) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">array</span> = Arrays.copyOfRange(objs, <span class="number">0</span>, objs.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;T&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> new ReverseIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="symbol">ReverseIterator</span> <span class="symbol">implements</span> <span class="symbol">Iterator</span>&lt;<span class="symbol">T</span>&gt; &#123;</span><br><span class="line">        <span class="comment">// 索引位置:</span></span><br><span class="line">        <span class="built_in">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> ReverseIterator() &#123;</span><br><span class="line">            <span class="comment">// 创建Iterator时,索引在数组末尾:</span></span><br><span class="line">            <span class="keyword">this</span>.index = ReverseArrayCollection.<span class="keyword">this</span>.<span class="built_in">array</span>.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">bool</span>ean hasNext() &#123;</span><br><span class="line">            <span class="comment">// 如果索引大于0,那么可以移动到下一个元素(倒序往前移动):</span></span><br><span class="line">            <span class="keyword">return</span> index &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T next() &#123;</span><br><span class="line">            <span class="comment">// 将索引移动到下一个元素并返回(倒序往前移动):</span></span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用内部类的好处是内部类隐含地持有一个它所在对象的<code>this</code>引用，可以通过<code>ReverseArrayCollection.this</code>引用到它所在的集合。上述代码实现的逻辑非常简单，但是实际应用时，如果考虑到多线程访问，当一个线程正在迭代某个集合，而另一个线程修改了集合的内容时，是否能继续安全地迭代，还是抛出<code>ConcurrentModificationException</code>，就需要更仔细地设计。</p>
<h2 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h2><blockquote>
<p>用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p>中介模式（Mediator）又称调停者模式，它的目的是把多方会谈变成双方会谈，从而实现多方的松耦合。</p>
<p>有些童鞋听到中介立刻想到房产中介，立刻气不打一处来。这个中介模式与房产中介还真有点像，所以消消气，先看例子。</p>
<p>考虑一个简单的点餐输入：</p>
<p> 汉堡</p>
<p> 鸡块</p>
<p> 薯条</p>
<p> 咖啡</p>
<p>选择全部 取消所有 反选</p>
<p>这个小系统有4个参与对象：</p>
<ul>
<li>多选框；</li>
<li>“选择全部”按钮；</li>
<li>“取消所有”按钮；</li>
<li>“反选”按钮。</li>
</ul>
<p>它的复杂性在于，当多选框变化时，它会影响“选择全部”和“取消所有”按钮的状态（是否可点击），当用户点击某个按钮时，例如“反选”，除了会影响多选框的状态，它又可能影响“选择全部”和“取消所有”按钮的状态。</p>
<p>所以这是一个多方会谈，逻辑写起来很复杂：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────┐     ┌─────────────────┐</span><br><span class="line">│  CheckBox List  │&lt;───&gt;│SelectAll Button │</span><br><span class="line">└─────────────────┘     └─────────────────┘</span><br><span class="line">         ▲ ▲                     ▲</span><br><span class="line">         │ └─────────────────────┤</span><br><span class="line">         ▼                       │</span><br><span class="line">┌─────────────────┐     ┌────────┴────────┐</span><br><span class="line">│SelectNone Button│&lt;────│ Inverse Button  │</span><br><span class="line">└─────────────────┘     └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>如果我们引入一个中介，把多方会谈变成多个双方会谈，虽然多了一个对象，但对象之间的关系就变简单了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            ┌─────────────────┐</span><br><span class="line">     ┌─────&gt;│  CheckBox List  │</span><br><span class="line">     │      └─────────────────┘</span><br><span class="line">     │      ┌─────────────────┐</span><br><span class="line">     │ ┌───&gt;│SelectAll Button │</span><br><span class="line">     ▼ ▼    └─────────────────┘</span><br><span class="line">┌─────────┐</span><br><span class="line">│Mediator │</span><br><span class="line">└─────────┘</span><br><span class="line">     ▲ ▲    ┌─────────────────┐</span><br><span class="line">     │ └───&gt;│SelectNone Button│</span><br><span class="line">     │      └─────────────────┘</span><br><span class="line">     │      ┌─────────────────┐</span><br><span class="line">     └─────&gt;│ Inverse Button  │</span><br><span class="line">            └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>下面我们用中介模式来实现各个UI组件的交互。首先把UI组件给画出来：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Main &#123;</span><br><span class="line">    public static void main(String<span class="literal">[]</span> args) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">OrderFrame(<span class="string">&quot;Hanburger&quot;</span>, <span class="string">&quot;Nugget&quot;</span>, <span class="string">&quot;Chip&quot;</span>, <span class="string">&quot;Coffee&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> OrderFrame extends JFrame &#123;</span><br><span class="line">    public <span class="constructor">OrderFrame(String<span class="operator">...</span> <span class="params">names</span>)</span> &#123;</span><br><span class="line">        set<span class="constructor">Title(<span class="string">&quot;Order&quot;</span>)</span>;</span><br><span class="line">        set<span class="constructor">Size(460, 200)</span>;</span><br><span class="line">        set<span class="constructor">DefaultCloseOperation(JFrame.EXIT_ON_CLOSE)</span>;</span><br><span class="line">        Container c = get<span class="constructor">ContentPane()</span>;</span><br><span class="line">        c.set<span class="constructor">Layout(<span class="params">new</span> FlowLayout(FlowLayout.LEADING, 20, 20)</span>);</span><br><span class="line">        c.add(<span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">&quot;Use Mediator Pattern&quot;</span>)</span>);</span><br><span class="line">        List&lt;JCheckBox&gt; checkboxList = add<span class="constructor">CheckBox(<span class="params">names</span>)</span>;</span><br><span class="line">        JButton selectAll = add<span class="constructor">Button(<span class="string">&quot;Select All&quot;</span>)</span>;</span><br><span class="line">        JButton selectNone = add<span class="constructor">Button(<span class="string">&quot;Select None&quot;</span>)</span>;</span><br><span class="line">        selectNone.set<span class="constructor">Enabled(<span class="params">false</span>)</span>;</span><br><span class="line">        JButton selectInverse = add<span class="constructor">Button(<span class="string">&quot;Inverse Select&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">new</span> <span class="constructor">Mediator(<span class="params">checkBoxList</span>, <span class="params">selectAll</span>, <span class="params">selectNone</span>, <span class="params">selectInverse</span>)</span>;</span><br><span class="line">        set<span class="constructor">Visible(<span class="params">true</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;JCheckBox&gt; add<span class="constructor">CheckBox(String<span class="operator">...</span> <span class="params">names</span>)</span> &#123;</span><br><span class="line">        JPanel panel = <span class="keyword">new</span> <span class="constructor">JPanel()</span>;</span><br><span class="line">        panel.add(<span class="keyword">new</span> <span class="constructor">JLabel(<span class="string">&quot;Menu:&quot;</span>)</span>);</span><br><span class="line">        List&lt;JCheckBox&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            JCheckBox checkbox = <span class="keyword">new</span> <span class="constructor">JCheckBox(<span class="params">name</span>)</span>;</span><br><span class="line">            <span class="built_in">list</span>.add(checkbox);</span><br><span class="line">            panel.add(checkbox);</span><br><span class="line">        &#125;</span><br><span class="line">        get<span class="constructor">ContentPane()</span>.add(panel);</span><br><span class="line">        return <span class="built_in">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JButton add<span class="constructor">Button(String <span class="params">label</span>)</span> &#123;</span><br><span class="line">        JButton button = <span class="keyword">new</span> <span class="constructor">JButton(<span class="params">label</span>)</span>;</span><br><span class="line">        get<span class="constructor">ContentPane()</span>.add(button);</span><br><span class="line">        return button;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们设计一个Mediator类，它引用4个UI组件，并负责跟它们交互：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 引用UI组件:</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;JCheckBox&gt; checkBoxList;</span><br><span class="line">    <span class="keyword">private</span> JButton selectAll;</span><br><span class="line">    <span class="keyword">private</span> JButton selectNone;</span><br><span class="line">    <span class="keyword">private</span> JButton selectInverse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="title">Mediator</span>(<span class="params">List&lt;JCheckBox&gt; checkBoxList, JButton selectAll, JButton selectNone, JButton selectInverse</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.checkBoxList = checkBoxList;</span><br><span class="line">        <span class="built_in">this</span>.selectAll = selectAll;</span><br><span class="line">        <span class="built_in">this</span>.selectNone = selectNone;</span><br><span class="line">        <span class="built_in">this</span>.selectInverse = selectInverse;</span><br><span class="line">        <span class="comment">// 绑定事件:</span></span><br><span class="line">        <span class="built_in">this</span>.checkBoxList.forEach(checkBox -&gt; &#123;</span><br><span class="line">            checkBox.addChangeListener(<span class="built_in">this</span>::onCheckBoxChanged);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">this</span>.selectAll.addActionListener(<span class="built_in">this</span>::onSelectAllClicked);</span><br><span class="line">        <span class="built_in">this</span>.selectNone.addActionListener(<span class="built_in">this</span>::onSelectNoneClicked);</span><br><span class="line">        <span class="built_in">this</span>.selectInverse.addActionListener(<span class="built_in">this</span>::onSelectInverseClicked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当checkbox有变化时:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onCheckBoxChanged</span>(<span class="params">ChangeEvent event</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">boolean</span> allChecked = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">boolean</span> allUnchecked = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> checkBox : checkBoxList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkBox.isSelected()) &#123;</span><br><span class="line">                allUnchecked = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                allChecked = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selectAll.setEnabled(!allChecked);</span><br><span class="line">        selectNone.setEnabled(!allUnchecked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select all:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onSelectAllClicked</span>(<span class="params">ActionEvent event</span>)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="literal">true</span>));</span><br><span class="line">        selectAll.setEnabled(<span class="literal">false</span>);</span><br><span class="line">        selectNone.setEnabled(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select none:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onSelectNoneClicked</span>(<span class="params">ActionEvent event</span>)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(<span class="literal">false</span>));</span><br><span class="line">        selectAll.setEnabled(<span class="literal">true</span>);</span><br><span class="line">        selectNone.setEnabled(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当点击select inverse:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onSelectInverseClicked</span>(<span class="params">ActionEvent event</span>)</span> &#123;</span><br><span class="line">        checkBoxList.forEach(checkBox -&gt; checkBox.setSelected(!checkBox.isSelected()));</span><br><span class="line">        onCheckBoxChanged(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一下看看效果：</p>
<p><img src="/6.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.assets/l-164189660629622.png" alt="mediator"></p>
<p>使用Mediator模式后，我们得到了以下好处：</p>
<ul>
<li>各个UI组件互不引用，这样就减少了组件之间的耦合关系；</li>
<li>Mediator用于当一个组件发生状态变化时，根据当前所有组件的状态决定更新某些组件；</li>
<li>如果新增一个UI组件，我们只需要修改Mediator更新状态的逻辑，现有的其他UI组件代码不变。</li>
</ul>
<p>Mediator模式经常用在有众多交互组件的UI上。为了简化UI程序，MVC模式以及MVVM模式都可以看作是Mediator模式的扩展。</p>
<h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><blockquote>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
</blockquote>
<p>备忘录模式（Memento），主要用于捕获一个对象的内部状态，以便在将来的某个时候恢复此状态。</p>
<p>其实我们使用的几乎所有软件都用到了备忘录模式。最简单的备忘录模式就是保存到文件，打开文件。对于文本编辑器来说，保存就是把<code>TextEditor</code>类的字符串存储到文件，打开就是恢复<code>TextEditor</code>类的状态。对于图像编辑器来说，原理是一样的，只是保存和恢复的数据格式比较复杂而已。Java的序列化也可以看作是备忘录模式。</p>
<p>在使用文本编辑器的时候，我们还经常使用Undo、Redo这些功能。这些其实也可以用备忘录模式实现，即不定期地把<code>TextEditor</code>类的字符串复制一份存起来，这样就可以Undo或Redo。</p>
<p>标准的备忘录模式有这么几种角色：</p>
<ul>
<li>Memonto：存储的内部状态；</li>
<li>Originator：创建一个备忘录并设置其状态；</li>
<li>Caretaker：负责保存备忘录。</li>
</ul>
<p>实际上我们在使用备忘录模式的时候，不必设计得这么复杂，只需要对类似<code>TextEditor</code>的类，增加<code>getState()</code>和<code>setState()</code>就可以了。</p>
<p>我们以一个文本编辑器<code>TextEditor</code>为例，它内部使用<code>StringBuilder</code>允许用户增删字符：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> StringBuilder buffer = <span class="keyword">new</span> <span class="built_in">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        buffer.<span class="built_in">append</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">String</span> s)</span> </span>&#123;</span><br><span class="line">        buffer.<span class="built_in">append</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.<span class="built_in">length</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.<span class="built_in">deleteCharAt</span>(buffer.<span class="built_in">length</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了支持这个<code>TextEditor</code>能保存和恢复状态，我们增加<code>getState()</code>和<code>setState()</code>两个方法：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextEditor</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取状态:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">String</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer.<span class="built_in">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复状态:</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">String</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer.<span class="built_in"><span class="keyword">delete</span></span>(<span class="number">0</span>, <span class="keyword">this</span>.buffer.<span class="built_in">length</span>());</span><br><span class="line">        <span class="keyword">this</span>.buffer.<span class="built_in">append</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对这个简单的文本编辑器，用一个<code>String</code>就可以表示其状态，对于复杂的对象模型，通常我们会使用JSON、XML等复杂格式。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
<p>观察者模式（Observer）又称发布-订阅模式（Publish-Subscribe：Pub&#x2F;Sub）。它是一种通知机制，让发送通知的一方（被观察方）和接收通知的一方（观察者）能彼此分离，互不影响。</p>
<p>要理解观察者模式，我们还是看例子。</p>
<p>假设一个电商网站，有多种<code>Product</code>（商品），同时，<code>Customer</code>（消费者）和<code>Admin</code>（管理员）对商品上架、价格改变都感兴趣，希望能第一时间获得通知。于是，<code>Store</code>（商场）可以这么写：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Store &#123;</span><br><span class="line">    Customer customer;</span><br><span class="line">    Admin admin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; products = <span class="keyword">new</span> HashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    public void add<span class="constructor">NewProduct(String <span class="params">name</span>, <span class="params">double</span> <span class="params">price</span>)</span> &#123;</span><br><span class="line">        Product p = <span class="keyword">new</span> <span class="constructor">Product(<span class="params">name</span>, <span class="params">price</span>)</span>;</span><br><span class="line">        products.put(p.get<span class="constructor">Name()</span>, p);</span><br><span class="line">        <span class="comment">// 通知用户:</span></span><br><span class="line">        customer.on<span class="constructor">Published(<span class="params">p</span>)</span>;</span><br><span class="line">        <span class="comment">// 通知管理员:</span></span><br><span class="line">        admin.on<span class="constructor">Published(<span class="params">p</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set<span class="constructor">ProductPrice(String <span class="params">name</span>, <span class="params">double</span> <span class="params">price</span>)</span> &#123;</span><br><span class="line">        Product p = products.get(name);</span><br><span class="line">        p.set<span class="constructor">Price(<span class="params">price</span>)</span>;</span><br><span class="line">        <span class="comment">// 通知用户:</span></span><br><span class="line">        customer.on<span class="constructor">PriceChanged(<span class="params">p</span>)</span>;</span><br><span class="line">        <span class="comment">// 通知管理员:</span></span><br><span class="line">        admin.on<span class="constructor">PriceChanged(<span class="params">p</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们观察上述<code>Store</code>类的问题：它直接引用了<code>Customer</code>和<code>Admin</code>。先不考虑多个<code>Customer</code>或多个<code>Admin</code>的问题，上述<code>Store</code>类最大的问题是，如果要加一个新的观察者类型，例如工商局管理员，<code>Store</code>类就必须继续改动。</p>
<p>因此，上述问题的本质是<code>Store</code>希望发送通知给那些关心<code>Product</code>的对象，但<code>Store</code>并不想知道这些人是谁。观察者模式就是要分离被观察者和观察者之间的耦合关系。</p>
<p>要实现这一目标也很简单，<code>Store</code>不能直接引用<code>Customer</code>和<code>Admin</code>，相反，它引用一个<code>ProductObserver</code>接口，任何人想要观察<code>Store</code>，只要实现该接口，并且把自己注册到<code>Store</code>即可：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> Store &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ProductObserver&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;<span class="literal">()</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Product&gt; products = <span class="keyword">new</span> HashMap&lt;&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册观察者:</span></span><br><span class="line">    public void add<span class="constructor">Observer(ProductObserver <span class="params">observer</span>)</span> &#123;</span><br><span class="line">        this.observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消注册:</span></span><br><span class="line">    public void remove<span class="constructor">Observer(ProductObserver <span class="params">observer</span>)</span> &#123;</span><br><span class="line">        this.observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add<span class="constructor">NewProduct(String <span class="params">name</span>, <span class="params">double</span> <span class="params">price</span>)</span> &#123;</span><br><span class="line">        Product p = <span class="keyword">new</span> <span class="constructor">Product(<span class="params">name</span>, <span class="params">price</span>)</span>;</span><br><span class="line">        products.put(p.get<span class="constructor">Name()</span>, p);</span><br><span class="line">        <span class="comment">// 通知观察者:</span></span><br><span class="line">        observers.<span class="keyword">for</span><span class="constructor">Each(<span class="params">o</span> -&gt; <span class="params">o</span>.<span class="params">onPublished</span>(<span class="params">p</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void set<span class="constructor">ProductPrice(String <span class="params">name</span>, <span class="params">double</span> <span class="params">price</span>)</span> &#123;</span><br><span class="line">        Product p = products.get(name);</span><br><span class="line">        p.set<span class="constructor">Price(<span class="params">price</span>)</span>;</span><br><span class="line">        <span class="comment">// 通知观察者:</span></span><br><span class="line">        observers.<span class="keyword">for</span><span class="constructor">Each(<span class="params">o</span> -&gt; <span class="params">o</span>.<span class="params">onPriceChanged</span>(<span class="params">p</span>)</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就是这么一个小小的改动，使得观察者类型就可以无限扩充，而且，观察者的定义可以放到客户端：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// observer:</span></span><br><span class="line">Admin a = <span class="keyword">new</span> <span class="constructor">Admin()</span>;</span><br><span class="line">Customer c = <span class="keyword">new</span> <span class="constructor">Customer()</span>;</span><br><span class="line"><span class="comment">// store:</span></span><br><span class="line">Store store = <span class="keyword">new</span> <span class="constructor">Store()</span>;</span><br><span class="line"><span class="comment">// 注册观察者:</span></span><br><span class="line">store.add<span class="constructor">Observer(<span class="params">a</span>)</span>;</span><br><span class="line">store.add<span class="constructor">Observer(<span class="params">c</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>甚至可以注册匿名观察者：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">store.addObserver(<span class="keyword">new</span> <span class="function"><span class="title">ProductObserver</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onPublished</span>(<span class="params">Product product</span>)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Log] on product published: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onPriceChanged</span>(<span class="params">Product product</span>)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[Log] on product price changed: &quot;</span> + product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>用一张图画出观察者模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─────────┐      ┌───────────────┐</span><br><span class="line">│  Store  │─ ─ ─&gt;│ProductObserver│</span><br><span class="line">└─────────┘      └───────────────┘</span><br><span class="line">     │                   ▲</span><br><span class="line">                         │</span><br><span class="line">     │             ┌─────┴─────┐</span><br><span class="line">     ▼             │           │</span><br><span class="line">┌─────────┐   ┌─────────┐ ┌─────────┐</span><br><span class="line">│ Product │   │  Admin  │ │Customer │ ...</span><br><span class="line">└─────────┘   └─────────┘ └─────────┘</span><br></pre></td></tr></table></figure>

<p>观察者模式也有很多变体形式。有的观察者模式把被观察者也抽象出接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductObservable</span> </span>&#123; <span class="comment">// 注意此处拼写是Observable不是Observer!</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(ProductObserver observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(ProductObserver observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的实体被观察者就要实现该接口：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Store</span> <span class="symbol">implements</span> <span class="symbol">ProductObservable</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些观察者模式把通知变成一个Event对象，从而不再有多种方法通知，而是统一成一种：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ProductObserver</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span>(<span class="params">ProductEvent <span class="keyword">event</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让观察者自己从Event对象中读取通知类型和通知数据。</p>
<p>广义的观察者模式包括所有消息系统。所谓消息系统，就是把观察者和被观察者完全分离，通过消息系统本身来通知：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                 ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">                   Messaging System</span><br><span class="line">                 │                       │</span><br><span class="line">                   ┌──────────────────┐</span><br><span class="line">              ┌──┼&gt;│Topic:newProduct  │──┼─┐    ┌─────────┐</span><br><span class="line">              │    └──────────────────┘    ├───&gt;│ConsumerA│</span><br><span class="line">┌─────────┐   │  │ ┌──────────────────┐  │ │    └─────────┘</span><br><span class="line">│Producer │───┼───&gt;│Topic:priceChanged│────┘</span><br><span class="line">└─────────┘   │  │ └──────────────────┘  │</span><br><span class="line">              │    ┌──────────────────┐         ┌─────────┐</span><br><span class="line">              └──┼&gt;│Topic:soldOut     │──┼─────&gt;│ConsumerB│</span><br><span class="line">                   └──────────────────┘         └─────────┘</span><br><span class="line">                 └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>

<p>消息发送方称为Producer，消息接收方称为Consumer，Producer发送消息的时候，必须选择发送到哪个Topic。Consumer可以订阅自己感兴趣的Topic，从而只获得特定类型的消息。</p>
<p>使用消息系统实现观察者模式时，Producer和Consumer甚至经常不在同一台机器上，并且双方对对方完全一无所知，因为注册观察者这个动作本身都在消息系统中完成，而不是在Producer内部完成。</p>
<p>此外，注意到我们在编写观察者模式的时候，通知Observer是依靠语句：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observers.<span class="keyword">for</span><span class="constructor">Each(<span class="params">o</span> -&gt; <span class="params">o</span>.<span class="params">onPublished</span>(<span class="params">p</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>这说明各个观察者是依次获得的同步通知，如果上一个观察者处理太慢，会导致下一个观察者不能及时获得通知。此外，如果观察者在处理通知的时候，发生了异常，还需要被观察者处理异常，才能保证继续通知下一个观察者。</p>
<p>思考：如何改成异步通知，使得所有观察者可以并发同时处理？</p>
<p>有的童鞋可能发现Java标准库有个<code>java.util.Observable</code>类和一个<code>Observer</code>接口，用来帮助我们实现观察者模式。但是，这个类非常不！好！用！实现观察者模式的时候，也不推荐借助这两个东东。</p>
<h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p>
</blockquote>
<p>状态模式（State）经常用在带有状态的对象中。</p>
<p>什么是状态？我们以QQ聊天为例，一个用户的QQ有几种状态：</p>
<ul>
<li>离线状态（尚未登录）；</li>
<li>正在登录状态；</li>
<li>在线状态；</li>
<li>忙状态（暂时离开）。</li>
</ul>
<p>如何表示状态？我们定义一个<code>enum</code>就可以表示不同的状态。但不同的状态需要对应不同的行为，比如收到消息时：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="keyword">state</span> == ONLINE) &#123;</span><br><span class="line">    // 闪烁图标</span><br><span class="line">&#125; else if (<span class="keyword">state</span> == BUSY) &#123;</span><br><span class="line">    reply(<span class="string">&quot;现在忙，稍后回复&quot;</span>);</span><br><span class="line">&#125; else if ...</span><br></pre></td></tr></table></figure>

<p>状态模式的目的是为了把上述一大串<code>if...else...</code>的逻辑给分拆到不同的状态类中，使得将来增加状态比较容易。</p>
<p>例如，我们设计一个聊天机器人，它有两个状态：</p>
<ul>
<li>未连线；</li>
<li>已连线。</li>
</ul>
<p>对于未连线状态，我们收到消息也不回复：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DisconnectedState</span> <span class="title">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bye!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">reply</span>(<span class="params"><span class="built_in">String</span> input</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于已连线状态，我们回应收到的消息：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> ConnectedState implements State &#123;</span><br><span class="line">    <span class="built_in">public</span> String init() &#123;</span><br><span class="line">        <span class="keyword">return</span> &quot;Hello, I&#x27;m Bob.&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> String reply(String <span class="keyword">input</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">input</span>.endsWith(&quot;?&quot;)) &#123;</span><br><span class="line">            <span class="keyword">return</span> &quot;Yes. &quot; + <span class="keyword">input</span>.substring(<span class="number">0</span>, <span class="keyword">input</span>.length() - <span class="number">1</span>) + &quot;!&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">input</span>.endsWith(&quot;.&quot;)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">input</span>.substring(<span class="number">0</span>, <span class="keyword">input</span>.length() - <span class="number">1</span>) + &quot;!&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">input</span>.substring(<span class="number">0</span>, <span class="keyword">input</span>.length() - <span class="number">1</span>) + &quot;?&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态模式的关键设计思想在于状态切换，我们引入一个<code>BotContext</code>完成状态切换：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class BotContext &#123;</span><br><span class="line">	private State <span class="keyword">state</span> = new DisconnectedState();</span><br><span class="line"></span><br><span class="line">	public String chat(String input) &#123;</span><br><span class="line">		if (<span class="string">&quot;hello&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class="line">            // 收到hello切换到在线状态:</span><br><span class="line">			<span class="keyword">state</span> = new ConnectedState();</span><br><span class="line">			return <span class="keyword">state</span>.init();</span><br><span class="line">		&#125; else if (<span class="string">&quot;bye&quot;</span>.equalsIgnoreCase(input)) &#123;</span><br><span class="line">            /  收到bye切换到离线状态:</span><br><span class="line">			<span class="keyword">state</span> = new DisconnectedState();</span><br><span class="line">			return <span class="keyword">state</span>.init();</span><br><span class="line">		&#125;</span><br><span class="line">		return <span class="keyword">state</span>.reply(input);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，一个价值千万的AI聊天机器人就诞生了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scanner scanner = <span class="keyword">new</span> <span class="constructor">Scanner(System.<span class="params">in</span>)</span>;</span><br><span class="line">BotContext bot = <span class="keyword">new</span> <span class="constructor">BotContext()</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print(<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">    String input = scanner.next<span class="constructor">Line()</span>;</span><br><span class="line">    String output = bot.chat(input);</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(output.is<span class="constructor">Empty()</span> ? <span class="string">&quot;(no reply)&quot;</span> : <span class="string">&quot;&lt; &quot;</span> + output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>试试效果：</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span> <span class="javascript">hello</span></span><br><span class="line">&lt; Hello, I&#x27;m Bob.</span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript">Nice to meet you.</span></span><br><span class="line">&lt; Nice to meet you!</span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript">Today is cold?</span></span><br><span class="line">&lt; Yes. Today is cold!</span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript">bye</span></span><br><span class="line">&lt; Bye!</span><br></pre></td></tr></table></figure>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。</p>
</blockquote>
<p>策略模式：Strategy，是指，定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p>
<p>策略模式在Java标准库中应用非常广泛，我们以排序为例，看看如何通过<code>Arrays.sort()</code>实现忽略大小写排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br></pre></td></tr></table></figure>

<p> Run</p>
<p>如果我们想忽略大小写排序，就传入<code>String::compareToIgnoreCase</code>，如果我们想倒序排序，就传入<code>(s1, s2) -&gt; -s1.compareTo(s2)</code>，这个比较两个元素大小的算法就是策略。</p>
<p>我们观察<code>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)</code>这个排序方法，它在内部实现了TimSort排序，但是，排序算法在比较两个元素大小的时候，需要借助我们传入的<code>Comparator</code>对象，才能完成比较。因此，这里的策略是指比较两个元素大小的策略，可以是忽略大小写比较，可以是倒序比较，也可以根据字符串长度比较。</p>
<p>因此，上述排序使用到了策略模式，它实际上指，在一个方法中，流程是确定的，但是，某些关键步骤的算法依赖调用方传入的策略，这样，传入不同的策略，即可获得不同的结果，大大增强了系统的灵活性。</p>
<p>如果我们自己实现策略模式的排序，用冒泡法编写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure>

<p> Run</p>
<p>一个完整的策略模式要定义策略以及使用策略的上下文。我们以购物车结算为例，假设网站针对普通会员、Prime会员有不同的折扣，同时活动期间还有一个满100减20的活动，这些就可以作为策略实现。先定义打折策略接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算折扣额度:</span></span><br><span class="line">    <span class="function">BigDecimal <span class="title">getDiscount</span><span class="params">(BigDecimal total)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，就是实现各种策略。普通用户策略如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDiscountStrategy</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">DiscountStrategy</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> BigDecimal getDiscount(BigDecimal total) &#123;</span><br><span class="line">        <span class="comment">// 普通会员打九折:</span></span><br><span class="line">        <span class="keyword">return</span> total.multiply(<span class="keyword">new</span> <span class="type">BigDecimal</span>(<span class="string">&quot;0.1&quot;</span>)).setScale(<span class="number">2</span>, RoundingMode.DOWN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>满减策略如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> OverDiscountStrategy implements DiscountStrategy &#123;</span><br><span class="line">    public BigDecimal get<span class="constructor">Discount(BigDecimal <span class="params">total</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 满100减20优惠:</span></span><br><span class="line">        return total.compare<span class="constructor">To(BigDecimal.<span class="params">valueOf</span>(100)</span>) &gt;= <span class="number">0</span> ? <span class="module-access"><span class="module"><span class="identifier">BigDecimal</span>.</span></span>value<span class="constructor">Of(20)</span> : BigDecimal.ZERO;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，要应用策略，我们需要一个<code>DiscountContext</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有某个策略:</span></span><br><span class="line">    <span class="keyword">private</span> DiscountStrategy strategy = <span class="keyword">new</span> UserDiscountStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许客户端设置新策略:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">setStrategy</span>(<span class="params">DiscountStrategy strategy</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="function"><span class="title">calculatePrice</span>(<span class="params">BigDecimal total</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> total.subtract(<span class="built_in">this</span>.strategy.getDiscount(total)).setScale(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方必须首先创建一个DiscountContext，并指定一个策略（或者使用默认策略），即可获得折扣后的价格：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DiscountContext ctx = <span class="keyword">new</span> <span class="constructor">DiscountContext()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认使用普通会员折扣:</span></span><br><span class="line">BigDecimal pay1 = ctx.calculate<span class="constructor">Price(BigDecimal.<span class="params">valueOf</span>(105)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(pay1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用满减折扣:</span></span><br><span class="line">ctx.set<span class="constructor">Strategy(<span class="params">new</span> OverDiscountStrategy()</span>);</span><br><span class="line">BigDecimal pay2 = ctx.calculate<span class="constructor">Price(BigDecimal.<span class="params">valueOf</span>(105)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(pay2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Prime会员折扣:</span></span><br><span class="line">ctx.set<span class="constructor">Strategy(<span class="params">new</span> PrimeDiscountStrategy()</span>);</span><br><span class="line">BigDecimal pay3 = ctx.calculate<span class="constructor">Price(BigDecimal.<span class="params">valueOf</span>(105)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(pay3);</span><br></pre></td></tr></table></figure>

<p>上述完整的策略模式如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐      ┌─────────────────┐</span><br><span class="line">│DiscountContext│─ ─ ─&gt;│DiscountStrategy │</span><br><span class="line">└───────────────┘      └─────────────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                ├─│UserDiscountStrategy │</span><br><span class="line">                                │ └─────────────────────┘</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                ├─│PrimeDiscountStrategy│</span><br><span class="line">                                │ └─────────────────────┘</span><br><span class="line">                                │ ┌─────────────────────┐</span><br><span class="line">                                └─│OverDiscountStrategy │</span><br><span class="line">                                  └─────────────────────┘</span><br></pre></td></tr></table></figure>

<p>策略模式的核心思想是在一个计算方法中把容易变化的算法抽出来作为“策略”参数传进去，从而使得新增策略不必修改原有逻辑。</p>
<h2 id="模式方法模板"><a href="#模式方法模板" class="headerlink" title="模式方法模板"></a>模式方法模板</h2><blockquote>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
</blockquote>
<p>模板方法（Template Method）是一个比较简单的模式。它的主要思想是，定义一个操作的一系列步骤，对于某些暂时确定不下来的步骤，就留给子类去实现好了，这样不同的子类就可以定义出不同的步骤。</p>
<p>因此，模板方法的核心在于定义一个“骨架”。我们还是举例说明。</p>
<p>假设我们开发了一个从数据库读取设置的类：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Setting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> final <span class="built_in">String</span> <span class="function"><span class="title">getSetting</span>(<span class="params"><span class="built_in">String</span> key</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">String</span> value = readFromDatabase(key);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">String</span> <span class="function"><span class="title">readFromDatabase</span>(<span class="params"><span class="built_in">String</span> key</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库读取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于从数据库读取数据较慢，我们可以考虑把读取的设置缓存起来，这样下一次读取同样的key就不必再访问数据库了。但是怎么实现缓存，暂时没想好，但不妨碍我们先写出使用缓存的代码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Setting &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> getSetting(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        <span class="comment">// 先从缓存读取:</span></span><br><span class="line">        <span class="keyword">String</span> value = lookupCache(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在缓存中未找到,从数据库读取:</span></span><br><span class="line">            value = readFromDatabase(<span class="built_in">key</span>);</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;[DEBUG] load from db: &quot;</span> + <span class="built_in">key</span> + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">            <span class="comment">// 放入缓存:</span></span><br><span class="line">            putIntoCache(<span class="built_in">key</span>, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;[DEBUG] load from cache: &quot;</span> + <span class="built_in">key</span> + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个流程没有问题，但是，<code>lookupCache(key)</code>和<code>putIntoCache(key, value)</code>这两个方法还根本没实现，怎么编译通过？这个不要紧，我们声明抽象方法就可以：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class AbstractSetting &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">String</span> getSetting(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">        <span class="keyword">String</span> value = lookupCache(<span class="built_in">key</span>);</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            value = readFromDatabase(<span class="built_in">key</span>);</span><br><span class="line">            putIntoCache(<span class="built_in">key</span>, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">String</span> lookupCache(<span class="keyword">String</span> <span class="built_in">key</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> putIntoCache(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">String</span> value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为声明了抽象方法，自然整个类也必须是抽象类。如何实现<code>lookupCache(key)</code>和<code>putIntoCache(key, value)</code>这两个方法就交给子类了。子类其实并不关心核心代码<code>getSetting(key)</code>的逻辑，它只需要关心如何完成两个小小的子任务就可以了。</p>
<p>假设我们希望用一个<code>Map</code>做缓存，那么可以写一个<code>LocalSetting</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalSetting</span> <span class="keyword">extends</span> <span class="title">AbstractSetting</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">String</span> <span class="function"><span class="title">lookupCache</span>(<span class="params"><span class="built_in">String</span> key</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">void</span> <span class="function"><span class="title">putIntoCache</span>(<span class="params"><span class="built_in">String</span> key, <span class="built_in">String</span> value</span>)</span> &#123;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们要使用Redis做缓存，那么可以再写一个<code>RedisSetting</code>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisSetting</span> <span class="title">extends</span> <span class="title">AbstractSetting</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> RedisClient client = RedisClient.<span class="built_in">create</span>(<span class="string">&quot;redis://localhost:6379&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">String</span> <span class="title">lookupCache</span><span class="params">(<span class="keyword">String</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">try</span></span> (StatefulRedisConnection&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; connection = client.<span class="built_in">connect</span>()) &#123;</span><br><span class="line">            RedisCommands&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; commands = connection.<span class="built_in">sync</span>();</span><br><span class="line">            <span class="keyword">return</span> commands.<span class="built_in">get</span>(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">putIntoCache</span><span class="params">(<span class="keyword">String</span> key, <span class="keyword">String</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">try</span></span> (StatefulRedisConnection&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; connection = client.<span class="built_in">connect</span>()) &#123;</span><br><span class="line">            RedisCommands&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; commands = connection.<span class="built_in">sync</span>();</span><br><span class="line">            commands.<span class="built_in">set</span>(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码使用本地缓存的代码这么写：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractSetting setting1 = <span class="keyword">new</span> <span class="constructor">LocalSetting()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;test = &quot;</span> + setting1.get<span class="constructor">Setting(<span class="string">&quot;test&quot;</span>)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;test = &quot;</span> + setting1.get<span class="constructor">Setting(<span class="string">&quot;test&quot;</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>要改成Redis缓存，只需要把<code>LocalSetting</code>替换为<code>RedisSetting</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbstractSetting setting2 = <span class="keyword">new</span> <span class="constructor">RedisSetting()</span>;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;autosave = &quot;</span> + setting2.get<span class="constructor">Setting(<span class="string">&quot;autosave&quot;</span>)</span>);</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(<span class="string">&quot;autosave = &quot;</span> + setting2.get<span class="constructor">Setting(<span class="string">&quot;autosave&quot;</span>)</span>);</span><br></pre></td></tr></table></figure>

<p>可见，模板方法的核心思想是：父类定义骨架，子类实现某些细节。</p>
<p>为了防止子类重写父类的骨架方法，可以在父类中对骨架方法使用<code>final</code>。对于需要子类实现的抽象方法，一般声明为<code>protected</code>，使得这些方法对外部客户端不可见。</p>
<p>Java标准库也有很多模板方法的应用。在集合类中，<code>AbstractList</code>和<code>AbstractQueuedSynchronizer</code>都定义了很多通用操作，子类只需要实现某些必要方法。</p>
<h2 id="3-11-访问者模式"><a href="#3-11-访问者模式" class="headerlink" title="3.11 访问者模式"></a>3.11 访问者模式</h2><blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p>访问者模式（Visitor）是一种操作一组对象的操作，它的目的是不改变对象的定义，但允许新增不同的访问者，来定义新的操作。</p>
<p>访问者模式的设计比较复杂，如果我们查看GoF原始的访问者模式，它是这么设计的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   ┌─────────┐       ┌───────────────────────┐</span><br><span class="line">   │ Client  │─ ─ ─ &gt;│        Visitor        │</span><br><span class="line">   └─────────┘       ├───────────────────────┤</span><br><span class="line">        │            │visitElementA(ElementA)│</span><br><span class="line">                     │visitElementB(ElementB)│</span><br><span class="line">        │            └───────────────────────┘</span><br><span class="line">                                 ▲</span><br><span class="line">        │                ┌───────┴───────┐</span><br><span class="line">                         │               │</span><br><span class="line">        │         ┌─────────────┐ ┌─────────────┐</span><br><span class="line">                  │  VisitorA   │ │  VisitorB   │</span><br><span class="line">        │         └─────────────┘ └─────────────┘</span><br><span class="line">        ▼</span><br><span class="line">┌───────────────┐        ┌───────────────┐</span><br><span class="line">│ObjectStructure│─ ─ ─ ─&gt;│    Element    │</span><br><span class="line">├───────────────┤        ├───────────────┤</span><br><span class="line">│handle(Visitor)│        │accept(Visitor)│</span><br><span class="line">└───────────────┘        └───────────────┘</span><br><span class="line">                                 ▲</span><br><span class="line">                        ┌────────┴────────┐</span><br><span class="line">                        │                 │</span><br><span class="line">                ┌───────────────┐ ┌───────────────┐</span><br><span class="line">                │   ElementA    │ │   ElementB    │</span><br><span class="line">                ├───────────────┤ ├───────────────┤</span><br><span class="line">                │accept(Visitor)│ │accept(Visitor)│</span><br><span class="line">                │doA()          │ │doB()          │</span><br><span class="line">                └───────────────┘ └───────────────┘</span><br></pre></td></tr></table></figure>

<p>上述模式的复杂之处在于上述访问者模式为了实现所谓的“双重分派”，设计了一个回调再回调的机制。因为Java只支持基于多态的单分派模式，这里强行模拟出“双重分派”反而加大了代码的复杂性。</p>
<p>这里我们只介绍简化的访问者模式。假设我们要递归遍历某个文件夹的所有子文件夹和文件，然后找出<code>.java</code>文件，正常的做法是写个递归：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void<span class="meta"> scan(</span><span class="meta">File</span> dir, <span class="meta">List</span>&lt;<span class="meta">File</span>&gt; collector) &#123;</span><br><span class="line">    for (<span class="meta">File</span> <span class="meta">file</span> : dir.listFiles()) &#123;</span><br><span class="line">        <span class="meta">if</span> (<span class="meta">file</span>.isFile() <span class="variable">&amp;&amp;</span> <span class="meta">file</span>.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">            collector.<span class="meta">add</span>(<span class="meta">file</span>);</span><br><span class="line">        &#125; <span class="meta">else</span> <span class="meta">if</span> (<span class="meta">file</span>.isDir()) &#123;</span><br><span class="line">            // 递归调用:</span><br><span class="line">           <span class="meta"> scan(</span><span class="meta">file</span>, collector);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码的问题在于，扫描目录的逻辑和处理.java文件的逻辑混在了一起。如果下次需要增加一个清理<code>.class</code>文件的功能，就必须再重复写扫描逻辑。</p>
<p>因此，访问者模式先把数据结构（这里是文件夹和文件构成的树型结构）和对其的操作（查找文件）分离开，以后如果要新增操作（例如清理<code>.class</code>文件），只需要新增访问者，不需要改变现有逻辑。</p>
<p>用访问者模式改写上述代码步骤如下：</p>
<p>首先，我们需要定义访问者接口，即该访问者能够干的事情：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface Visitor &#123;</span><br><span class="line">    <span class="comment">// 访问文件夹:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitDir</span><span class="params">(<span class="built_in">File</span> dir)</span></span>;</span><br><span class="line">    <span class="comment">// 访问文件:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitFile</span><span class="params">(<span class="built_in">File</span> file)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着，我们要定义能持有文件夹和文件的数据结构<code>FileStructure</code>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileStructure</span> &#123;</span></span><br><span class="line">    <span class="comment">// 根目录:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">File</span> path;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileStructure</span><span class="params">(<span class="built_in">File</span> path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们给<code>FileStructure</code>增加一个<code>handle()</code>方法，传入一个访问者：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> FileStructure &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> handle(Visitor visitor) &#123;</span><br><span class="line">		scan(<span class="keyword">this</span>.path, visitor);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> scan(<span class="keyword">File</span> <span class="keyword">file</span>, Visitor visitor) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">file</span>.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 让访问者处理文件夹:</span></span><br><span class="line">			visitor.visitDir(<span class="keyword">file</span>);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">File</span> sub : <span class="keyword">file</span>.listFiles()) &#123;</span><br><span class="line">                <span class="comment">// 递归处理子文件夹:</span></span><br><span class="line">				scan(sub, visitor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">file</span>.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 让访问者处理文件:</span></span><br><span class="line">			visitor.visitFile(<span class="keyword">file</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就把访问者的行为抽象出来了。如果我们要实现一种操作，例如，查找<code>.java</code>文件，就传入<code>JavaFileVisitor</code>：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileStructure fs = <span class="keyword">new</span> <span class="type">FileStructure</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">fs.handle(<span class="keyword">new</span> <span class="type">JavaFileVisitor</span>());</span><br></pre></td></tr></table></figure>

<p>这个<code>JavaFileVisitor</code>实现如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> JavaFileVisitor <span class="keyword">implements</span> Visitor &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> visitDir(<span class="keyword">File</span> dir) &#123;</span><br><span class="line">        System.out.<span class="keyword">println</span>(<span class="string">&quot;Visit dir: &quot;</span> + dir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> visitFile(<span class="keyword">File</span> <span class="keyword">file</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">file</span>.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(<span class="string">&quot;Found java file: &quot;</span> + <span class="keyword">file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，如果要清理<code>.class</code>文件，可以再写一个<code>ClassFileClearnerVisitor</code>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ClassFileCleanerVisitor <span class="keyword">implements</span> Visitor &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> visitDir(<span class="keyword">File</span> dir) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> visitFile(<span class="keyword">File</span> <span class="keyword">file</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">file</span>.getName().endsWith(<span class="string">&quot;.class&quot;</span>)) &#123;</span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">&quot;Will clean class file: &quot;</span> + <span class="keyword">file</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，访问者模式的核心思想是为了访问比较复杂的数据结构，不去改变数据结构，而是把对数据的操作抽象出来，在“访问”的过程中以回调形式在访问者中处理操作逻辑。如果要新增一组操作，那么只需要增加一个新的访问者。</p>
<p>实际上，Java标准库提供的<code>Files.walkFileTree()</code>已经实现了一个访问者模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.*;</span><br></pre></td></tr></table></figure>

<p> Run</p>
<p><code>Files.walkFileTree()</code>允许访问者返回<code>FileVisitResult.CONTINUE</code>以便继续访问，或者返回<code>FileVisitResult.TERMINATE</code>停止访问。</p>
<p>类似的，对XML的SAX处理也是一个访问者模式，我们需要提供一个SAX Handler作为访问者处理XML的各个节点。</p>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="prev" title="5.函数式编程">
                  <i class="fa fa-chevron-left"></i> 5.函数式编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/04/4-Java_5.JavaEE%E8%BF%9B%E9%98%B6_7.%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="next" title="7.中间件">
                  7.中间件 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
