<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="描述：Java. 轻量级应用框架什么是Spring？ Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。 ![java-spring](2.Spring 5.assets&#x2F;l.jpeg) Spring最早是由Rod Johnson这哥们在他的《Expert One-o">
<meta property="og:type" content="article">
<meta property="og:title" content="2.Spring 5">
<meta property="og:url" content="https://2673747024.github.io/2022/02/04/Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_2.Spring%205/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="描述：Java. 轻量级应用框架什么是Spring？ Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。 ![java-spring](2.Spring 5.assets&#x2F;l.jpeg) Spring最早是由Rod Johnson这哥们在他的《Expert One-o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.liaoxuefeng.com/files/attachments/1352171687772226/l">
<meta property="og:image" content="https://www.liaoxuefeng.com/files/attachments/1352171742298178/l">
<meta property="og:image" content="https://www.liaoxuefeng.com/files/attachments/1352172098814018/l">
<meta property="og:image" content="https://www.liaoxuefeng.com/files/attachments/1352172147048514/l">
<meta property="og:image" content="https://www.liaoxuefeng.com/files/attachments/1352172193185858/l">
<meta property="og:image" content="https://www.liaoxuefeng.com/files/attachments/1352172895731745/l">
<meta property="article:published_time" content="2022-02-04T14:29:23.016Z">
<meta property="article:modified_time" content="2022-02-04T15:01:35.200Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.liaoxuefeng.com/files/attachments/1352171687772226/l">


<link rel="canonical" href="https://2673747024.github.io/2022/02/04/Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_2.Spring%205/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/04/Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_2.Spring%205/","path":"2022/02/04/Java_4.开发框架_2.Spring 5/","title":"2.Spring 5"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>2.Spring 5 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8F%8F%E8%BF%B0%EF%BC%9AJava-%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6"><span class="nav-number">1.</span> <span class="nav-text">描述：Java. 轻量级应用框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Framework"><span class="nav-number">1.0.1.</span> <span class="nav-text">Spring Framework</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IOC%E5%AE%B9%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">IOC容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IOC%E5%8E%9F%E7%90%86"><span class="nav-number">2.2.</span> <span class="nav-text">IOC原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">依赖注入方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E4%BE%B5%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">2.2.2.</span> <span class="nav-text">无侵入容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%85%8DBean"><span class="nav-number">2.3.</span> <span class="nav-text">装配Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ApplicationContext"><span class="nav-number">2.3.1.</span> <span class="nav-text">ApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Annotation%E9%85%8D%E7%BD%AE"><span class="nav-number">2.4.</span> <span class="nav-text">使用Annotation配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%80%83"><span class="nav-number">2.4.1.</span> <span class="nav-text">思考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E5%88%B6Bean"><span class="nav-number">2.5.</span> <span class="nav-text">定制Bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scope"><span class="nav-number">2.5.1.</span> <span class="nav-text">Scope</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5List"><span class="nav-number">2.5.2.</span> <span class="nav-text">注入List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E6%B3%A8%E5%85%A5"><span class="nav-number">2.5.3.</span> <span class="nav-text">可选注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%89%E6%96%B9Bean"><span class="nav-number">2.5.4.</span> <span class="nav-text">创建第三方Bean</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81"><span class="nav-number">2.5.5.</span> <span class="nav-text">初始化和销毁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%AB%E5%90%8D"><span class="nav-number">2.5.6.</span> <span class="nav-text">使用别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8FactoryBean"><span class="nav-number">2.5.7.</span> <span class="nav-text">使用FactoryBean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Resource"><span class="nav-number">2.6.</span> <span class="nav-text">使用Resource</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AE"><span class="nav-number">2.7.</span> <span class="nav-text">注入配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E8%A3%85%E9%85%8D"><span class="nav-number">2.8.</span> <span class="nav-text">使用条件装配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Conditional"><span class="nav-number">2.8.1.</span> <span class="nav-text">使用Conditional</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8AOP"><span class="nav-number">3.</span> <span class="nav-text">使用AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">3.1.</span> <span class="nav-text">简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP%E5%8E%9F%E7%90%86"><span class="nav-number">3.1.1.</span> <span class="nav-text">AOP原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E9%85%8DAOP"><span class="nav-number">3.2.</span> <span class="nav-text">装配AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.2.1.</span> <span class="nav-text">拦截器类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%A3%85%E9%85%8DAOP"><span class="nav-number">3.3.</span> <span class="nav-text">使用注解装配AOP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97"><span class="nav-number">3.4.</span> <span class="nav-text">AOP避坑指南</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%82%A5%E5%9B%9B%EF%BC%9F"><span class="nav-number">3.4.1.</span> <span class="nav-text">怎么肥四？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%80%83-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">思考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">4.</span> <span class="nav-text">4. 访问数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-0-%E7%AE%80%E4%BB%8B"><span class="nav-number">4.1.</span> <span class="nav-text">4.0 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%BD%BF%E7%94%A8%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.2.</span> <span class="nav-text">4.1 使用声明式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JdbcTemplate%E7%94%A8%E6%B3%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">JdbcTemplate用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E4%BD%BF%E7%94%A8DAO"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 使用DAO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E9%9B%86%E6%88%90Hibernate"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 集成Hibernate</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Insert%E6%93%8D%E4%BD%9C"><span class="nav-number">4.4.1.</span> <span class="nav-text">Insert操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delete%E6%93%8D%E4%BD%9C"><span class="nav-number">4.4.2.</span> <span class="nav-text">Delete操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Update%E6%93%8D%E4%BD%9C"><span class="nav-number">4.4.3.</span> <span class="nav-text">Update操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Example%E6%9F%A5%E8%AF%A2"><span class="nav-number">4.4.4.</span> <span class="nav-text">使用Example查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Criteria%E6%9F%A5%E8%AF%A2"><span class="nav-number">4.4.5.</span> <span class="nav-text">使用Criteria查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8HQL%E6%9F%A5%E8%AF%A2"><span class="nav-number">4.4.6.</span> <span class="nav-text">使用HQL查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Hibernate%E5%8E%9F%E7%94%9F%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.4.7.</span> <span class="nav-text">使用Hibernate原生接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-%E9%9B%86%E6%88%90JPA"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 集成JPA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-%E9%9B%86%E6%88%90MyBatis"><span class="nav-number">4.6.</span> <span class="nav-text">4.6 集成MyBatis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XML%E9%85%8D%E7%BD%AE"><span class="nav-number">4.6.1.</span> <span class="nav-text">XML配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-%E8%AE%BE%E8%AE%A1ORM"><span class="nav-number">4.7.</span> <span class="nav-text">4.7 设计ORM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1ORM%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.7.1.</span> <span class="nav-text">设计ORM接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0ORM"><span class="nav-number">4.7.2.</span> <span class="nav-text">实现ORM</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">5. 开发Web应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-0-%E7%AE%80%E4%BB%8B"><span class="nav-number">5.1.</span> <span class="nav-text">5.0 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E4%BD%BF%E7%94%A8Spring-MVC"><span class="nav-number">5.2.</span> <span class="nav-text">5.1 使用Spring MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AESpring-MVC"><span class="nav-number">5.2.1.</span> <span class="nav-text">配置Spring MVC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99Controller"><span class="nav-number">5.2.2.</span> <span class="nav-text">编写Controller</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E4%BD%BF%E7%94%A8REST"><span class="nav-number">5.3.</span> <span class="nav-text">5.2 使用REST</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E9%9B%86%E6%88%90Filter"><span class="nav-number">5.4.</span> <span class="nav-text">5.3 集成Filter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E4%BD%BF%E7%94%A8Interceptor"><span class="nav-number">5.5.</span> <span class="nav-text">5.4 使用Interceptor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="nav-number">5.5.1.</span> <span class="nav-text">处理异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E5%A4%84%E7%90%86CORS"><span class="nav-number">5.6.</span> <span class="nav-text">5.5 处理CORS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-CrossOrigin"><span class="nav-number">5.6.1.</span> <span class="nav-text">使用@CrossOrigin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8CorsRegistry"><span class="nav-number">5.6.2.</span> <span class="nav-text">使用CorsRegistry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8CorsFilter"><span class="nav-number">5.6.3.</span> <span class="nav-text">使用CorsFilter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95"><span class="nav-number">5.6.4.</span> <span class="nav-text">测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E5%9B%BD%E9%99%85%E5%8C%96"><span class="nav-number">5.7.</span> <span class="nav-text">5.6 国际化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Locale"><span class="nav-number">5.7.1.</span> <span class="nav-text">获取Locale</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="nav-number">5.7.2.</span> <span class="nav-text">提取资源文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAMessageSource"><span class="nav-number">5.7.3.</span> <span class="nav-text">创建MessageSource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%AD%E8%A8%80"><span class="nav-number">5.7.4.</span> <span class="nav-text">实现多语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2Locale"><span class="nav-number">5.7.5.</span> <span class="nav-text">切换Locale</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-number">5.8.</span> <span class="nav-text">5.7 异步处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Locale-1"><span class="nav-number">5.8.1.</span> <span class="nav-text">获取Locale</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E5%8F%96%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6-1"><span class="nav-number">5.8.2.</span> <span class="nav-text">提取资源文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAMessageSource-1"><span class="nav-number">5.8.3.</span> <span class="nav-text">创建MessageSource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%AD%E8%A8%80-1"><span class="nav-number">5.8.4.</span> <span class="nav-text">实现多语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E6%8D%A2Locale-1"><span class="nav-number">5.8.5.</span> <span class="nav-text">切换Locale</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-%E4%BD%BF%E7%94%A8WebSocket"><span class="nav-number">5.9.</span> <span class="nav-text">5.8 使用WebSocket</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86WebSocket%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.9.1.</span> <span class="nav-text">处理WebSocket连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91"><span class="nav-number">5.9.2.</span> <span class="nav-text">客户端开发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">6. 集成第三方组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-0-%E7%AE%80%E4%BB%8B"><span class="nav-number">6.1.</span> <span class="nav-text">6.0 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E9%9B%86%E6%88%90JavaMail"><span class="nav-number">6.2.</span> <span class="nav-text">6.1 集成JavaMail</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E9%9B%86%E6%88%90JMS"><span class="nav-number">6.3.</span> <span class="nav-text">6.2 集成JMS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E4%BD%BF%E7%94%A8Scheduler"><span class="nav-number">6.4.</span> <span class="nav-text">6.3 使用Scheduler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Cron%E4%BB%BB%E5%8A%A1"><span class="nav-number">6.4.1.</span> <span class="nav-text">使用Cron任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E6%88%90Quartz"><span class="nav-number">6.4.2.</span> <span class="nav-text">集成Quartz</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E9%9B%86%E6%88%90JMX"><span class="nav-number">6.5.</span> <span class="nav-text">6.4 集成JMX</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">96</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/04/Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_2.Spring%205/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          2.Spring 5
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-04 22:29:23 / 修改时间：23:01:35" itemprop="dateCreated datePublished" datetime="2022-02-04T22:29:23+08:00">2022-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/4-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6/" itemprop="url" rel="index"><span itemprop="name">4.开发框架</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：46.3k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈197 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="描述：Java-轻量级应用框架"><a href="#描述：Java-轻量级应用框架" class="headerlink" title="描述：Java. 轻量级应用框架"></a>描述：Java. 轻量级应用框架</h1><p>什么是Spring？</p>
<p>Spring是一个支持快速开发Java EE应用程序的框架。它提供了一系列底层容器和基础设施，并可以和大量常用的开源框架无缝集成，可以说是开发Java EE应用程序的必备。</p>
<p>![java-spring](2.Spring 5.assets&#x2F;l.jpeg)</p>
<p>Spring最早是由Rod Johnson这哥们在他的《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1426848/">Expert One-on-One J2EE Development without EJB</a>》一书中提出的用来取代EJB的轻量级框架。随后这哥们又开始专心开发这个基础框架，并起名为Spring Framework。</p>
<p>随着Spring越来越受欢迎，在Spring Framework基础上，又诞生了Spring Boot、Spring Cloud、Spring Data、Spring Security等一系列基于Spring Framework的项目。本章我们只介绍Spring Framework，即最核心的Spring框架。后续章节我们还会涉及Spring Boot、Spring Cloud等其他框架。</p>
<h3 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h3><p>Spring Framework主要包括几个模块：</p>
<ul>
<li>支持IoC和AOP的容器；</li>
<li>支持JDBC和ORM的数据访问模块；</li>
<li>支持声明式事务的模块；</li>
<li>支持基于Servlet的MVC开发；</li>
<li>支持基于Reactive的Web开发；</li>
<li>以及集成JMS、JavaMail、JMX、缓存等其他模块。</li>
</ul>
<p>我们会依次介绍Spring Framework的主要功能。</p>
<h1 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在学习Spring框架时，我们遇到的第一个也是最核心的概念就是容器。</p>
<p>什么是容器？容器是一种为某种特定组件的运行提供必要支持的一个软件环境。例如，Tomcat就是一个Servlet容器，它可以为Servlet的运行提供运行环境。类似Docker这样的软件也是一个容器，它提供了必要的Linux环境以便运行一个特定的Linux进程。</p>
<p>通常来说，使用容器运行组件，除了提供一个组件运行环境之外，容器还提供了许多底层服务。例如，Servlet容器底层实现了TCP连接，解析HTTP协议等非常复杂的服务，如果没有容器来提供这些服务，我们就无法编写像Servlet这样代码简单，功能强大的组件。早期的JavaEE服务器提供的EJB容器最重要的功能就是通过声明式事务服务，使得EJB组件的开发人员不必自己编写冗长的事务处理代码，所以极大地简化了事务处理。</p>
<p>Spring的核心就是提供了一个IoC容器，它可以管理所有轻量级的JavaBean组件，提供的底层服务包括组件的生命周期管理、配置和组装服务、AOP支持，以及建立在AOP基础上的声明式事务服务等。</p>
<p>本章我们讨论的IoC容器，主要介绍Spring容器如何对组件进行生命周期管理和配置组装服务。</p>
<h2 id="IOC原理"><a href="#IOC原理" class="headerlink" title="IOC原理"></a>IOC原理</h2><p>Spring提供的容器又称为IoC容器，什么是IoC？</p>
<p>IoC全称Inversion of Control，直译为控制反转。那么何谓IoC？在理解IoC之前，我们先看看通常的Java组件是如何协作的。</p>
<p>我们假定一个在线书店，通过<code>BookService</code>获取书籍：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> HikariConfig config = <span class="keyword">new</span> <span class="built_in">HikariConfig</span>();</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource = <span class="keyword">new</span> <span class="built_in">HikariDataSource</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Book <span class="title">getBook</span><span class="params">(<span class="keyword">long</span> bookId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">try</span></span> (Connection conn = dataSource.<span class="built_in">getConnection</span>()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> book;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了从数据库查询书籍，<code>BookService</code>持有一个<code>DataSource</code>。为了实例化一个<code>HikariDataSource</code>，又不得不实例化一个<code>HikariConfig</code>。</p>
<p>现在，我们继续编写<code>UserService</code>获取用户：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> HikariConfig config = <span class="keyword">new</span> <span class="built_in">HikariConfig</span>();</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource = <span class="keyword">new</span> <span class="built_in">HikariDataSource</span>(config);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">try</span></span> (Connection conn = dataSource.<span class="built_in">getConnection</span>()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>UserService</code>也需要访问数据库，因此，我们不得不也实例化一个<code>HikariDataSource</code>。</p>
<p>在处理用户购买的<code>CartServlet</code>中，我们需要实例化<code>UserService</code>和<code>BookService</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> CartServlet extends HttpServlet &#123;</span><br><span class="line">    <span class="keyword">private</span> BookService bookService = <span class="keyword">new</span> <span class="constructor">BookService()</span>;</span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">new</span> <span class="constructor">UserService()</span>;</span><br><span class="line"></span><br><span class="line">    protected void <span class="keyword">do</span><span class="constructor">Get(HttpServletRequest <span class="params">req</span>, HttpServletResponse <span class="params">resp</span>)</span> throws ServletException, IOException &#123;</span><br><span class="line">        long currentUserId = get<span class="constructor">FromCookie(<span class="params">req</span>)</span>;</span><br><span class="line">        User currentUser = userService.get<span class="constructor">User(<span class="params">currentUserId</span>)</span>;</span><br><span class="line">        Book book = bookService.get<span class="constructor">Book(<span class="params">req</span>.<span class="params">getParameter</span>(<span class="string">&quot;bookId&quot;</span>)</span>);</span><br><span class="line">        cartService.add<span class="constructor">ToCart(<span class="params">currentUser</span>, <span class="params">book</span>)</span>;<span class="operator"></span></span><br><span class="line"><span class="operator">        ...</span></span><br><span class="line"><span class="operator">    </span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的，在购买历史<code>HistoryServlet</code>中，也需要实例化<code>UserService</code>和<code>BookService</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">HistoryServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookService</span> bookService = <span class="keyword">new</span> <span class="type">BookService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> userService = <span class="keyword">new</span> <span class="type">UserService</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述每个组件都采用了一种简单的通过<code>new</code>创建实例并持有的方式。仔细观察，会发现以下缺点：</p>
<ol>
<li>实例化一个组件其实很难，例如，<code>BookService</code>和<code>UserService</code>要创建<code>HikariDataSource</code>，实际上需要读取配置，才能先实例化<code>HikariConfig</code>，再实例化<code>HikariDataSource</code>。</li>
<li>没有必要让<code>BookService</code>和<code>UserService</code>分别创建<code>DataSource</code>实例，完全可以共享同一个<code>DataSource</code>，但谁负责创建<code>DataSource</code>，谁负责获取其他组件已经创建的<code>DataSource</code>，不好处理。类似的，<code>CartServlet</code>和<code>HistoryServlet</code>也应当共享<code>BookService</code>实例和<code>UserService</code>实例，但也不好处理。</li>
<li>很多组件需要销毁以便释放资源，例如<code>DataSource</code>，但如果该组件被多个组件共享，如何确保它的使用方都已经全部被销毁？</li>
<li>随着更多的组件被引入，例如，书籍评论，需要共享的组件写起来会更困难，这些组件的依赖关系会越来越复杂。</li>
<li>测试某个组件，例如<code>BookService</code>，是复杂的，因为必须要在真实的数据库环境下执行。</li>
</ol>
<p>从上面的例子可以看出，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。</p>
<p>因此，核心问题是：</p>
<ol>
<li>谁负责创建组件？</li>
<li>谁负责根据依赖关系组装组件？</li>
<li>销毁时，如何按依赖顺序正确销毁？</li>
</ol>
<p>解决这一问题的核心方案就是IoC。</p>
<p>传统的应用程序中，控制权在程序本身，程序的控制流程完全由开发者控制，例如：</p>
<p><code>CartServlet</code>创建了<code>BookService</code>，在创建<code>BookService</code>的过程中，又创建了<code>DataSource</code>组件。这种模式的缺点是，一个组件如果要使用另一个组件，必须先知道如何正确地创建它。</p>
<p>在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制，例如，<code>BookService</code>自己并不会创建<code>DataSource</code>，而是等待外部通过<code>setDataSource()</code>方法来注入一个<code>DataSource</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不直接<code>new</code>一个<code>DataSource</code>，而是注入一个<code>DataSource</code>，这个小小的改动虽然简单，却带来了一系列好处：</p>
<ol>
<li><code>BookService</code>不再关心如何创建<code>DataSource</code>，因此，不必编写读取数据库配置之类的代码；</li>
<li><code>DataSource</code>实例被注入到<code>BookService</code>，同样也可以注入到<code>UserService</code>，因此，共享一个组件非常简单；</li>
<li>测试<code>BookService</code>更容易，因为注入的是<code>DataSource</code>，可以使用内存数据库，而不是真实的MySQL配置。</li>
</ol>
<p>因此，IoC又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。</p>
<p>因为IoC容器要负责实例化所有的组件，因此，有必要告诉容器如何创建组件，以及各组件的依赖关系。一种最简单的配置是通过XML文件来实现，例如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">&quot;dataSource&quot;</span> <span class="keyword">class</span>=&quot;<span class="symbol">HikariDataSource</span>&quot; /&gt;</span><br><span class="line">    &lt;<span class="symbol">bean</span> <span class="symbol">id</span>=&quot;<span class="symbol">bookService</span>&quot; <span class="symbol">class</span>=&quot;<span class="symbol">BookService</span>&quot;&gt;</span><br><span class="line">        &lt;<span class="symbol">property</span> <span class="symbol">name</span>=&quot;<span class="symbol">dataSource</span>&quot; <span class="symbol">ref</span>=&quot;<span class="symbol">dataSource</span>&quot; /&gt;</span><br><span class="line">    &lt;/<span class="symbol">bean</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">bean</span> <span class="symbol">id</span>=&quot;<span class="symbol">userService</span>&quot; <span class="symbol">class</span>=&quot;<span class="symbol">UserService</span>&quot;&gt;</span><br><span class="line">        &lt;<span class="symbol">property</span> <span class="symbol">name</span>=&quot;<span class="symbol">dataSource</span>&quot; <span class="symbol">ref</span>=&quot;<span class="symbol">dataSource</span>&quot; /&gt;</span><br><span class="line">    &lt;/<span class="symbol">bean</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">beans</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上述XML配置文件指示IoC容器创建3个JavaBean组件，并把id为<code>dataSource</code>的组件通过属性<code>dataSource</code>（即调用<code>setDataSource()</code>方法）注入到另外两个组件中。</p>
<p>在Spring的IoC容器中，我们把所有组件统称为JavaBean，即配置一个组件就是配置一个Bean。</p>
<h3 id="依赖注入方式"><a href="#依赖注入方式" class="headerlink" title="依赖注入方式"></a>依赖注入方式</h3><p>我们从上面的代码可以看到，依赖注入可以通过<code>set()</code>方法实现。但依赖注入也可以通过构造方法实现。</p>
<p>很多Java类都具有带参数的构造方法，如果我们把<code>BookService</code>改造为通过构造方法注入，那么实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BookService</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring的IoC容器同时支持属性注入和构造方法注入，并允许混合使用。</p>
<h3 id="无侵入容器"><a href="#无侵入容器" class="headerlink" title="无侵入容器"></a>无侵入容器</h3><p>在设计上，Spring的IoC容器是一个高度可扩展的无侵入容器。所谓无侵入，是指应用程序的组件无需实现Spring的特定接口，或者说，组件根本不知道自己在Spring的容器中运行。这种无侵入的设计有以下好处：</p>
<ol>
<li>应用程序组件既可以在Spring的IoC容器中运行，也可以自己编写代码自行组装配置；</li>
<li>测试的时候并不依赖Spring容器，可单独进行测试，大大提高了开发效率。</li>
</ol>
<h2 id="装配Bean"><a href="#装配Bean" class="headerlink" title="装配Bean"></a>装配Bean</h2><p>我们前面讨论了为什么要使用Spring的IoC容器，因为让容器来为我们创建并装配Bean能获得很大的好处，那么到底如何使用IoC容器？装配好的Bean又如何使用？</p>
<p>我们来看一个具体的用户注册登录的例子。整个工程的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-appcontext</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── Main.java</span><br><span class="line">        │               └── service</span><br><span class="line">        │                   ├── MailService.java</span><br><span class="line">        │                   ├── User.java</span><br><span class="line">        │                   └── UserService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── application.xml</span><br></pre></td></tr></table></figure>

<p>首先，我们用Maven创建工程并引入<code>spring-context</code>依赖：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-ioc-appcontext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>我们先编写一个<code>MailService</code>，用于在用户登录和注册成功后发送邮件通知：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> MailService &#123;</span><br><span class="line">    <span class="keyword">private</span> ZoneId zoneId = <span class="module-access"><span class="module"><span class="identifier">ZoneId</span>.</span></span>system<span class="constructor">Default()</span>;</span><br><span class="line"></span><br><span class="line">    public void set<span class="constructor">ZoneId(ZoneId <span class="params">zoneId</span>)</span> &#123;</span><br><span class="line">        this.zoneId = zoneId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String get<span class="constructor">Time()</span> &#123;</span><br><span class="line">        return <span class="module-access"><span class="module"><span class="identifier">ZonedDateTime</span>.</span></span>now(this.zoneId).format(DateTimeFormatter.ISO_ZONED_DATE_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void send<span class="constructor">LoginMail(User <span class="params">user</span>)</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">&quot;Hi, %s! You are logged in at %s&quot;</span>, user.get<span class="constructor">Name()</span>, get<span class="constructor">Time()</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void send<span class="constructor">RegistrationMail(User <span class="params">user</span>)</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>err.println(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">&quot;Welcome, %s!&quot;</span>, user.get<span class="constructor">Name()</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再编写一个<code>UserService</code>，实现用户注册和登录：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> UserService &#123;</span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    public void set<span class="constructor">MailService(MailService <span class="params">mailService</span>)</span> &#123;</span><br><span class="line">        this.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="module-access"><span class="module"><span class="identifier">List</span>.</span></span><span class="keyword">of</span>( <span class="comment">// users:</span></span><br><span class="line">            <span class="keyword">new</span> <span class="constructor">User(1, <span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Bob&quot;</span>)</span>, <span class="comment">// bob</span></span><br><span class="line">            <span class="keyword">new</span> <span class="constructor">User(2, <span class="string">&quot;alice@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Alice&quot;</span>)</span>, <span class="comment">// alice</span></span><br><span class="line">            <span class="keyword">new</span> <span class="constructor">User(3, <span class="string">&quot;tom@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;Tom&quot;</span>)</span>)); <span class="comment">// tom</span></span><br><span class="line"></span><br><span class="line">    public User login(String email, String password) &#123;</span><br><span class="line">        <span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.get<span class="constructor">Email()</span>.equals<span class="constructor">IgnoreCase(<span class="params">email</span>)</span><span class="operator"> &amp;&amp; </span>user.get<span class="constructor">Password()</span>.equals(password)) &#123;</span><br><span class="line">                mailService.send<span class="constructor">LoginMail(<span class="params">user</span>)</span>;</span><br><span class="line">                return user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="string">&quot;login failed.&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User get<span class="constructor">User(<span class="params">long</span> <span class="params">id</span>)</span> &#123;</span><br><span class="line">        return this.users.stream<span class="literal">()</span>.filter(user -&gt; user.get<span class="constructor">Id()</span><span class="operator"> == </span>id).find<span class="constructor">First()</span>.<span class="keyword">or</span><span class="constructor">ElseThrow()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User register(String email, String password, String name) &#123;</span><br><span class="line">        users.<span class="keyword">for</span><span class="constructor">Each((<span class="params">user</span>)</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (user.get<span class="constructor">Email()</span>.equals<span class="constructor">IgnoreCase(<span class="params">email</span>)</span>) &#123;</span><br><span class="line">                throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="string">&quot;email exist.&quot;</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        User user = <span class="keyword">new</span> <span class="constructor">User(<span class="params">users</span>.<span class="params">stream</span>()</span>.map<span class="constructor">ToLong(<span class="params">u</span> -&gt; <span class="params">u</span>.<span class="params">getId</span>()</span>).max<span class="literal">()</span>.get<span class="constructor">AsLong()</span> + <span class="number">1</span>, email, password, name);</span><br><span class="line">        users.add(user);</span><br><span class="line">        mailService.send<span class="constructor">RegistrationMail(<span class="params">user</span>)</span>;</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>UserService</code>通过<code>setMailService()</code>注入了一个<code>MailService</code>。</p>
<p>然后，我们需要编写一个特定的<code>application.xml</code>配置文件，告诉Spring的IoC容器应该如何创建并组装Bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.UserService&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mailService&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mailService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itranswarp.learnjava.service.MailService&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意观察上述配置文件，其中与XML Schema相关的部分格式是固定的，我们只关注两个<code>&lt;bean ...&gt;</code>的配置：</p>
<ul>
<li>每个<code>&lt;bean ...&gt;</code>都有一个<code>id</code>标识，相当于Bean的唯一ID；</li>
<li>在<code>userService</code>Bean中，通过<code>&lt;property name=&quot;...&quot; ref=&quot;...&quot; /&gt;</code>注入了另一个Bean；</li>
<li>Bean的顺序不重要，Spring根据依赖关系会自动正确初始化。</li>
</ul>
<p>把上述XML配置文件用Java代码写出来，就像这样：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = <span class="keyword">new</span> <span class="constructor">UserService()</span>;</span><br><span class="line">MailService mailService = <span class="keyword">new</span> <span class="constructor">MailService()</span>;</span><br><span class="line">userService.set<span class="constructor">MailService(<span class="params">mailService</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>只不过Spring容器是通过读取XML文件后使用反射完成的。</p>
<p>如果注入的不是Bean，而是<code>boolean</code>、<code>int</code>、<code>String</code>这样的数据类型，则通过<code>value</code>注入，例如，创建一个<code>HikariDataSource</code>：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="built_in">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="built_in">class</span>=<span class="string">&quot;com.zaxxer.hikari.HikariDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> value=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span> /&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;password&quot;</span> /&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">&quot;maximumPoolSize&quot;</span> value=<span class="string">&quot;10&quot;</span> /&gt;</span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="built_in">name</span>=<span class="string">&quot;autoCommit&quot;</span> value=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>最后一步，我们需要创建一个Spring的IoC容器实例，然后加载配置文件，让Spring容器为我们创建并装配好配置文件中指定的所有Bean，这只需要一行代码：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ApplicationContext context</span> = new ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>接下来，我们就可以从Spring容器中“取出”装配好的Bean然后使用它：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 获取Bean:</span><br><span class="line">UserService userService = context.getBean(UserService.class);</span><br><span class="line"><span class="regexp">//</span> 正常调用:</span><br><span class="line">User user = userService.login(<span class="string">&quot;bob@example.com&quot;</span>, <span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>完整的<code>main()</code>方法如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Main &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = <span class="built_in">new</span> ClassPathXmlApplicationContext(&quot;application.xml&quot;);</span><br><span class="line">        UserService userService = context.getBean(UserService.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">User</span> <span class="keyword">user</span> = userService.<span class="keyword">login</span>(&quot;bob@example.com&quot;, &quot;password&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">user</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><p>我们从创建Spring容器的代码：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ApplicationContext context</span> = new ClassPathXmlApplicationContext(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，Spring容器就是<code>ApplicationContext</code>，它是一个接口，有很多实现类，这里我们选择<code>ClassPathXmlApplicationContext</code>，表示它会自动从classpath中查找指定的XML配置文件。</p>
<p>获得了<code>ApplicationContext</code>的实例，就获得了IoC容器的引用。从<code>ApplicationContext</code>中我们可以根据Bean的ID获取Bean，但更多的时候我们根据Bean的类型获取Bean的引用：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserService userService = context.get<span class="constructor">Bean(UserService.<span class="params">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>Spring还提供另一种IoC容器叫<code>BeanFactory</code>，使用方式和<code>ApplicationContext</code>类似：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory <span class="keyword">factory</span> = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;application.xml&quot;</span>));</span><br><span class="line">MailService mailService = <span class="keyword">factory</span>.getBean(MailService.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure>

<p><code>BeanFactory</code>和<code>ApplicationContext</code>的区别在于，<code>BeanFactory</code>的实现是按需创建，即第一次获取Bean时才创建这个Bean，而<code>ApplicationContext</code>会一次性创建所有的Bean。实际上，<code>ApplicationContext</code>接口是从<code>BeanFactory</code>接口继承而来的，并且，<code>ApplicationContext</code>提供了一些额外的功能，包括国际化支持、事件和通知机制等。通常情况下，我们总是使用<code>ApplicationContext</code>，很少会考虑使用<code>BeanFactory</code>。</p>
<h2 id="使用Annotation配置"><a href="#使用Annotation配置" class="headerlink" title="使用Annotation配置"></a>使用Annotation配置</h2><p>使用Spring的IoC容器，实际上就是通过类似XML这样的配置文件，把我们自己的Bean的依赖关系描述出来，然后让容器来创建并装配Bean。一旦容器初始化完毕，我们就直接从容器中获取Bean使用它们。</p>
<p>使用XML配置的优点是所有的Bean都能一目了然地列出来，并通过配置注入能直观地看到每个Bean的依赖。它的缺点是写起来非常繁琐，每增加一个组件，就必须把新的Bean配置到XML中。</p>
<p>有没有其他更简单的配置方式呢？</p>
<p>有！我们可以使用Annotation配置，可以完全不需要XML，让Spring自动扫描Bean并组装它们。</p>
<p>我们把上一节的示例改造一下，先删除XML配置文件，然后，给<code>UserService</code>和<code>MailService</code>添加几个注解。</p>
<p>首先，我们给<code>MailService</code>添加一个<code>@Component</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>@Component</code>注解就相当于定义了一个Bean，它有一个可选的名称，默认是<code>mailService</code>，即小写开头的类名。</p>
<p>然后，我们给<code>UserService</code>添加一个<code>@Component</code>注解和一个<code>@Autowired</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MailService mailService;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>@Autowired</code>就相当于把指定类型的Bean注入到指定的字段中。和XML配置相比，<code>@Autowired</code>大幅简化了注入，因为它不但可以写在<code>set()</code>方法上，还可以直接写在字段上，甚至可以写在构造方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(<span class="meta">@Autowired</span> MailService mailService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一般把<code>@Autowired</code>写在字段上，通常使用package权限的字段，便于测试。</p>
<p>最后，编写一个<code>AppConfig</code>类启动容器：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">Configuration</span></span><br><span class="line">@ComponentScan</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> AppConfig &#123;</span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = <span class="built_in">new</span> AnnotationConfigApplicationContext(AppConfig.<span class="keyword">class</span>);</span><br><span class="line">        UserService userService = context.getBean(UserService.<span class="keyword">class</span>);</span><br><span class="line">        <span class="keyword">User</span> <span class="keyword">user</span> = userService.<span class="keyword">login</span>(&quot;bob@example.com&quot;, &quot;password&quot;);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println(<span class="keyword">user</span>.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>main()</code>方法外，<code>AppConfig</code>标注了<code>@Configuration</code>，表示它是一个配置类，因为我们创建<code>ApplicationContext</code>时：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> <span class="constructor">AnnotationConfigApplicationContext(AppConfig.<span class="params">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>使用的实现类是<code>AnnotationConfigApplicationContext</code>，必须传入一个标注了<code>@Configuration</code>的类名。</p>
<p>此外，<code>AppConfig</code>还标注了<code>@ComponentScan</code>，它告诉容器，自动搜索当前类所在的包以及子包，把所有标注为<code>@Component</code>的Bean自动创建出来，并根据<code>@Autowired</code>进行装配。</p>
<p>整个工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-annoconfig</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── itranswarp</span><br><span class="line">                    └── learnjava</span><br><span class="line">                        ├── AppConfig.java</span><br><span class="line">                        └── service</span><br><span class="line">                            ├── MailService.java</span><br><span class="line">                            ├── User.java</span><br><span class="line">                            └── UserService.java</span><br></pre></td></tr></table></figure>

<p>使用Annotation配合自动扫描能大幅简化Spring的配置，我们只需要保证：</p>
<ul>
<li>每个Bean被标注为<code>@Component</code>并正确使用<code>@Autowired</code>注入；</li>
<li>配置类被标注为<code>@Configuration</code>和<code>@ComponentScan</code>；</li>
<li>所有Bean均在指定包以及子包内。</li>
</ul>
<p>使用<code>@ComponentScan</code>非常方便，但是，我们也要特别注意包的层次结构。通常来说，启动配置<code>AppConfig</code>位于自定义的顶层包（例如<code>com.itranswarp.learnjava</code>），其他Bean按类别放入子包。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>如果我们想给<code>UserService</code>注入<code>HikariDataSource</code>，但是这个类位于<code>com.zaxxer.hikari</code>包中，并且<code>HikariDataSource</code>也不可能有<code>@Component</code>注解，如何告诉IoC容器创建并配置<code>HikariDataSource</code>？或者换个说法，如何创建并配置一个第三方Bean？</p>
<h2 id="定制Bean"><a href="#定制Bean" class="headerlink" title="定制Bean"></a>定制Bean</h2><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>对于Spring容器来说，当我们把一个Bean标记为<code>@Component</code>后，它就会自动为我们创建一个单例（Singleton），即容器初始化时创建Bean，容器关闭前销毁Bean。在容器运行期间，我们调用<code>getBean(Class)</code>获取到的Bean总是同一个实例。</p>
<p>还有一种Bean，我们每次调用<code>getBean(Class)</code>，容器都返回一个新的实例，这种Bean称为Prototype（原型），它的生命周期显然和Singleton不同。声明一个Prototype的Bean时，需要添加一个额外的<code>@Scope</code>注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE) <span class="comment">// @Scope(&quot;prototype&quot;)</span></span><br><span class="line">public class MailSession &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注入List"><a href="#注入List" class="headerlink" title="注入List"></a>注入List</h3><p>有些时候，我们会有一系列接口相同，不同实现类的Bean。例如，注册用户时，我们要对email、password和name这3个变量进行验证。为了便于扩展，我们先定义验证接口：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface Validator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">validate</span><span class="params">(<span class="keyword">String</span> email, <span class="keyword">String</span> password, <span class="keyword">String</span> name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，分别使用3个<code>Validator</code>对用户参数进行验证：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailValidator</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Validator</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> void validate(<span class="keyword">String</span> email, <span class="keyword">String</span> password, <span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!email.matches(<span class="string">&quot;^[a-z0-9]+\\@[a-z0-9]+\\.[a-z]&#123;2,10&#125;$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;invalid email: &quot;</span> + email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordValidator</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Validator</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> void validate(<span class="keyword">String</span> email, <span class="keyword">String</span> password, <span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!password.matches(<span class="string">&quot;^.&#123;6,20&#125;$&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;invalid password&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameValidator</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">Validator</span></span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> void validate(<span class="keyword">String</span> email, <span class="keyword">String</span> password, <span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="literal">null</span> || name.isBlank() || name.length() &gt; <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">&quot;invalid name: &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们通过一个<code>Validators</code>作为入口进行验证：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Validators &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    List&lt;<span class="keyword">Validator</span>&gt; validators;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> <span class="type">void</span> <span class="keyword">validate</span>(String email, String <span class="keyword">password</span>, String <span class="type">name</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (var <span class="keyword">validator</span> : this.validators) &#123;</span><br><span class="line">            <span class="keyword">validator</span>.<span class="keyword">validate</span>(email, <span class="keyword">password</span>, <span class="type">name</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>Validators</code>被注入了一个<code>List&lt;Validator&gt;</code>，Spring会自动把所有类型为<code>Validator</code>的Bean装配为一个<code>List</code>注入进来，这样一来，我们每新增一个<code>Validator</code>类型，就自动被Spring装配到<code>Validators</code>中了，非常方便。</p>
<p>因为Spring是通过扫描classpath获取到所有的Bean，而<code>List</code>是有序的，要指定<code>List</code>中Bean的顺序，可以加上<code>@Order</code>注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Order</span>(<span class="number">1</span>)</span><br><span class="line">public class EmailValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Order</span>(<span class="number">2</span>)</span><br><span class="line">public class PasswordValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Order</span>(<span class="number">3</span>)</span><br><span class="line">public class NameValidator implements Validator &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可选注入"><a href="#可选注入" class="headerlink" title="可选注入"></a>可选注入</h3><p>默认情况下，当我们标记了一个<code>@Autowired</code>后，Spring如果没有找到对应类型的Bean，它会抛出<code>NoSuchBeanDefinitionException</code>异常。</p>
<p>可以给<code>@Autowired</code>增加一个<code>required = false</code>的参数：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> MailService &#123;</span><br><span class="line">    @<span class="constructor">Autowired(<span class="params">required</span> = <span class="params">false</span>)</span></span><br><span class="line">    ZoneId zoneId = <span class="module-access"><span class="module"><span class="identifier">ZoneId</span>.</span></span>system<span class="constructor">Default()</span>;<span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>

<p>这个参数告诉Spring容器，如果找到一个类型为<code>ZoneId</code>的Bean，就注入，如果找不到，就忽略。</p>
<p>这种方式非常适合有定义就使用定义，没有就使用默认值的情况。</p>
<h3 id="创建第三方Bean"><a href="#创建第三方Bean" class="headerlink" title="创建第三方Bean"></a>创建第三方Bean</h3><p>如果一个Bean不在我们自己的package管理之内，例如<code>ZoneId</code>，如何创建它？</p>
<p>答案是我们自己在<code>@Configuration</code>类中编写一个Java方法创建并返回它，注意给方法标记一个<code>@Bean</code>注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="comment">// 创建一个Bean:</span></span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring对标记为<code>@Bean</code>的方法只调用一次，因此返回的Bean仍然是单例。</p>
<h3 id="初始化和销毁"><a href="#初始化和销毁" class="headerlink" title="初始化和销毁"></a>初始化和销毁</h3><p>有些时候，一个Bean在注入必要的依赖后，需要进行初始化（监听消息等）。在容器关闭时，有时候还需要清理资源（关闭连接池等）。我们通常会定义一个<code>init()</code>方法进行初始化，定义一个<code>shutdown()</code>方法进行清理，然后，引入JSR-250定义的Annotation：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在Bean的初始化和清理方法上标记<code>@PostConstruct</code>和<code>@PreDestroy</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="literal">false</span>)</span><br><span class="line">    ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Init mail service with zoneId = &quot;</span> + <span class="built_in">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">shutdown</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Shutdown mail service&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring容器会对上述Bean做如下初始化流程：</p>
<ul>
<li>调用构造方法创建<code>MailService</code>实例；</li>
<li>根据<code>@Autowired</code>进行注入；</li>
<li>调用标记有<code>@PostConstruct</code>的<code>init()</code>方法进行初始化。</li>
</ul>
<p>而销毁时，容器会首先调用标记有<code>@PreDestroy</code>的<code>shutdown()</code>方法。</p>
<p>Spring只根据Annotation查找<em>无参数</em>方法，对方法名不作要求。</p>
<h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><p>默认情况下，对一种类型的Bean，容器只创建一个实例。但有些时候，我们需要对一种类型的Bean创建多个实例。例如，同时连接多个数据库，就必须创建多个<code>DataSource</code>实例。</p>
<p>如果我们在<code>@Configuration</code>类中创建了多个同类型的Bean：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Bean</span></span><br><span class="line">    <span class="selector-tag">ZoneId</span> <span class="selector-tag">createZoneOfUTC8</span>() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring会报<code>NoUniqueBeanDefinitionException</code>异常，意思是出现了重复的Bean定义。</p>
<p>这个时候，需要给每个Bean添加不同的名字：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span>(<span class="string">&quot;z&quot;</span>)</span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Bean</span></span><br><span class="line">    @<span class="selector-tag">Qualifier</span>(<span class="string">&quot;utc8&quot;</span>)</span><br><span class="line">    <span class="selector-tag">ZoneId</span> <span class="selector-tag">createZoneOfUTC8</span>() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用<code>@Bean(&quot;name&quot;)</code>指定别名，也可以用<code>@Bean</code>+<code>@Qualifier(&quot;name&quot;)</code>指定别名。</p>
<p>存在多个同类型的Bean时，注入<code>ZoneId</code>又会报错：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NoUniqueBeanDefinitionException: <span class="keyword">No</span> qualifying bean <span class="keyword">of</span> <span class="keyword">type</span> <span class="string">&#x27;java.time.ZoneId&#x27;</span> available: expected single matching bean but <span class="built_in">found</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>意思是期待找到唯一的<code>ZoneId</code>类型Bean，但是找到两。因此，注入时，要指定Bean的名称：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class MailService &#123;</span><br><span class="line">	<span class="variable">@Autowired</span>(required = false)</span><br><span class="line">	<span class="variable">@Qualifier</span>(<span class="string">&quot;z&quot;</span>) <span class="comment">// 指定注入名称为&quot;z&quot;的ZoneId</span></span><br><span class="line">	ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种方法是把其中某个Bean指定为<code>@Primary</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    <span class="variable">@Primary</span> <span class="comment">// 指定为主要Bean</span></span><br><span class="line">    <span class="variable">@Qualifier</span>(<span class="string">&quot;z&quot;</span>)</span><br><span class="line">    ZoneId createZoneOfZ() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(<span class="string">&quot;Z&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Bean</span></span><br><span class="line">    @<span class="selector-tag">Qualifier</span>(<span class="string">&quot;utc8&quot;</span>)</span><br><span class="line">    <span class="selector-tag">ZoneId</span> <span class="selector-tag">createZoneOfUTC8</span>() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(<span class="string">&quot;UTC+08:00&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在注入时，如果没有指出Bean的名字，Spring会注入标记有<code>@Primary</code>的Bean。这种方式也很常用。例如，对于主从两个数据源，通常将主数据源定义为<code>@Primary</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    <span class="variable">@Primary</span></span><br><span class="line">    DataSource createMasterDataSource() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    <span class="variable">@Qualifier</span>(<span class="string">&quot;slave&quot;</span>)</span><br><span class="line">    DataSource createSlaveDataSource() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他Bean默认注入的就是主数据源。如果要注入从数据源，那么只需要指定名称即可。</p>
<h3 id="使用FactoryBean"><a href="#使用FactoryBean" class="headerlink" title="使用FactoryBean"></a>使用FactoryBean</h3><p>我们在设计模式的<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319170474017">工厂方法</a>中讲到，很多时候，可以通过工厂模式创建对象。Spring也提供了工厂模式，允许定义一个工厂，然后由工厂创建真正的Bean。</p>
<p>用工厂模式创建Bean需要实现<code>FactoryBean</code>接口。我们观察下面的代码：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoneIdFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">ZoneId</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String zone = <span class="string">&quot;Z&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">ZoneId <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> ZoneId.<span class="title">of</span><span class="params">(zone)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> ZoneId.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个Bean实现了<code>FactoryBean</code>接口后，Spring会先实例化这个工厂，然后调用<code>getObject()</code>创建真正的Bean。<code>getObjectType()</code>可以指定创建的Bean的类型，因为指定类型不一定与实际类型一致，可以是接口或抽象类。</p>
<p>因此，如果定义了一个<code>FactoryBean</code>，要注意Spring创建的Bean实际上是这个<code>FactoryBean</code>的<code>getObject()</code>方法返回的Bean。为了和普通Bean区分，我们通常都以<code>XxxFactoryBean</code>命名。</p>
<h2 id="使用Resource"><a href="#使用Resource" class="headerlink" title="使用Resource"></a>使用Resource</h2><p>在Java程序中，我们经常会读取配置文件、资源文件等。使用Spring容器时，我们也可以把“文件”注入进来，方便程序读取。</p>
<p>例如，AppService需要读取<code>logo.txt</code>这个文件，通常情况下，我们需要写很多繁琐的代码，主要是为了定位文件，打开InputStream。</p>
<p>Spring提供了一个<code>org.springframework.core.io.Resource</code>（注意不是<code>javax.annotation.Resource</code>），它可以像<code>String</code>、<code>int</code>一样使用<code>@Value</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;classpath:/logo.txt&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Resource resource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String logo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">                <span class="keyword">new</span> InputStreamReader(resource.getInputStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logo = reader.lines().collect(Collectors.joining(<span class="string">&quot;\n&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入<code>Resource</code>最常用的方式是通过classpath，即类似<code>classpath:/logo.txt</code>表示在classpath中搜索<code>logo.txt</code>文件，然后，我们直接调用<code>Resource.getInputStream()</code>就可以获取到输入流，避免了自己搜索文件的代码。</p>
<p>也可以直接指定文件的路径，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(<span class="meta-string">&quot;file:/path/to/logo.txt&quot;</span>)</span></span><br><span class="line"><span class="keyword">private</span> Resource resource;</span><br></pre></td></tr></table></figure>

<p>但使用classpath是最简单的方式。上述工程结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring-ioc-resource</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               └── AppService.java</span><br><span class="line">        └── resources</span><br><span class="line">            └── logo.txt</span><br></pre></td></tr></table></figure>

<p>使用Maven的标准目录结构，所有资源文件放入<code>src/main/resources</code>即可。</p>
<h2 id="注入配置"><a href="#注入配置" class="headerlink" title="注入配置"></a>注入配置</h2><p>在开发应用程序时，经常需要读取配置文件。最常用的配置方法是以<code>key=value</code>的形式写在<code>.properties</code>文件中。</p>
<p>例如，<code>MailService</code>根据配置的<code>app.zone=Asia/Shanghai</code>来决定使用哪个时区。要读取配置文件，我们可以使用上一节讲到的<code>Resource</code>来读取位于classpath下的一个<code>app.properties</code>文件。但是，这样仍然比较繁琐。</p>
<p>Spring容器还提供了一个更简单的<code>@PropertySource</code>来自动读取配置文件。我们只需要在<code>@Configuration</code>配置类上再添加一个注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@PropertySource</span>(<span class="string">&quot;app.properties&quot;</span>) <span class="comment">// 表示读取classpath的app.properties</span></span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Value</span>(<span class="string">&quot;$&#123;app.zone:Z&#125;&quot;</span>)</span><br><span class="line">    String zoneId;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(zoneId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring容器看到<code>@PropertySource(&quot;app.properties&quot;)</code>注解后，自动读取这个配置文件，然后，我们使用<code>@Value</code>正常注入：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">&quot;<span class="subst">$&#123;app.zone:Z&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">String</span> zoneId;</span><br></pre></td></tr></table></figure>

<p>注意注入的字符串语法，它的格式如下：</p>
<ul>
<li><code>&quot;$&#123;app.zone&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，如果key不存在，启动将报错；</li>
<li><code>&quot;$&#123;app.zone:Z&#125;&quot;</code>表示读取key为<code>app.zone</code>的value，但如果key不存在，就使用默认值<code>Z</code>。</li>
</ul>
<p>这样一来，我们就可以根据<code>app.zone</code>的配置来创建<code>ZoneId</code>。</p>
<p>还可以把注入的注解写到方法参数中：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line">ZoneId createZoneId(<span class="variable">@Value</span>(<span class="string">&quot;$&#123;app.zone:Z&#125;&quot;</span>) String zoneId) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(zoneId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，先使用<code>@PropertySource</code>读取配置文件，然后通过<code>@Value</code>以<code>$&#123;key:defaultValue&#125;</code>的形式注入，可以极大地简化读取配置的麻烦。</p>
<p>另一种注入配置的方式是先通过一个简单的JavaBean持有所有的配置，例如，一个<code>SmtpConfig</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmtpConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">&quot;<span class="subst">$&#123;smtp.host&#125;</span>&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">&quot;<span class="subst">$&#123;smtp.port:<span class="number">25</span>&#125;</span>&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> int port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getHost() &#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> int getPort() &#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，在需要读取的地方，使用<code>#&#123;smtpConfig.host&#125;</code>注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String smtpHost;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;smtpConfig.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> smtpPort;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意观察<code>#&#123;&#125;</code>这种注入语法，它和<code>$&#123;key&#125;</code>不同的是，<code>#&#123;&#125;</code>表示从JavaBean读取属性。<code>&quot;#&#123;smtpConfig.host&#125;&quot;</code>的意思是，从名称为<code>smtpConfig</code>的Bean读取<code>host</code>属性，即调用<code>getHost()</code>方法。一个Class名为<code>SmtpConfig</code>的Bean，它在Spring容器中的默认名称就是<code>smtpConfig</code>，除非用<code>@Qualifier</code>指定了名称。</p>
<p>使用一个独立的JavaBean持有所有属性，然后在其他Bean中以<code>#&#123;bean.property&#125;</code>注入的好处是，多个Bean都可以引用同一个Bean的某个属性。例如，如果<code>SmtpConfig</code>决定从数据库中读取相关配置项，那么<code>MailService</code>注入的<code>@Value(&quot;#&#123;smtpConfig.host&#125;&quot;)</code>仍然可以不修改正常运行。</p>
<h2 id="使用条件装配"><a href="#使用条件装配" class="headerlink" title="使用条件装配"></a>使用条件装配</h2><p>开发应用程序时，我们会使用开发环境，例如，使用内存数据库以便快速启动。而运行在生产环境时，我们会使用生产环境，例如，使用MySQL数据库。如果应用程序可以根据自身的环境做一些适配，无疑会更加灵活。</p>
<p>Spring为应用程序准备了Profile这一概念，用来表示不同的环境。例如，我们分别定义开发、测试和生产这3个环境：</p>
<ul>
<li>native</li>
<li>test</li>
<li>production</li>
</ul>
<p>创建某个Bean时，Spring容器可以根据注解<code>@Profile</code>来决定是否创建。例如，以下配置：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    <span class="variable">@Profile</span>(<span class="string">&quot;!test&quot;</span>)</span><br><span class="line">    ZoneId createZoneId() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.systemDefault</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Bean</span></span><br><span class="line">    @<span class="selector-tag">Profile</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line">    <span class="selector-tag">ZoneId</span> <span class="selector-tag">createZoneIdForTest</span>() &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">ZoneId</span><span class="selector-class">.of</span>(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前的Profile设置为<code>test</code>，则Spring容器会调用<code>createZoneIdForTest()</code>创建<code>ZoneId</code>，否则，调用<code>createZoneId()</code>创建<code>ZoneId</code>。注意到<code>@Profile(&quot;!test&quot;)</code>表示非test环境。</p>
<p>在运行程序时，加上JVM参数<code>-Dspring.profiles.active=test</code>就可以指定以<code>test</code>环境启动。</p>
<p>实际上，Spring允许指定多个Profile，例如：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Dspring.profiles.active</span>=test,master</span><br></pre></td></tr></table></figure>

<p>可以表示<code>test</code>环境，并使用<code>master</code>分支代码。</p>
<p>要满足多个Profile条件，可以这样写：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line"><span class="variable">@Profile</span>(&#123; <span class="string">&quot;test&quot;</span>, <span class="string">&quot;master&quot;</span> &#125;) <span class="comment">// 同时满足test和master</span></span><br><span class="line">ZoneId createZoneId() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用Conditional"><a href="#使用Conditional" class="headerlink" title="使用Conditional"></a>使用Conditional</h3><p>除了根据<code>@Profile</code>条件来决定是否创建某个Bean外，Spring还可以根据<code>@Conditional</code>决定是否创建某个Bean。</p>
<p>例如，我们对<code>SmtpMailService</code>添加如下注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Conditional</span>(OnSmtpEnvCondition.class)</span><br><span class="line">public class SmtpMailService implements MailService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的意思是，如果满足<code>OnSmtpEnvCondition</code>的条件，才会创建<code>SmtpMailService</code>这个Bean。<code>OnSmtpEnvCondition</code>的条件是什么呢？我们看一下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSmtpEnvCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;true&quot;</span>.equalsIgnoreCase(System.getenv(<span class="string">&quot;smtp&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，<code>OnSmtpEnvCondition</code>的条件是存在环境变量<code>smtp</code>，值为<code>true</code>。这样，我们就可以通过环境变量来控制是否创建<code>SmtpMailService</code>。</p>
<p>Spring只提供了<code>@Conditional</code>注解，具体判断逻辑还需要我们自己实现。Spring Boot提供了更多使用起来更简单的条件注解，例如，如果配置文件中存在<code>app.smtp=true</code>，则创建<code>MailService</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@ConditionalOnProperty</span>(name=<span class="string">&quot;app.smtp&quot;</span>, havingValue=<span class="string">&quot;true&quot;</span>)</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前classpath中存在类<code>javax.mail.Transport</code>，则创建<code>MailService</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@ConditionalOnClass</span>(name = <span class="string">&quot;javax.mail.Transport&quot;</span>)</span><br><span class="line">public class MailService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后续我们会介绍Spring Boot的条件装配。我们以文件存储为例，假设我们需要保存用户上传的头像，并返回存储路径，在本地开发运行时，我们总是存储到文件：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@ConditionalOnProperty</span>(name = <span class="string">&quot;app.storage&quot;</span>, havingValue = <span class="string">&quot;file&quot;</span>, matchIfMissing = true)</span><br><span class="line">public class FileUploader implements Uploader &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在生产环境运行时，我们会把文件存储到类似AWS S3上：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@ConditionalOnProperty</span>(name = <span class="string">&quot;app.storage&quot;</span>, havingValue = <span class="string">&quot;s3&quot;</span>)</span><br><span class="line">public class S3Uploader implements Uploader &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他需要存储的服务则注入<code>Uploader</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Uploader uploader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当应用程序检测到配置文件存在<code>app.storage=s3</code>时，自动使用<code>S3Uploader</code>，如果存在配置<code>app.storage=file</code>，或者配置<code>app.storage</code>不存在，则使用<code>FileUploader</code>。</p>
<p>可见，使用条件注解，能更灵活地装配Bean。</p>
<h1 id="使用AOP"><a href="#使用AOP" class="headerlink" title="使用AOP"></a>使用AOP</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>AOP是Aspect Oriented Programming，即面向切面编程。</p>
<p>那什么是AOP？</p>
<p>我们先回顾一下OOP：Object Oriented Programming，OOP作为面向对象编程的模式，获得了巨大的成功，OOP的主要功能是数据封装、继承和多态。</p>
<p>而AOP是一种新的编程方式，它和OOP不同，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，或者称之为切面（Aspect）。</p>
<p>要理解AOP的概念，我们先用OOP举例，比如一个业务组件<code>BookService</code>，它有几个业务方法：</p>
<ul>
<li>createBook：添加新的Book；</li>
<li>updateBook：修改Book；</li>
<li>deleteBook：删除Book。</li>
</ul>
<p>对每个业务方法，例如，<code>createBook()</code>，除了业务逻辑，还需要安全检查、日志记录和事务处理，它的代码像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">securityCheck</span>();</span><br><span class="line">        Transaction tx = <span class="built_in">startTransaction</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 核心业务逻辑</span></span><br><span class="line">            tx.<span class="built_in">commit</span>();</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span> (RuntimeException e) &#123;</span><br><span class="line">            tx.<span class="built_in">rollback</span>();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;created book: &quot;</span> + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续编写<code>updateBook()</code>，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">securityCheck</span>();</span><br><span class="line">        Transaction tx = <span class="built_in">startTransaction</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 核心业务逻辑</span></span><br><span class="line">            tx.<span class="built_in">commit</span>();</span><br><span class="line">        &#125; <span class="built_in"><span class="keyword">catch</span></span> (RuntimeException e) &#123;</span><br><span class="line">            tx.<span class="built_in">rollback</span>();</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">&quot;updated book: &quot;</span> + book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于安全检查、日志、事务等代码，它们会重复出现在每个业务方法中。使用OOP，我们很难将这些四处分散的代码模块化。</p>
<p>考察业务模型可以发现，<code>BookService</code>关心的是自身的核心逻辑，但整个系统还要求关注安全检查、日志、事务等功能，这些功能实际上“横跨”多个业务方法，为了实现这些功能，不得不在每个业务方法上重复编写代码。</p>
<p>一种可行的方式是使用<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">Proxy模式</a>，将某个功能，例如，权限检查，放入Proxy中：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityCheckBookService</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BookService <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityCheckBookService</span><span class="params">(BookService <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">createBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        <span class="keyword">target</span>.createBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        <span class="keyword">target</span>.updateBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">deleteBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">        securityCheck();</span><br><span class="line">        <span class="keyword">target</span>.deleteBook(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">securityCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的缺点是比较麻烦，必须先抽取接口，然后，针对每个方法实现Proxy。</p>
<p>另一种方法是，既然<code>SecurityCheckBookService</code>的代码都是标准的Proxy样板代码，不如把权限检查视作一种切面（Aspect），把日志、事务也视为切面，然后，以某种自动化的方式，把切面织入到核心逻辑中，实现Proxy模式。</p>
<p>如果我们以AOP的视角来编写上述业务，可以依次实现：</p>
<ol>
<li>核心逻辑，即BookService；</li>
<li>切面逻辑，即：</li>
<li>权限检查的Aspect；</li>
<li>日志的Aspect；</li>
<li>事务的Aspect。</li>
</ol>
<p>然后，以某种方式，让框架来把上述3个Aspect以Proxy的方式“织入”到<code>BookService</code>中，这样一来，就不必编写复杂而冗长的Proxy模式。</p>
<h3 id="AOP原理"><a href="#AOP原理" class="headerlink" title="AOP原理"></a>AOP原理</h3><p>如何把切面织入到核心逻辑中？这正是AOP需要解决的问题。换句话说，如果客户端获得了<code>BookService</code>的引用，当调用<code>bookService.createBook()</code>时，如何对调用方法进行拦截，并在拦截前后进行安全检查、日志、事务等处理，就相当于完成了所有业务功能。</p>
<p>在Java平台上，对于AOP的织入，有3种方式：</p>
<ol>
<li>编译期：在编译时，由编译器把切面调用编译进字节码，这种方式需要定义新的关键字并扩展编译器，AspectJ就扩展了Java编译器，使用关键字aspect来实现织入；</li>
<li>类加载器：在目标类被装载到JVM时，通过一个特殊的类加载器，对目标类的字节码重新“增强”；</li>
<li>运行期：目标对象和切面都是普通Java类，通过JVM的动态代理功能或者第三方库实现运行期动态织入。</li>
</ol>
<p>最简单的方式是第三种，Spring的AOP实现就是基于JVM的动态代理。由于JVM的动态代理要求必须实现接口，如果一个普通类没有业务接口，就需要通过<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>或者<a target="_blank" rel="noopener" href="https://www.javassist.org/">Javassist</a>这些第三方库实现。</p>
<p>AOP技术看上去比较神秘，但实际上，它本质就是一个动态代理，让我们把一些常用功能如权限检查、日志、事务等，从每个业务方法中剥离出来。</p>
<p>需要特别指出的是，AOP对于解决特定问题，例如事务管理非常有用，这是因为分散在各处的事务代码几乎是完全相同的，并且它们需要的参数（JDBC的Connection）也是固定的。另一些特定问题，如日志，就不那么容易实现，因为日志虽然简单，但打印日志的时候，经常需要捕获局部变量，如果使用AOP实现日志，我们只能输出固定格式的日志，因此，使用AOP时，必须适合特定的场景。</p>
<h2 id="装配AOP"><a href="#装配AOP" class="headerlink" title="装配AOP"></a>装配AOP</h2><p>在AOP编程中，我们经常会遇到下面的概念：</p>
<ul>
<li>Aspect：切面，即一个横跨多个核心逻辑的功能，或者称之为系统关注点；</li>
<li>Joinpoint：连接点，即定义在应用程序流程的何处插入切面的执行；</li>
<li>Pointcut：切入点，即一组连接点的集合；</li>
<li>Advice：增强，指特定连接点上执行的动作；</li>
<li>Introduction：引介，指为一个已有的Java对象动态地增加新的接口；</li>
<li>Weaving：织入，指将切面整合到程序的执行流程中；</li>
<li>Interceptor：拦截器，是一种实现增强的方式；</li>
<li>Target Object：目标对象，即真正执行业务的核心逻辑对象；</li>
<li>AOP Proxy：AOP代理，是客户端持有的增强后的对象引用。</li>
</ul>
<p>看完上述术语，是不是感觉对AOP有了进一步的困惑？其实，我们不用关心AOP创造的“术语”，只需要理解AOP本质上只是一种代理模式的实现方式，在Spring的容器中实现AOP特别方便。</p>
<p>我们以<code>UserService</code>和<code>MailService</code>为例，这两个属于核心业务逻辑，现在，我们准备给<code>UserService</code>的每个业务方法执行前添加日志，给<code>MailService</code>的每个业务方法执行前后添加日志，在Spring中，需要以下步骤：</p>
<p>首先，我们通过Maven引入Spring对AOP的支持：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$</span><span class="template-variable">&#123;spring.version&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上述依赖会自动引入AspectJ，使用AspectJ实现AOP比较方便，因为它的定义比较简单。</p>
<p>然后，我们定义一个<code>LoggingAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在执行UserService的每个方法前执行:</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行MailService的每个方法前后执行:</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(public * com.itranswarp.learnjava.service.MailService.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] start &quot;</span> + pjp.getSignature());</span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        System.err.println(<span class="string">&quot;[Around] done &quot;</span> + pjp.getSignature());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察<code>doAccessCheck()</code>方法，我们定义了一个<code>@Before</code>注解，后面的字符串是告诉AspectJ应该在何处执行该方法，这里写的意思是：执行<code>UserService</code>的每个<code>public</code>方法前执行<code>doAccessCheck()</code>代码。</p>
<p>再观察<code>doLogging()</code>方法，我们定义了一个<code>@Around</code>注解，它和<code>@Before</code>不同，<code>@Around</code>可以决定是否执行目标方法，因此，我们在<code>doLogging()</code>内部先打印日志，再调用方法，最后打印日志后返回结果。</p>
<p>在<code>LoggingAspect</code>类的声明处，除了用<code>@Component</code>表示它本身也是一个Bean外，我们再加上<code>@Aspect</code>注解，表示它的<code>@Before</code>标注的方法需要注入到<code>UserService</code>的每个<code>public</code>方法执行前，<code>@Around</code>标注的方法需要注入到<code>MailService</code>的每个<code>public</code>方法执行前后。</p>
<p>紧接着，我们需要给<code>@Configuration</code>类加上一个<code>@EnableAspectJAutoProxy</code>注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableAspectJAutoProxy</span></span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring的IoC容器看到这个注解，就会自动查找带有<code>@Aspect</code>的Bean，然后根据每个方法的<code>@Before</code>、<code>@Around</code>等注解把AOP注入到特定的Bean中。执行代码，我们可以看到以下输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[Before]</span> do access check...</span><br><span class="line"><span class="selector-attr">[Around]</span> start void com<span class="selector-class">.itranswarp</span><span class="selector-class">.learnjava</span><span class="selector-class">.service</span><span class="selector-class">.MailService</span><span class="selector-class">.sendRegistrationMail</span>(User)</span><br><span class="line">Welcome, test!</span><br><span class="line"><span class="selector-attr">[Around]</span> done void com<span class="selector-class">.itranswarp</span><span class="selector-class">.learnjava</span><span class="selector-class">.service</span><span class="selector-class">.MailService</span><span class="selector-class">.sendRegistrationMail</span>(User)</span><br><span class="line"><span class="selector-attr">[Before]</span> do access check...</span><br><span class="line"><span class="selector-attr">[Around]</span> start void com<span class="selector-class">.itranswarp</span><span class="selector-class">.learnjava</span><span class="selector-class">.service</span><span class="selector-class">.MailService</span><span class="selector-class">.sendLoginMail</span>(User)</span><br><span class="line">Hi, Bob! You are logged <span class="keyword">in</span> at <span class="number">2020</span>-<span class="number">02</span>-<span class="number">14</span>T23:<span class="number">13</span>:<span class="number">52.167996</span>+<span class="number">08</span>:<span class="number">00</span><span class="selector-attr">[Asia/Shanghai]</span></span><br><span class="line"><span class="selector-attr">[Around]</span> done void com<span class="selector-class">.itranswarp</span><span class="selector-class">.learnjava</span><span class="selector-class">.service</span><span class="selector-class">.MailService</span><span class="selector-class">.sendLoginMail</span>(User)</span><br></pre></td></tr></table></figure>

<p>这说明执行业务逻辑前后，确实执行了我们定义的Aspect（即<code>LoggingAspect</code>的方法）。</p>
<p>有些童鞋会问，<code>LoggingAspect</code>定义的方法，是如何注入到其他Bean的呢？</p>
<p>其实AOP的原理非常简单。我们以<code>LoggingAspect.doAccessCheck()</code>为例，要把它注入到<code>UserService</code>的每个<code>public</code>方法中，最简单的方法是编写一个子类，并持有原始实例的引用：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserServiceAopProxy <span class="keyword">extends</span> UserService &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService <span class="keyword">target</span>;</span><br><span class="line">    <span class="keyword">private</span> LoggingAspect <span class="class"><span class="keyword">aspect</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceAopProxy</span><span class="params">(UserService <span class="keyword">target</span>, LoggingAspect aspect)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">        <span class="keyword">this</span>.aspect = <span class="class"><span class="keyword">aspect</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先执行Aspect的代码:</span></span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="comment">// 再执行UserService的逻辑:</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">target</span>.<span class="title">login</span><span class="params">(email, password)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">User <span class="title">register</span><span class="params">(String email, String password, String name)</span> </span>&#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">target</span>.<span class="title">register</span><span class="params">(email, password, name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些都是Spring容器启动时为我们自动创建的注入了Aspect的子类，它取代了原始的<code>UserService</code>（原始的<code>UserService</code>实例作为内部变量隐藏在<code>UserServiceAopProxy</code>中）。如果我们打印从Spring容器获取的<code>UserService</code>实例类型，它类似<code>UserService$$EnhancerBySpringCGLIB$$1f44e01c</code>，实际上是Spring使用CGLIB动态创建的子类，但对于调用方来说，感觉不到任何区别。</p>
<p> Spring对接口类型使用JDK动态代理，对普通类使用CGLIB创建子类。如果一个Bean的class是final，Spring将无法为其创建子类。</p>
<p>可见，虽然Spring容器内部实现AOP的逻辑比较复杂（需要使用AspectJ解析注解，并通过CGLIB实现代理类），但我们使用AOP非常简单，一共需要三步：</p>
<ol>
<li>定义执行方法，并在方法上通过AspectJ的注解告诉Spring应该在何处调用此方法；</li>
<li>标记<code>@Component</code>和<code>@Aspect</code>；</li>
<li>在<code>@Configuration</code>类上标注<code>@EnableAspectJAutoProxy</code>。</li>
</ol>
<p>至于AspectJ的注入语法则比较复杂，请参考<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-pointcuts-examples">Spring文档</a>。</p>
<p>Spring也提供其他方法来装配AOP，但都没有使用AspectJ注解的方式来得简洁明了，所以我们不再作介绍。</p>
<h3 id="拦截器类型"><a href="#拦截器类型" class="headerlink" title="拦截器类型"></a>拦截器类型</h3><p>顾名思义，拦截器有以下类型：</p>
<ul>
<li>@Before：这种拦截器先执行拦截代码，再执行目标代码。如果拦截器抛异常，那么目标代码就不执行了；</li>
<li>@After：这种拦截器先执行目标代码，再执行拦截器代码。无论目标代码是否抛异常，拦截器代码都会执行；</li>
<li>@AfterReturning：和@After不同的是，只有当目标代码正常返回时，才执行拦截器代码；</li>
<li>@AfterThrowing：和@After不同的是，只有当目标代码抛出了异常时，才执行拦截器代码；</li>
<li>@Around：能完全控制目标代码是否执行，并可以在执行前后、抛异常后执行任意拦截代码，可以说是包含了上面所有功能。</li>
</ul>
<h2 id="使用注解装配AOP"><a href="#使用注解装配AOP" class="headerlink" title="使用注解装配AOP"></a>使用注解装配AOP</h2><p>上一节我们讲解了使用AspectJ的注解，并配合一个复杂的<code>execution(* xxx.Xyz.*(..))</code>语法来定义应该如何装配AOP。</p>
<p>在实际项目中，这种写法其实很少使用。假设你写了一个<code>SecurityAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(public * com.itranswarp.learnjava.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SecurityContext.getCurrentUser() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;check failed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本能实现无差别全覆盖，即某个包下面的所有Bean的所有方法都会被这个<code>check()</code>方法拦截。</p>
<p>还有的童鞋喜欢用方法名前缀进行拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(public * update*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doLogging</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 对update开头的方法切换数据源:</span></span><br><span class="line">    String old = setCurrentDataSource(<span class="string">&quot;master&quot;</span>);</span><br><span class="line">    Object retVal = pjp.proceed();</span><br><span class="line">    restoreCurrentDataSource(old);</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种非精准打击误伤面更大，因为从方法前缀区分是否是数据库操作是非常不可取的。</p>
<p>我们在使用AOP时，要注意到虽然Spring容器可以把指定的方法通过AOP规则装配到指定的Bean的指定方法前后，但是，如果自动装配时，因为不恰当的范围，容易导致意想不到的结果，即很多不需要AOP代理的Bean也被自动代理了，并且，后续新增的Bean，如果不清楚现有的AOP装配规则，容易被强迫装配。</p>
<p>使用AOP时，被装配的Bean最好自己能清清楚楚地知道自己被安排了。例如，Spring提供的<code>@Transactional</code>就是一个非常好的例子。如果我们自己写的Bean希望在一个数据库事务中被调用，就标注上<code>@Transactional</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有事务:</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="function"><span class="title">createUser</span>(<span class="params"><span class="built_in">String</span> name</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无事务:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">isValidName</span>(<span class="params"><span class="built_in">String</span> name</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有事务:</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">updateUser</span>(<span class="params">User user</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者直接在class级别注解，表示“所有public方法都被安排了”：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Transactional</span></span><br><span class="line">public class UserService &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>@Transactional</code>，某个方法是否启用了事务就一清二楚了。因此，装配AOP的时候，使用注解是最好的方式。</p>
<p>我们以一个实际例子演示如何使用注解实现AOP装配。为了监控应用程序的性能，我们定义一个性能监控的注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Target</span>(METHOD)</span><br><span class="line"><span class="variable">@Retention</span>(RUNTIME)</span><br><span class="line">public <span class="variable">@interface</span> MetricTime &#123;</span><br><span class="line">    <span class="selector-tag">String</span> <span class="selector-tag">value</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要被监控的关键方法上标注该注解：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 监控register()方法性能:</span></span><br><span class="line">    <span class="meta">@MetricTime</span>(<span class="string">&quot;register&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> User <span class="function"><span class="title">register</span>(<span class="params"><span class="built_in">String</span> email, <span class="built_in">String</span> password, <span class="built_in">String</span> name</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们定义<code>MetricAspect</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(metricTime)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">metric</span><span class="params">(ProceedingJoinPoint joinPoint, MetricTime metricTime)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String name = metricTime.value();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> t = System.currentTimeMillis() - start;</span><br><span class="line">            <span class="comment">// 写入日志或发送至JMX:</span></span><br><span class="line">            System.err.println(<span class="string">&quot;[Metrics] &quot;</span> + name + <span class="string">&quot;: &quot;</span> + t + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>metric()</code>方法标注了<code>@Around(&quot;@annotation(metricTime)&quot;)</code>，它的意思是，符合条件的目标方法是带有<code>@MetricTime</code>注解的方法，因为<code>metric()</code>方法参数类型是<code>MetricTime</code>（注意参数名是<code>metricTime</code>不是<code>MetricTime</code>），我们通过它获取性能监控的名称。</p>
<p>有了<code>@MetricTime</code>注解，再配合<code>MetricAspect</code>，任何Bean，只要方法标注了<code>@MetricTime</code>注解，就可以自动实现性能监控。运行代码，输出结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Welcome, Bob!</span><br><span class="line"><span class="string">[Metrics]</span> register: <span class="number">16</span>ms</span><br></pre></td></tr></table></figure>

<h2 id="AOP避坑指南"><a href="#AOP避坑指南" class="headerlink" title="AOP避坑指南"></a>AOP避坑指南</h2><p>无论是使用AspectJ语法，还是配合Annotation，使用AOP，实际上就是让Spring自动为我们创建一个Proxy，使得调用方能无感知地调用指定方法，但运行期却动态“织入”了其他逻辑，因此，AOP本质上就是一个<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">代理模式</a>。</p>
<p>因为Spring使用了CGLIB来实现运行期动态创建Proxy，如果我们没能深入理解其运行原理和实现机制，就极有可能遇到各种诡异的问题。</p>
<p>我们来看一个实际的例子。</p>
<p>假设我们定义了一个<code>UserService</code>的Bean：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法:</span></span><br><span class="line">    <span class="keyword">public</span> UserService() &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;UserService(): init...&quot;</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;UserService(): zoneId = &quot;</span> + <span class="keyword">this</span>.zoneId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public方法:</span></span><br><span class="line">    <span class="keyword">public</span> ZoneId getZoneId() &#123;</span><br><span class="line">        <span class="keyword">return</span> zoneId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public final方法:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId getFinalZoneId() &#123;</span><br><span class="line">        <span class="keyword">return</span> zoneId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写个<code>MailService</code>，并注入<code>UserService</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">sendMail</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ZoneId zoneId = userService.zoneId;</span><br><span class="line">        <span class="built_in">String</span> dt = ZonedDateTime.now(zoneId).toString();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, it is &quot;</span> + dt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后用<code>main()</code>方法测试一下：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@Configuration</span></span><br><span class="line"><span class="keyword">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> AppConfig &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.<span class="keyword">class</span>);</span><br><span class="line">        MailService mailService = context.getBean(MailService.<span class="keyword">class</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(mailService.sendMail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看输出，一切正常：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">UserService</span>(): init...</span><br><span class="line"><span class="attribute">UserService</span>(): zoneId = Asia/Shanghai</span><br><span class="line"><span class="attribute">Hello</span>, it is <span class="number">2020</span>-<span class="number">04</span>-<span class="number">12</span>T<span class="number">10</span>:<span class="number">23</span>:<span class="number">22</span>.<span class="number">917721</span>+<span class="number">08</span>:<span class="number">00</span>[Asia/Shanghai]</span><br></pre></td></tr></table></figure>

<p>下一步，我们给<code>UserService</code>加上AOP支持，就添加一个最简单的<code>LoggingAspect</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Aspect</span></span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class LoggingAspect &#123;</span><br><span class="line">    <span class="variable">@Before</span>(<span class="string">&quot;execution(public * com..*.UserService.*(..))&quot;</span>)</span><br><span class="line">    public void doAccessCheck() &#123;</span><br><span class="line">        <span class="selector-tag">System</span><span class="selector-class">.err</span><span class="selector-class">.println</span>(<span class="string">&quot;[Before] do access check...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别忘了在<code>AppConfig</code>上加上<code>@EnableAspectJAutoProxy</code>。再次运行，不出意外的话，会得到一个<code>NullPointerException</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java<span class="selector-class">.lang</span><span class="selector-class">.NullPointerException</span>: zone</span><br><span class="line">    at java.base/java<span class="selector-class">.util</span><span class="selector-class">.Objects</span><span class="selector-class">.requireNonNull</span>(Objects<span class="selector-class">.java</span>:<span class="number">246</span>)</span><br><span class="line">    at java.base/java<span class="selector-class">.time</span><span class="selector-class">.Clock</span><span class="selector-class">.system</span>(Clock<span class="selector-class">.java</span>:<span class="number">203</span>)</span><br><span class="line">    at java.base/java<span class="selector-class">.time</span><span class="selector-class">.ZonedDateTime</span><span class="selector-class">.now</span>(ZonedDateTime<span class="selector-class">.java</span>:<span class="number">216</span>)</span><br><span class="line">    at com<span class="selector-class">.itranswarp</span><span class="selector-class">.learnjava</span><span class="selector-class">.service</span><span class="selector-class">.MailService</span><span class="selector-class">.sendMail</span>(MailService<span class="selector-class">.java</span>:<span class="number">19</span>)</span><br><span class="line">    at com<span class="selector-class">.itranswarp</span><span class="selector-class">.learnjava</span><span class="selector-class">.AppConfig</span><span class="selector-class">.main</span>(AppConfig<span class="selector-class">.java</span>:<span class="number">21</span>)</span><br></pre></td></tr></table></figure>

<p>仔细跟踪代码，会发现<code>null</code>值出现在<code>MailService.sendMail()</code>内部的这一行代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">sendMail</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ZoneId zoneId = userService.zoneId;</span><br><span class="line">        System.out.println(zoneId); <span class="comment">// null</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还故意在<code>UserService</code>中特意用<code>final</code>修饰了一下成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用<code>final</code>标注的成员变量为<code>null</code>？逗我呢？</p>
<h3 id="怎么肥四？"><a href="#怎么肥四？" class="headerlink" title="怎么肥四？"></a>怎么肥四？</h3><p>为什么加了AOP就报NPE，去了AOP就一切正常？<code>final</code>字段不执行，难道JVM有问题？为了解答这个诡异的问题，我们需要深入理解Spring使用CGLIB生成Proxy的原理：</p>
<p>第一步，正常创建一个<code>UserService</code>的原始实例，这是通过反射调用构造方法实现的，它的行为和我们预期的完全一致；</p>
<p>第二步，通过CGLIB创建一个<code>UserService</code>的子类，并引用了原始实例和<code>LoggingAspect</code>：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserService$$EnhancerBySpringCGLIB <span class="keyword">extends</span> UserService &#123;</span><br><span class="line">    UserService <span class="keyword">target</span>;</span><br><span class="line">    LoggingAspect <span class="class"><span class="keyword">aspect</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserService$$EnhancerBySpringCGLIB() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">ZoneId <span class="title">getZoneId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        aspect.doAccessCheck();</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">target</span>.<span class="title">getZoneId</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们观察Spring创建的AOP代理，它的类名总是类似<code>UserService$$EnhancerBySpringCGLIB$$1c76af9d</code>（你没看错，Java的类名实际上允许<code>$</code>字符）。为了让调用方获得<code>UserService</code>的引用，它必须继承自<code>UserService</code>。然后，该代理类会覆写所有<code>public</code>和<code>protected</code>方法，并在内部将调用委托给原始的<code>UserService</code>实例。</p>
<p>这里出现了两个<code>UserService</code>实例：</p>
<p>一个是我们代码中定义的<em>原始实例</em>，它的成员变量已经按照我们预期的方式被初始化完成：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">UserService original</span> = new UserService();</span><br></pre></td></tr></table></figure>

<p>第二个<code>UserService</code>实例实际上类型是<code>UserService$$EnhancerBySpringCGLIB</code>，它引用了原始的<code>UserService</code>实例：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserService<span class="symbol">$</span><span class="symbol">$</span>EnhancerBySpringCGLIB proxy = new UserService<span class="symbol">$</span><span class="symbol">$</span>EnhancerBySpringCGLIB();</span><br><span class="line">proxy.target = original;</span><br><span class="line">proxy.aspect = ...</span><br></pre></td></tr></table></figure>

<p>注意到这种情况仅出现在启用了AOP的情况，此刻，从<code>ApplicationContext</code>中获取的<code>UserService</code>实例是proxy，注入到<code>MailService</code>中的<code>UserService</code>实例也是proxy。</p>
<p>那么最终的问题来了：proxy实例的成员变量，也就是从<code>UserService</code>继承的<code>zoneId</code>，它的值是<code>null</code>。</p>
<p>原因在于，<code>UserService</code>成员变量的初始化：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>UserService$$EnhancerBySpringCGLIB</code>中，并未执行。原因是，没必要初始化proxy的成员变量，因为proxy的目的是代理方法。</p>
<p>实际上，成员变量的初始化是在构造方法中完成的。这是我们看到的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId zoneId = ZoneId.systemDefault();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是编译器实际编译的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ZoneId zoneId;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 构造方法的第一行代码总是调用super()</span></span><br><span class="line">        zoneId = ZoneId.systemDefault(); <span class="comment">// 继续初始化成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，对于Spring通过CGLIB动态创建的<code>UserService$$EnhancerBySpringCGLIB</code>代理类，它的构造方法中，并未调用<code>super()</code>，因此，从父类继承的成员变量，包括<code>final</code>类型的成员变量，统统都没有初始化。</p>
<p>有的童鞋会问：Java语言规定，任何类的构造方法，第一行必须调用<code>super()</code>，如果没有，编译器会自动加上，怎么Spring的CGLIB就可以搞特殊？</p>
<p>这是因为自动加<code>super()</code>的功能是Java编译器实现的，它发现你没加，就自动给加上，发现你加错了，就报编译错误。但实际上，如果直接构造字节码，一个类的构造方法中，不一定非要调用<code>super()</code>。Spring使用CGLIB构造的Proxy类，是直接生成字节码，并没有源码-编译-字节码这个步骤，因此：</p>
<p> Spring通过CGLIB创建的代理类，不会初始化代理类自身继承的任何成员变量，包括final类型的成员变量！</p>
<p>再考察<code>MailService</code>的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">sendMail</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        ZoneId zoneId = userService.zoneId;</span><br><span class="line">        System.out.println(zoneId); <span class="comment">// null</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有启用AOP，注入的是原始的<code>UserService</code>实例，那么一切正常，因为<code>UserService</code>实例的<code>zoneId</code>字段已经被正确初始化了。</p>
<p>如果启动了AOP，注入的是代理后的<code>UserService$$EnhancerBySpringCGLIB</code>实例，那么问题大了：获取的<code>UserService$$EnhancerBySpringCGLIB</code>实例的<code>zoneId</code>字段，永远为<code>null</code>。</p>
<p>那么问题来了：启用了AOP，如何修复？</p>
<p>修复很简单，只需要把直接访问字段的代码，改为通过方法访问：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">sendMail</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 不要直接访问UserService的字段:</span></span><br><span class="line">        ZoneId zoneId = userService.getZoneId();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论注入的<code>UserService</code>是原始实例还是代理实例，<code>getZoneId()</code>都能正常工作，因为代理类会覆写<code>getZoneId()</code>方法，并将其委托给原始实例：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserService$$EnhancerBySpringCGLIB <span class="keyword">extends</span> UserService &#123;</span><br><span class="line">    UserService <span class="keyword">target</span> = ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function">ZoneId <span class="title">getZoneId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">target</span>.<span class="title">getZoneId</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到我们还给<code>UserService</code>添加了一个<code>public</code>+<code>final</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ZoneId <span class="title">getFinalZoneId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zoneId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在<code>MailService</code>中，调用的不是<code>getZoneId()</code>，而是<code>getFinalZoneId()</code>，又会出现<code>NullPointerException</code>，这是因为，代理类无法覆写<code>final</code>方法（这一点绕不过JVM的ClassLoader检查），该方法返回的是代理类的<code>zoneId</code>字段，即<code>null</code>。</p>
<p>实际上，如果我们加上日志，Spring在启动时会打印一个警告：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">43</span>:<span class="number">09.929</span> [main] DEBUG org.springframework.aop.framework.CglibAopProxy - <span class="keyword">Final</span> <span class="function"><span class="keyword">method</span> [<span class="title">public</span> <span class="title">final</span> <span class="title">java</span>.<span class="title">time</span>.<span class="title">ZoneId</span> <span class="title">xxx</span>.<span class="title">UserService</span>.<span class="title">getFinalZoneId</span><span class="params">()</span>] <span class="title">cannot</span> <span class="title">get</span> <span class="title">proxied</span> <span class="title">via</span> <span class="title">CGLIB</span>:</span> Calls <span class="keyword">to</span> this <span class="function"><span class="keyword">method</span> <span class="title">will</span> <span class="title">NOT</span> <span class="title">be</span> <span class="title">routed</span> <span class="title">to</span> <span class="title">the</span> <span class="title">target</span> <span class="title">instance</span> <span class="title">and</span> <span class="title">might</span> <span class="title">lead</span> <span class="title">to</span> <span class="title">NPEs</span> <span class="title">against</span> <span class="title">uninitialized</span> <span class="title">fields</span> <span class="title">in</span> <span class="title">the</span> <span class="title">proxy</span> <span class="title">instance</span>.</span></span><br></pre></td></tr></table></figure>

<p>上面的日志大意就是，因为被代理的<code>UserService</code>有一个<code>final</code>方法<code>getFinalZoneId()</code>，这会导致其他Bean如果调用此方法，无法将其代理到真正的原始实例，从而可能发生NPE异常。</p>
<p>因此，正确使用AOP，我们需要一个避坑指南：</p>
<ol>
<li>访问被注入的Bean时，总是调用方法而非直接访问字段；</li>
<li>编写Bean时，如果可能会被代理，就不要编写<code>public final</code>方法。</li>
</ol>
<p>这样才能保证有没有AOP，代码都能正常工作。</p>
<h3 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>为什么Spring刻意不初始化Proxy继承的字段？</p>
<p>如果一个Bean不允许任何AOP代理，应该怎么做来“保护”自己在运行期不会被代理？</p>
<h1 id="4-访问数据库"><a href="#4-访问数据库" class="headerlink" title="4. 访问数据库"></a>4. 访问数据库</h1><h2 id="4-0-简介"><a href="#4-0-简介" class="headerlink" title="4.0 简介"></a>4.0 简介</h2><p>数据库基本上是现代应用程序的标准存储，绝大多数程序都把自己的业务数据存储在关系数据库中，可见，访问数据库几乎是所有应用程序必备能力。</p>
<p>我们在前面已经介绍了Java程序访问数据库的标准接口JDBC，它的实现方式非常简洁，即：Java标准库定义接口，各数据库厂商以“驱动”的形式实现接口。应用程序要使用哪个数据库，就把该数据库厂商的驱动以jar包形式引入进来，同时自身仅使用JDBC接口，编译期并不需要特定厂商的驱动。</p>
<p>使用JDBC虽然简单，但代码比较繁琐。Spring为了简化数据库访问，主要做了以下几点工作：</p>
<ul>
<li>提供了简化的访问JDBC的模板类，不必手动释放资源；</li>
<li>提供了一个统一的DAO类以实现Data Access Object模式；</li>
<li>把<code>SQLException</code>封装为<code>DataAccessException</code>，这个异常是一个<code>RuntimeException</code>，并且让我们能区分SQL异常的原因，例如，<code>DuplicateKeyException</code>表示违反了一个唯一约束；</li>
<li>能方便地集成Hibernate、JPA和MyBatis这些数据库访问框架。</li>
</ul>
<p>本章我们将详细讲解在Spring中访问数据库的最佳实践。</p>
<h2 id="4-1-使用声明式事务"><a href="#4-1-使用声明式事务" class="headerlink" title="4.1 使用声明式事务"></a>4.1 使用声明式事务</h2><p>我们在前面介绍<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943820274272">JDBC编程</a>时已经讲过，Java程序使用JDBC接口访问关系数据库的时候，需要以下几步：</p>
<ul>
<li>创建全局<code>DataSource</code>实例，表示数据库连接池；</li>
<li>在需要读写数据库的方法内部，按如下步骤访问数据库：<ul>
<li>从全局<code>DataSource</code>实例获取<code>Connection</code>实例；</li>
<li>通过<code>Connection</code>实例创建<code>PreparedStatement</code>实例；</li>
<li>执行SQL语句，如果是查询，则通过<code>ResultSet</code>读取结果集，如果是修改，则获得<code>int</code>结果。</li>
</ul>
</li>
</ul>
<p>正确编写JDBC代码的关键是使用<code>try ... finally</code>释放资源，涉及到事务的代码需要正确提交或回滚事务。</p>
<p>在Spring使用JDBC，首先我们通过IoC容器创建并管理一个<code>DataSource</code>实例，然后，Spring提供了一个<code>JdbcTemplate</code>，可以方便地让我们操作JDBC，因此，通常情况下，我们会实例化一个<code>JdbcTemplate</code>。顾名思义，这个类主要使用了<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319636041762">Template模式</a>。</p>
<p>编写示例代码或者测试代码时，我们强烈推荐使用<a target="_blank" rel="noopener" href="http://hsqldb.org/">HSQLDB</a>这个数据库，它是一个用Java编写的关系数据库，可以以内存模式或者文件模式运行，本身只有一个jar包，非常适合演示代码或者测试代码。</p>
<p>我们以实际工程为例，先创建Maven工程<code>spring-data-jdbc</code>，然后引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在AppConfig中，我们需要创建以下几个必须的Bean：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan</span><br><span class="line">@<span class="constructor">PropertySource(<span class="string">&quot;jdbc.properties&quot;</span>)</span></span><br><span class="line">public <span class="keyword">class</span> AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @<span class="constructor">Value(<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>)</span></span><br><span class="line">    String jdbcUrl;</span><br><span class="line"></span><br><span class="line">    @<span class="constructor">Value(<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>)</span></span><br><span class="line">    String jdbcUsername;</span><br><span class="line"></span><br><span class="line">    @<span class="constructor">Value(<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>)</span></span><br><span class="line">    String jdbcPassword;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    DataSource create<span class="constructor">DataSource()</span> &#123;</span><br><span class="line">        HikariConfig config = <span class="keyword">new</span> <span class="constructor">HikariConfig()</span>;</span><br><span class="line">        config.set<span class="constructor">JdbcUrl(<span class="params">jdbcUrl</span>)</span>;</span><br><span class="line">        config.set<span class="constructor">Username(<span class="params">jdbcUsername</span>)</span>;</span><br><span class="line">        config.set<span class="constructor">Password(<span class="params">jdbcPassword</span>)</span>;</span><br><span class="line">        config.add<span class="constructor">DataSourceProperty(<span class="string">&quot;autoCommit&quot;</span>, <span class="string">&quot;true&quot;</span>)</span>;</span><br><span class="line">        config.add<span class="constructor">DataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;5&quot;</span>)</span>;</span><br><span class="line">        config.add<span class="constructor">DataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60&quot;</span>)</span>;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">HikariDataSource(<span class="params">config</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    JdbcTemplate create<span class="constructor">JdbcTemplate(@Autowired DataSource <span class="params">dataSource</span>)</span> &#123;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">JdbcTemplate(<span class="params">dataSource</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述配置中：</p>
<ol>
<li>通过<code>@PropertySource(&quot;jdbc.properties&quot;)</code>读取数据库配置文件；</li>
<li>通过<code>@Value(&quot;$&#123;jdbc.url&#125;&quot;)</code>注入配置文件的相关配置；</li>
<li>创建一个DataSource实例，它的实际类型是<code>HikariDataSource</code>，创建时需要用到注入的配置；</li>
<li>创建一个JdbcTemplate实例，它需要注入<code>DataSource</code>，这是通过方法参数完成注入的。</li>
</ol>
<p>最后，针对HSQLDB写一个配置文件<code>jdbc.properties</code>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据库文件名为testdb:</span></span><br><span class="line">jdbc.<span class="attribute">url</span>=jdbc:hsqldb:file:testdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hsqldb默认的用户名是sa，口令是空字符串:</span></span><br><span class="line">jdbc.<span class="attribute">username</span>=sa</span><br><span class="line">jdbc.password=</span><br></pre></td></tr></table></figure>

<p>可以通过HSQLDB自带的工具来初始化数据库表，这里我们写一个Bean，在Spring容器启动时自动创建一个<code>users</code>表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">&quot;CREATE TABLE IF NOT EXISTS users (&quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;id BIGINT IDENTITY NOT NULL PRIMARY KEY, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;email VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;password VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;name VARCHAR(100) NOT NULL, &quot;</span> <span class="comment">//</span></span><br><span class="line">                + <span class="string">&quot;UNIQUE (email))&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，所有准备工作都已完毕。我们只需要在需要访问数据库的Bean中，注入<code>JdbcTemplate</code>即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JdbcTemplate用法"><a href="#JdbcTemplate用法" class="headerlink" title="JdbcTemplate用法"></a>JdbcTemplate用法</h3><p>Spring提供的<code>JdbcTemplate</code>采用Template模式，提供了一系列以回调为特点的工具方法，目的是避免繁琐的<code>try...catch</code>语句。</p>
<p>我们以具体的示例来说明JdbcTemplate的用法。</p>
<p>首先我们看<code>T execute(ConnectionCallback&lt;T&gt; action)</code>方法，它提供了Jdbc的<code>Connection</code>供我们使用：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User getUserById(<span class="built_in">long</span> id) &#123;</span><br><span class="line">    <span class="comment">// 注意传入的是ConnectionCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute((Connection conn) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 可以直接使用conn实例，不要释放它，回调结束后JdbcTemplate自动释放:</span></span><br><span class="line">        <span class="comment">// 在内部手动创建的PreparedStatement、ResultSet必须用try(...)释放:</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="built_in">var</span> ps = conn.prepareStatement(<span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)) &#123;</span><br><span class="line">            ps.setObject(<span class="number">1</span>, id);</span><br><span class="line">            <span class="keyword">try</span> (<span class="built_in">var</span> rs = ps.executeQuery()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rs.<span class="keyword">next</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> User( <span class="comment">// new User object:</span></span><br><span class="line">                            rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                            rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，上述回调方法允许获取Connection，然后做任何基于Connection的操作。</p>
<p>我们再看<code>T execute(String sql, PreparedStatementCallback&lt;T&gt; action)</code>的用法：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User getUserByName(<span class="keyword">String</span> name) &#123;</span><br><span class="line">    <span class="comment">// 需要传入SQL语句，以及PreparedStatementCallback:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.execute(<span class="string">&quot;SELECT * FROM users WHERE name = ?&quot;</span>, (PreparedStatement ps) -&gt; &#123;</span><br><span class="line">        <span class="comment">// PreparedStatement实例已经由JdbcTemplate创建，并在回调后自动释放:</span></span><br><span class="line">        ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">var</span> rs = ps.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">User</span>( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;user not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们看<code>T queryForObject(String sql, Object[] args, RowMapper&lt;T&gt; rowMapper)</code>方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="function"><span class="title">getUserByEmail</span>(<span class="params"><span class="built_in">String</span> email</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 传入SQL，参数和RowMapper实例:</span></span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT * FROM users WHERE email = ?&quot;</span>, <span class="keyword">new</span> <span class="built_in">Object</span>[] &#123; email &#125;,</span><br><span class="line">            (ResultSet rs, int rowNum) -&gt; &#123;</span><br><span class="line">                <span class="comment">// 将ResultSet的当前行映射为一个JavaBean:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> User( <span class="comment">// new User object:</span></span><br><span class="line">                        rs.getLong(<span class="string">&quot;id&quot;</span>), <span class="comment">// id</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;email&quot;</span>), <span class="comment">// email</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;password&quot;</span>), <span class="comment">// password</span></span><br><span class="line">                        rs.getString(<span class="string">&quot;name&quot;</span>)); <span class="comment">// name</span></span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>queryForObject()</code>方法中，传入SQL以及SQL参数后，<code>JdbcTemplate</code>会自动创建<code>PreparedStatement</code>，自动执行查询并返回<code>ResultSet</code>，我们提供的<code>RowMapper</code>需要做的事情就是把<code>ResultSet</code>的当前行映射成一个JavaBean并返回。整个过程中，使用<code>Connection</code>、<code>PreparedStatement</code>和<code>ResultSet</code>都不需要我们手动管理。</p>
<p><code>RowMapper</code>不一定返回JavaBean，实际上它可以返回任何Java对象。例如，使用<code>SELECT COUNT(*)</code>查询时，可以返回<code>Long</code>：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">long</span> <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.queryForObject(<span class="string">&quot;SELECT COUNT(*) FROM users&quot;</span>, <span class="keyword">null</span>, (ResultSet rs, <span class="keyword">int</span> rowNum) -&gt; &#123;</span><br><span class="line">        <span class="comment">// SELECT COUNT(*)查询只有一列，取第一列数据:</span></span><br><span class="line">        <span class="function"><span class="keyword">return</span> rs.<span class="title">getLong</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们期望返回多行记录，而不是一行，可以用<code>query()</code>方法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> List&lt;<span class="keyword">User</span>&gt; getUsers(<span class="type">int</span> pageIndex) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">limit</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="keyword">offset</span> = <span class="keyword">limit</span> * (pageIndex - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate.query(&quot;SELECT * FROM users LIMIT ? OFFSET ?&quot;, <span class="built_in">new</span> <span class="keyword">Object</span>[] &#123; <span class="keyword">limit</span>, <span class="keyword">offset</span> &#125;,</span><br><span class="line">            <span class="built_in">new</span> BeanPropertyRowMapper&lt;&gt;(<span class="keyword">User</span>.<span class="keyword">class</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述<code>query()</code>方法传入的参数仍然是SQL、SQL参数以及<code>RowMapper</code>实例。这里我们直接使用Spring提供的<code>BeanPropertyRowMapper</code>。如果数据库表的结构恰好和JavaBean的属性名称一致，那么<code>BeanPropertyRowMapper</code>就可以直接把一行记录按列名转换为JavaBean。</p>
<p>如果我们执行的不是查询，而是插入、更新和删除操作，那么需要使用<code>update()</code>方法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> updateUser(<span class="keyword">User</span> <span class="keyword">user</span>) &#123;</span><br><span class="line">    // 传入<span class="keyword">SQL</span>，<span class="keyword">SQL</span>参数，返回更新的行数:</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != jdbcTemplate.<span class="keyword">update</span>(&quot;UPDATE user SET name = ? WHERE id=?&quot;, <span class="keyword">user</span>.getName(), <span class="keyword">user</span>.getId())) &#123;</span><br><span class="line">        throw <span class="built_in">new</span> RuntimeException(&quot;User not found by id&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有一种<code>INSERT</code>操作比较特殊，那就是如果某一列是自增列（例如自增主键），通常，我们需要获取插入后的自增值。<code>JdbcTemplate</code>提供了一个<code>KeyHolder</code>来简化这一操作：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> User register(<span class="keyword">String</span> email, <span class="keyword">String</span> password, <span class="keyword">String</span> name) &#123;</span><br><span class="line">    <span class="comment">// 创建一个KeyHolder:</span></span><br><span class="line">    KeyHolder holder = <span class="keyword">new</span> <span class="type">GeneratedKeyHolder</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> != jdbcTemplate.update(</span><br><span class="line">        <span class="comment">// 参数1:PreparedStatementCreator</span></span><br><span class="line">        (conn) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 创建PreparedStatement时，必须指定RETURN_GENERATED_KEYS:</span></span><br><span class="line">            <span class="keyword">var</span> ps = conn.prepareStatement(<span class="string">&quot;INSERT INTO users(email,password,name) VALUES(?,?,?)&quot;</span>,</span><br><span class="line">                    Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">            ps.setObject(<span class="number">1</span>, email);</span><br><span class="line">            ps.setObject(<span class="number">2</span>, password);</span><br><span class="line">            ps.setObject(<span class="number">3</span>, name);</span><br><span class="line">            <span class="keyword">return</span> ps;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 参数2:KeyHolder</span></span><br><span class="line">        holder)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;Insert failed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从KeyHolder中获取返回的自增值:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">User</span>(holder.getKey().longValue(), email, password, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JdbcTemplate</code>还有许多重载方法，这里我们不一一介绍。需要强调的是，<code>JdbcTemplate</code>只是对JDBC操作的一个简单封装，它的目的是尽量减少手动编写<code>try(resource) &#123;...&#125;</code>的代码，对于查询，主要通过<code>RowMapper</code>实现了JDBC结果集到Java对象的转换。</p>
<p>我们总结一下<code>JdbcTemplate</code>的用法，那就是：</p>
<ul>
<li>针对简单查询，优选<code>query()</code>和<code>queryForObject()</code>，因为只需提供SQL语句、参数和<code>RowMapper</code>；</li>
<li>针对更新操作，优选<code>update()</code>，因为只需提供SQL语句和参数；</li>
<li>任何复杂的操作，最终也可以通过<code>execute(ConnectionCallback)</code>实现，因为拿到<code>Connection</code>就可以做任何JDBC操作。</li>
</ul>
<p>实际上我们使用最多的仍然是各种查询。如果在设计表结构的时候，能够和JavaBean的属性一一对应，那么直接使用<code>BeanPropertyRowMapper</code>就很方便。如果表结构和JavaBean不一致怎么办？那就需要稍微改写一下查询，使结果集的结构和JavaBean保持一致。</p>
<p>例如，表的列名是<code>office_address</code>，而JavaBean属性是<code>workAddress</code>，就需要指定别名，改写查询如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, email, office_address <span class="keyword">AS</span> workAddress, <span class="type">name</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email = ?</span><br></pre></td></tr></table></figure>

<h2 id="4-3-使用DAO"><a href="#4-3-使用DAO" class="headerlink" title="4.3 使用DAO"></a>4.3 使用DAO</h2><p>在传统的多层应用程序中，通常是Web层调用业务层，业务层调用数据访问层。业务层负责处理各种业务逻辑，而数据访问层只负责对数据进行增删改查。因此，实现数据访问层就是用<code>JdbcTemplate</code>实现对数据库的操作。</p>
<p>编写数据访问层的时候，可以使用DAO模式。DAO即Data Access Object的缩写，它没有什么神秘之处，实现起来基本如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">User</span> <span class="title">getById</span>(long id) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List<span class="tag">&lt;User&gt;</span> getUsers(int page) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">User</span> <span class="title">createUser</span>(<span class="keyword">User</span> <span class="title">user</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">User</span> <span class="title">updateUser</span>(<span class="keyword">User</span> <span class="title">user</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void deleteUser(<span class="keyword">User</span> <span class="title">user</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring提供了一个<code>JdbcDaoSupport</code>类，用于简化DAO的实现。这个<code>JdbcDaoSupport</code>没什么复杂的，核心代码就是持有一个<code>JdbcTemplate</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">JdbcTemplate</span> jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">final</span> void setJdbcTemplate(<span class="type">JdbcTemplate</span> jdbcTemplate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">        initTemplateConfig();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="keyword">final</span> <span class="type">JdbcTemplate</span> getJdbcTemplate() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的意图是子类直接从<code>JdbcDaoSupport</code>继承后，可以随时调用<code>getJdbcTemplate()</code>获得<code>JdbcTemplate</code>的实例。那么问题来了：因为<code>JdbcDaoSupport</code>的<code>jdbcTemplate</code>字段没有标记<code>@Autowired</code>，所以，子类想要注入<code>JdbcTemplate</code>，还得自己想个办法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="type">JdbcTemplate</span> jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        <span class="keyword">super</span>.setJdbcTemplate(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有的童鞋可能看出来了：既然<code>UserDao</code>都已经注入了<code>JdbcTemplate</code>，那再把它放到父类里，通过<code>getJdbcTemplate()</code>访问岂不是多此一举？</p>
<p>如果使用传统的XML配置，并不需要编写<code>@Autowired JdbcTemplate jdbcTemplate</code>，但是考虑到现在基本上是使用注解的方式，我们可以编写一个<code>AbstractDao</code>，专门负责注入<code>JdbcTemplate</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">JdbcTemplate</span> jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    public void init() &#123;</span><br><span class="line">        <span class="keyword">super</span>.setJdbcTemplate(jdbcTemplate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，子类的代码就非常干净，可以直接调用<code>getJdbcTemplate()</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">AbstractDao</span> </span>&#123;</span><br><span class="line">    public <span class="type">User</span> getById(long id) &#123;</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().queryForObject(</span><br><span class="line">                <span class="string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> <span class="type">BeanPropertyRowMapper</span>&lt;&gt;(<span class="type">User</span>.<span class="keyword">class</span>),</span><br><span class="line">                id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倘若肯再多写一点样板代码，就可以把<code>AbstractDao</code>改成泛型，并实现<code>getById()</code>，<code>getAll()</code>，<code>deleteById()</code>这样的通用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDao</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String table;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; entityClass;</span><br><span class="line">    <span class="keyword">private</span> RowMapper&lt;T&gt; rowMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前类型的泛型类型:</span></span><br><span class="line">        <span class="keyword">this</span>.entityClass = getParameterizedType();</span><br><span class="line">        <span class="keyword">this</span>.table = <span class="keyword">this</span>.entityClass.getSimpleName().toLowerCase() + <span class="string">&quot;s&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().queryForObject(<span class="string">&quot;SELECT * FROM &quot;</span> + table + <span class="string">&quot; WHERE id = ?&quot;</span>, <span class="keyword">this</span>.rowMapper, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getAll</span><span class="params">(<span class="keyword">int</span> pageIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> limit = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> offset = limit * (pageIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> getJdbcTemplate().query(<span class="string">&quot;SELECT * FROM &quot;</span> + table + <span class="string">&quot; LIMIT ? OFFSET ?&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123; limit, offset &#125;,</span><br><span class="line">                <span class="keyword">this</span>.rowMapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        getJdbcTemplate().update(<span class="string">&quot;DELETE FROM &quot;</span> + table + <span class="string">&quot; WHERE id = ?&quot;</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，每个子类就自动获得了这些通用方法：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Transactional</span></span><br><span class="line">public class UserDao extends AbstractDao&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 已经有了:</span></span><br><span class="line">    <span class="comment">// User getById(long)</span></span><br><span class="line">    <span class="comment">// List&lt;User&gt; getAll(int)</span></span><br><span class="line">    <span class="comment">// void deleteById(long)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Transactional</span></span><br><span class="line">public class BookDao extends AbstractDao&lt;Book&gt; &#123;</span><br><span class="line">    <span class="comment">// 已经有了:</span></span><br><span class="line">    <span class="comment">// Book getById(long)</span></span><br><span class="line">    <span class="comment">// List&lt;Book&gt; getAll(int)</span></span><br><span class="line">    <span class="comment">// void deleteById(long)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，DAO模式就是一个简单的数据访问模式，是否使用DAO，根据实际情况决定，因为很多时候，直接在Service层操作数据库也是完全没有问题的。</p>
<h2 id="4-4-集成Hibernate"><a href="#4-4-集成Hibernate" class="headerlink" title="4.4 集成Hibernate"></a>4.4 集成Hibernate</h2><p>使用<code>JdbcTemplate</code>的时候，我们用得最多的方法就是<code>List&lt;T&gt; query(String sql, Object[] args, RowMapper rowMapper)</code>。这个<code>RowMapper</code>的作用就是把<code>ResultSet</code>的一行记录映射为Java Bean。</p>
<p>这种把关系数据库的表记录映射为Java对象的过程就是ORM：Object-Relational Mapping。ORM既可以把记录转换成Java对象，也可以把Java对象转换为行记录。</p>
<p>使用<code>JdbcTemplate</code>配合<code>RowMapper</code>可以看作是最原始的ORM。如果要实现更自动化的ORM，可以选择成熟的ORM框架，例如<a target="_blank" rel="noopener" href="https://hibernate.org/">Hibernate</a>。</p>
<p>我们来看看如何在Spring中集成Hibernate。</p>
<p>Hibernate作为ORM框架，它可以替代<code>JdbcTemplate</code>，但Hibernate仍然需要JDBC驱动，所以，我们需要引入JDBC驱动、连接池，以及Hibernate本身。在Maven中，我们加入以下依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JDBC驱动，这里使用HSQLDB --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hsqldb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hsqldb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- JDBC连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Hibernate --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.2.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Spring Context和Spring ORM --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在AppConfig中，我们仍然需要创建DataSource、引入JDBC配置文件，以及启用声明式事务：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(<span class="string">&quot;jdbc.properties&quot;</span>)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    DataSource createDataSource() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了启用Hibernate，我们需要创建一个<code>LocalSessionFactoryBean</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">class</span> AppConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    LocalSessionFactoryBean create<span class="constructor">SessionFactory(@Autowired DataSource <span class="params">dataSource</span>)</span> &#123;</span><br><span class="line">        var props = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">        props.set<span class="constructor">Property(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>)</span>; <span class="comment">// 生产环境不要使用</span></span><br><span class="line">        props.set<span class="constructor">Property(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>)</span>;</span><br><span class="line">        props.set<span class="constructor">Property(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>)</span>;</span><br><span class="line">        var sessionFactoryBean = <span class="keyword">new</span> <span class="constructor">LocalSessionFactoryBean()</span>;</span><br><span class="line">        sessionFactoryBean.set<span class="constructor">DataSource(<span class="params">dataSource</span>)</span>;</span><br><span class="line">        <span class="comment">// 扫描指定的package获取所有entity class:</span></span><br><span class="line">        sessionFactoryBean.set<span class="constructor">PackagesToScan(<span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>)</span>;</span><br><span class="line">        sessionFactoryBean.set<span class="constructor">HibernateProperties(<span class="params">props</span>)</span>;</span><br><span class="line">        return sessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意我们在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1308043627200545">定制Bean</a>中讲到过<code>FactoryBean</code>，<code>LocalSessionFactoryBean</code>是一个<code>FactoryBean</code>，它会再自动创建一个<code>SessionFactory</code>，在Hibernate中，<code>Session</code>是封装了一个JDBC <code>Connection</code>的实例，而<code>SessionFactory</code>是封装了JDBC <code>DataSource</code>的实例，即<code>SessionFactory</code>持有连接池，每次需要操作数据库的时候，<code>SessionFactory</code>创建一个新的<code>Session</code>，相当于从连接池获取到一个新的<code>Connection</code>。<code>SessionFactory</code>就是Hibernate提供的最核心的一个对象，但<code>LocalSessionFactoryBean</code>是Spring提供的为了让我们方便创建<code>SessionFactory</code>的类。</p>
<p>注意到上面创建<code>LocalSessionFactoryBean</code>的代码，首先用<code>Properties</code>持有Hibernate初始化<code>SessionFactory</code>时用到的所有设置，常用的设置请参考<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#configurations">Hibernate文档</a>，这里我们只定义了3个设置：</p>
<ul>
<li><code>hibernate.hbm2ddl.auto=update</code>：表示自动创建数据库的表结构，注意不要在生产环境中启用；</li>
<li><code>hibernate.dialect=org.hibernate.dialect.HSQLDialect</code>：指示Hibernate使用的数据库是HSQLDB。Hibernate使用一种HQL的查询语句，它和SQL类似，但真正在“翻译”成SQL时，会根据设定的数据库“方言”来生成针对数据库优化的SQL；</li>
<li><code>hibernate.show_sql=true</code>：让Hibernate打印执行的SQL，这对于调试非常有用，我们可以方便地看到Hibernate生成的SQL语句是否符合我们的预期。</li>
</ul>
<p>除了设置<code>DataSource</code>和<code>Properties</code>之外，注意到<code>setPackagesToScan()</code>我们传入了一个<code>package</code>名称，它指示Hibernate扫描这个包下面的所有Java类，自动找出能映射为数据库表记录的JavaBean。后面我们会仔细讨论如何编写符合Hibernate要求的JavaBean。</p>
<p>紧接着，我们还需要创建<code>HibernateTemplate</code>以及<code>HibernateTransactionManager</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">AppConfig</span> &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    HibernateTemplate createHibernateTemplate(<span class="variable">@Autowired</span> SessionFactory sessionFactory) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">HibernateTemplate</span>(sessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Bean</span></span><br><span class="line">    <span class="selector-tag">PlatformTransactionManager</span> <span class="selector-tag">createTxManager</span>(<span class="variable">@Autowired</span> SessionFactory sessionFactory) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">HibernateTransactionManager</span>(sessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个Bean的创建都十分简单。<code>HibernateTransactionManager</code>是配合Hibernate使用声明式事务所必须的，而<code>HibernateTemplate</code>则是Spring为了便于我们使用Hibernate提供的工具类，不是非用不可，但推荐使用以简化代码。</p>
<p>到此为止，所有的配置都定义完毕，我们来看看如何将数据库表结构映射为Java对象。</p>
<p>考察如下的数据库表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    createdAt <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `email` (`email`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>其中，<code>id</code>是自增主键，<code>email</code>、<code>password</code>、<code>name</code>是<code>VARCHAR</code>类型，<code>email</code>带唯一索引以确保唯一性，<code>createdAt</code>存储整型类型的时间戳。用JavaBean表示如下：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> email;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters and setters</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种映射关系十分易懂，但我们需要添加一些注解来告诉Hibernate如何把<code>User</code>类映射到表记录：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line">public class User &#123;</span><br><span class="line">    <span class="variable">@Id</span></span><br><span class="line">    <span class="variable">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, updatable = false)</span><br><span class="line">    public Long getId() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, unique = true, length = <span class="number">100</span>)</span><br><span class="line">    public String getEmail() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, length = <span class="number">100</span>)</span><br><span class="line">    public String getPassword() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, length = <span class="number">100</span>)</span><br><span class="line">    public String getName() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, updatable = false)</span><br><span class="line">    public Long getCreatedAt() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个JavaBean被用于映射，我们就标记一个<code>@Entity</code>。默认情况下，映射的表名是<code>user</code>，如果实际的表名不同，例如实际表名是<code>users</code>，可以追加一个<code>@Table(name=&quot;users&quot;)</code>表示：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Table</span>(name=&quot;users)</span><br><span class="line">public class User &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个属性到数据库列的映射用<code>@Column()</code>标识，<code>nullable</code>指示列是否允许为<code>NULL</code>，<code>updatable</code>指示该列是否允许被用在<code>UPDATE</code>语句，<code>length</code>指示<code>String</code>类型的列的长度（如果没有指定，默认是<code>255</code>）。</p>
<p>对于主键，还需要用<code>@Id</code>标识，自增主键再追加一个<code>@GeneratedValue</code>，以便Hibernate能读取到自增主键的值。</p>
<p>细心的童鞋可能还注意到，主键<code>id</code>定义的类型不是<code>long</code>，而是<code>Long</code>。这是因为Hibernate如果检测到主键为<code>null</code>，就不会在<code>INSERT</code>语句中指定主键的值，而是返回由数据库生成的自增值，否则，Hibernate认为我们的程序指定了主键的值，会在<code>INSERT</code>语句中直接列出。<code>long</code>型字段总是具有默认值<code>0</code>，因此，每次插入的主键值总是0，导致除第一次外后续插入都将失败。</p>
<p><code>createdAt</code>虽然是整型，但我们并没有使用<code>long</code>，而是<code>Long</code>，这是因为使用基本类型会导致某种查询会添加意外的条件，后面我们会详细讨论，这里只需牢记，作为映射使用的JavaBean，所有属性都使用包装类型而不是基本类型。</p>
<p> 使用Hibernate时，不要使用基本类型的属性，总是使用包装类型，如Long或Integer。</p>
<p>类似的，我们再定义一个<code>Book</code>类：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line">public class Book &#123;</span><br><span class="line">    <span class="variable">@Id</span></span><br><span class="line">    <span class="variable">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, updatable = false)</span><br><span class="line">    public Long getId() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, length = <span class="number">100</span>)</span><br><span class="line">    public String getTitle() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, updatable = false)</span><br><span class="line">    public Long getCreatedAt() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仔细观察<code>User</code>和<code>Book</code>，会发现它们定义的<code>id</code>、<code>createdAt</code>属性是一样的，这在数据库表结构的设计中很常见：对于每个表，通常我们会统一使用一种主键生成机制，并添加<code>createdAt</code>表示创建时间，<code>updatedAt</code>表示修改时间等通用字段。</p>
<p>不必在<code>User</code>和<code>Book</code>中重复定义这些通用字段，我们可以把它们提到一个抽象类中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="literal">false</span>, updatable = <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">public</span> Long <span class="function"><span class="title">getId</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(nullable = <span class="literal">false</span>, updatable = <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">public</span> Long <span class="function"><span class="title">getCreatedAt</span>(<span class="params"></span>)</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transient</span></span><br><span class="line">    <span class="keyword">public</span> ZonedDateTime <span class="function"><span class="title">getCreatedDateTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(<span class="built_in">this</span>.createdAt).atZone(ZoneId.systemDefault());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PrePersist</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">preInsert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        setCreatedAt(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>AbstractEntity</code>来说，我们要标注一个<code>@MappedSuperclass</code>表示它用于继承。此外，注意到我们定义了一个<code>@Transient</code>方法，它返回一个“虚拟”的属性。因为<code>getCreatedDateTime()</code>是计算得出的属性，而不是从数据库表读出的值，因此必须要标注<code>@Transient</code>，否则Hibernate会尝试从数据库读取名为<code>createdDateTime</code>这个不存在的字段从而出错。</p>
<p>再注意到<code>@PrePersist</code>标识的方法，它表示在我们将一个JavaBean持久化到数据库之前（即执行INSERT语句），Hibernate会先执行该方法，这样我们就可以自动设置好<code>createdAt</code>属性。</p>
<p>有了<code>AbstractEntity</code>，我们就可以大幅简化<code>User</code>和<code>Book</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line">public class User extends AbstractEntity &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, unique = true, length = <span class="number">100</span>)</span><br><span class="line">    public String getEmail() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, length = <span class="number">100</span>)</span><br><span class="line">    public String getPassword() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Column</span>(nullable = false, length = <span class="number">100</span>)</span><br><span class="line">    public String getName() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到使用的所有注解均来自<code>javax.persistence</code>，它是JPA规范的一部分。这里我们只介绍使用注解的方式配置Hibernate映射关系，不再介绍传统的比较繁琐的XML配置。通过Spring集成Hibernate时，也不再需要<code>hibernate.cfg.xml</code>配置文件，用一句话总结：</p>
<p> 使用Spring集成Hibernate，配合JPA注解，无需任何额外的XML配置。</p>
<p>类似<code>User</code>、<code>Book</code>这样的用于ORM的Java Bean，我们通常称之为Entity Bean。</p>
<p>最后，我们来看看如果对<code>user</code>表进行增删改查。因为使用了Hibernate，因此，我们要做的，实际上是对<code>User</code>这个JavaBean进行“增删改查”。我们编写一个<code>UserService</code>，注入<code>HibernateTemplate</code>以便简化代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Transactional</span></span><br><span class="line">public class UserService &#123;</span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    HibernateTemplate hibernateTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Insert操作"><a href="#Insert操作" class="headerlink" title="Insert操作"></a>Insert操作</h3><p>要持久化一个<code>User</code>实例，我们只需调用<code>save()</code>方法。以<code>register()</code>方法为例，代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public User register(String email, String password, String name) &#123;</span><br><span class="line">    <span class="comment">// 创建一个User对象:</span></span><br><span class="line">    User user = <span class="keyword">new</span> <span class="constructor">User()</span>;</span><br><span class="line">    <span class="comment">// 设置好各个属性:</span></span><br><span class="line">    user.set<span class="constructor">Email(<span class="params">email</span>)</span>;</span><br><span class="line">    user.set<span class="constructor">Password(<span class="params">password</span>)</span>;</span><br><span class="line">    user.set<span class="constructor">Name(<span class="params">name</span>)</span>;</span><br><span class="line">    <span class="comment">// 不要设置id，因为使用了自增主键</span></span><br><span class="line">    <span class="comment">// 保存到数据库:</span></span><br><span class="line">    hibernateTemplate.save(user);</span><br><span class="line">    <span class="comment">// 现在已经自动获得了id:</span></span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(user.get<span class="constructor">Id()</span>);</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Delete操作"><a href="#Delete操作" class="headerlink" title="Delete操作"></a>Delete操作</h3><p>删除一个<code>User</code>相当于从表中删除对应的记录。注意Hibernate总是用<code>id</code>来删除记录，因此，要正确设置<code>User</code>的<code>id</code>属性才能正常删除记录：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">boolean</span> deleteUser(Long id) &#123;</span><br><span class="line">    <span class="keyword">User</span> <span class="keyword">user</span> = hibernateTemplate.<span class="keyword">get</span>(<span class="keyword">User</span>.<span class="keyword">class</span>, id);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">user</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hibernateTemplate.<span class="keyword">delete</span>(<span class="keyword">user</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过主键删除记录时，一个常见的用法是先根据主键加载该记录，再删除。<code>load()</code>和<code>get()</code>都可以根据主键加载记录，它们的区别在于，当记录不存在时，<code>get()</code>返回<code>null</code>，而<code>load()</code>抛出异常。</p>
<h3 id="Update操作"><a href="#Update操作" class="headerlink" title="Update操作"></a>Update操作</h3><p>更新记录相当于先更新<code>User</code>的指定属性，然后调用<code>update()</code>方法：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="type">void</span> updateUser(Long id, String <span class="type">name</span>) &#123;</span><br><span class="line">    <span class="keyword">User</span> <span class="keyword">user</span> = hibernateTemplate.<span class="keyword">load</span>(<span class="keyword">User</span>.<span class="keyword">class</span>, id);</span><br><span class="line">    <span class="keyword">user</span>.setName(<span class="type">name</span>);</span><br><span class="line">    hibernateTemplate.<span class="keyword">update</span>(<span class="keyword">user</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面我们在定义<code>User</code>时，对有的属性标注了<code>@Column(updatable=false)</code>。Hibernate在更新记录时，它只会把<code>@Column(updatable=true)</code>的属性加入到<code>UPDATE</code>语句中，这样可以提供一层额外的安全性，即如果不小心修改了<code>User</code>的<code>email</code>、<code>createdAt</code>等属性，执行<code>update()</code>时并不会更新对应的数据库列。但也必须牢记：这个功能是Hibernate提供的，如果绕过Hibernate直接通过JDBC执行<code>UPDATE</code>语句仍然可以更新数据库的任意列的值。</p>
<p>最后，我们编写的大部分方法都是各种各样的查询。根据<code>id</code>查询我们可以直接调用<code>load()</code>或<code>get()</code>，如果要使用条件查询，有3种方法。</p>
<p>假设我们想执行以下查询：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> email = ? <span class="keyword">AND</span> <span class="keyword">password</span> = ?</span><br></pre></td></tr></table></figure>

<p>我们来看看可以使用什么查询。</p>
<h3 id="使用Example查询"><a href="#使用Example查询" class="headerlink" title="使用Example查询"></a>使用Example查询</h3><p>第一种方法是使用<code>findByExample()</code>，给出一个<code>User</code>实例，Hibernate把该实例所有非<code>null</code>的属性拼成<code>WHERE</code>条件：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> <span class="keyword">login</span>(String email, String <span class="keyword">password</span>) &#123;</span><br><span class="line">    <span class="keyword">User</span> example = <span class="built_in">new</span> <span class="keyword">User</span>();</span><br><span class="line">    example.setEmail(email);</span><br><span class="line">    example.setPassword(<span class="keyword">password</span>);</span><br><span class="line">    List&lt;<span class="keyword">User</span>&gt; list = hibernateTemplate.findByExample(example);</span><br><span class="line">    <span class="keyword">return</span> list.isEmpty() ? <span class="keyword">null</span> : list.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为<code>example</code>实例只有<code>email</code>和<code>password</code>两个属性为非<code>null</code>，所以最终生成的<code>WHERE</code>语句就是<code>WHERE email = ? AND password = ?</code>。</p>
<p>如果我们把<code>User</code>的<code>createdAt</code>的类型从<code>Long</code>改为<code>long</code>，<code>findByExample()</code>的查询将出问题，原因在于<code>example</code>实例的<code>long</code>类型字段有了默认值0，导致Hibernate最终生成的<code>WHERE</code>语句意外变成了<code>WHERE email = ? AND password = ? AND createdAt = 0</code>。显然，额外的查询条件将导致错误的查询结果。</p>
<p> 使用findByExample()时，注意基本类型字段总是会加入到WHERE条件！</p>
<h3 id="使用Criteria查询"><a href="#使用Criteria查询" class="headerlink" title="使用Criteria查询"></a>使用Criteria查询</h3><p>第二种查询方法是使用Criteria查询，可以实现如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> <span class="keyword">login</span>(String email, String <span class="keyword">password</span>) &#123;</span><br><span class="line">    DetachedCriteria criteria = DetachedCriteria.forClass(<span class="keyword">User</span>.<span class="keyword">class</span>);</span><br><span class="line">    criteria.<span class="keyword">add</span>(Restrictions.eq(&quot;email&quot;, email))</span><br><span class="line">            .<span class="keyword">add</span>(Restrictions.eq(&quot;password&quot;, <span class="keyword">password</span>));</span><br><span class="line">    List&lt;<span class="keyword">User</span>&gt; list = (List&lt;<span class="keyword">User</span>&gt;) hibernateTemplate.findByCriteria(criteria);</span><br><span class="line">    <span class="keyword">return</span> list.isEmpty() ? <span class="keyword">null</span> : list.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DetachedCriteria</code>使用链式语句来添加多个<code>AND</code>条件。和<code>findByExample()</code>相比，<code>findByCriteria()</code>可以组装出更灵活的<code>WHERE</code>条件，例如：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> (email = ? <span class="keyword">OR</span> <span class="type">name</span> = ?) <span class="keyword">AND</span> <span class="keyword">password</span> = ?</span><br></pre></td></tr></table></figure>

<p>上述查询没法用<code>findByExample()</code>实现，但用Criteria查询可以实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DetachedCriteria criteria = <span class="module-access"><span class="module"><span class="identifier">DetachedCriteria</span>.</span></span><span class="keyword">for</span><span class="constructor">Class(User.<span class="params">class</span>)</span>;</span><br><span class="line">criteria.add(</span><br><span class="line">    <span class="module-access"><span class="module"><span class="identifier">Restrictions</span>.</span></span><span class="keyword">and</span>(</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">Restrictions</span>.</span></span><span class="keyword">or</span>(</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Restrictions</span>.</span></span>eq(<span class="string">&quot;email&quot;</span>, email),</span><br><span class="line">            <span class="module-access"><span class="module"><span class="identifier">Restrictions</span>.</span></span>eq(<span class="string">&quot;name&quot;</span>, email)</span><br><span class="line">        ),</span><br><span class="line">		<span class="module-access"><span class="module"><span class="identifier">Restrictions</span>.</span></span>eq(<span class="string">&quot;password&quot;</span>, password)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>只要组织好<code>Restrictions</code>的嵌套关系，Criteria查询可以实现任意复杂的查询。</p>
<h3 id="使用HQL查询"><a href="#使用HQL查询" class="headerlink" title="使用HQL查询"></a>使用HQL查询</h3><p>最后一种常用的查询是直接编写Hibernate内置的HQL查询：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="keyword">User</span>&gt; list = (List&lt;<span class="keyword">User</span>&gt;) hibernateTemplate.find(&quot;FROM User WHERE email=? AND password=?&quot;, email, <span class="keyword">password</span>);</span><br></pre></td></tr></table></figure>

<p>和SQL相比，HQL使用类名和属性名，由Hibernate自动转换为实际的表名和列名。详细的HQL语法可以参考<a target="_blank" rel="noopener" href="https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#hql">Hibernate文档</a>。</p>
<p>除了可以直接传入HQL字符串外，Hibernate还可以使用一种<code>NamedQuery</code>，它给查询起个名字，然后保存在注解中。使用<code>NamedQuery</code>时，我们要先在<code>User</code>类标注：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@NamedQueries</span>(</span><br><span class="line">    <span class="variable">@NamedQuery</span>(</span><br><span class="line">        <span class="comment">// 查询名称:</span></span><br><span class="line">        name = <span class="string">&quot;login&quot;</span>,</span><br><span class="line">        <span class="comment">// 查询语句:</span></span><br><span class="line">        query = <span class="string">&quot;SELECT u FROM User u WHERE u.email=?0 AND u.password=?1&quot;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="variable">@Entity</span></span><br><span class="line">public class User extends AbstractEntity &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到引入的NamedQuery是<code>javax.persistence.NamedQuery</code>，它和直接传入HQL有点不同的是，占位符使用<code>?0</code>、<code>?1</code>，并且索引是从<code>0</code>开始的（真乱）。</p>
<p>使用<code>NamedQuery</code>只需要引入查询名和参数：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> <span class="keyword">login</span>(String email, String <span class="keyword">password</span>) &#123;</span><br><span class="line">    List&lt;<span class="keyword">User</span>&gt; list = (List&lt;<span class="keyword">User</span>&gt;) hibernateTemplate.findByNamedQuery(&quot;login&quot;, email, <span class="keyword">password</span>);</span><br><span class="line">    <span class="keyword">return</span> list.isEmpty() ? <span class="keyword">null</span> : list.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接写HQL和使用<code>NamedQuery</code>各有优劣。前者可以在代码中直观地看到查询语句，后者可以在<code>User</code>类统一管理所有相关查询。</p>
<h3 id="使用Hibernate原生接口"><a href="#使用Hibernate原生接口" class="headerlink" title="使用Hibernate原生接口"></a>使用Hibernate原生接口</h3><p>如果要使用Hibernate原生接口，但不知道怎么写，可以参考<code>HibernateTemplate</code>的源码。使用Hibernate的原生接口实际上总是从<code>SessionFactory</code>出发，它通常用全局变量存储，在<code>HibernateTemplate</code>中以成员变量被注入。有了<code>SessionFactory</code>，使用Hibernate用法如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="function"><span class="title">operation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    Session session = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">boolean</span> isNew = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 获取当前Session或者打开新的Session:</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        session = <span class="built_in">this</span>.sessionFactory.getCurrentSession();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException e) &#123;</span><br><span class="line">        session = <span class="built_in">this</span>.sessionFactory.openSession();</span><br><span class="line">        isNew = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 操作Session:</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        User user = session.load(User.class, 123L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭新打开的Session:</span></span><br><span class="line">        <span class="keyword">if</span> (isNew) &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-5-集成JPA"><a href="#4-5-集成JPA" class="headerlink" title="4.5 集成JPA"></a>4.5 集成JPA</h2><p>上一节我们讲了在Spring中集成Hibernate。Hibernate是第一个被广泛使用的ORM框架，但是很多小伙伴还听说过JPA：Java Persistence API，这又是啥？</p>
<p>在讨论JPA之前，我们要注意到JavaEE早在1999年就发布了，并且有Servlet、JMS等诸多标准。和其他平台不同，Java世界早期非常热衷于标准先行，各家跟进：大家先坐下来把接口定了，然后，各自回家干活去实现接口，这样，用户就可以在不同的厂家提供的产品进行选择，还可以随意切换，因为用户编写代码的时候只需要引用接口，并不需要引用具体的底层实现（想想JDBC）。</p>
<p>JPA就是JavaEE的一个ORM标准，它的实现其实和Hibernate没啥本质区别，但是用户如果使用JPA，那么引用的就是<code>javax.persistence</code>这个“标准”包，而不是<code>org.hibernate</code>这样的第三方包。因为JPA只是接口，所以，还需要选择一个实现产品，跟JDBC接口和MySQL驱动一个道理。</p>
<p>我们使用JPA时也完全可以选择Hibernate作为底层实现，但也可以选择其它的JPA提供方，比如<a target="_blank" rel="noopener" href="https://www.eclipse.org/eclipselink/">EclipseLink</a>。Spring内置了JPA的集成，并支持选择Hibernate或EclipseLink作为实现。这里我们仍然以主流的Hibernate作为JPA实现为例子，演示JPA的基本用法。</p>
<p>和使用Hibernate一样，我们只需要引入如下依赖：</p>
<ul>
<li>org.springframework:spring-context:5.2.0.RELEASE</li>
<li>org.springframework:spring-orm:5.2.0.RELEASE</li>
<li>javax.annotation:javax.annotation-api:1.3.2</li>
<li>org.hibernate:hibernate-core:5.4.2.Final</li>
<li>com.zaxxer:HikariCP:3.4.2</li>
<li>org.hsqldb:hsqldb:2.5.0</li>
</ul>
<p>然后，在<code>AppConfig</code>中启用声明式事务管理，创建<code>DataSource</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(<span class="string">&quot;jdbc.properties&quot;</span>)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    DataSource createDataSource() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Hibernate时，我们需要创建一个<code>LocalSessionFactoryBean</code>，并让它再自动创建一个<code>SessionFactory</code>。使用JPA也是类似的，我们需要创建一个<code>LocalContainerEntityManagerFactoryBean</code>，并让它再自动创建一个<code>EntityManagerFactory</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">LocalContainerEntityManagerFactoryBean create<span class="constructor">EntityManagerFactory(@Autowired DataSource <span class="params">dataSource</span>)</span> &#123;</span><br><span class="line">    var entityManagerFactoryBean = <span class="keyword">new</span> <span class="constructor">LocalContainerEntityManagerFactoryBean()</span>;</span><br><span class="line">    <span class="comment">// 设置DataSource:</span></span><br><span class="line">    entityManagerFactoryBean.set<span class="constructor">DataSource(<span class="params">dataSource</span>)</span>;</span><br><span class="line">    <span class="comment">// 扫描指定的package获取所有entity class:</span></span><br><span class="line">    entityManagerFactoryBean.set<span class="constructor">PackagesToScan(<span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">// 指定JPA的提供商是Hibernate:</span></span><br><span class="line">    JpaVendorAdapter vendorAdapter = <span class="keyword">new</span> <span class="constructor">HibernateJpaVendorAdapter()</span>;</span><br><span class="line">    entityManagerFactoryBean.set<span class="constructor">JpaVendorAdapter(<span class="params">vendorAdapter</span>)</span>;</span><br><span class="line">    <span class="comment">// 设定特定提供商自己的配置:</span></span><br><span class="line">    var props = <span class="keyword">new</span> <span class="constructor">Properties()</span>;</span><br><span class="line">    props.set<span class="constructor">Property(<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span>, <span class="string">&quot;update&quot;</span>)</span>;</span><br><span class="line">    props.set<span class="constructor">Property(<span class="string">&quot;hibernate.dialect&quot;</span>, <span class="string">&quot;org.hibernate.dialect.HSQLDialect&quot;</span>)</span>;</span><br><span class="line">    props.set<span class="constructor">Property(<span class="string">&quot;hibernate.show_sql&quot;</span>, <span class="string">&quot;true&quot;</span>)</span>;</span><br><span class="line">    entityManagerFactoryBean.set<span class="constructor">JpaProperties(<span class="params">props</span>)</span>;</span><br><span class="line">    return entityManagerFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上述代码，除了需要注入<code>DataSource</code>和设定自动扫描的<code>package</code>外，还需要指定JPA的提供商，这里使用Spring提供的一个<code>HibernateJpaVendorAdapter</code>，最后，针对Hibernate自己需要的配置，以<code>Properties</code>的形式注入。</p>
<p>最后，我们还需要实例化一个<code>JpaTransactionManager</code>，以实现声明式事务：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line">PlatformTransactionManager createTxManager(<span class="variable">@Autowired</span> EntityManagerFactory entityManagerFactory) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">JpaTransactionManager</span>(entityManagerFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就完成了JPA的全部初始化工作。有些童鞋可能从网上搜索得知JPA需要<code>persistence.xml</code>配置文件，以及复杂的<code>orm.xml</code>文件。这里我们负责地告诉大家，使用Spring+Hibernate作为JPA实现，无需任何配置文件。</p>
<p>所有Entity Bean的配置和上一节完全相同，全部采用Annotation标注。我们现在只需关心具体的业务类如何通过JPA接口操作数据库。</p>
<p>还是以<code>UserService</code>为例，除了标注<code>@Component</code>和<code>@Transactional</code>外，我们需要注入一个<code>EntityManager</code>，但是不要使用<code>Autowired</code>，而是<code>@PersistenceContext</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span></span><br><span class="line"><span class="variable">@Transactional</span></span><br><span class="line">public class UserService &#123;</span><br><span class="line">    <span class="variable">@PersistenceContext</span></span><br><span class="line">    EntityManager em;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们回顾一下JDBC、Hibernate和JPA提供的接口，实际上，它们的关系如下：</p>
<table>
<thead>
<tr>
<th align="left">JDBC</th>
<th align="left">Hibernate</th>
<th align="left">JPA</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DataSource</td>
<td align="left">SessionFactory</td>
<td align="left">EntityManagerFactory</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">Session</td>
<td align="left">EntityManager</td>
</tr>
</tbody></table>
<p><code>SessionFactory</code>和<code>EntityManagerFactory</code>相当于<code>DataSource</code>，<code>Session</code>和<code>EntityManager</code>相当于<code>Connection</code>。每次需要访问数据库的时候，需要获取新的<code>Session</code>和<code>EntityManager</code>，用完后再关闭。</p>
<p>但是，注意到<code>UserService</code>注入的不是<code>EntityManagerFactory</code>，而是<code>EntityManager</code>，并且标注了<code>@PersistenceContext</code>。难道使用JPA可以允许多线程操作同一个<code>EntityManager</code>？</p>
<p>实际上这里注入的并不是真正的<code>EntityManager</code>，而是一个<code>EntityManager</code>的代理类，相当于：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">EntityManagerProxy</span> <span class="symbol">implements</span> <span class="symbol">EntityManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EntityManagerFactory emf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring遇到标注了<code>@PersistenceContext</code>的<code>EntityManager</code>会自动注入代理，该代理会在必要的时候自动打开<code>EntityManager</code>。换句话说，多线程引用的<code>EntityManager</code>虽然是同一个代理类，但该代理类内部针对不同线程会创建不同的<code>EntityManager</code>实例。</p>
<p>简单总结一下，标注了<code>@PersistenceContext</code>的<code>EntityManager</code>可以被多线程安全地共享。</p>
<p>因此，在<code>UserService</code>的每个业务方法里，直接使用<code>EntityManager</code>就很方便。以主键查询为例：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> getUserById(long id) &#123;</span><br><span class="line">    <span class="keyword">User</span> <span class="keyword">user</span> = this.em.find(<span class="keyword">User</span>.<span class="keyword">class</span>, id);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">user</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">        throw <span class="built_in">new</span> RuntimeException(&quot;User not found by id: &quot; + id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">user</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JPA同样支持Criteria查询，比如我们需要的查询如下：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> email = ?</span><br></pre></td></tr></table></figure>

<p>使用Criteria查询的代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public User fetch<span class="constructor">UserByEmail(String <span class="params">email</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// CriteriaBuilder:</span></span><br><span class="line">    var cb = em.get<span class="constructor">CriteriaBuilder()</span>;</span><br><span class="line">    CriteriaQuery&lt;User&gt; q = cb.create<span class="constructor">Query(User.<span class="params">class</span>)</span>;</span><br><span class="line">    Root&lt;User&gt; r = q.from(<span class="module-access"><span class="module"><span class="identifier">User</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">    q.where(cb.equal(r.get(<span class="string">&quot;email&quot;</span>), cb.parameter(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span><span class="keyword">class</span>, <span class="string">&quot;e&quot;</span>)));</span><br><span class="line">    TypedQuery&lt;User&gt; query = em.create<span class="constructor">Query(<span class="params">q</span>)</span>;</span><br><span class="line">    <span class="comment">// 绑定参数:</span></span><br><span class="line">    query.set<span class="constructor">Parameter(<span class="string">&quot;e&quot;</span>, <span class="params">email</span>)</span>;</span><br><span class="line">    <span class="comment">// 执行查询:</span></span><br><span class="line">    List&lt;User&gt; <span class="built_in">list</span> = query.get<span class="constructor">ResultList()</span>;</span><br><span class="line">    return <span class="built_in">list</span>.is<span class="constructor">Empty()</span> ? null : <span class="built_in">list</span>.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个简单的查询用Criteria写出来就像上面那样复杂，太恐怖了，如果条件多加几个，这种写法谁读得懂？</p>
<p>所以，正常人还是建议写JPQL查询，它的语法和HQL基本差不多：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public User get<span class="constructor">UserByEmail(String <span class="params">email</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// JPQL查询:</span></span><br><span class="line">    TypedQuery&lt;User&gt; query = em.create<span class="constructor">Query(<span class="string">&quot;SELECT u FROM User u WHERE u.email = :e&quot;</span>, User.<span class="params">class</span>)</span>;</span><br><span class="line">    query.set<span class="constructor">Parameter(<span class="string">&quot;e&quot;</span>, <span class="params">email</span>)</span>;</span><br><span class="line">    List&lt;User&gt; <span class="built_in">list</span> = query.get<span class="constructor">ResultList()</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>.is<span class="constructor">Empty()</span>) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="string">&quot;User not found by email.&quot;</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return <span class="built_in">list</span>.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，JPA也支持NamedQuery，即先给查询起个名字，再按名字创建查询：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">User</span> <span class="keyword">login</span>(String email, String <span class="keyword">password</span>) &#123;</span><br><span class="line">    TypedQuery&lt;<span class="keyword">User</span>&gt; query = em.createNamedQuery(&quot;login&quot;, <span class="keyword">User</span>.<span class="keyword">class</span>);</span><br><span class="line">    query.setParameter(&quot;e&quot;, email);</span><br><span class="line">    query.setParameter(&quot;p&quot;, <span class="keyword">password</span>);</span><br><span class="line">    List&lt;<span class="keyword">User</span>&gt; list = query.getResultList();</span><br><span class="line">    <span class="keyword">return</span> list.isEmpty() ? <span class="keyword">null</span> : list.<span class="keyword">get</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NamedQuery通过注解标注在<code>User</code>类上，它的定义和上一节的<code>User</code>类一样：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@NamedQueries</span>(</span><br><span class="line">    <span class="variable">@NamedQuery</span>(</span><br><span class="line">        name = <span class="string">&quot;login&quot;</span>,</span><br><span class="line">        query = <span class="string">&quot;SELECT u FROM User u WHERE u.email=:e AND u.password=:p&quot;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"><span class="variable">@Entity</span></span><br><span class="line">public class User &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对数据库进行增删改的操作，可以分别使用<code>persist()</code>、<code>remove()</code>和<code>merge()</code>方法，参数均为Entity Bean本身，使用非常简单，这里不再多述。</p>
<h2 id="4-6-集成MyBatis"><a href="#4-6-集成MyBatis" class="headerlink" title="4.6 集成MyBatis"></a>4.6 集成MyBatis</h2><p>使用Hibernate或JPA操作数据库时，这类ORM干的主要工作就是把ResultSet的每一行变成Java Bean，或者把Java Bean自动转换到INSERT或UPDATE语句的参数中，从而实现ORM。</p>
<p>而ORM框架之所以知道如何把行数据映射到Java Bean，是因为我们在Java Bean的属性上给了足够的注解作为元数据，ORM框架获取Java Bean的注解后，就知道如何进行双向映射。</p>
<p>那么，ORM框架是如何跟踪Java Bean的修改，以便在<code>update()</code>操作中更新必要的属性？</p>
<p>答案是使用<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">Proxy模式</a>，从ORM框架读取的User实例实际上并不是User类，而是代理类，代理类继承自User类，但针对每个setter方法做了覆写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    boolean _isNameChanged;</span><br><span class="line"></span><br><span class="line">    public void setName(<span class="type">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(name);</span><br><span class="line">        _isNameChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，代理类可以跟踪到每个属性的变化。</p>
<p>针对一对多或多对一关系时，代理类可以直接通过getter方法查询数据库：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="type">Session</span> _session;</span><br><span class="line">    boolean _isNameChanged;</span><br><span class="line"></span><br><span class="line">    public void setName(<span class="type">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(name);</span><br><span class="line">        _isNameChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取User对象关联的Address对象:</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    public <span class="type">Address</span> getAddress() &#123;</span><br><span class="line">        <span class="type">Query</span> q = _session.createQuery(<span class="string">&quot;from Address where userId = :userId&quot;</span>);</span><br><span class="line">        q.setParameter(<span class="string">&quot;userId&quot;</span>, <span class="keyword">this</span>.getId());</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Address</span>&gt; list = query.list();</span><br><span class="line">        <span class="keyword">return</span> list.isEmpty() ? <span class="literal">null</span> : list(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现这样的查询，UserProxy必须保存Hibernate的当前Session。但是，当事务提交后，Session自动关闭，此时再获取<code>getAddress()</code>将无法访问数据库，或者获取的不是事务一致的数据。因此，ORM框架总是引入了Attached&#x2F;Detached状态，表示当前此Java Bean到底是在Session的范围内，还是脱离了Session变成了一个“游离”对象。很多初学者无法正确理解状态变化和事务边界，就会造成大量的<code>PersistentObjectException</code>异常。这种隐式状态使得普通Java Bean的生命周期变得复杂。</p>
<p>此外，Hibernate和JPA为了实现兼容多种数据库，它使用HQL或JPQL查询，经过一道转换，变成特定数据库的SQL，理论上这样可以做到无缝切换数据库，但这一层自动转换除了少许的性能开销外，给SQL级别的优化带来了麻烦。</p>
<p>最后，ORM框架通常提供了缓存，并且还分为一级缓存和二级缓存。一级缓存是指在一个Session范围内的缓存，常见的情景是根据主键查询时，两次查询可以返回同一实例：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> user1 = <span class="keyword">session</span>.<span class="keyword">load</span>(<span class="keyword">User</span>.<span class="keyword">class</span>, <span class="number">123</span>);</span><br><span class="line"><span class="keyword">User</span> user2 = <span class="keyword">session</span>.<span class="keyword">load</span>(<span class="keyword">User</span>.<span class="keyword">class</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>二级缓存是指跨Session的缓存，一般默认关闭，需要手动配置。二级缓存极大的增加了数据的不一致性，原因在于SQL非常灵活，常常会导致意外的更新。例如：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1读取:</span></span><br><span class="line">User user1 = session1.load(<span class="module-access"><span class="module"><span class="identifier">User</span>.</span></span><span class="keyword">class</span>, <span class="number">123</span>);<span class="operator"></span></span><br><span class="line"><span class="operator">...</span></span><br><span class="line"><span class="operator"></span><span class="comment">// 一段时间后，线程2读取:</span></span><br><span class="line">User user2 = session2.load(<span class="module-access"><span class="module"><span class="identifier">User</span>.</span></span><span class="keyword">class</span>, <span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>当二级缓存生效的时候，两个线程读取的User实例是一样的，但是，数据库对应的行记录完全可能被修改，例如：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给老用户增加100积分:</span></span><br><span class="line"><span class="keyword">UPDATE</span> users <span class="keyword">SET</span> bonus = bonus + <span class="number">100</span> <span class="keyword">WHERE</span> createdAt &lt;= ?</span><br></pre></td></tr></table></figure>

<p>ORM无法判断<code>id=123</code>的用户是否受该<code>UPDATE</code>语句影响。考虑到数据库通常会支持多个应用程序，此UPDATE语句可能由其他进程执行，ORM框架就更不知道了。</p>
<p>我们把这种ORM框架称之为全自动ORM框架。</p>
<p>对比Spring提供的JdbcTemplate，它和ORM框架相比，主要有几点差别：</p>
<ol>
<li>查询后需要手动提供Mapper实例以便把ResultSet的每一行变为Java对象；</li>
<li>增删改操作所需的参数列表，需要手动传入，即把User实例变为[user.id, user.name, user.email]这样的列表，比较麻烦。</li>
</ol>
<p>但是JdbcTemplate的优势在于它的确定性：即每次读取操作一定是数据库操作而不是缓存，所执行的SQL是完全确定的，缺点就是代码比较繁琐，构造<code>INSERT INTO users VALUES (?,?,?)</code>更是复杂。</p>
<p>所以，介于全自动ORM如Hibernate和手写全部如JdbcTemplate之间，还有一种半自动的ORM，它只负责把ResultSet自动映射到Java Bean，或者自动填充Java Bean参数，但仍需自己写出SQL。<a target="_blank" rel="noopener" href="https://mybatis.org/">MyBatis</a>就是这样一种半自动化ORM框架。</p>
<p>我们来看看如何在Spring中集成MyBatis。</p>
<p>首先，我们要引入MyBatis本身，其次，由于Spring并没有像Hibernate那样内置对MyBatis的集成，所以，我们需要再引入MyBatis官方自己开发的一个与Spring集成的库：</p>
<ul>
<li>org.mybatis:mybatis:3.5.4</li>
<li>org.mybatis:mybatis-spring:2.0.4</li>
</ul>
<p>和前面一样，先创建<code>DataSource</code>是必不可少的：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(<span class="string">&quot;jdbc.properties&quot;</span>)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    DataSource createDataSource() &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回顾一下Hibernate和JPA的<code>SessionFactory</code>与<code>EntityManagerFactory</code>，MyBatis与之对应的是<code>SqlSessionFactory</code>和<code>SqlSession</code>：</p>
<table>
<thead>
<tr>
<th align="left">JDBC</th>
<th align="left">Hibernate</th>
<th align="left">JPA</th>
<th align="left">MyBatis</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DataSource</td>
<td align="left">SessionFactory</td>
<td align="left">EntityManagerFactory</td>
<td align="left">SqlSessionFactory</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">Session</td>
<td align="left">EntityManager</td>
<td align="left">SqlSession</td>
</tr>
</tbody></table>
<p>可见，ORM的设计套路都是类似的。使用MyBatis的核心就是创建<code>SqlSessionFactory</code>，这里我们需要创建的是<code>SqlSessionFactoryBean</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">SqlSessionFactoryBean <span class="function"><span class="title">createSqlSessionFactoryBean</span>(<span class="params"><span class="meta">@Autowired</span> DataSource dataSource</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为MyBatis可以直接使用Spring管理的声明式事务，因此，创建事务管理器和使用JDBC是一样的：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line">PlatformTransactionManager createTxManager(<span class="variable">@Autowired</span> DataSource dataSource) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和Hibernate不同的是，MyBatis使用Mapper来实现映射，而且Mapper必须是接口。我们以User类为例，在User类和users表之间映射的UserMapper编写如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">UserMapper</span> &#123;</span><br><span class="line">	<span class="variable">@Select</span>(<span class="string">&quot;SELECT * FROM users WHERE id = #&#123;id&#125;&quot;</span>)</span><br><span class="line">	User getById(<span class="variable">@Param</span>(<span class="string">&quot;id&quot;</span>) long id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里的Mapper不是JdbcTemplate的RowMapper的概念，它是定义访问users表的接口方法。比如我们定义了一个<code>User getById(long)</code>的主键查询方法，不仅要定义接口方法本身，还要明确写出查询的SQL，这里用注解<code>@Select</code>标记。SQL语句的任何参数，都与方法参数按名称对应。例如，方法参数id的名字通过注解<code>@Param()</code>标记为<code>id</code>，则SQL语句里将来替换的占位符就是<code>#&#123;id&#125;</code>。</p>
<p>如果有多个参数，那么每个参数命名后直接在SQL中写出对应的占位符即可：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(<span class="string">&quot;SELECT * FROM users LIMIT #&#123;offset&#125;, #&#123;maxResults&#125;&quot;</span>)</span><br><span class="line">List&lt;User&gt; getAll(<span class="variable">@Param</span>(<span class="string">&quot;offset&quot;</span>) int offset, <span class="variable">@Param</span>(<span class="string">&quot;maxResults&quot;</span>) int maxResults);</span><br></pre></td></tr></table></figure>

<p>注意：MyBatis执行查询后，将根据方法的返回类型自动把ResultSet的每一行转换为User实例，转换规则当然是按列名和属性名对应。如果列名和属性名不同，最简单的方式是编写SELECT语句的别名：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列名是created_time，属性名是createdAt:</span></span><br><span class="line"><span class="keyword">SELECT</span> id, <span class="type">name</span>, email, created_time <span class="keyword">AS</span> createdAt <span class="keyword">FROM</span> users</span><br></pre></td></tr></table></figure>

<p>执行INSERT语句就稍微麻烦点，因为我们希望传入User实例，因此，定义的方法接口与<code>@Insert</code>注解如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Insert</span>(<span class="string">&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;</span>)</span><br><span class="line">void insert(<span class="variable">@Param</span>(<span class="string">&quot;user&quot;</span>) User user);</span><br></pre></td></tr></table></figure>

<p>上述方法传入的参数名称是<code>user</code>，参数类型是User类，在SQL中引用的时候，以<code>#&#123;obj.property&#125;</code>的方式写占位符。和Hibernate这样的全自动化ORM相比，MyBatis必须写出完整的INSERT语句。</p>
<p>如果<code>users</code>表的id是自增主键，那么，我们在SQL中不传入id，但希望获取插入后的主键，需要再加一个<code>@Options</code>注解：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Options</span>(useGeneratedKeys = true, keyProperty = <span class="string">&quot;id&quot;</span>, keyColumn = <span class="string">&quot;id&quot;</span>)</span><br><span class="line"><span class="variable">@Insert</span>(<span class="string">&quot;INSERT INTO users (email, password, name, createdAt) VALUES (#&#123;user.email&#125;, #&#123;user.password&#125;, #&#123;user.name&#125;, #&#123;user.createdAt&#125;)&quot;</span>)</span><br><span class="line">void insert(<span class="variable">@Param</span>(<span class="string">&quot;user&quot;</span>) User user);</span><br></pre></td></tr></table></figure>

<p><code>keyProperty</code>和<code>keyColumn</code>分别指出JavaBean的属性和数据库的主键列名。</p>
<p>执行UPDATE和DELETE语句相对比较简单，我们定义方法如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Update</span>(<span class="string">&quot;UPDATE users SET name = #&#123;user.name&#125;, createdAt = #&#123;user.createdAt&#125; WHERE id = #&#123;user.id&#125;&quot;</span>)</span><br><span class="line">void update(<span class="variable">@Param</span>(<span class="string">&quot;user&quot;</span>) User user);</span><br><span class="line"></span><br><span class="line"><span class="variable">@Delete</span>(<span class="string">&quot;DELETE FROM users WHERE id = #&#123;id&#125;&quot;</span>)</span><br><span class="line">void deleteById(<span class="variable">@Param</span>(<span class="string">&quot;id&quot;</span>) long id);</span><br></pre></td></tr></table></figure>

<p>有了<code>UserMapper</code>接口，还需要对应的实现类才能真正执行这些数据库操作的方法。虽然可以自己写实现类，但我们除了编写<code>UserMapper</code>接口外，还有<code>BookMapper</code>、<code>BonusMapper</code>……一个一个写太麻烦，因此，MyBatis提供了一个<code>MapperFactoryBean</code>来自动创建所有Mapper的实现类。可以用一个简单的注解来启用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.itranswarp.learnjava.mapper&quot;)</span></span><br><span class="line">...其他注解...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了<code>@MapperScan</code>，就可以让MyBatis自动扫描指定包的所有Mapper并创建实现类。在真正的业务逻辑中，我们可以直接注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注入UserMapper:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用Mapper方法:</span></span><br><span class="line">        User user = userMapper.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;User not found by id.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，业务逻辑主要就是通过<code>XxxMapper</code>定义的数据库方法来访问数据库。</p>
<h3 id="XML配置"><a href="#XML配置" class="headerlink" title="XML配置"></a>XML配置</h3><p>上述在Spring中集成MyBatis的方式，我们只需要用到注解，并没有任何XML配置文件。MyBatis也允许使用XML配置映射关系和SQL语句，例如，更新<code>User</code>时根据属性值构造动态SQL：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">update</span> id=&quot;updateUser&quot;&gt;</span><br><span class="line">  <span class="keyword">UPDATE</span> users <span class="keyword">SET</span></span><br><span class="line">  &lt;<span class="keyword">set</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=&quot;user.name != null&quot;&gt; <span class="type">name</span> = #&#123;<span class="keyword">user</span>.name&#125; &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=&quot;user.hobby != null&quot;&gt; hobby = #&#123;<span class="keyword">user</span>.hobby&#125; &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">if</span> test=&quot;user.summary != null&quot;&gt; <span class="keyword">summary</span> = #&#123;<span class="keyword">user</span>.<span class="keyword">summary</span>&#125; &lt;/<span class="keyword">if</span>&gt;</span><br><span class="line">  &lt;/<span class="keyword">set</span>&gt;</span><br><span class="line">  <span class="keyword">WHERE</span> id = #&#123;<span class="keyword">user</span>.id&#125;</span><br><span class="line">&lt;/<span class="keyword">update</span>&gt;</span><br></pre></td></tr></table></figure>

<p>编写XML配置的优点是可以组装出动态SQL，并且把所有SQL操作集中在一起。缺点是配置起来太繁琐，调用方法时如果想查看SQL还需要定位到XML配置中。这里我们不介绍XML的配置方式，需要了解的童鞋请自行阅读<a target="_blank" rel="noopener" href="https://mybatis.org/mybatis-3/zh/configuration.html">官方文档</a>。</p>
<p>使用MyBatis最大的问题是所有SQL都需要全部手写，优点是执行的SQL就是我们自己写的SQL，对SQL进行优化非常简单，也可以编写任意复杂的SQL，或者使用数据库的特定语法，但切换数据库可能就不太容易。好消息是大部分项目并没有切换数据库的需求，完全可以针对某个数据库编写尽可能优化的SQL。</p>
<h2 id="4-7-设计ORM"><a href="#4-7-设计ORM" class="headerlink" title="4.7 设计ORM"></a>4.7 设计ORM</h2><p>我们从前几节可以看到，所谓ORM，也是建立在JDBC的基础上，通过ResultSet到JavaBean的映射，实现各种查询。有自动跟踪Entity修改的全自动化ORM如Hibernate和JPA，需要为每个Entity创建代理，也有完全自己映射，连INSERT和UPDATE语句都需要手动编写的MyBatis，但没有任何透明的Proxy。</p>
<p>而查询是涉及到数据库使用最广泛的操作，需要最大的灵活性。各种ORM解决方案各不相同，Hibernate和JPA自己实现了HQL和JPQL查询语法，用以生成最终的SQL，而MyBatis则完全手写，每增加一个查询都需要先编写SQL并增加接口方法。</p>
<p>还有一种Hibernate和JPA支持的Criteria查询，用Hibernate写出来类似：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DetachedCriteria criteria = <span class="module-access"><span class="module"><span class="identifier">DetachedCriteria</span>.</span></span><span class="keyword">for</span><span class="constructor">Class(User.<span class="params">class</span>)</span>;</span><br><span class="line">criteria.add(<span class="module-access"><span class="module"><span class="identifier">Restrictions</span>.</span></span>eq(<span class="string">&quot;email&quot;</span>, email))</span><br><span class="line">        .add(<span class="module-access"><span class="module"><span class="identifier">Restrictions</span>.</span></span>eq(<span class="string">&quot;password&quot;</span>, password));</span><br><span class="line">List&lt;User&gt; <span class="built_in">list</span> = (List&lt;User&gt;) hibernateTemplate.find<span class="constructor">ByCriteria(<span class="params">criteria</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>上述Criteria查询写法复杂，但和JPA相比，还是小巫见大巫了：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var cb = em.get<span class="constructor">CriteriaBuilder()</span>;</span><br><span class="line">CriteriaQuery&lt;User&gt; q = cb.create<span class="constructor">Query(User.<span class="params">class</span>)</span>;</span><br><span class="line">Root&lt;User&gt; r = q.from(<span class="module-access"><span class="module"><span class="identifier">User</span>.</span></span><span class="keyword">class</span>);</span><br><span class="line">q.where(cb.equal(r.get(<span class="string">&quot;email&quot;</span>), cb.parameter(<span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span><span class="keyword">class</span>, <span class="string">&quot;e&quot;</span>)));</span><br><span class="line">TypedQuery&lt;User&gt; query = em.create<span class="constructor">Query(<span class="params">q</span>)</span>;</span><br><span class="line">query.set<span class="constructor">Parameter(<span class="string">&quot;e&quot;</span>, <span class="params">email</span>)</span>;</span><br><span class="line">List&lt;User&gt; <span class="built_in">list</span> = query.get<span class="constructor">ResultList()</span>;</span><br></pre></td></tr></table></figure>

<p>此外，是否支持自动读取一对多和多对一关系也是全自动化ORM框架的一个重要功能。</p>
<p>如果我们自己来设计并实现一个ORM，应该吸取这些ORM的哪些特色，然后高效实现呢？</p>
<h3 id="设计ORM接口"><a href="#设计ORM接口" class="headerlink" title="设计ORM接口"></a>设计ORM接口</h3><p>任何设计，都必须明确设计目标。这里我们准备实现的ORM并不想要全自动ORM那种自动读取一对多和多对一关系的功能，也不想给Entity加上复杂的状态，因此，对于Entity来说，它就是纯粹的JavaBean，没有任何Proxy。</p>
<p>此外，ORM要兼顾易用性和适用性。易用性是指能覆盖95%的应用场景，但总有一些复杂的SQL，很难用ORM去自动生成，因此，也要给出原生的JDBC接口，能支持5%的特殊需求。</p>
<p>最后，我们希望设计的接口要易于编写，并使用流式API便于阅读。为了配合编译器检查，还应该支持泛型，避免强制转型。</p>
<p>以User类为例，我们设计的查询接口如下：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 按主键查询: <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id = ?</span><br><span class="line"><span class="keyword">User</span> u = db.<span class="keyword">get</span>(<span class="keyword">User</span>.<span class="keyword">class</span>, <span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">// 条件查询唯一记录: <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email = ? <span class="keyword">AND</span> <span class="keyword">password</span> = ?</span><br><span class="line"><span class="keyword">User</span> u = db.<span class="keyword">from</span>(<span class="keyword">User</span>.<span class="keyword">class</span>)</span><br><span class="line">           .<span class="keyword">where</span>(&quot;email=? AND password=?&quot;, &quot;bob@example.com&quot;, &quot;bob123&quot;)</span><br><span class="line">           .<span class="keyword">unique</span>();</span><br><span class="line"></span><br><span class="line">// 条件查询多条记录: <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id &lt; ? <span class="keyword">ORDER</span> <span class="keyword">BY</span> email <span class="keyword">LIMIT</span> ?, ?</span><br><span class="line">List&lt;<span class="keyword">User</span>&gt; us = db.<span class="keyword">from</span>(<span class="keyword">User</span>.<span class="keyword">class</span>)</span><br><span class="line">                  .<span class="keyword">where</span>(&quot;id &lt; ?&quot;, <span class="number">1000</span>)</span><br><span class="line">                  .orderBy(&quot;email&quot;)</span><br><span class="line">                  .<span class="keyword">limit</span>(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">                  .list();</span><br><span class="line"></span><br><span class="line">// 查询特定列: <span class="keyword">SELECT</span> id, <span class="type">name</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> email = ?</span><br><span class="line"><span class="keyword">User</span> u = db.<span class="keyword">select</span>(&quot;id&quot;, &quot;name&quot;)</span><br><span class="line">           .<span class="keyword">from</span>(<span class="keyword">User</span>.<span class="keyword">class</span>)</span><br><span class="line">           .<span class="keyword">where</span>(&quot;email = ?&quot;, &quot;bob@example.com&quot;)</span><br><span class="line">           .<span class="keyword">unique</span>();</span><br></pre></td></tr></table></figure>

<p>这样的流式API便于阅读，也非常容易推导出最终生成的SQL。</p>
<p>对于插入、更新和删除操作，就相对比较简单：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入User:</span></span><br><span class="line"><span class="keyword">db</span>.insert(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按主键更新更新User:</span></span><br><span class="line"><span class="keyword">db</span>.<span class="keyword">update</span>(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按主键删除User:</span></span><br><span class="line"><span class="keyword">db</span>.delete(User.<span class="keyword">class</span>, 123);</span><br></pre></td></tr></table></figure>

<p>对于Entity来说，通常一个表对应一个。手动列出所有Entity是非常麻烦的，一定要传入package自动扫描。</p>
<p>最后，ORM总是需要元数据才能知道如何映射。我们不想编写复杂的XML配置，也没必要自己去定义一套规则，直接使用JPA的注解就行。</p>
<h3 id="实现ORM"><a href="#实现ORM" class="headerlink" title="实现ORM"></a>实现ORM</h3><p>我们并不需要从JDBC底层开始编写，并且，还要考虑到事务，最好能直接使用Spring的声明式事务。实际上，我们可以设计一个全局<code>DbTemplate</code>，它注入了Spring的<code>JdbcTemplate</code>，涉及到数据库操作时，全部通过<code>JdbcTemplate</code>完成，自然天生支持Spring的声明式事务，因为这个ORM只是在<code>JdbcTemplate</code>的基础上做了一层封装。</p>
<p>在<code>AppConfig</code>中，我们初始化所有Bean如下：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(<span class="string">&quot;jdbc.properties&quot;</span>)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    DataSource createDataSource() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Bean</span></span><br><span class="line">    JdbcTemplate createJdbcTemplate(<span class="variable">@Autowired</span> DataSource dataSource) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">JdbcTemplate</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Bean</span></span><br><span class="line">    <span class="selector-tag">DbTemplate</span> <span class="selector-tag">createDbTemplate</span>(<span class="variable">@Autowired</span> JdbcTemplate jdbcTemplate) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">DbTemplate</span>(jdbcTemplate, <span class="string">&quot;com.itranswarp.learnjava.entity&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Bean</span></span><br><span class="line">    <span class="selector-tag">PlatformTransactionManager</span> <span class="selector-tag">createTxManager</span>(<span class="variable">@Autowired</span> DataSource dataSource) &#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是我们所需的所有配置。</p>
<p>编写业务逻辑，例如<code>UserService</code>，写出来像这样：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Transactional</span><br><span class="line">public <span class="keyword">class</span> UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    DbTemplate db;</span><br><span class="line"></span><br><span class="line">    public User get<span class="constructor">UserById(<span class="params">long</span> <span class="params">id</span>)</span> &#123;</span><br><span class="line">        return db.get(<span class="module-access"><span class="module"><span class="identifier">User</span>.</span></span><span class="keyword">class</span>, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User get<span class="constructor">UserByEmail(String <span class="params">email</span>)</span> &#123;</span><br><span class="line">        return db.from(<span class="module-access"><span class="module"><span class="identifier">User</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">                 .where(<span class="string">&quot;email = ?&quot;</span>, email)</span><br><span class="line">                 .unique<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;User&gt; get<span class="constructor">Users(<span class="params">int</span> <span class="params">pageIndex</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> pageSize = <span class="number">100</span>;</span><br><span class="line">        return db.from(<span class="module-access"><span class="module"><span class="identifier">User</span>.</span></span><span class="keyword">class</span>)</span><br><span class="line">                 .order<span class="constructor">By(<span class="string">&quot;id&quot;</span>)</span></span><br><span class="line">                 .limit((pageIndex - <span class="number">1</span>)<span class="operator"> * </span>pageSize, pageSize)</span><br><span class="line">                 .<span class="built_in">list</span><span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User register(String email, String password, String name) &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> <span class="constructor">User()</span>;</span><br><span class="line">        user.set<span class="constructor">Email(<span class="params">email</span>)</span>;</span><br><span class="line">        user.set<span class="constructor">Password(<span class="params">password</span>)</span>;</span><br><span class="line">        user.set<span class="constructor">Name(<span class="params">name</span>)</span>;</span><br><span class="line">        user.set<span class="constructor">CreatedAt(System.<span class="params">currentTimeMillis</span>()</span>);</span><br><span class="line">        db.insert(user);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;<span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码给出了ORM的接口，以及如何在业务逻辑中使用ORM。下一步，就是如何实现这个<code>DbTemplate</code>。这里我们只给出框架代码，有兴趣的童鞋可以自己实现核心代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbTemplate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存Entity Class到Mapper的映射:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Map</span>&lt;Class&lt;?&gt;, Mapper&lt;?&gt;&gt; classMapping;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="function"><span class="title">fetch</span>(<span class="params">Class&lt;T&gt; clazz, <span class="built_in">Object</span> id</span>)</span> &#123;</span><br><span class="line">        Mapper&lt;T&gt; mapper = getMapper(clazz);</span><br><span class="line">        List&lt;T&gt; list = (List&lt;T&gt;) jdbcTemplate.query(mapper.selectSQL, <span class="keyword">new</span> <span class="built_in">Object</span>[] &#123; id &#125;, mapper.rowMapper);</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="function"><span class="title">get</span>(<span class="params">Class&lt;T&gt; clazz, <span class="built_in">Object</span> id</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="built_in">void</span> <span class="function"><span class="title">insert</span>(<span class="params">T bean</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="built_in">void</span> <span class="function"><span class="title">update</span>(<span class="params">T bean</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="built_in">void</span> <span class="function"><span class="title">delete</span>(<span class="params">Class&lt;T&gt; clazz, <span class="built_in">Object</span> id</span>)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现链式API的核心代码是第一步从<code>DbTemplate</code>调用<code>select()</code>或<code>from()</code>时实例化一个<code>CriteriaQuery</code>实例，并在后续的链式调用中设置它的字段：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbTemplate</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> Select select(<span class="keyword">String</span>... selectFields) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Select</span>(<span class="keyword">new</span> <span class="type">Criteria</span>(<span class="built_in">this</span>), selectFields);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; From&lt;T&gt; from(Class&lt;T&gt; entityClass) &#123;</span><br><span class="line">        Mapper&lt;T&gt; mapper = getMapper(entityClass);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">From</span>&lt;&gt;(<span class="keyword">new</span> <span class="type">Criteria</span>&lt;&gt;(<span class="built_in">this</span>), mapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后以此定义<code>Select</code>、<code>From</code>、<code>Where</code>、<code>OrderBy</code>、<code>Limit</code>等。在<code>From</code>中可以设置Class类型、表名等：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">From&lt;T&gt;</span> <span class="keyword">extends</span> <span class="title">CriteriaQuery&lt;T&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">From</span>(<span class="type">Criteria</span>&lt;<span class="type">T</span>&gt; criteria, <span class="type">Mapper</span>&lt;<span class="type">T</span>&gt; mapper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(criteria);</span><br><span class="line">        <span class="comment">// from可以设置class、tableName:</span></span><br><span class="line">        <span class="keyword">this</span>.criteria.mapper = mapper;</span><br><span class="line">        <span class="keyword">this</span>.criteria.clazz = mapper.entityClass;</span><br><span class="line">        <span class="keyword">this</span>.criteria.table = mapper.tableName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">Where</span>&lt;<span class="type">T</span>&gt; where(<span class="type">String</span> clause, <span class="type">Object</span>... args) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Where</span>&lt;&gt;(<span class="keyword">this</span>.criteria, clause, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Where</code>中可以设置条件参数：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Where&lt;T&gt;</span> <span class="keyword">extends</span> <span class="title">CriteriaQuery&lt;T&gt;</span> </span>&#123;</span><br><span class="line">    <span class="type">Where</span>(<span class="type">Criteria</span>&lt;<span class="type">T</span>&gt; criteria, <span class="type">String</span> clause, <span class="type">Object</span>... params) &#123;</span><br><span class="line">        <span class="keyword">super</span>(criteria);</span><br><span class="line">        <span class="keyword">this</span>.criteria.where = clause;</span><br><span class="line">        <span class="keyword">this</span>.criteria.whereParams = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// add:</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Object</span> param : params) &#123;</span><br><span class="line">            <span class="keyword">this</span>.criteria.whereParams.add(param);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，链式调用的尽头是调用<code>list()</code>返回一组结果，调用<code>unique()</code>返回唯一结果，调用<code>first()</code>返回首个结果。</p>
<p>在IDE中，可以非常方便地实现链式调用：</p>
<p>![warpdb](2.Spring 5.assets&#x2F;0.gif)</p>
<p>需要复杂查询的时候，总是可以使用<code>JdbcTemplate</code>执行任意复杂的SQL。</p>
<h1 id="5-开发Web应用"><a href="#5-开发Web应用" class="headerlink" title="5. 开发Web应用"></a>5. 开发Web应用</h1><h2 id="5-0-简介"><a href="#5-0-简介" class="headerlink" title="5.0 简介"></a>5.0 简介</h2><p>在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945497738400">Web开发</a>一章中，我们已经详细介绍了JavaEE中Web开发的基础：Servlet。具体地说，有以下几点：</p>
<ol>
<li>Servlet规范定义了几种标准组件：Servlet、JSP、Filter和Listener；</li>
<li>Servlet的标准组件总是运行在Servlet容器中，如Tomcat、Jetty、WebLogic等。</li>
</ol>
<p>直接使用Servlet进行Web开发好比直接在JDBC上操作数据库，比较繁琐，更好的方法是在Servlet基础上封装MVC框架，基于MVC开发Web应用，大部分时候，不需要接触Servlet API，开发省时省力。</p>
<p>我们在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266264917931808">MVC开发</a>和<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009">MVC高级开发</a>已经由浅入深地介绍了如何编写MVC框架。当然，自己写的MVC主要是理解原理，要实现一个功能全面的MVC需要大量的工作以及广泛的测试。</p>
<p>因此，开发Web应用，首先要选择一个优秀的MVC框架。常用的MVC框架有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://struts.apache.org/">Struts</a>：最古老的一个MVC框架，目前版本是2，和1.x有很大的区别；</li>
<li>WebWork：一个比Struts设计更优秀的MVC框架，但不知道出于什么原因，从2.0开始把自己的代码全部塞给Struts 2了；</li>
<li><a target="_blank" rel="noopener" href="https://turbine.apache.org/">Turbine</a>：一个重度使用Velocity，强调布局的MVC框架；</li>
<li>其他100+MVC框架……（略）</li>
</ul>
<p>Spring虽然都可以集成任何Web框架，但是，Spring本身也开发了一个MVC框架，就叫<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html">Spring MVC</a>。这个MVC框架设计得足够优秀以至于我们已经不想再费劲去集成类似Struts这样的框架了。</p>
<p>本章我们会详细介绍如何基于Spring MVC开发Web应用。</p>
<h2 id="5-1-使用Spring-MVC"><a href="#5-1-使用Spring-MVC" class="headerlink" title="5.1 使用Spring MVC"></a>5.1 使用Spring MVC</h2><p>我们在前面介绍<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945497738400">Web开发</a>时已经讲过了Java Web的基础：Servlet容器，以及标准的Servlet组件：</p>
<ul>
<li>Servlet：能处理HTTP请求并将HTTP响应返回；</li>
<li>JSP：一种嵌套Java代码的HTML，将被编译为Servlet；</li>
<li>Filter：能过滤指定的URL以实现拦截功能；</li>
<li>Listener：监听指定的事件，如ServletContext、HttpSession的创建和销毁。</li>
</ul>
<p>此外，Servlet容器为每个Web应用程序自动创建一个唯一的<code>ServletContext</code>实例，这个实例就代表了Web应用程序本身。</p>
<p>在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1337408645759009">MVC高级开发</a>中，我们手撸了一个MVC框架，接口和Spring MVC类似。如果直接使用Spring MVC，我们写出来的代码类似：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span></span><br><span class="line">public class UserController &#123;</span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/register&quot;</span>)</span><br><span class="line">    public ModelAndView register() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@PostMapping</span>(<span class="string">&quot;/signin&quot;</span>)</span><br><span class="line">    public ModelAndView signin(<span class="variable">@RequestParam</span>(<span class="string">&quot;email&quot;</span>) String email, <span class="variable">@RequestParam</span>(<span class="string">&quot;password&quot;</span>) String password) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，Spring提供的是一个IoC容器，所有的Bean，包括Controller，都在Spring IoC容器中被初始化，而Servlet容器由JavaEE服务器提供（如Tomcat），Servlet容器对Spring一无所知，他们之间到底依靠什么进行联系，又是以何种顺序初始化的？</p>
<p>在理解上述问题之前，我们先把基于Spring MVC开发的项目结构搭建起来。首先创建基于Web的Maven工程，引入如下依赖：</p>
<ul>
<li>org.springframework:spring-context:5.2.0.RELEASE</li>
<li>org.springframework:spring-webmvc:5.2.0.RELEASE</li>
<li>org.springframework:spring-jdbc:5.2.0.RELEASE</li>
<li>javax.annotation:javax.annotation-api:1.3.2</li>
<li>io.pebbletemplates:pebble-spring5:3.1.2</li>
<li>ch.qos.logback:logback-core:1.2.3</li>
<li>ch.qos.logback:logback-classic:1.2.3</li>
<li>com.zaxxer:HikariCP:3.4.2</li>
<li>org.hsqldb:hsqldb:2.5.0</li>
</ul>
<p>以及<code>provided</code>依赖：</p>
<ul>
<li>org.apache.tomcat.embed:tomcat-embed-core:9.0.26</li>
<li>org.apache.tomcat.embed:tomcat-embed-jasper:9.0.26</li>
</ul>
<p>这个标准的Maven Web工程目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">spring-web-mvc</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    └── main</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        │       └── itranswarp</span><br><span class="line">        │           └── learnjava</span><br><span class="line">        │               ├── AppConfig.java</span><br><span class="line">        │               ├── DatabaseInitializer.java</span><br><span class="line">        │               ├── entity</span><br><span class="line">        │               │   └── User.java</span><br><span class="line">        │               ├── service</span><br><span class="line">        │               │   └── UserService.java</span><br><span class="line">        │               └── web</span><br><span class="line">        │                   └── UserController.java</span><br><span class="line">        ├── resources</span><br><span class="line">        │   ├── jdbc.properties</span><br><span class="line">        │   └── logback.xml</span><br><span class="line">        └── webapp</span><br><span class="line">            ├── WEB-INF</span><br><span class="line">            │   ├── templates</span><br><span class="line">            │   │   ├── _base.html</span><br><span class="line">            │   │   ├── index.html</span><br><span class="line">            │   │   ├── profile.html</span><br><span class="line">            │   │   ├── register.html</span><br><span class="line">            │   │   └── signin.html</span><br><span class="line">            │   └── web.xml</span><br><span class="line">            └── static</span><br><span class="line">                ├── css</span><br><span class="line">                │   └── bootstrap.css</span><br><span class="line">                └── js</span><br><span class="line">                    └── jquery.js</span><br></pre></td></tr></table></figure>

<p>其中，<code>src/main/webapp</code>是标准web目录，<code>WEB-INF</code>存放<code>web.xml</code>，编译的class，第三方jar，以及不允许浏览器直接访问的View模版，<code>static</code>目录存放所有静态文件。</p>
<p>在<code>src/main/resources</code>目录中存放的是Java程序读取的classpath资源文件，除了JDBC的配置文件<code>jdbc.properties</code>外，我们又新增了一个<code>logback.xml</code>，这是Logback的默认查找的配置文件：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">		<span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">			<span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d</span><span class="template-variable">&#123;yyyy-MM-dd HH:mm:ss&#125;</span><span class="xml"> %-5level %logger</span><span class="template-variable">&#123;36&#125;</span><span class="xml"> - %msg%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.itranswarp.learnjava&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上面给出了一个写入到标准输出的Logback配置，可以基于上述配置添加写入到文件的配置。</p>
<p>在<code>src/main/java</code>中就是我们编写的Java代码了。</p>
<h3 id="配置Spring-MVC"><a href="#配置Spring-MVC" class="headerlink" title="配置Spring MVC"></a>配置Spring MVC</h3><p>和普通Spring配置一样，我们编写正常的<code>AppConfig</code>后，只需加上<code>@EnableWebMvc</code>注解，就“激活”了Spring MVC：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableWebMvc</span> <span class="comment">// 启用Spring MVC</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(<span class="string">&quot;classpath:/jdbc.properties&quot;</span>)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了创建<code>DataSource</code>、<code>JdbcTemplate</code>、<code>PlatformTransactionManager</code>外，<code>AppConfig</code>需要额外创建几个用于Spring MVC的Bean：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">WebMvcConfigurer <span class="function"><span class="title">createWebMvcConfigurer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="function"><span class="title">WebMvcConfigurer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">addResourceHandlers</span>(<span class="params">ResourceHandlerRegistry registry</span>)</span> &#123;</span><br><span class="line">            registry.addResourceHandler(<span class="string">&quot;/static/**&quot;</span>).addResourceLocations(<span class="string">&quot;/static/&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WebMvcConfigurer</code>并不是必须的，但我们在这里创建一个默认的<code>WebMvcConfigurer</code>，只覆写<code>addResourceHandlers()</code>，目的是让Spring MVC自动处理静态文件，并且映射路径为<code>/static/**</code>。</p>
<p>另一个必须要创建的Bean是<code>ViewResolver</code>，因为Spring MVC允许集成任何模板引擎，使用哪个模板引擎，就实例化一个对应的<code>ViewResolver</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">ViewResolver create<span class="constructor">ViewResolver(@Autowired ServletContext <span class="params">servletContext</span>)</span> &#123;</span><br><span class="line">    PebbleEngine engine = <span class="keyword">new</span> PebbleEngine.<span class="constructor">Builder()</span>.auto<span class="constructor">Escaping(<span class="params">true</span>)</span></span><br><span class="line">            .cache<span class="constructor">Active(<span class="params">false</span>)</span></span><br><span class="line">            .loader(<span class="keyword">new</span> <span class="constructor">ServletLoader(<span class="params">servletContext</span>)</span>)</span><br><span class="line">            .extension(<span class="keyword">new</span> <span class="constructor">SpringExtension()</span>)</span><br><span class="line">            .build<span class="literal">()</span>;</span><br><span class="line">    PebbleViewResolver viewResolver = <span class="keyword">new</span> <span class="constructor">PebbleViewResolver()</span>;</span><br><span class="line">    viewResolver.set<span class="constructor">Prefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>)</span>;</span><br><span class="line">    viewResolver.set<span class="constructor">Suffix(<span class="string">&quot;&quot;</span>)</span>;</span><br><span class="line">    viewResolver.set<span class="constructor">PebbleEngine(<span class="params">engine</span>)</span>;</span><br><span class="line">    return viewResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ViewResolver</code>通过指定prefix和suffix来确定如何查找View。上述配置使用Pebble引擎，指定模板文件存放在<code>/WEB-INF/templates/</code>目录下。</p>
<p>剩下的Bean都是普通的<code>@Component</code>，但Controller必须标记为<code>@Controller</code>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Controller使用@Controller标记而不是@Component:</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 正常使用@Autowired注入:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理一个URL映射:</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是普通的Java应用程序，我们通过<code>main()</code>方法可以很简单地创建一个Spring容器的实例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="function"><span class="title">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>)</span> &#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是问题来了，现在是Web应用程序，而Web应用程序总是由Servlet容器创建，那么，Spring容器应该由谁创建？在什么时候创建？Spring容器中的Controller又是如何通过Servlet调用的？</p>
<p>在Web应用中启动Spring容器有很多种方法，可以通过Listener启动，也可以通过Servlet启动，可以使用XML配置，也可以使用注解配置。这里，我们只介绍一种<em>最简单</em>的启动Spring容器的方式。</p>
<p>第一步，我们在<code>web.xml</code>中配置Spring MVC提供的<code>DispatcherServlet</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">web-app</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span></span><br><span class="line"><span class="meta"> <span class="meta-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>org.springframework.web.context.support.AnnotationConfigWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>com.itranswarp.learnjava.AppConfig<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>0<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>初始化参数<code>contextClass</code>指定使用注解配置的<code>AnnotationConfigWebApplicationContext</code>，配置文件的位置参数<code>contextConfigLocation</code>指向<code>AppConfig</code>的完整类名，最后，把这个Servlet映射到<code>/*</code>，即处理所有URL。</p>
<p>上述配置可以看作一个样板配置，有了这个配置，Servlet容器会首先初始化Spring MVC的<code>DispatcherServlet</code>，在<code>DispatcherServlet</code>启动时，它根据配置<code>AppConfig</code>创建了一个类型是WebApplicationContext的IoC容器，完成所有Bean的初始化，并将容器绑到ServletContext上。</p>
<p>因为<code>DispatcherServlet</code>持有IoC容器，能从IoC容器中获取所有<code>@Controller</code>的Bean，因此，<code>DispatcherServlet</code>接收到所有HTTP请求后，根据Controller方法配置的路径，就可以正确地把请求转发到指定方法，并根据返回的<code>ModelAndView</code>决定如何渲染页面。</p>
<p>最后，我们在<code>AppConfig</code>中通过<code>main()</code>方法启动嵌入式Tomcat：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws Exception &#123;</span><br><span class="line">    Tomcat tomcat = <span class="keyword">new</span> <span class="type">Tomcat</span>();</span><br><span class="line">    tomcat.setPort(Integer.getInteger(<span class="string">&quot;port&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">    tomcat.getConnector();</span><br><span class="line">    Context ctx = tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;src/main/webapp&quot;</span>).getAbsolutePath());</span><br><span class="line">    WebResourceRoot resources = <span class="keyword">new</span> <span class="type">StandardRoot</span>(ctx);</span><br><span class="line">    resources.addPreResources(</span><br><span class="line">            <span class="keyword">new</span> <span class="type">DirResourceSet</span>(resources, <span class="string">&quot;/WEB-INF/classes&quot;</span>, <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;target/classes&quot;</span>).getAbsolutePath(), <span class="string">&quot;/&quot;</span>));</span><br><span class="line">    ctx.setResources(resources);</span><br><span class="line">    tomcat.start();</span><br><span class="line">    tomcat.getServer().await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述Web应用程序就是我们使用Spring MVC时的一个最小启动功能集。由于使用了JDBC和数据库，用户的注册、登录信息会被持久化：</p>
<p>![spring-mvc](2.Spring 5.assets&#x2F;l.png)</p>
<h3 id="编写Controller"><a href="#编写Controller" class="headerlink" title="编写Controller"></a>编写Controller</h3><p>有了Web应用程序的最基本的结构，我们的重点就可以放在如何编写Controller上。Spring MVC对Controller没有固定的要求，也不需要实现特定的接口。以UserController为例，编写Controller只需要遵循以下要点：</p>
<p>总是标记<code>@Controller</code>而不是<code>@Component</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个方法对应一个HTTP请求路径，用<code>@GetMapping</code>或<code>@PostMapping</code>表示GET或POST请求：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@PostMapping</span>(<span class="string">&quot;/signin&quot;</span>)</span><br><span class="line">public ModelAndView doSignin(</span><br><span class="line">        <span class="variable">@RequestParam</span>(<span class="string">&quot;email&quot;</span>) String email,</span><br><span class="line">        <span class="variable">@RequestParam</span>(<span class="string">&quot;password&quot;</span>) String password,</span><br><span class="line">        HttpSession session) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要接收的HTTP参数以<code>@RequestParam()</code>标注，可以设置默认值。如果方法参数需要传入<code>HttpServletRequest</code>、<code>HttpServletResponse</code>或者<code>HttpSession</code>，直接添加这个类型的参数即可，Spring MVC会自动按类型传入。</p>
<p>返回的ModelAndView通常包含View的路径和一个Map作为Model，但也可以没有Model，例如：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="type">ModelAndView</span>(<span class="string">&quot;signin.html&quot;</span>); <span class="comment">// 仅View，没有Model</span></span><br></pre></td></tr></table></figure>

<p>返回重定向时既可以写<code>new ModelAndView(&quot;redirect:/signin&quot;)</code>，也可以直接返回String：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">index</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/signin&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/profile&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果在方法内部直接操作<code>HttpServletResponse</code>发送响应，返回<code>null</code>表示无需进一步处理：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ModelAndView download(HttpServletResponse response) &#123;</span><br><span class="line">    <span class="built_in">byte</span>[] data = ...</span><br><span class="line">    response.setContentType(<span class="string">&quot;application/octet-stream&quot;</span>);</span><br><span class="line">    OutputStream <span class="built_in">output</span> = response.getOutputStream();</span><br><span class="line">    <span class="built_in">output</span>.<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="built_in">output</span>.<span class="built_in">flush</span>();</span><br><span class="line">    <span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对URL进行分组，每组对应一个Controller是一种很好的组织形式，并可以在Controller的class定义出添加URL前缀，例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Controller</span></span><br><span class="line"><span class="variable">@RequestMapping</span>(<span class="string">&quot;/user&quot;</span>)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    <span class="comment">// 注意实际URL映射是/user/profile</span></span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/profile&quot;</span>)</span><br><span class="line">    public ModelAndView profile() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意实际URL映射是/user/changePassword</span></span><br><span class="line">    <span class="variable">@GetMapping</span>(<span class="string">&quot;/changePassword&quot;</span>)</span><br><span class="line">    public ModelAndView changePassword() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际方法的URL映射总是前缀+路径，这种形式还可以有效避免不小心导致的重复的URL映射。</p>
<p>可见，Spring MVC允许我们编写既简单又灵活的Controller实现。</p>
<h2 id="5-2-使用REST"><a href="#5-2-使用REST" class="headerlink" title="5.2 使用REST"></a>5.2 使用REST</h2><p>使用Spring MVC开发Web应用程序的主要工作就是编写Controller逻辑。在Web应用中，除了需要使用MVC给用户显示页面外，还有一类API接口，我们称之为REST，通常输入输出都是JSON，便于第三方调用或者使用页面JavaScript与之交互。</p>
<p>直接在Controller中处理JSON是可以的，因为Spring MVC的<code>@GetMapping</code>和<code>@PostMapping</code>都支持指定输入和输出的格式。如果我们想接收JSON，输出JSON，那么可以这样写：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">&quot;/rest&quot;</span>,</span><br><span class="line">             consumes = <span class="string">&quot;application/json;charset=UTF-8&quot;</span>,</span><br><span class="line">             produces = <span class="string">&quot;application/json;charset=UTF-8&quot;</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">rest</span>(<span class="params"><span class="meta">@RequestBody</span> User user</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;\&quot;restSupport\&quot;:true&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的Maven工程需要加入Jackson这个依赖：<code>com.fasterxml.jackson.core:jackson-databind:2.11.0</code></p>
<p>注意到<code>@PostMapping</code>使用<code>consumes</code>声明能接收的类型，使用<code>produces</code>声明输出的类型，并且额外加了<code>@ResponseBody</code>表示返回的<code>String</code>无需额外处理，直接作为输出内容写入<code>HttpServletResponse</code>。输入的JSON则根据注解<code>@RequestBody</code>直接被Spring反序列化为<code>User</code>这个JavaBean。</p>
<p>使用curl命令测试一下：</p>
<figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H &quot;Content-Type: application/json&quot; -d &#x27;&#123;&quot;email&quot;:&quot;bob@example.com&quot;&#125;&#x27; http://localhost:8080/rest      </span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript">POST /rest HTTP/<span class="number">1.1</span></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript">Host: localhost:<span class="number">8080</span></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript">User-Agent: curl/<span class="number">7.64</span><span class="number">.1</span></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript">Accept: *<span class="comment">/*</span></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript"><span class="comment">Content-Type: application/json</span></span></span><br><span class="line"><span class="meta">&gt;</span> <span class="javascript"><span class="comment">Content-Length: 27</span></span></span><br><span class="line"><span class="meta">&gt;</span> </span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Content-Type: application/json;charset=utf-8</span><br><span class="line">&lt; Content-Length: 20</span><br><span class="line">&lt; Date: Sun, 10 May 2020 09:56:01 GMT</span><br><span class="line">&lt; </span><br><span class="line">&#123;&quot;restSupport&quot;:true&#125;</span><br></pre></td></tr></table></figure>

<p>输出正是我们写入的字符串。</p>
<p>直接用Spring的Controller配合一大堆注解写REST太麻烦了，因此，Spring还额外提供了一个<code>@RestController</code>注解，使用<code>@RestController</code>替代<code>@Controller</code>后，每个方法自动变成API接口方法。我们还是以实际代码举例，编写<code>ApiController</code>如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">&quot;/users&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="function"><span class="title">users</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUsers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">&quot;/users/&#123;id&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> User <span class="function"><span class="title">user</span>(<span class="params"><span class="meta">@PathVariable</span>(<span class="string">&quot;id&quot;</span>) long id</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">&quot;/signin&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; <span class="function"><span class="title">signin</span>(<span class="params"><span class="meta">@RequestBody</span> SignInRequest signinRequest</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user = userService.signin(signinRequest.email, signinRequest.password);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Map</span>.of(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Map</span>.of(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;SIGNIN_FAILED&quot;</span>, <span class="string">&quot;message&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SignInRequest</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">String</span> email;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">String</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写REST接口只需要定义<code>@RestController</code>，然后，每个方法都是一个API接口，输入和输出只要能被Jackson序列化或反序列化为JSON就没有问题。我们用浏览器测试GET请求，可直接显示JSON响应：</p>
<p>![user-api](2.Spring 5.assets&#x2F;l-16419149374143.png)</p>
<p>要测试POST请求，可以用curl命令：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H <span class="string">&quot;Content-Type: application/json&quot;</span> -d &#x27;&#123;<span class="string">&quot;email&quot;</span>:<span class="string">&quot;bob@example.com&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;bob123&quot;</span>&#125;&#x27; http://localhost:<span class="number">8080</span>/api/signin</span><br><span class="line">&gt; POST /api/signin HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Host: localhost:<span class="number">8080</span></span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.64</span>.<span class="number">1</span></span><br><span class="line">&gt; <span class="keyword">Accept</span>: */*</span><br><span class="line">&gt; Content-<span class="keyword">Type</span>: application/json</span><br><span class="line">&gt; Content-Length: <span class="number">47</span></span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/<span class="number">1.1</span> <span class="number">200</span> </span><br><span class="line">&lt; Content-<span class="keyword">Type</span>: application/json</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Date: Sun, <span class="number">10</span> May <span class="number">2020</span> <span class="number">08</span>:<span class="number">14</span>:<span class="number">13</span> GMT</span><br><span class="line">&lt; </span><br><span class="line">&#123;<span class="string">&quot;user&quot;</span>:&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1</span>,<span class="string">&quot;email&quot;</span>:<span class="string">&quot;bob@example.com&quot;</span>,<span class="string">&quot;password&quot;</span>:<span class="string">&quot;bob123&quot;</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;Bob&quot;</span>,...</span><br></pre></td></tr></table></figure>

<p>注意观察上述JSON的输出，<code>User</code>能被正确地序列化为JSON，但暴露了<code>password</code>属性，这是我们不期望的。要避免输出<code>password</code>属性，可以把<code>User</code>复制到另一个<code>UserBean</code>对象，该对象只持有必要的属性，但这样做比较繁琐。另一种简单的方法是直接在<code>User</code>的<code>password</code>属性定义处加上<code>@JsonIgnore</code>表示完全忽略该属性：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> <span class="function"><span class="title">getPassword</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样一来，如果写一个<code>register(User user)</code>方法，那么该方法的User对象也拿不到注册时用户传入的密码了。如果要允许输入<code>password</code>，但不允许输出<code>password</code>，即在JSON序列化和反序列化时，允许写属性，禁用读属性，可以更精细地控制如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonProperty(access = Access.WRITE_ONLY)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，可以使用<code>@JsonProperty(access = Access.READ_ONLY)</code>允许输出，不允许输入。</p>
<h2 id="5-3-集成Filter"><a href="#5-3-集成Filter" class="headerlink" title="5.3 集成Filter"></a>5.3 集成Filter</h2><p>在Spring MVC中，<code>DispatcherServlet</code>只需要固定配置到<code>web.xml</code>中，剩下的工作主要是专注于编写Controller。</p>
<p>但是，在Servlet规范中，我们还可以<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266264823560128">使用Filter</a>。如果要在Spring MVC中使用<code>Filter</code>，应该怎么做？</p>
<p>有的童鞋在上一节的Web应用中可能发现了，如果注册时输入中文会导致乱码，因为Servlet默认按非UTF-8编码读取参数。为了修复这一问题，我们可以简单地使用一个EncodingFilter，在全局范围类给<code>HttpServletRequest</code>和<code>HttpServletResponse</code>强制设置为UTF-8编码。</p>
<p>可以自己编写一个EncodingFilter，也可以直接使用Spring MVC自带的一个<code>CharacterEncodingFilter</code>。配置Filter时，只需在<code>web.xml</code>中声明即可：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>因为这种Filter和我们业务关系不大，注意到<code>CharacterEncodingFilter</code>其实和Spring的IoC容器没有任何关系，两者均互不知晓对方的存在，因此，配置这种Filter十分简单。</p>
<p>我们再考虑这样一个问题：如果允许用户使用Basic模式进行用户验证，即在HTTP请求中添加头<code>Authorization: Basic email:password</code>，这个需求如何实现？</p>
<p>编写一个<code>AuthFilter</code>是最简单的实现方式：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> AuthFilter implements Filter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    public void <span class="keyword">do</span><span class="constructor">Filter(ServletRequest <span class="params">request</span>, ServletResponse <span class="params">response</span>, FilterChain <span class="params">chain</span>)</span></span><br><span class="line">            throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletRequest req = (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">// 获取Authorization头:</span></span><br><span class="line">        String authHeader = req.get<span class="constructor">Header(<span class="string">&quot;Authorization&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (authHeader != null<span class="operator"> &amp;&amp; </span>authHeader.starts<span class="constructor">With(<span class="string">&quot;Basic &quot;</span>)</span>) &#123;</span><br><span class="line">            <span class="comment">// 从Header中提取email和password:</span></span><br><span class="line">            String email = prefix<span class="constructor">From(<span class="params">authHeader</span>)</span>;</span><br><span class="line">            String password = suffix<span class="constructor">From(<span class="params">authHeader</span>)</span>;</span><br><span class="line">            <span class="comment">// 登录:</span></span><br><span class="line">            User user = userService.signin(email, password);</span><br><span class="line">            <span class="comment">// 放入Session:</span></span><br><span class="line">            req.get<span class="constructor">Session()</span>.set<span class="constructor">Attribute(UserController.KEY_USER, <span class="params">user</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续处理请求:</span></span><br><span class="line">        chain.<span class="keyword">do</span><span class="constructor">Filter(<span class="params">request</span>, <span class="params">response</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在问题来了：在Spring中创建的这个<code>AuthFilter</code>是一个普通Bean，Servlet容器并不知道，所以它不会起作用。</p>
<p>如果我们直接在<code>web.xml</code>中声明这个<code>AuthFilter</code>，注意到<code>AuthFilter</code>的实例将由Servlet容器而不是Spring容器初始化，因此，<code>@Autowire</code>根本不生效，用于登录的<code>UserService</code>成员变量永远是<code>null</code>。</p>
<p>所以，得通过一种方式，让Servlet容器实例化的Filter，间接引用Spring容器实例化的<code>AuthFilter</code>。Spring MVC提供了一个<code>DelegatingFilterProxy</code>，专门来干这个事情：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">    &lt;<span class="keyword">filter</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">filter</span>-<span class="type">name</span>&gt;authFilter&lt;/<span class="keyword">filter</span>-<span class="type">name</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">filter</span>-<span class="keyword">class</span>&gt;org.springframework.web.<span class="keyword">filter</span>.DelegatingFilterProxy&lt;/<span class="keyword">filter</span>-<span class="keyword">class</span>&gt;</span><br><span class="line">    &lt;/<span class="keyword">filter</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;<span class="keyword">filter</span>-<span class="keyword">mapping</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">filter</span>-<span class="type">name</span>&gt;authFilter&lt;/<span class="keyword">filter</span>-<span class="type">name</span>&gt;</span><br><span class="line">        &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment">    &lt;/filter-mapping&gt;</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">&lt;/web-app&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们来看实现原理：</p>
<ol>
<li>Servlet容器从<code>web.xml</code>中读取配置，实例化<code>DelegatingFilterProxy</code>，注意命名是<code>authFilter</code>；</li>
<li>Spring容器通过扫描<code>@Component</code>实例化<code>AuthFilter</code>。</li>
</ol>
<p>当<code>DelegatingFilterProxy</code>生效后，它会自动查找注册在<code>ServletContext</code>上的Spring容器，再试图从容器中查找名为<code>authFilter</code>的Bean，也就是我们用<code>@Component</code>声明的<code>AuthFilter</code>。</p>
<p><code>DelegatingFilterProxy</code>将请求代理给<code>AuthFilter</code>，核心代码如下：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingFilterProxy</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Filter <span class="keyword">delegate</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> doFilter(...) throws ... &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">delegate</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">delegate</span> = findBeanFromSpringContainer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delegate</span>.doFilter(req, resp, chain);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是一个<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1281319432618017">代理模式</a>的简单应用。我们画个图表示它们之间的引用关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─</span><br><span class="line">  ┌─────────────────────┐        ┌───────────┐   │</span><br><span class="line">│ │DelegatingFilterProxy│─│─│─ ─&gt;│AuthFilter │</span><br><span class="line">  └─────────────────────┘        └───────────┘   │</span><br><span class="line">│ ┌─────────────────────┐ │ │    ┌───────────┐</span><br><span class="line">  │  DispatcherServlet  │─ ─ ─ ─&gt;│Controllers│   │</span><br><span class="line">│ └─────────────────────┘ │ │    └───────────┘</span><br><span class="line">                                                 │</span><br><span class="line">│    Servlet Container    │ │  Spring Container</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─   ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>

<p>如果在<code>web.xml</code>中配置的Filter名字和Spring容器的Bean的名字不一致，那么需要指定Bean的名字：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>basicAuthFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定Bean的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetBeanName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>authFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实际应用时，尽量保持名字一致，以减少不必要的配置。</p>
<p>要使用Basic模式的用户认证，我们可以使用curl命令测试。例如，用户登录名是<code>tom@example.com</code>，口令是<code>tomcat</code>，那么先构造一个使用URL编码的<code>用户名:口令</code>的字符串：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tom</span>%<span class="number">40</span>example.com:tomcat</span><br></pre></td></tr></table></figure>

<p>对其进行Base64编码，最终构造出的Header如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span>: Basic dG<span class="number">9</span>tJTQwZXhhbXBsZS<span class="number">5</span>jb<span class="number">206</span>dG<span class="number">9</span>tY<span class="number">2</span>F<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>使用如下的<code>curl</code>命令并获得响应如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v -H &#x27;Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0&#x27; http://localhost:8080/profile</span><br><span class="line">&gt; GET /profile HTTP/1.1</span><br><span class="line">&gt; Host: localhost:8080</span><br><span class="line">&gt; User-Agent: curl/7.64.1</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; Authorization: Basic dG9tJTQwZXhhbXBsZS5jb206dG9tY2F0</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 </span><br><span class="line">&lt; Set-Cookie: JSESSIONID=CE0F4BFC394816F717443397D4FEABBE; Path=/; HttpOnly</span><br><span class="line">&lt; Content-Type: text/html;charset=UTF-8</span><br><span class="line">&lt; Content-Language: en-CN</span><br><span class="line">&lt; Transfer-Encoding: chunked</span><br><span class="line">&lt; Date: Wed, 29 Apr 2020 00:15:50 GMT</span><br><span class="line">&lt; </span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">...HTML输出...</span><br></pre></td></tr></table></figure>

<p>上述响应说明<code>AuthFilter</code>已生效。</p>
<p> 注意：Basic认证模式并不安全，本节只用来作为使用Filter的示例。</p>
<h2 id="5-4-使用Interceptor"><a href="#5-4-使用Interceptor" class="headerlink" title="5.4 使用Interceptor"></a>5.4 使用Interceptor</h2><p>在Web程序中，注意到使用Filter的时候，Filter由Servlet容器管理，它在Spring MVC的Web应用程序中作用范围如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">         │   ▲</span><br><span class="line">         ▼   │</span><br><span class="line">       ┌───────┐</span><br><span class="line">       │Filter1│</span><br><span class="line">       └───────┘</span><br><span class="line">         │   ▲</span><br><span class="line">         ▼   │</span><br><span class="line">       ┌───────┐</span><br><span class="line">┌ ─ ─ ─│Filter2│─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">       └───────┘</span><br><span class="line">│        │   ▲                  │</span><br><span class="line">         ▼   │</span><br><span class="line">│ ┌─────────────────┐           │</span><br><span class="line">  │DispatcherServlet│&lt;───┐</span><br><span class="line">│ └─────────────────┘    │      │</span><br><span class="line">   │              ┌────────────┐</span><br><span class="line">│  │              │ModelAndView││</span><br><span class="line">   │              └────────────┘</span><br><span class="line">│  │                     ▲      │</span><br><span class="line">   │    ┌───────────┐    │</span><br><span class="line">│  ├───&gt;│Controller1│────┤      │</span><br><span class="line">   │    └───────────┘    │</span><br><span class="line">│  │                     │      │</span><br><span class="line">   │    ┌───────────┐    │</span><br><span class="line">│  └───&gt;│Controller2│────┘      │</span><br><span class="line">        └───────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>

<p>上图虚线框就是Filter2的拦截范围，Filter组件实际上并不知道后续内部处理是通过Spring MVC提供的<code>DispatcherServlet</code>还是其他Servlet组件，因为Filter是Servlet规范定义的标准组件，它可以应用在任何基于Servlet的程序中。</p>
<p>如果只基于Spring MVC开发应用程序，还可以使用Spring MVC提供的一种功能类似Filter的拦截器：Interceptor。和Filter相比，Interceptor拦截范围不是后续整个处理流程，而是仅针对Controller拦截：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">     ┌───────┐</span><br><span class="line">     │Filter1│</span><br><span class="line">     └───────┘</span><br><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">     ┌───────┐</span><br><span class="line">     │Filter2│</span><br><span class="line">     └───────┘</span><br><span class="line">       │   ▲</span><br><span class="line">       ▼   │</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│DispatcherServlet│&lt;───┐</span><br><span class="line">└─────────────────┘    │</span><br><span class="line"> │              ┌────────────┐</span><br><span class="line"> │              │ModelAndView│</span><br><span class="line"> │              └────────────┘</span><br><span class="line"> │ ┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐ ▲</span><br><span class="line"> │    ┌───────────┐    │</span><br><span class="line"> ├─┼─&gt;│Controller1│──┼─┤</span><br><span class="line"> │    └───────────┘    │</span><br><span class="line"> │ │                 │ │</span><br><span class="line"> │    ┌───────────┐    │</span><br><span class="line"> └─┼─&gt;│Controller2│──┼─┘</span><br><span class="line">      └───────────┘</span><br><span class="line">   └ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>

<p>上图虚线框就是Interceptor的拦截范围，注意到Controller的处理方法一般都类似这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/path/to/hello&quot;)</span></span><br><span class="line">    <span class="function">ModelAndView <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，Interceptor的拦截范围其实就是Controller方法，它实际上就相当于基于AOP的方法拦截。因为Interceptor只拦截Controller方法，所以要注意，返回<code>ModelAndView</code>后，后续对View的渲染就脱离了Interceptor的拦截范围。</p>
<p>使用Interceptor的好处是Interceptor本身是Spring管理的Bean，因此注入任意Bean都非常简单。此外，可以应用多个Interceptor，并通过简单的<code>@Order</code>指定顺序。我们先写一个<code>LoggerInterceptor</code>：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;preHandle &#123;&#125;...&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">if</span> (request.getParameter(<span class="string">&quot;debug&quot;</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            PrintWriter pw = response.getWriter();</span><br><span class="line">            pw.write(<span class="string">&quot;&lt;p&gt;DEBUG MODE&lt;/p&gt;&quot;</span>);</span><br><span class="line">            pw.flush();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;postHandle &#123;&#125;.&quot;</span>, request.getRequestURI());</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__time__&quot;</span>, LocalDateTime.now());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;afterCompletion &#123;&#125;: exception = &#123;&#125;&quot;</span>, request.getRequestURI(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个Interceptor必须实现<code>HandlerInterceptor</code>接口，可以选择实现<code>preHandle()</code>、<code>postHandle()</code>和<code>afterCompletion()</code>方法。<code>preHandle()</code>是Controller方法调用前执行，<code>postHandle()</code>是Controller方法正常返回后执行，而<code>afterCompletion()</code>无论Controller方法是否抛异常都会执行，参数<code>ex</code>就是Controller方法抛出的异常（未抛出异常是<code>null</code>）。</p>
<p>在<code>preHandle()</code>中，也可以直接处理响应，然后返回<code>false</code>表示无需调用Controller方法继续处理了，通常在认证或者安全检查失败时直接返回错误响应。在<code>postHandle()</code>中，因为捕获了Controller方法返回的<code>ModelAndView</code>，所以可以继续往<code>ModelAndView</code>里添加一些通用数据，很多页面需要的全局数据如Copyright信息等都可以放到这里，无需在每个Controller方法中重复添加。</p>
<p>我们再继续添加一个<code>AuthInterceptor</code>，用于替代上一节使用<code>AuthFilter</code>进行Basic认证的功能：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">Order(2)</span></span><br><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> AuthInterceptor implements HandlerInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(<span class="params">getClass</span>()</span>);</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean pre<span class="constructor">Handle(HttpServletRequest <span class="params">request</span>, HttpServletResponse <span class="params">response</span>, Object <span class="params">handler</span>)</span></span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;pre authenticate &#123;&#125;...&quot;</span>, request.get<span class="constructor">RequestURI()</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            authenticate<span class="constructor">ByHeader(<span class="params">request</span>)</span>;</span><br><span class="line">        &#125; catch (RuntimeException e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;login by authorization header failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void authenticate<span class="constructor">ByHeader(HttpServletRequest <span class="params">req</span>)</span> &#123;</span><br><span class="line">        String authHeader = req.get<span class="constructor">Header(<span class="string">&quot;Authorization&quot;</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (authHeader != null<span class="operator"> &amp;&amp; </span>authHeader.starts<span class="constructor">With(<span class="string">&quot;Basic &quot;</span>)</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;try authenticate by authorization header...&quot;</span>);</span><br><span class="line">            String up = <span class="keyword">new</span> <span class="constructor">String(Base64.<span class="params">getDecoder</span>()</span>.decode(authHeader.substring(<span class="number">6</span>)), StandardCharsets.UTF_8);</span><br><span class="line">            <span class="built_in">int</span> pos = up.index<span class="constructor">Of(&#x27;:&#x27;)</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String email = <span class="module-access"><span class="module"><span class="identifier">URLDecoder</span>.</span></span>decode(up.substring(<span class="number">0</span>, pos), StandardCharsets.UTF_8);</span><br><span class="line">                String password = <span class="module-access"><span class="module"><span class="identifier">URLDecoder</span>.</span></span>decode(up.substring(pos + <span class="number">1</span>), StandardCharsets.UTF_8);</span><br><span class="line">                User user = userService.signin(email, password);</span><br><span class="line">                req.get<span class="constructor">Session()</span>.set<span class="constructor">Attribute(UserController.KEY_USER, <span class="params">user</span>)</span>;</span><br><span class="line">                logger.info(<span class="string">&quot;user &#123;&#125; login by authorization header ok.&quot;</span>, email);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>AuthInterceptor</code>是由Spring容器直接管理的，因此注入<code>UserService</code>非常方便。</p>
<p>最后，要让拦截器生效，我们在<code>WebMvcConfigurer</code>中注册所有的Interceptor：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line">WebMvcConfigurer createWebMvcConfigurer(<span class="variable">@Autowired</span> HandlerInterceptor[] interceptors) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">WebMvcConfigurer</span>() &#123;</span><br><span class="line">        <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">addInterceptors</span>(InterceptorRegistry registry) &#123;</span><br><span class="line">            <span class="selector-tag">for</span> (var <span class="attribute">interceptor </span>: interceptors) &#123;</span><br><span class="line">                <span class="selector-tag">registry</span><span class="selector-class">.addInterceptor</span>(interceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果拦截器没有生效，请检查是否忘了在WebMvcConfigurer中注册。</p>
<h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><p>在Controller中，Spring MVC还允许定义基于<code>@ExceptionHandler</code>注解的异常处理方法。我们来看具体的示例代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public <span class="keyword">class</span> UserController &#123;</span><br><span class="line">    @<span class="constructor">ExceptionHandler(RuntimeException.<span class="params">class</span>)</span></span><br><span class="line">    public ModelAndView handle<span class="constructor">UnknowException(Exception <span class="params">ex</span>)</span> &#123;</span><br><span class="line">        return <span class="keyword">new</span> <span class="constructor">ModelAndView(<span class="string">&quot;500.html&quot;</span>, Map.<span class="params">of</span>(<span class="string">&quot;error&quot;</span>, <span class="params">ex</span>.<span class="params">getClass</span>()</span>.get<span class="constructor">SimpleName()</span>, <span class="string">&quot;message&quot;</span>, ex.get<span class="constructor">Message()</span>));</span><br><span class="line">    &#125;<span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>

<p>异常处理方法没有固定的方法签名，可以传入<code>Exception</code>、<code>HttpServletRequest</code>等，返回值可以是<code>void</code>，也可以是<code>ModelAndView</code>，上述代码通过<code>@ExceptionHandler(RuntimeException.class)</code>表示当发生<code>RuntimeException</code>的时候，就自动调用此方法处理。</p>
<p>注意到我们返回了一个新的<code>ModelAndView</code>，这样在应用程序内部如果发生了预料之外的异常，可以给用户显示一个出错页面，而不是简单的500 Internal Server Error或404 Not Found。例如B站的错误页：</p>
<p>![500](2.Spring 5.assets&#x2F;l-16419149632125.png)</p>
<p>可以编写多个错误处理方法，每个方法针对特定的异常。例如，处理<code>LoginException</code>使得页面可以自动跳转到登录页。</p>
<p>使用<code>ExceptionHandler</code>时，要注意它仅作用于当前的Controller，即ControllerA中定义的一个<code>ExceptionHandler</code>方法对ControllerB不起作用。如果我们有很多Controller，每个Controller都需要处理一些通用的异常，例如<code>LoginException</code>，思考一下应该怎么避免重复代码？</p>
<h2 id="5-5-处理CORS"><a href="#5-5-处理CORS" class="headerlink" title="5.5 处理CORS"></a>5.5 处理CORS</h2><p>在开发REST应用时，很多时候，是通过页面的JavaScript和后端的REST API交互。</p>
<p>在JavaScript与REST交互的时候，有很多安全限制。默认情况下，浏览器按同源策略放行JavaScript调用API，即：</p>
<ul>
<li>如果A站在域名<code>a.com</code>页面的JavaScript调用A站自己的API时，没有问题；</li>
<li>如果A站在域名<code>a.com</code>页面的JavaScript调用B站<code>b.com</code>的API时，将被浏览器拒绝访问，因为不满足同源策略。</li>
</ul>
<p>同源要求域名要完全相同（<code>a.com</code>和<code>www.a.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口要相同 。</p>
<p>那么，在域名<code>a.com</code>页面的JavaScript要调用B站<code>b.com</code>的API时，还有没有办法？</p>
<p>办法是有的，那就是CORS，全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。如果A站的JavaScript访问B站API的时候，B站能够返回响应头<code>Access-Control-Allow-Origin: http://a.com</code>，那么，浏览器就允许A站的JavaScript访问B站的API。</p>
<p>注意到跨域访问能否成功，取决于B站是否愿意给A站返回一个正确的<code>Access-Control-Allow-Origin</code>响应头，所以决定权永远在提供API的服务方手中。</p>
<p>关于CORS的详细信息可以参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS">MDN文档</a>，这里不再详述。</p>
<p>使用Spring的<code>@RestController</code>开发REST应用时，同样会面对跨域问题。如果我们允许指定的网站通过页面JavaScript访问这些REST API，就必须正确地设置CORS。</p>
<p>有好几种方法设置CORS，我们来一一介绍。</p>
<h3 id="使用-CrossOrigin"><a href="#使用-CrossOrigin" class="headerlink" title="使用@CrossOrigin"></a>使用@CrossOrigin</h3><p>第一种方法是使用<code>@CrossOrigin</code>注解，可以在<code>@RestController</code>的class级别或方法级别定义一个<code>@CrossOrigin</code>，例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@CrossOrigin</span>(origins = <span class="string">&quot;http://local.liaoxuefeng.com:8080&quot;</span>)</span><br><span class="line"><span class="variable">@RestController</span></span><br><span class="line"><span class="variable">@RequestMapping</span>(<span class="string">&quot;/api&quot;</span>)</span><br><span class="line">public class ApiController &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述定义在<code>ApiController</code>处的<code>@CrossOrigin</code>指定了只允许来自<code>local.liaoxuefeng.com</code>跨域访问，允许多个域访问需要写成数组形式，例如<code>origins = &#123;&quot;http://a.com&quot;, &quot;https://www.b.com&quot;&#125;)</code>。如果要允许任何域访问，写成<code>origins = &quot;*&quot;</code>即可。</p>
<p>如果有多个REST Controller都需要使用CORS，那么，每个Controller都必须标注<code>@CrossOrigin</code>注解。</p>
<h3 id="使用CorsRegistry"><a href="#使用CorsRegistry" class="headerlink" title="使用CorsRegistry"></a>使用CorsRegistry</h3><p>第二种方法是在<code>WebMvcConfigurer</code>中定义一个全局CORS配置，下面是一个示例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">WebMvcConfigurer <span class="function"><span class="title">createWebMvcConfigurer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="function"><span class="title">WebMvcConfigurer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">addCorsMappings</span>(<span class="params">CorsRegistry registry</span>)</span> &#123;</span><br><span class="line">            registry.addMapping(<span class="string">&quot;/api/**&quot;</span>)</span><br><span class="line">                    .allowedOrigins(<span class="string">&quot;http://local.liaoxuefeng.com:8080&quot;</span>)</span><br><span class="line">                    .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>)</span><br><span class="line">                    .maxAge(<span class="number">3600</span>);</span><br><span class="line">            <span class="comment">// 可以继续添加其他URL规则:</span></span><br><span class="line">            <span class="comment">// registry.addMapping(&quot;/rest/v2/**&quot;)...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式可以创建一个全局CORS配置，如果仔细地设计URL结构，那么可以一目了然地看到各个URL的CORS规则，推荐使用这种方式配置CORS。</p>
<h3 id="使用CorsFilter"><a href="#使用CorsFilter" class="headerlink" title="使用CorsFilter"></a>使用CorsFilter</h3><p>第三种方法是使用Spring提供的<code>CorsFilter</code>，我们在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1282384114745378/">集成Filter</a>中详细介绍了将Spring容器内置的Bean暴露为Servlet容器的Filter的方法，由于这种配置方式需要修改<code>web.xml</code>，也比较繁琐，所以推荐使用第二种方式。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>当我们配置好CORS后，可以在浏览器中测试一下规则是否生效。</p>
<p>我们先用<code>http://localhost:8080</code>在Chrome浏览器中打开首页，然后打开Chrome的开发者工具，切换到Console，输入一个JavaScript语句来跨域访问API：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON( <span class="string">&quot;http://local.liaoxuefeng.com:8080/api/users&quot;</span>, <span class="function"><span class="params">(data)</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data)));</span><br></pre></td></tr></table></figure>

<p>上述源站的域是<code>http://localhost:8080</code>，跨域访问的是<code>http://local.liaoxuefeng.com:8080</code>，因为配置的CORS不允许<code>localhost</code>访问，所以不出意外地得到一个错误：</p>
<p>![cors-deny](2.Spring 5.assets&#x2F;l-16419149778577.png)</p>
<p>浏览题打印了错误原因就是<code>been blocked by CORS policy</code>。</p>
<p>我们再用<code>http://local.liaoxuefeng.com:8080</code>在Chrome浏览器中打开首页，在Console中执行JavaScript访问<code>localhost</code>：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON( <span class="string">&quot;http://localhost:8080/api/users&quot;</span>, <span class="function"><span class="params">(data)</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(data)));</span><br></pre></td></tr></table></figure>

<p>因为CORS规则允许来自<code>http://local.liaoxuefeng.com:8080</code>的访问，因此访问成功，打印出API的返回值：</p>
<p>![cors-ok](2.Spring 5.assets&#x2F;l-16419149778588.png)</p>
<h2 id="5-6-国际化"><a href="#5-6-国际化" class="headerlink" title="5.6 国际化"></a>5.6 国际化</h2><p>在开发应用程序的时候，经常会遇到支持多语言的需求，这种支持多语言的功能称之为国际化，英文是internationalization，缩写为i18n（因为首字母i和末字母n中间有18个字母）。</p>
<p>还有针对特定地区的本地化功能，英文是localization，缩写为L10n，本地化是指根据地区调整类似姓名、日期的显示等。</p>
<p>也有把上面两者合称为全球化，英文是globalization，缩写为g11n。</p>
<p>在Java中，支持多语言和本地化是通过<code>MessageFormat</code>配合<code>Locale</code>实现的：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> MessageFormat</span><br></pre></td></tr></table></figure>

<p> Run</p>
<p>对于Web应用程序，要实现国际化功能，主要是渲染View的时候，要把各种语言的资源文件提出来，这样，不同的用户访问同一个页面时，显示的语言就是不同的。</p>
<p>我们来看看在Spring MVC应用程序中如何实现国际化。</p>
<h3 id="获取Locale"><a href="#获取Locale" class="headerlink" title="获取Locale"></a>获取Locale</h3><p>实现国际化的第一步是获取到用户的<code>Locale</code>。在Web应用程序中，HTTP规范规定了浏览器会在请求中携带<code>Accept-Language</code>头，用来指示用户浏览器设定的语言顺序，如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>-Language: zh-CN,zh;q=<span class="number">0</span>.<span class="number">8</span>,en;q=<span class="number">0</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上述HTTP请求头表示优先选择简体中文，其次选择中文，最后选择英文。<code>q</code>表示权重，解析后我们可获得一个根据优先级排序的语言列表，把它转换为Java的<code>Locale</code>，即获得了用户的<code>Locale</code>。大多数框架通常只返回权重最高的<code>Locale</code>。</p>
<p>Spring MVC通过<code>LocaleResolver</code>来自动从<code>HttpServletRequest</code>中获取<code>Locale</code>。有多种<code>LocaleResolver</code>的实现类，其中最常用的是<code>CookieLocaleResolver</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">LocaleResolver create<span class="constructor">LocaleResolver()</span> &#123;</span><br><span class="line">    var clr = <span class="keyword">new</span> <span class="constructor">CookieLocaleResolver()</span>;</span><br><span class="line">    clr.set<span class="constructor">DefaultLocale(Locale.ENGLISH)</span>;</span><br><span class="line">    clr.set<span class="constructor">DefaultTimeZone(TimeZone.<span class="params">getDefault</span>()</span>);</span><br><span class="line">    return clr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CookieLocaleResolver</code>从<code>HttpServletRequest</code>中获取<code>Locale</code>时，首先根据一个特定的Cookie判断是否指定了<code>Locale</code>，如果没有，就从HTTP头获取，如果还没有，就返回默认的<code>Locale</code>。</p>
<p>当用户第一次访问网站时，<code>CookieLocaleResolver</code>只能从HTTP头获取<code>Locale</code>，即使用浏览器的默认语言。通常网站也允许用户自己选择语言，此时，<code>CookieLocaleResolver</code>就会把用户选择的语言存放到Cookie中，下一次访问时，就会返回用户上次选择的语言而不是浏览器默认语言。</p>
<h3 id="提取资源文件"><a href="#提取资源文件" class="headerlink" title="提取资源文件"></a>提取资源文件</h3><p>第二步是把写死在模板中的字符串以资源文件的方式存储在外部。对于多语言，主文件名如果命名为<code>messages</code>，那么资源文件必须按如下方式命名并放入classpath中：</p>
<ul>
<li>默认语言，文件名必须为<code>messages.properties</code>；</li>
<li>简体中文，Locale是<code>zh_CN</code>，文件名必须为<code>messages_zh_CN.properties</code>；</li>
<li>日文，Locale是<code>ja_JP</code>，文件名必须为<code>messages_ja_JP.properties</code>；</li>
<li>其它更多语言……</li>
</ul>
<p>每个资源文件都有相同的key，例如，默认语言是英文，文件<code>messages.properties</code>内容如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language.select</span>=Language</span><br><span class="line"><span class="attr">home</span>=Home</span><br><span class="line"><span class="attr">signin</span>=Sign In</span><br><span class="line"><span class="attr">copyright</span>=Copyright©&#123;<span class="number">0</span>,number,<span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>

<p>文件<code>messages_zh_CN.properties</code>内容如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language.select</span>=语言</span><br><span class="line"><span class="attr">home</span>=首页</span><br><span class="line"><span class="attr">signin</span>=登录</span><br><span class="line"><span class="attr">copyright</span>=版权所有©&#123;<span class="number">0</span>,number,<span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建MessageSource"><a href="#创建MessageSource" class="headerlink" title="创建MessageSource"></a>创建MessageSource</h3><p>第三步是创建一个Spring提供的<code>MessageSource</code>实例，它自动读取所有的<code>.properties</code>文件，并提供一个统一接口来实现“翻译”：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code, arguments, locale:</span></span><br><span class="line"><span class="built_in">String</span> text = messageSource.getMessage(<span class="string">&quot;signin&quot;</span>, <span class="built_in">null</span>, <span class="built_in">locale</span>);</span><br></pre></td></tr></table></figure>

<p>其中，<code>signin</code>是我们在<code>.properties</code>文件中定义的key，第二个参数是<code>Object[]</code>数组作为格式化时传入的参数，最后一个参数就是获取的用户<code>Locale</code>实例。</p>
<p>创建<code>MessageSource</code>如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="string">&quot;i18n&quot;</span>)</span></span><br><span class="line">MessageSource create<span class="constructor">MessageSource()</span> &#123;</span><br><span class="line">    var messageSource = <span class="keyword">new</span> <span class="constructor">ResourceBundleMessageSource()</span>;</span><br><span class="line">    <span class="comment">// 指定文件是UTF-8编码:</span></span><br><span class="line">    messageSource.set<span class="constructor">DefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">// 指定主文件名:</span></span><br><span class="line">    messageSource.set<span class="constructor">Basename(<span class="string">&quot;messages&quot;</span>)</span>;</span><br><span class="line">    return messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>ResourceBundleMessageSource</code>会自动根据主文件名自动把所有相关语言的资源文件都读进来。</p>
<p>再注意到Spring容器会创建不只一个<code>MessageSource</code>实例，我们自己创建的这个<code>MessageSource</code>是专门给页面国际化使用的，因此命名为<code>i18n</code>，不会与其它<code>MessageSource</code>实例冲突。</p>
<h3 id="实现多语言"><a href="#实现多语言" class="headerlink" title="实现多语言"></a>实现多语言</h3><p>要在View中使用<code>MessageSource</code>加上<code>Locale</code>输出多语言，我们通过编写一个<code>MvcInterceptor</code>，把相关资源注入到<code>ModelAndView</code>中：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意注入的MessageSource名称是i18n:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">&quot;i18n&quot;</span>)</span><br><span class="line">    MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析用户的Locale:</span></span><br><span class="line">            Locale locale = localeResolver.resolveLocale(request);</span><br><span class="line">            <span class="comment">// 放入Model:</span></span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__messageSource__&quot;</span>, messageSource);</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__locale__&quot;</span>, locale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘了在<code>WebMvcConfigurer</code>中注册<code>MvcInterceptor</code>。现在，就可以在View中调用<code>MessageSource.getMessage()</code>方法来实现多语言：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/signin&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">__messageSource__.getMessage</span>(<span class="name">&#x27;signin&#x27;</span>, <span class="literal">null</span>, __locale__) &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上述这种写法虽然可行，但格式太复杂了。使用View时，要根据每个特定的View引擎定制国际化函数。在Pebble中，我们可以封装一个国际化函数，名称就是下划线<code>_</code>，改造一下创建<code>ViewResolver</code>的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ViewResolver <span class="function"><span class="title">createViewResolver</span>(<span class="params"><span class="meta">@Autowired</span> ServletContext servletContext, <span class="meta">@Autowired</span> <span class="meta">@Qualifier</span>(<span class="string">&quot;i18n&quot;</span>) MessageSource messageSource</span>)</span> &#123;</span><br><span class="line">    PebbleEngine engine = <span class="keyword">new</span> PebbleEngine.Builder()</span><br><span class="line">            .autoEscaping(<span class="literal">true</span>)</span><br><span class="line">            .cacheActive(<span class="literal">false</span>)</span><br><span class="line">            .loader(<span class="keyword">new</span> ServletLoader(servletContext))</span><br><span class="line">            <span class="comment">// 添加扩展:</span></span><br><span class="line">            .extension(createExtension(messageSource))</span><br><span class="line">            .build();</span><br><span class="line">    PebbleViewResolver viewResolver = <span class="keyword">new</span> PebbleViewResolver();</span><br><span class="line">    viewResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">    viewResolver.setSuffix(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    viewResolver.setPebbleEngine(engine);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Extension <span class="function"><span class="title">createExtension</span>(<span class="params">MessageSource messageSource</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="function"><span class="title">AbstractExtension</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Function</span>&gt; <span class="function"><span class="title">getFunctions</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Map</span>.of(<span class="string">&quot;_&quot;</span>, <span class="keyword">new</span> <span class="function"><span class="title">Function</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">Object</span> <span class="function"><span class="title">execute</span>(<span class="params"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; args, PebbleTemplate self, EvaluationContext context, int lineNumber</span>)</span> &#123;</span><br><span class="line">                    <span class="built_in">String</span> key = (<span class="built_in">String</span>) args.get(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                    List&lt;<span class="built_in">Object</span>&gt; <span class="built_in">arguments</span> = <span class="built_in">this</span>.extractArguments(args);</span><br><span class="line">                    Locale locale = (Locale) context.getVariable(<span class="string">&quot;__locale__&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> messageSource.getMessage(key, <span class="built_in">arguments</span>.toArray(), <span class="string">&quot;???&quot;</span> + key + <span class="string">&quot;???&quot;</span>, locale);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> List&lt;<span class="built_in">Object</span>&gt; <span class="function"><span class="title">extractArguments</span>(<span class="params"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; args</span>)</span> &#123;</span><br><span class="line">                    int i = <span class="number">1</span>;</span><br><span class="line">                    List&lt;<span class="built_in">Object</span>&gt; <span class="built_in">arguments</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">while</span> (args.containsKey(<span class="built_in">String</span>.valueOf(i))) &#123;</span><br><span class="line">                        <span class="built_in">Object</span> param = args.get(<span class="built_in">String</span>.valueOf(i));</span><br><span class="line">                        <span class="built_in">arguments</span>.add(param);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> List&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">getArgumentNames</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们可以把多语言页面改写为：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/signin&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">_</span>(<span class="name">&#x27;signin&#x27;</span>) &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果是带参数的多语言，需要把参数传进去：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h5</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">_</span>(<span class="name">&#x27;copyright&#x27;</span>, <span class="number">2020</span>) &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用其它View引擎时，也应当根据引擎接口实现更方便的语法。</p>
<h3 id="切换Locale"><a href="#切换Locale" class="headerlink" title="切换Locale"></a>切换Locale</h3><p>最后，我们需要允许用户手动切换<code>Locale</code>，编写一个<code>LocaleController</code>来实现该功能：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line"><span class="keyword">public</span> class LocaleController &#123;</span><br><span class="line">    final Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/locale/&#123;lo&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> setLocale(@PathVariable(<span class="string">&quot;lo&quot;</span>) <span class="built_in">String</span> lo, HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        <span class="comment">// 根据传入的lo创建Locale实例:</span></span><br><span class="line">        <span class="built_in">Locale</span> <span class="built_in">locale</span> = <span class="built_in">null</span>;</span><br><span class="line">        int pos = lo.indexOf(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">String</span> lang = lo.substring(<span class="number">0</span>, pos);</span><br><span class="line">            <span class="built_in">String</span> country = lo.substring(pos + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">locale</span> = <span class="literal">new</span> <span class="built_in">Locale</span>(lang, country);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">locale</span> = <span class="literal">new</span> <span class="built_in">Locale</span>(lo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设定此Locale:</span></span><br><span class="line">        localeResolver.setLocale(request, response, <span class="built_in">locale</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;locale is set to &#123;&#125;.&quot;</span>, <span class="built_in">locale</span>);</span><br><span class="line">        <span class="comment">// 刷新页面:</span></span><br><span class="line">        <span class="built_in">String</span> <span class="keyword">referer</span> = request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:&quot;</span> + (<span class="keyword">referer</span> == <span class="built_in">null</span> ? <span class="string">&quot;/&quot;</span> : <span class="keyword">referer</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面设计中，通常在右上角给用户提供一个语言选择列表，来看看效果：</p>
<p>![i18n-en](2.Spring 5.assets&#x2F;l-164191499871211.png)</p>
<p>切换到中文：</p>
<p>![i18n-zh-cn](2.Spring 5.assets&#x2F;l-164191499871312.png)</p>
<h2 id="5-7-异步处理"><a href="#5-7-异步处理" class="headerlink" title="5.7 异步处理"></a>5.7 异步处理</h2><p>在开发应用程序的时候，经常会遇到支持多语言的需求，这种支持多语言的功能称之为国际化，英文是internationalization，缩写为i18n（因为首字母i和末字母n中间有18个字母）。</p>
<p>还有针对特定地区的本地化功能，英文是localization，缩写为L10n，本地化是指根据地区调整类似姓名、日期的显示等。</p>
<p>也有把上面两者合称为全球化，英文是globalization，缩写为g11n。</p>
<p>在Java中，支持多语言和本地化是通过<code>MessageFormat</code>配合<code>Locale</code>实现的：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> MessageFormat</span><br></pre></td></tr></table></figure>

<p> Run</p>
<p>对于Web应用程序，要实现国际化功能，主要是渲染View的时候，要把各种语言的资源文件提出来，这样，不同的用户访问同一个页面时，显示的语言就是不同的。</p>
<p>我们来看看在Spring MVC应用程序中如何实现国际化。</p>
<h3 id="获取Locale-1"><a href="#获取Locale-1" class="headerlink" title="获取Locale"></a>获取Locale</h3><p>实现国际化的第一步是获取到用户的<code>Locale</code>。在Web应用程序中，HTTP规范规定了浏览器会在请求中携带<code>Accept-Language</code>头，用来指示用户浏览器设定的语言顺序，如：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Accept</span>-Language: zh-CN,zh;q=<span class="number">0</span>.<span class="number">8</span>,en;q=<span class="number">0</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上述HTTP请求头表示优先选择简体中文，其次选择中文，最后选择英文。<code>q</code>表示权重，解析后我们可获得一个根据优先级排序的语言列表，把它转换为Java的<code>Locale</code>，即获得了用户的<code>Locale</code>。大多数框架通常只返回权重最高的<code>Locale</code>。</p>
<p>Spring MVC通过<code>LocaleResolver</code>来自动从<code>HttpServletRequest</code>中获取<code>Locale</code>。有多种<code>LocaleResolver</code>的实现类，其中最常用的是<code>CookieLocaleResolver</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">LocaleResolver create<span class="constructor">LocaleResolver()</span> &#123;</span><br><span class="line">    var clr = <span class="keyword">new</span> <span class="constructor">CookieLocaleResolver()</span>;</span><br><span class="line">    clr.set<span class="constructor">DefaultLocale(Locale.ENGLISH)</span>;</span><br><span class="line">    clr.set<span class="constructor">DefaultTimeZone(TimeZone.<span class="params">getDefault</span>()</span>);</span><br><span class="line">    return clr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CookieLocaleResolver</code>从<code>HttpServletRequest</code>中获取<code>Locale</code>时，首先根据一个特定的Cookie判断是否指定了<code>Locale</code>，如果没有，就从HTTP头获取，如果还没有，就返回默认的<code>Locale</code>。</p>
<p>当用户第一次访问网站时，<code>CookieLocaleResolver</code>只能从HTTP头获取<code>Locale</code>，即使用浏览器的默认语言。通常网站也允许用户自己选择语言，此时，<code>CookieLocaleResolver</code>就会把用户选择的语言存放到Cookie中，下一次访问时，就会返回用户上次选择的语言而不是浏览器默认语言。</p>
<h3 id="提取资源文件-1"><a href="#提取资源文件-1" class="headerlink" title="提取资源文件"></a>提取资源文件</h3><p>第二步是把写死在模板中的字符串以资源文件的方式存储在外部。对于多语言，主文件名如果命名为<code>messages</code>，那么资源文件必须按如下方式命名并放入classpath中：</p>
<ul>
<li>默认语言，文件名必须为<code>messages.properties</code>；</li>
<li>简体中文，Locale是<code>zh_CN</code>，文件名必须为<code>messages_zh_CN.properties</code>；</li>
<li>日文，Locale是<code>ja_JP</code>，文件名必须为<code>messages_ja_JP.properties</code>；</li>
<li>其它更多语言……</li>
</ul>
<p>每个资源文件都有相同的key，例如，默认语言是英文，文件<code>messages.properties</code>内容如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language.select</span>=Language</span><br><span class="line"><span class="attr">home</span>=Home</span><br><span class="line"><span class="attr">signin</span>=Sign In</span><br><span class="line"><span class="attr">copyright</span>=Copyright©&#123;<span class="number">0</span>,number,<span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>

<p>文件<code>messages_zh_CN.properties</code>内容如下：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language.select</span>=语言</span><br><span class="line"><span class="attr">home</span>=首页</span><br><span class="line"><span class="attr">signin</span>=登录</span><br><span class="line"><span class="attr">copyright</span>=版权所有©&#123;<span class="number">0</span>,number,<span class="comment">#&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建MessageSource-1"><a href="#创建MessageSource-1" class="headerlink" title="创建MessageSource"></a>创建MessageSource</h3><p>第三步是创建一个Spring提供的<code>MessageSource</code>实例，它自动读取所有的<code>.properties</code>文件，并提供一个统一接口来实现“翻译”：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code, arguments, locale:</span></span><br><span class="line"><span class="built_in">String</span> text = messageSource.getMessage(<span class="string">&quot;signin&quot;</span>, <span class="built_in">null</span>, <span class="built_in">locale</span>);</span><br></pre></td></tr></table></figure>

<p>其中，<code>signin</code>是我们在<code>.properties</code>文件中定义的key，第二个参数是<code>Object[]</code>数组作为格式化时传入的参数，最后一个参数就是获取的用户<code>Locale</code>实例。</p>
<p>创建<code>MessageSource</code>如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@<span class="constructor">Bean(<span class="string">&quot;i18n&quot;</span>)</span></span><br><span class="line">MessageSource create<span class="constructor">MessageSource()</span> &#123;</span><br><span class="line">    var messageSource = <span class="keyword">new</span> <span class="constructor">ResourceBundleMessageSource()</span>;</span><br><span class="line">    <span class="comment">// 指定文件是UTF-8编码:</span></span><br><span class="line">    messageSource.set<span class="constructor">DefaultEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span>;</span><br><span class="line">    <span class="comment">// 指定主文件名:</span></span><br><span class="line">    messageSource.set<span class="constructor">Basename(<span class="string">&quot;messages&quot;</span>)</span>;</span><br><span class="line">    return messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>ResourceBundleMessageSource</code>会自动根据主文件名自动把所有相关语言的资源文件都读进来。</p>
<p>再注意到Spring容器会创建不只一个<code>MessageSource</code>实例，我们自己创建的这个<code>MessageSource</code>是专门给页面国际化使用的，因此命名为<code>i18n</code>，不会与其它<code>MessageSource</code>实例冲突。</p>
<h3 id="实现多语言-1"><a href="#实现多语言-1" class="headerlink" title="实现多语言"></a>实现多语言</h3><p>要在View中使用<code>MessageSource</code>加上<code>Locale</code>输出多语言，我们通过编写一个<code>MvcInterceptor</code>，把相关资源注入到<code>ModelAndView</code>中：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意注入的MessageSource名称是i18n:</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">&quot;i18n&quot;</span>)</span><br><span class="line">    MessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object <span class="keyword">handler</span>, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modelAndView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析用户的Locale:</span></span><br><span class="line">            Locale locale = localeResolver.resolveLocale(request);</span><br><span class="line">            <span class="comment">// 放入Model:</span></span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__messageSource__&quot;</span>, messageSource);</span><br><span class="line">            modelAndView.addObject(<span class="string">&quot;__locale__&quot;</span>, locale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要忘了在<code>WebMvcConfigurer</code>中注册<code>MvcInterceptor</code>。现在，就可以在View中调用<code>MessageSource.getMessage()</code>方法来实现多语言：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/signin&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">__messageSource__.getMessage</span>(<span class="name">&#x27;signin&#x27;</span>, <span class="literal">null</span>, __locale__) &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>上述这种写法虽然可行，但格式太复杂了。使用View时，要根据每个特定的View引擎定制国际化函数。在Pebble中，我们可以封装一个国际化函数，名称就是下划线<code>_</code>，改造一下创建<code>ViewResolver</code>的代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">ViewResolver <span class="function"><span class="title">createViewResolver</span>(<span class="params"><span class="meta">@Autowired</span> ServletContext servletContext, <span class="meta">@Autowired</span> <span class="meta">@Qualifier</span>(<span class="string">&quot;i18n&quot;</span>) MessageSource messageSource</span>)</span> &#123;</span><br><span class="line">    PebbleEngine engine = <span class="keyword">new</span> PebbleEngine.Builder()</span><br><span class="line">            .autoEscaping(<span class="literal">true</span>)</span><br><span class="line">            .cacheActive(<span class="literal">false</span>)</span><br><span class="line">            .loader(<span class="keyword">new</span> ServletLoader(servletContext))</span><br><span class="line">            <span class="comment">// 添加扩展:</span></span><br><span class="line">            .extension(createExtension(messageSource))</span><br><span class="line">            .build();</span><br><span class="line">    PebbleViewResolver viewResolver = <span class="keyword">new</span> PebbleViewResolver();</span><br><span class="line">    viewResolver.setPrefix(<span class="string">&quot;/WEB-INF/templates/&quot;</span>);</span><br><span class="line">    viewResolver.setSuffix(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    viewResolver.setPebbleEngine(engine);</span><br><span class="line">    <span class="keyword">return</span> viewResolver;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Extension <span class="function"><span class="title">createExtension</span>(<span class="params">MessageSource messageSource</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="function"><span class="title">AbstractExtension</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Function</span>&gt; <span class="function"><span class="title">getFunctions</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Map</span>.of(<span class="string">&quot;_&quot;</span>, <span class="keyword">new</span> <span class="function"><span class="title">Function</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="built_in">Object</span> <span class="function"><span class="title">execute</span>(<span class="params"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; args, PebbleTemplate self, EvaluationContext context, int lineNumber</span>)</span> &#123;</span><br><span class="line">                    <span class="built_in">String</span> key = (<span class="built_in">String</span>) args.get(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">                    List&lt;<span class="built_in">Object</span>&gt; <span class="built_in">arguments</span> = <span class="built_in">this</span>.extractArguments(args);</span><br><span class="line">                    Locale locale = (Locale) context.getVariable(<span class="string">&quot;__locale__&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> messageSource.getMessage(key, <span class="built_in">arguments</span>.toArray(), <span class="string">&quot;???&quot;</span> + key + <span class="string">&quot;???&quot;</span>, locale);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> List&lt;<span class="built_in">Object</span>&gt; <span class="function"><span class="title">extractArguments</span>(<span class="params"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">Object</span>&gt; args</span>)</span> &#123;</span><br><span class="line">                    int i = <span class="number">1</span>;</span><br><span class="line">                    List&lt;<span class="built_in">Object</span>&gt; <span class="built_in">arguments</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">while</span> (args.containsKey(<span class="built_in">String</span>.valueOf(i))) &#123;</span><br><span class="line">                        <span class="built_in">Object</span> param = args.get(<span class="built_in">String</span>.valueOf(i));</span><br><span class="line">                        <span class="built_in">arguments</span>.add(param);</span><br><span class="line">                        i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">arguments</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">public</span> List&lt;<span class="built_in">String</span>&gt; <span class="function"><span class="title">getArgumentNames</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们可以把多语言页面改写为：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/signin&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">_</span>(<span class="name">&#x27;signin&#x27;</span>) &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果是带参数的多语言，需要把参数传进去：</p>
<figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">h5</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">_</span>(<span class="name">&#x27;copyright&#x27;</span>, <span class="number">2020</span>) &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用其它View引擎时，也应当根据引擎接口实现更方便的语法。</p>
<h3 id="切换Locale-1"><a href="#切换Locale-1" class="headerlink" title="切换Locale"></a>切换Locale</h3><p>最后，我们需要允许用户手动切换<code>Locale</code>，编写一个<code>LocaleController</code>来实现该功能：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line"><span class="keyword">public</span> class LocaleController &#123;</span><br><span class="line">    final Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    LocaleResolver localeResolver;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">&quot;/locale/&#123;lo&#125;&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> setLocale(@PathVariable(<span class="string">&quot;lo&quot;</span>) <span class="built_in">String</span> lo, HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">        <span class="comment">// 根据传入的lo创建Locale实例:</span></span><br><span class="line">        <span class="built_in">Locale</span> <span class="built_in">locale</span> = <span class="built_in">null</span>;</span><br><span class="line">        int pos = lo.indexOf(<span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">String</span> lang = lo.substring(<span class="number">0</span>, pos);</span><br><span class="line">            <span class="built_in">String</span> country = lo.substring(pos + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">locale</span> = <span class="literal">new</span> <span class="built_in">Locale</span>(lang, country);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">locale</span> = <span class="literal">new</span> <span class="built_in">Locale</span>(lo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设定此Locale:</span></span><br><span class="line">        localeResolver.setLocale(request, response, <span class="built_in">locale</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;locale is set to &#123;&#125;.&quot;</span>, <span class="built_in">locale</span>);</span><br><span class="line">        <span class="comment">// 刷新页面:</span></span><br><span class="line">        <span class="built_in">String</span> <span class="keyword">referer</span> = request.getHeader(<span class="string">&quot;Referer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:&quot;</span> + (<span class="keyword">referer</span> == <span class="built_in">null</span> ? <span class="string">&quot;/&quot;</span> : <span class="keyword">referer</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面设计中，通常在右上角给用户提供一个语言选择列表，来看看效果：</p>
<p>![i18n-en](2.Spring 5.assets&#x2F;l-164191501404415.png)</p>
<p>切换到中文：</p>
<p>![i18n-zh-cn](2.Spring 5.assets&#x2F;l-164191501404516.png)</p>
<h2 id="5-8-使用WebSocket"><a href="#5-8-使用WebSocket" class="headerlink" title="5.8 使用WebSocket"></a>5.8 使用WebSocket</h2><p>WebSocket是一种基于HTTP的长链接技术。传统的HTTP协议是一种请求-响应模型，如果浏览器不发送请求，那么服务器无法主动给浏览器推送数据。如果需要定期给浏览器推送数据，例如股票行情，或者不定期给浏览器推送数据，例如在线聊天，基于HTTP协议实现这类需求，只能依靠浏览器的JavaScript定时轮询，效率很低且实时性不高。</p>
<p>因为HTTP本身是基于TCP连接的，所以，WebSocket在HTTP协议的基础上做了一个简单的升级，即建立TCP连接后，浏览器发送请求时，附带几个头：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br></pre></td></tr></table></figure>

<p>就表示客户端希望升级连接，变成长连接的WebSocket，服务器返回升级成功的响应：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br></pre></td></tr></table></figure>

<p>收到成功响应后表示WebSocket“握手”成功，这样，代表WebSocket的这个TCP连接将不会被服务器关闭，而是一直保持，服务器可随时向浏览器推送消息，浏览器也可随时向服务器推送消息。双方推送的消息既可以是文本消息，也可以是二进制消息，一般来说，绝大部分应用程序会推送基于JSON的文本消息。</p>
<p>现代浏览器都已经支持WebSocket协议，服务器则需要底层框架支持。Java的Servlet规范从3.1开始支持WebSocket，所以，必须选择支持Servlet 3.1或更高规范的Servlet容器，才能支持WebSocket。最新版本的Tomcat、Jetty等开源服务器均支持WebSocket。</p>
<p>我们以实际代码演示如何在Spring MVC中实现对WebSocket的支持。首先，我们需要在<code>pom.xml</code>中加入以下依赖：</p>
<ul>
<li>org.apache.tomcat.embed:tomcat-embed-websocket:9.0.26</li>
<li>org.springframework:spring-websocket:5.2.0.RELEASE</li>
</ul>
<p>第一项是嵌入式Tomcat支持WebSocket的组件，第二项是Spring封装的支持WebSocket的接口。</p>
<p>接下来，我们需要在AppConfig中加入Spring Web对WebSocket的配置，此处我们需要创建一个<code>WebSocketConfigurer</code>实例：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line">WebSocketConfigurer createWebSocketConfigurer(</span><br><span class="line">        <span class="variable">@Autowired</span> ChatHandler chatHandler,</span><br><span class="line">        <span class="variable">@Autowired</span> ChatHandshakeInterceptor chatInterceptor)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">WebSocketConfigurer</span>() &#123;</span><br><span class="line">        <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">registerWebSocketHandlers</span>(WebSocketHandlerRegistry registry) &#123;</span><br><span class="line">            <span class="comment">// 把URL与指定的WebSocketHandler关联，可关联多个:</span></span><br><span class="line">            <span class="selector-tag">registry</span><span class="selector-class">.addHandler</span>(chatHandler, <span class="string">&quot;/chat&quot;</span>)<span class="selector-class">.addInterceptors</span>(chatInterceptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此实例在内部通过<code>WebSocketHandlerRegistry</code>注册能处理WebSocket的<code>WebSocketHandler</code>，以及可选的WebSocket拦截器<code>HandshakeInterceptor</code>。我们注入的这两个类都是自己编写的业务逻辑，后面我们详细讨论如何编写它们，这里只需关注浏览器连接到WebSocket的URL是<code>/chat</code>。</p>
<h3 id="处理WebSocket连接"><a href="#处理WebSocket连接" class="headerlink" title="处理WebSocket连接"></a>处理WebSocket连接</h3><p>和处理普通HTTP请求不同，没法用一个方法处理一个URL。Spring提供了<code>TextWebSocketHandler</code>和<code>BinaryWebSocketHandler</code>分别处理文本消息和二进制消息，这里我们选择文本消息作为聊天室的协议，因此，<code>ChatHandler</code>需要继承自<code>TextWebSocketHandler</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当浏览器请求一个WebSocket连接后，如果成功建立连接，Spring会自动调用<code>afterConnectionEstablished()</code>方法，任何原因导致WebSocket连接中断时，Spring会自动调用<code>afterConnectionClosed</code>方法，因此，覆写这两个方法即可处理连接成功和结束后的业务逻辑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存所有Client的WebSocket会话实例:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Map</span>&lt;<span class="type">String</span>, <span class="type">WebSocketSession</span>&gt; clients = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void afterConnectionEstablished(<span class="type">WebSocketSession</span> session) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="comment">// 新会话根据ID放入Map:</span></span><br><span class="line">        clients.put(session.getId(), session);</span><br><span class="line">        session.getAttributes().put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;Guest1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void afterConnectionClosed(<span class="type">WebSocketSession</span> session, <span class="type">CloseStatus</span> status) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        clients.remove(session.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个WebSocket会话以<code>WebSocketSession</code>表示，且已分配唯一ID。和WebSocket相关的数据，例如用户名称等，均可放入关联的<code>getAttributes()</code>中。</p>
<p>用实例变量<code>clients</code>持有当前所有的<code>WebSocketSession</code>是为了广播，即向所有用户推送同一消息时，可以这么写：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String json =<span class="operator"> ...</span></span><br><span class="line"><span class="operator"></span>TextMessage message = <span class="keyword">new</span> <span class="constructor">TextMessage(<span class="params">json</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String id : clients.key<span class="constructor">Set()</span>) &#123;</span><br><span class="line">    WebSocketSession session = clients.get(id);</span><br><span class="line">    session.send<span class="constructor">Message(<span class="params">message</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发送的消息是序列化后的JSON，可以用ChatMessage表示：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatMessage</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每收到一个用户的消息后，我们就需要广播给所有用户：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ChatHandler</span> <span class="keyword">extends</span> <span class="title">TextWebSocketHandler</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void handleTextMessage(<span class="type">WebSocketSession</span> session, <span class="type">TextMessage</span> message) <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">String</span> s = message.getPayload();</span><br><span class="line">        <span class="type">String</span> r = ... <span class="comment">// 根据输入消息构造待发送消息</span></span><br><span class="line">        broadcastMessage(r); <span class="comment">// 推送给所有用户</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要推送给指定的几个用户，那就需要在<code>clients</code>中根据条件查找出某些<code>WebSocketSession</code>，然后发送消息。</p>
<p>注意到我们在注册WebSocket时还传入了一个<code>ChatHandshakeInterceptor</code>，这个类实际上可以从<code>HttpSessionHandshakeInterceptor</code>继承，它的主要作用是在WebSocket建立连接后，把HttpSession的一些属性复制到WebSocketSession，例如，用户的登录信息等：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">ChatHandshakeInterceptor</span> <span class="keyword">extends</span> <span class="title">HttpSessionHandshakeInterceptor</span> </span>&#123;</span><br><span class="line">    public <span class="type">ChatHandshakeInterceptor</span>() &#123;</span><br><span class="line">        <span class="comment">// 指定从HttpSession复制属性到WebSocketSession:</span></span><br><span class="line">        <span class="keyword">super</span>(<span class="type">List</span>.of(<span class="type">UserController</span>.<span class="type">KEY_USER</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在<code>ChatHandler</code>中，可以从<code>WebSocketSession.getAttributes()</code>中获取到复制过来的属性。</p>
<h3 id="客户端开发"><a href="#客户端开发" class="headerlink" title="客户端开发"></a>客户端开发</h3><p>在完成了服务器端的开发后，我们还需要在页面编写一点JavaScript逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建WebSocket连接:</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://&#x27;</span> + location.host + <span class="string">&#x27;/chat&#x27;</span>);</span><br><span class="line"><span class="comment">// 连接成功时:</span></span><br><span class="line">ws.addEventListener(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;websocket connected.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 收到消息时:</span></span><br><span class="line">ws.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;message: &#x27;</span> + event.data);</span><br><span class="line">    <span class="keyword">var</span> msgs = <span class="built_in">JSON</span>.parse(event.data);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 连接关闭时:</span></span><br><span class="line">ws.addEventListener(<span class="string">&#x27;close&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;websocket closed.&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 绑定到全局变量:</span></span><br><span class="line"><span class="built_in">window</span>.chatWs = ws;</span><br></pre></td></tr></table></figure>

<p>用户可以在连接成功后任何时候给服务器发送消息：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inputText = <span class="string">&#x27;Hello, WebSocket.&#x27;</span>;</span><br><span class="line"><span class="built_in">window</span>.chatWs.send(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">text</span>: inputText&#125;));</span><br></pre></td></tr></table></figure>

<p>最后，连调浏览器和服务器端，如果一切无误，可以开多个不同的浏览器测试WebSocket的推送和广播：</p>
<p>![chat](2.Spring 5.assets&#x2F;l-164191502995819.png)</p>
<p>和上一节我们介绍的异步处理类似，Servlet的线程模型并不适合大规模的长链接。基于NIO的Netty等框架更适合处理WebSocket长链接，我们将在后面介绍。</p>
<h1 id="6-集成第三方组件"><a href="#6-集成第三方组件" class="headerlink" title="6. 集成第三方组件"></a>6. 集成第三方组件</h1><h2 id="6-0-简介"><a href="#6-0-简介" class="headerlink" title="6.0 简介"></a>6.0 简介</h2><p>Spring框架不仅提供了标准的IoC容器、AOP支持、数据库访问以及WebMVC等标准功能，还可以非常方便地集成许多常用的第三方组件：</p>
<ul>
<li>可以集成JavaMail发送邮件；</li>
<li>可以集成JMS消息服务；</li>
<li>可以集成Quartz实现定时任务；</li>
<li>可以集成Redis等服务。</li>
</ul>
<p>本章我们介绍如何在Spring中简单快捷地集成这些第三方组件。</p>
<h2 id="6-1-集成JavaMail"><a href="#6-1-集成JavaMail" class="headerlink" title="6.1 集成JavaMail"></a>6.1 集成JavaMail</h2><p>我们在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1319099923693601">发送Email</a>和<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1319099948859426">接收Email</a>中已经介绍了如何通过JavaMail来收发电子邮件。在Spring中，同样可以集成JavaMail。</p>
<p>因为在服务器端，主要以发送邮件为主，例如在注册成功、登录时、购物付款后通知用户，基本上不会遇到接收用户邮件的情况，所以本节我们只讨论如何在Spring中发送邮件。</p>
<p>在Spring中，发送邮件最终也是需要JavaMail，Spring只对JavaMail做了一点简单的封装，目的是简化代码。为了在Spring中集成JavaMail，我们在<code>pom.xml</code>中添加以下依赖：</p>
<ul>
<li>org.springframework:spring-context-support:5.2.0.RELEASE</li>
<li>javax.mail:javax.mail-api:1.6.2</li>
<li>com.sun.mail:javax.mail:1.6.2</li>
</ul>
<p>以及其他Web相关依赖。</p>
<p>我们希望用户在注册成功后能收到注册邮件，为此，我们先定义一个<code>JavaMailSender</code>的Bean：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">JavaMailSender createJavaMailSender(</span><br><span class="line">        <span class="comment">// smtp.properties:</span></span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">&quot;<span class="subst">$&#123;smtp.host&#125;</span>&quot;</span>) <span class="built_in">String</span> host,</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">&quot;<span class="subst">$&#123;smtp.port&#125;</span>&quot;</span>) <span class="built_in">int</span> port,</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">&quot;<span class="subst">$&#123;smtp.auth&#125;</span>&quot;</span>) <span class="built_in">String</span> auth,</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">&quot;<span class="subst">$&#123;smtp.username&#125;</span>&quot;</span>) <span class="built_in">String</span> username,</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">&quot;<span class="subst">$&#123;smtp.password&#125;</span>&quot;</span>) <span class="built_in">String</span> password,</span><br><span class="line">        <span class="meta">@Value</span>(<span class="string">&quot;<span class="subst">$&#123;smtp.debug:<span class="keyword">true</span>&#125;</span>&quot;</span>) <span class="built_in">String</span> debug)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> mailSender = <span class="keyword">new</span> JavaMailSenderImpl();</span><br><span class="line">    mailSender.setHost(host);</span><br><span class="line">    mailSender.setPort(port);</span><br><span class="line">    mailSender.setUsername(username);</span><br><span class="line">    mailSender.setPassword(password);</span><br><span class="line">    Properties props = mailSender.getJavaMailProperties();</span><br><span class="line">    props.put(<span class="string">&quot;mail.transport.protocol&quot;</span>, <span class="string">&quot;smtp&quot;</span>);</span><br><span class="line">    props.put(<span class="string">&quot;mail.smtp.auth&quot;</span>, auth);</span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">587</span>) &#123;</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.starttls.enable&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (port == <span class="number">465</span>) &#123;</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.socketFactory.port&quot;</span>, <span class="string">&quot;465&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;mail.smtp.socketFactory.class&quot;</span>, <span class="string">&quot;javax.net.ssl.SSLSocketFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    props.put(<span class="string">&quot;mail.debug&quot;</span>, debug);</span><br><span class="line">    <span class="keyword">return</span> mailSender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>JavaMailSender</code>接口的实现类是<code>JavaMailSenderImpl</code>，初始化时，传入的参数与JavaMail是完全一致的。</p>
<p>另外注意到需要注入的属性是从<code>smtp.properties</code>中读取的，因此，<code>AppConfig</code>导入的就不止一个<code>.properties</code>文件，可以导入多个：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableWebMvc</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(&#123; <span class="string">&quot;classpath:/jdbc.properties&quot;</span>, <span class="string">&quot;classpath:/smtp.properties&quot;</span> &#125;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步是封装一个<code>MailService</code>，并定义<code>sendRegistrationMail()</code>方法：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> MailService &#123;</span><br><span class="line">    @<span class="constructor">Value(<span class="string">&quot;$&#123;smtp.from&#125;&quot;</span>)</span></span><br><span class="line">    String from;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    JavaMailSender mailSender;</span><br><span class="line"></span><br><span class="line">    public void send<span class="constructor">RegistrationMail(User <span class="params">user</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MimeMessage mimeMessage = mailSender.create<span class="constructor">MimeMessage()</span>;</span><br><span class="line">            MimeMessageHelper helper = <span class="keyword">new</span> <span class="constructor">MimeMessageHelper(<span class="params">mimeMessage</span>, <span class="string">&quot;utf-8&quot;</span>)</span>;</span><br><span class="line">            helper.set<span class="constructor">From(<span class="params">from</span>)</span>;</span><br><span class="line">            helper.set<span class="constructor">To(<span class="params">user</span>.<span class="params">getEmail</span>()</span>);</span><br><span class="line">            helper.set<span class="constructor">Subject(<span class="string">&quot;Welcome to Java course!&quot;</span>)</span>;</span><br><span class="line">            String html = <span class="module-access"><span class="module"><span class="identifier">String</span>.</span></span>format(<span class="string">&quot;&lt;p&gt;Hi, %s,&lt;/p&gt;&lt;p&gt;Welcome to Java course!&lt;/p&gt;&lt;p&gt;Sent at %s&lt;/p&gt;&quot;</span>, user.get<span class="constructor">Name()</span>, <span class="module-access"><span class="module"><span class="identifier">LocalDateTime</span>.</span></span>now<span class="literal">()</span>);</span><br><span class="line">            helper.set<span class="constructor">Text(<span class="params">html</span>, <span class="params">true</span>)</span>;</span><br><span class="line">            mailSender.send(mimeMessage);</span><br><span class="line">        &#125; catch (MessagingException e) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">RuntimeException(<span class="params">e</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上述代码，<code>MimeMessage</code>是JavaMail的邮件对象，而<code>MimeMessageHelper</code>是Spring提供的用于简化设置MimeMessage的类，比如我们设置HTML邮件就可以直接调用<code>setText(String text, boolean html)</code>方法，而不必再调用比较繁琐的JavaMail接口方法。</p>
<p>最后一步是调用<code>JavaMailSender.send()</code>方法把邮件发送出去。</p>
<p>在MVC的某个Controller方法中，当用户注册成功后，我们就启动一个新线程来异步发送邮件：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">User user = userService.register(email, password, name);</span><br><span class="line">logger.info(<span class="string">&quot;user registered: &#123;&#125;&quot;</span>, user.get<span class="constructor">Email()</span>);</span><br><span class="line"><span class="comment">// send registration mail:</span></span><br><span class="line"><span class="keyword">new</span> <span class="constructor">Thread(()</span> -&gt; &#123;</span><br><span class="line">    mailService.send<span class="constructor">RegistrationMail(<span class="params">user</span>)</span>;</span><br><span class="line">&#125;).start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<p>因为发送邮件是一种耗时的任务，从几秒到几分钟不等，因此，异步发送是保证页面能快速显示的必要措施。这里我们直接启动了一个新的线程，但实际上还有更优化的方法，我们在下一节讨论。</p>
<h2 id="6-2-集成JMS"><a href="#6-2-集成JMS" class="headerlink" title="6.2 集成JMS"></a>6.2 集成JMS</h2><p>JMS即Java Message Service，是JavaEE的消息服务接口。JMS主要有两个版本：1.1和2.0。2.0和1.1相比，主要是简化了收发消息的代码。</p>
<p>所谓消息服务，就是两个进程之间，通过消息服务器传递消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌────────┐    ┌──────────────┐    ┌────────┐</span><br><span class="line">│Producer│───&gt;│Message Server│───&gt;│Consumer│</span><br><span class="line">└────────┘    └──────────────┘    └────────┘</span><br></pre></td></tr></table></figure>

<p>使用消息服务，而不是直接调用对方的API，它的好处是：</p>
<ul>
<li>双方各自无需知晓对方的存在，消息可以异步处理，因为消息服务器会在Consumer离线的时候自动缓存消息；</li>
<li>如果Producer发送的消息频率高于Consumer的处理能力，消息可以积压在消息服务器，不至于压垮Consumer；</li>
<li>通过一个消息服务器，可以连接多个Producer和多个Consumer。</li>
</ul>
<p>因为消息服务在各类应用程序中非常有用，所以JavaEE专门定义了JMS规范。注意到JMS是一组接口定义，如果我们要使用JMS，还需要选择一个具体的JMS产品。常用的JMS服务器有开源的<a target="_blank" rel="noopener" href="https://activemq.apache.org/">ActiveMQ</a>，商业服务器如WebLogic、WebSphere等也内置了JMS支持。这里我们选择开源的ActiveMQ作为JMS服务器，因此，在开发JMS之前我们必须首先安装ActiveMQ。</p>
<p>现在问题来了：从官网下载ActiveMQ时，蹦出一个页面，让我们选择ActiveMQ Classic或者ActiveMQ Artemis，这两个是什么关系，又有什么区别？</p>
<p>实际上ActiveMQ Classic原来就叫ActiveMQ，是Apache开发的基于JMS 1.1的消息服务器，目前稳定版本号是5.x，而ActiveMQ Artemis是由RedHat捐赠的<a target="_blank" rel="noopener" href="https://hornetq.jboss.org/">HornetQ</a>服务器代码的基础上开发的，目前稳定版本号是2.x。和ActiveMQ Classic相比，Artemis版的代码与Classic完全不同，并且，它支持JMS 2.0，使用基于Netty的异步IO，大大提升了性能。此外，Artemis不仅提供了JMS接口，它还提供了AMQP接口，STOMP接口和物联网使用的MQTT接口。选择Artemis，相当于一鱼四吃。</p>
<p>所以，我们这里直接选择ActiveMQ Artemis。从官网<a target="_blank" rel="noopener" href="https://activemq.apache.org/components/artemis/download/">下载</a>最新的2.x版本，解压后设置环境变量<code>ARTEMIS_HOME</code>，指向Artemis根目录，例如<code>C:\Apps\artemis</code>，然后，把<code>ARTEMIS_HOME/bin</code>加入PATH环境变量：</p>
<ul>
<li>Windows下添加<code>%ARTEMIS_HOME%\bin</code>到Path路径；</li>
<li>Mac和Linux下添加<code>$ARTEMIS_HOME/bin</code>到PATH路径。</li>
</ul>
<p>Artemis有个很好的设计，就是它把程序和数据完全分离了。我们解压后的<code>ARTEMIS_HOME</code>目录是程序目录，要启动一个Artemis服务，还需要创建一个数据目录。我们把数据目录直接设定在项目<code>spring-integration-jms</code>的<code>jms-data</code>目录下。执行命令<code>artemis create jms-data</code>：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ pwd</span><br><span class="line">/Users/liaoxuefeng/workspace/spring-integration-jms</span><br><span class="line"></span><br><span class="line">$ artemis <span class="built_in">create</span> jms-data</span><br><span class="line">Creating ActiveMQ Artemis instance <span class="keyword">at</span>: /Users/liaoxuefeng/workspace/spring-integration-jms/jms-data</span><br><span class="line"></span><br><span class="line"><span class="comment">--user: is a mandatory property!</span></span><br><span class="line">Please provide <span class="keyword">the</span> default username:</span><br><span class="line">admin</span><br><span class="line"></span><br><span class="line"><span class="comment">--password: is mandatory with this configuration:</span></span><br><span class="line">Please provide <span class="keyword">the</span> default password:</span><br><span class="line">********</span><br><span class="line"></span><br><span class="line"><span class="comment">--allow-anonymous | --require-login: is a mandatory property!</span></span><br><span class="line">Allow anonymous access?, valid values are Y,N,True,False</span><br><span class="line">N</span><br><span class="line"></span><br><span class="line">Auto tuning journal ...</span><br><span class="line">done! Your <span class="keyword">system</span> can make <span class="number">0.09</span> writes per <span class="built_in">millisecond</span>, your journal-buffer-timeout will be <span class="number">11392000</span></span><br><span class="line"></span><br><span class="line">You can now <span class="built_in">start</span> <span class="keyword">the</span> broker <span class="keyword">by</span> executing:  </span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis&quot;</span> run</span><br><span class="line"></span><br><span class="line">Or you can run <span class="keyword">the</span> broker <span class="keyword">in</span> <span class="keyword">the</span> background <span class="keyword">using</span>:</span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;/Users/liaoxuefeng/workspace/spring-integration-jms/jms-data/bin/artemis-service&quot;</span> <span class="built_in">start</span></span><br></pre></td></tr></table></figure>

<p>在创建过程中，会要求输入连接用户和口令，这里我们设定<code>admin</code>和<code>password</code>，以及是否允许匿名访问（这里选择<code>N</code>）。</p>
<p>此数据目录<code>jms-data</code>不仅包含消息数据、日志，还自动创建了两个启动服务的命令<code>bin/artemis</code>和<code>bin/artemis-service</code>，前者在前台启动运行，按Ctrl+C结束，后者会一直在后台运行。</p>
<p>我们把目录切换到<code>jms-data/bin</code>，直接运行<code>artemis run</code>即可启动Artemis服务：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ ./artemis run</span><br><span class="line">     <span class="symbol">_</span>        <span class="symbol">_</span>               <span class="symbol">_</span></span><br><span class="line">    / \  ____| |<span class="symbol">_</span>  ___ <span class="symbol">__</span>  <span class="symbol">__</span>(<span class="symbol">_</span>) _____</span><br><span class="line">   / <span class="symbol">_</span> \|  <span class="symbol">_</span> \ <span class="symbol">__</span>|/ <span class="symbol">_</span> \  \/  | |/  <span class="symbol">__</span>/</span><br><span class="line">  / ___ \ | \/ |<span class="symbol">_</span>/  <span class="symbol">__</span>/ |\/| | |\___ \</span><br><span class="line"> /<span class="symbol">_</span>/   \<span class="symbol">_</span>\|   \<span class="symbol">__</span>\____|<span class="symbol">_</span>|  |<span class="symbol">_</span>|<span class="symbol">_</span>|/___ /</span><br><span class="line"> Apache ActiveMQ Artemis <span class="number">2.13</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> <span class="number">07</span>:<span class="number">50</span>:<span class="number">21</span>,<span class="number">718</span> INFO  [org.apache.activemq.artemis] AMQ241001: HTTP Server started <span class="built_in">at</span> http://localhost:<span class="number">8161</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> <span class="number">07</span>:<span class="number">50</span>:<span class="number">21</span>,<span class="number">718</span> INFO  [org.apache.activemq.artemis] AMQ241002: Artemis Jolokia REST API available <span class="built_in">at</span> http://localhost:<span class="number">8161</span>/console/jolokia</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> <span class="number">07</span>:<span class="number">50</span>:<span class="number">21</span>,<span class="number">719</span> INFO  [org.apache.activemq.artemis] AMQ241004: Artemis Console available <span class="built_in">at</span> http://localhost:<span class="number">8161</span>/console</span><br></pre></td></tr></table></figure>

<p>启动成功后，Artemis提示可以通过URL<code>http://localhost:8161/console</code>访问管理后台。注意<em>不要关闭命令行窗口</em>。</p>
<p>在编写JMS代码之前，我们首先得理解JMS的消息模型。JMS把生产消息的一方称为Producer，处理消息的一方称为Consumer。有两种类型的消息通道，一种是Queue：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌────────┐    ┌────────┐    ┌────────┐</span><br><span class="line">│Producer│───&gt;│ Queue  │───&gt;│Consumer│</span><br><span class="line">└────────┘    └────────┘    └────────┘</span><br></pre></td></tr></table></figure>

<p>一种是Topic：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                            ┌────────┐</span><br><span class="line">                         ┌─&gt;│Consumer│</span><br><span class="line">                         │  └────────┘</span><br><span class="line">┌────────┐    ┌────────┐ │  ┌────────┐</span><br><span class="line">│Producer│───&gt;│ Topic  │─┼─&gt;│Consumer│</span><br><span class="line">└────────┘    └────────┘ │  └────────┘</span><br><span class="line">                         │  ┌────────┐</span><br><span class="line">                         └─&gt;│Consumer│</span><br><span class="line">                            └────────┘</span><br></pre></td></tr></table></figure>

<p>它们的区别在于，Queue是一种一对一的通道，如果Consumer离线无法处理消息时，Queue会把消息存起来，等Consumer再次连接的时候发给它。设定了持久化机制的Queue不会丢失消息。如果有多个Consumer接入同一个Queue，那么它们等效于以集群方式处理消息，例如，发送方发送的消息是A，B，C，D，E，F，两个Consumer可能分别收到A，C，E和B，D，F，即每个消息只会交给其中一个Consumer处理。</p>
<p>Topic则是一种一对多通道。一个Producer发出的消息，会被多个Consumer同时收到，即每个Consumer都会收到一份完整的消息流。那么问题来了：如果某个Consumer暂时离线，过一段时间后又上线了，那么在它离线期间产生的消息还能不能收到呢？</p>
<p>这取决于消息服务器对Topic类型消息的持久化机制。如果消息服务器不存储Topic消息，那么离线的Consumer会丢失部分离线时期的消息，如果消息服务器存储了Topic消息，那么离线的Consumer可以收到自上次离线时刻开始后产生的所有消息。JMS规范通过Consumer指定一个持久化订阅可以在上线后收取所有离线期间的消息，如果指定的是非持久化订阅，那么离线期间的消息会全部丢失。</p>
<p>细心的童鞋可以看出来，如果一个Topic的消息全部都持久化了，并且只有一个Consumer，那么它和Queue其实是一样的。实际上，很多消息服务器内部都只有Topic类型的消息架构，Queue可以通过Topic“模拟”出来。</p>
<p>无论是Queue还是Topic，对Producer没有什么要求。多个Producer也可以写入同一个Queue或者Topic，此时消息服务器内部会自动排序确保消息总是有序的。</p>
<p>以上是消息服务的基本模型。具体到某个消息服务器时，Producer和Consumer通常是通过TCP连接消息服务器，在编写JMS程序时，又会遇到<code>ConnectionFactory</code>、<code>Connection</code>、<code>Session</code>等概念，其实这和JDBC连接是类似的：</p>
<ul>
<li>ConnectionFactory：代表一个到消息服务器的连接池，类似JDBC的DataSource；</li>
<li>Connection：代表一个到消息服务器的连接，类似JDBC的Connection；</li>
<li>Session：代表一个经过认证后的连接会话；</li>
<li>Message：代表一个消息对象。</li>
</ul>
<p>在JMS 1.1中，发送消息的典型代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Connection connection = null;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建连接:</span></span><br><span class="line">        connection = connectionFactory.create<span class="constructor">Connection()</span>;</span><br><span class="line">        <span class="comment">// 创建会话:</span></span><br><span class="line">        Session session = connection.create<span class="constructor">Session(<span class="params">false</span>,Session.AUTO_ACKNOWLEDGE)</span>;</span><br><span class="line">        <span class="comment">// 创建一个Producer并关联到某个Queue:</span></span><br><span class="line">        MessageProducer messageProducer = session.create<span class="constructor">Producer(<span class="params">queue</span>)</span>;</span><br><span class="line">        <span class="comment">// 创建一个文本消息:</span></span><br><span class="line">        TextMessage textMessage = session.create<span class="constructor">TextMessage(<span class="params">text</span>)</span>;</span><br><span class="line">        <span class="comment">// 发送消息:</span></span><br><span class="line">        messageProducer.send(textMessage);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="comment">// 关闭连接:</span></span><br><span class="line">        <span class="keyword">if</span> (connection != null) &#123;</span><br><span class="line">            connection.close<span class="literal">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; catch (JMSException ex) &#123;</span><br><span class="line">    <span class="comment">// 处理JMS异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JMS 2.0改进了一些API接口，发送消息变得更简单：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (JMSContext <span class="keyword">context</span> = connectionFactory.createContext()) &#123;</span><br><span class="line">    <span class="keyword">context</span>.createProducer().send(queue, <span class="type">text</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JMSContext</code>实现了<code>AutoCloseable</code>接口，可以使用<code>try(resource)</code>语法，代码更简单。</p>
<p>有了以上预备知识，我们就可以开始开发JMS应用了。</p>
<p>首先，我们在<code>pom.xml</code>中添加如下依赖：</p>
<ul>
<li>org.springframework:spring-jms:5.2.0.RELEASE</li>
<li>javax.jms:javax.jms-api:2.0.1</li>
<li>org.apache.activemq:artemis-jms-client:2.13.0</li>
<li>io.netty:netty-handler-proxy:4.1.45.Final</li>
</ul>
<p>在AppConfig中，通过<code>@EnableJms</code>让Spring自动扫描JMS相关的Bean，并加载JMS配置文件<code>jms.properties</code>：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableWebMvc</span></span><br><span class="line"><span class="variable">@EnableJms</span> <span class="comment">// 启用JMS</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(&#123; <span class="string">&quot;classpath:/jdbc.properties&quot;</span>, <span class="string">&quot;classpath:/jms.properties&quot;</span> &#125;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要创建的Bean是ConnectionFactory，即连接消息服务器的连接池：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line">ConnectionFactory createJMSConnectionFactory(</span><br><span class="line">    <span class="variable">@Value</span>(<span class="string">&quot;$&#123;jms.uri:tcp://localhost:61616&#125;&quot;</span>) String uri,</span><br><span class="line">    <span class="variable">@Value</span>(<span class="string">&quot;$&#123;jms.username:admin&#125;&quot;</span>) String username,</span><br><span class="line">    <span class="variable">@Value</span>(<span class="string">&quot;$&#123;jms.password:password&#125;&quot;</span>) String password)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">ActiveMQJMSConnectionFactory</span>(uri, username, password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们使用的消息服务器是ActiveMQ Artemis，所以<code>ConnectionFactory</code>的实现类就是消息服务器提供的<code>ActiveMQJMSConnectionFactory</code>，它需要的参数均由配置文件读取后传入，并设置了默认值。</p>
<p>我们再创建一个<code>JmsTemplate</code>，它是Spring提供的一个工具类，和<code>JdbcTemplate</code>类似，可以简化发送消息的代码：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Bean</span></span><br><span class="line">JmsTemplate createJmsTemplate(<span class="variable">@Autowired</span> ConnectionFactory connectionFactory) &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">new</span> <span class="selector-tag">JmsTemplate</span>(connectionFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步要创建的是<code>JmsListenerContainerFactory</code>，</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(<span class="string">&quot;jmsListenerContainerFactory&quot;</span>)</span><br><span class="line">DefaultJmsListenerContainerFactory createJmsListenerContainerFactory(<span class="meta">@Autowired</span> ConnectionFactory connectionFactory) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">factory</span> = <span class="keyword">new</span> DefaultJmsListenerContainerFactory();</span><br><span class="line">    <span class="keyword">factory</span>.setConnectionFactory(connectionFactory);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">factory</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了必须指定Bean的名称为<code>jmsListenerContainerFactory</code>外，这个Bean的作用是处理和Consumer相关的Bean。我们先跳过它的原理，继续编写<code>MessagingService</code>来发送消息：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessagingService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span> ObjectMapper objectMapper;</span><br><span class="line">    <span class="meta">@Autowired</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sendMailMessage</span><span class="params">(MailMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String text = objectMapper.writeValueAsString(msg);</span><br><span class="line">        jmsTemplate.send(<span class="string">&quot;jms/queue/mail&quot;</span>, <span class="keyword">new</span> MessageCreator() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="function">Message <span class="title">createMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> JMSException </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">return</span> session.<span class="title">createTextMessage</span><span class="params">(text)</span></span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JMS的消息类型支持以下几种：</p>
<ul>
<li>TextMessage：文本消息；</li>
<li>BytesMessage：二进制消息；</li>
<li>MapMessage：包含多个Key-Value对的消息；</li>
<li>ObjectMessage：直接序列化Java对象的消息；</li>
<li>StreamMessage：一个包含基本类型序列的消息。</li>
</ul>
<p>最常用的是发送基于JSON的文本消息，上述代码通过<code>JmsTemplate</code>创建一个<code>TextMessage</code>并发送到名称为<code>jms/queue/mail</code>的Queue。</p>
<p>注意：Artemis消息服务器默认配置下会自动创建Queue，因此不必手动创建一个名为<code>jms/queue/mail</code>的Queue，但不是所有的消息服务器都会自动创建Queue，生产环境的消息服务器通常会关闭自动创建功能，需要手动创建Queue。</p>
<p>再注意到<code>MailMessage</code>是我们自己定义的一个JavaBean，真正的JMS消息是创建的<code>TextMessage</code>，它的内容是JSON。</p>
<p>当用户注册成功后，我们就调用<code>MessagingService.sendMailMessage()</code>发送一条JMS消息，此代码十分简单，这里不再贴出。</p>
<p>下面我们要详细讨论的是如何处理消息，即编写Consumer。从理论上讲，可以创建另一个Java进程来处理消息，但对于我们这个简单的Web程序来说没有必要，直接在同一个Web应用中接收并处理消息即可。</p>
<p>处理消息的核心代码是编写一个Bean，并在处理方法上标注<code>@JmsListener</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public <span class="keyword">class</span> MailMessageListener &#123;</span><br><span class="line">    final Logger logger = <span class="module-access"><span class="module"><span class="identifier">LoggerFactory</span>.</span></span>get<span class="constructor">Logger(<span class="params">getClass</span>()</span>);</span><br><span class="line"></span><br><span class="line">    @Autowired ObjectMapper objectMapper;</span><br><span class="line">    @Autowired MailService mailService;</span><br><span class="line"></span><br><span class="line">    @<span class="constructor">JmsListener(<span class="params">destination</span> = <span class="string">&quot;jms/queue/mail&quot;</span>, <span class="params">concurrency</span> = <span class="string">&quot;10&quot;</span>)</span></span><br><span class="line">    public void on<span class="constructor">MailMessageReceived(Message <span class="params">message</span>)</span> throws Exception &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;received message: &quot;</span> + message);</span><br><span class="line">        <span class="keyword">if</span> (message instanceof TextMessage) &#123;</span><br><span class="line">            String text = ((TextMessage) message).get<span class="constructor">Text()</span>;</span><br><span class="line">            MailMessage mm = objectMapper.read<span class="constructor">Value(<span class="params">text</span>, MailMessage.<span class="params">class</span>)</span>;</span><br><span class="line">            mailService.send<span class="constructor">RegistrationMail(<span class="params">mm</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;unable to process non-text message!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到<code>@JmsListener</code>指定了Queue的名称，因此，凡是发到此Queue的消息都会被这个<code>onMailMessageReceived()</code>方法处理，方法参数是JMS的<code>Message</code>接口，我们通过强制转型为<code>TextMessage</code>并提取JSON，反序列化后获得自定义的JavaBean，也就获得了发送邮件所需的所有信息。</p>
<p>下面问题来了：Spring处理JMS消息的流程是什么？</p>
<p>如果我们直接调用JMS的API来处理消息，那么编写的代码大致如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建JMS连接:</span></span><br><span class="line">Connection connection = connectionFactory.create<span class="constructor">Connection()</span>;</span><br><span class="line"><span class="comment">// 创建会话:</span></span><br><span class="line">Session session = connection.create<span class="constructor">Session(<span class="params">false</span>, Session.AUTO_ACKNOWLEDGE)</span>;</span><br><span class="line"><span class="comment">// 创建一个Consumer:</span></span><br><span class="line">MessageConsumer consumer = session.create<span class="constructor">Consumer(<span class="params">queue</span>)</span>;</span><br><span class="line"><span class="comment">// 为Consumer指定一个消息处理器:</span></span><br><span class="line">consumer.set<span class="constructor">MessageListener(<span class="params">new</span> MessageListener()</span> &#123; </span><br><span class="line">    public void on<span class="constructor">Message(Message <span class="params">message</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 在此处理消息... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 启动接收消息的循环:</span></span><br><span class="line">connection.start<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>

<p>我们自己编写的<code>MailMessageListener.onMailMessageReceived()</code>相当于消息处理器：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageListener(<span class="keyword">new</span> <span class="function"><span class="title">MessageListener</span>(<span class="params"></span>)</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">onMessage</span>(<span class="params">Message message</span>)</span> &#123;</span><br><span class="line">        mailMessageListener.onMailMessageReceived(message); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>所以，Spring根据<code>AppConfig</code>的注解<code>@EnableJms</code>自动扫描带有<code>@JmsListener</code>的Bean方法，并为其创建一个<code>MessageListener</code>把它包装起来。</p>
<p>注意到前面我们还创建了一个<code>JmsListenerContainerFactory</code>的Bean，它的作用就是为每个<code>MessageListener</code>创建<code>MessageConsumer</code>并启动消息接收循环。</p>
<p>再注意到<code>@JmsListener</code>还有一个<code>concurrency</code>参数，10表示可以最多同时并发处理10个消息，<code>5-10</code>表示并发处理的线程可以在5~10之间调整。</p>
<p>因此，Spring在通过<code>MessageListener</code>接收到消息后，并不是直接调用<code>mailMessageListener.onMailMessageReceived()</code>，而是用线程池调用，因此，要时刻牢记，<code>onMailMessageReceived()</code>方法可能被多线程并发执行，一定要保证线程安全。</p>
<p>我们总结一下Spring接收消息的步骤：</p>
<p>通过<code>JmsListenerContainerFactory</code>配合<code>@EnableJms</code>扫描所有<code>@JmsListener</code>方法，自动创建<code>MessageConsumer</code>、<code>MessageListener</code>以及线程池，启动消息循环接收处理消息，最终由我们自己编写的<code>@JmsListener</code>方法处理消息，可能会由多线程同时并发处理。</p>
<p>要验证消息发送和处理，我们注册一个新用户，可以看到如下日志输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> <span class="number">08</span>:<span class="number">04</span>:<span class="number">27</span> INFO  c<span class="selector-class">.i</span><span class="selector-class">.learnjava</span><span class="selector-class">.web</span><span class="selector-class">.UserController</span> - user registered: bob@example<span class="selector-class">.com</span></span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> <span class="number">08</span>:<span class="number">04</span>:<span class="number">27</span> INFO  c<span class="selector-class">.i</span><span class="selector-class">.l</span><span class="selector-class">.service</span><span class="selector-class">.MailMessageListener</span> - received message: ActiveMQMessage<span class="selector-attr">[ID:9fc5...]</span>:PERSISTENT/ClientMessageImpl<span class="selector-attr">[messageID=983, durable=true, address=jms/queue/mail, ...]</span>]</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> <span class="number">08</span>:<span class="number">04</span>:<span class="number">27</span> INFO  c<span class="selector-class">.i</span><span class="selector-class">.learnjava</span><span class="selector-class">.service</span><span class="selector-class">.MailService</span> - <span class="selector-attr">[send mail]</span> sending registration mail to bob@example<span class="selector-class">.com</span>...</span><br><span class="line"><span class="number">2020</span>-<span class="number">06</span>-<span class="number">02</span> <span class="number">08</span>:<span class="number">04</span>:<span class="number">30</span> INFO  c<span class="selector-class">.i</span><span class="selector-class">.learnjava</span><span class="selector-class">.service</span><span class="selector-class">.MailService</span> - <span class="selector-attr">[send mail]</span> registration mail was sent to bob@example<span class="selector-class">.com</span>.</span><br></pre></td></tr></table></figure>

<p>可见，消息被成功发送到Artemis，然后在很短的时间内被接收处理了。</p>
<p>使用消息服务对发送Email进行改造的好处是，发送Email的能力通常是有限的，通过JMS消息服务，如果短时间内需要给大量用户发送Email，可以先把消息堆积在JMS服务器上慢慢发送，对于批量发送邮件、短信等尤其有用。</p>
<h2 id="6-3-使用Scheduler"><a href="#6-3-使用Scheduler" class="headerlink" title="6.3 使用Scheduler"></a>6.3 使用Scheduler</h2><p>在很多应用程序中，经常需要执行定时任务。例如，每天或每月给用户发送账户汇总报表，定期检查并发送系统状态报告，等等。</p>
<p>定时任务我们在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849">使用线程池</a>一节中已经讲到了，Java标准库本身就提供了定时执行任务的功能。在Spring中，使用定时任务更简单，不需要手写线程池相关代码，只需要两个注解即可。</p>
<p>我们还是以实际代码为例，建立工程<code>spring-integration-schedule</code>，无需额外的依赖，我们可以直接在<code>AppConfig</code>中加上<code>@EnableScheduling</code>就开启了定时任务的支持：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableWebMvc</span></span><br><span class="line"><span class="variable">@EnableScheduling</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(&#123; <span class="string">&quot;classpath:/jdbc.properties&quot;</span>, <span class="string">&quot;classpath:/task.properties&quot;</span> &#125;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以直接在一个Bean中编写一个<code>public void</code>无参数方法，然后加上<code>@Scheduled</code>注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 60_000, fixedRate = 60_000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkSystemStatusEveryMinute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start check system status...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述注解指定了启动延迟60秒，并以60秒的间隔执行任务。现在，我们直接运行应用程序，就可以在控制台看到定时任务打印的日志：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2020-06-03 18:47:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start<span class="built_in"> check </span>system status...</span><br><span class="line">2020-06-03 18:48:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start<span class="built_in"> check </span>system status...</span><br><span class="line">2020-06-03 18:49:32 INFO  [pool-1-thread-1] c.i.learnjava.service.TaskService - Start<span class="built_in"> check </span>system status...</span><br></pre></td></tr></table></figure>

<p>如果没有看到定时任务的日志，需要检查：</p>
<ul>
<li>是否忘记了在<code>AppConfig</code>中标注<code>@EnableScheduling</code>；</li>
<li>是否忘记了在定时任务的方法所在的class标注<code>@Component</code>。</li>
</ul>
<p>除了可以使用<code>fixedRate</code>外，还可以使用<code>fixedDelay</code>，两者的区别我们已经在<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306581130018849">使用线程池</a>一节中讲过，这里不再重复。</p>
<p>有的童鞋在实际开发中会遇到一个问题，因为Java的注解全部是常量，写死了<code>fixedDelay=30000</code>，如果根据实际情况要改成60秒怎么办，只能重新编译？</p>
<p>我们可以把定时任务的配置放到配置文件中，例如<code>task.properties</code>：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">task.checkDiskSpace</span>=<span class="number">30000</span></span><br></pre></td></tr></table></figure>

<p>这样就可以随时修改配置文件而无需动代码。但是在代码中，我们需要用<code>fixedDelayString</code>取代<code>fixedDelay</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(initialDelay = 30_000, fixedDelayString = &quot;$&#123;task.checkDiskSpace:30000&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkDiskSpaceEveryMinute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start check disk space...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上述代码的注解参数<code>fixedDelayString</code>是一个属性占位符，并配有默认值30000，Spring在处理<code>@Scheduled</code>注解时，如果遇到<code>String</code>，会根据占位符自动用配置项替换，这样就可以灵活地修改定时任务的配置。</p>
<p>此外，<code>fixedDelayString</code>还可以使用更易读的<code>Duration</code>，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(initialDelay = 30_000, fixedDelayString = <span class="meta-string">&quot;<span class="subst">$&#123;task.checkDiskSpace:PT2M30S&#125;</span>&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>以字符串<code>PT2M30S</code>表示的<code>Duration</code>就是2分30秒，请参考<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1303871087444002">LocalDateTime</a>一节的Duration相关部分。</p>
<p>多个<code>@Scheduled</code>方法完全可以放到一个Bean中，这样便于统一管理各类定时任务。</p>
<h3 id="使用Cron任务"><a href="#使用Cron任务" class="headerlink" title="使用Cron任务"></a>使用Cron任务</h3><p>还有一类定时任务，它不是简单的重复执行，而是按时间触发，我们把这类任务称为Cron任务，例如：</p>
<ul>
<li>每天凌晨2:15执行报表任务；</li>
<li>每个工作日12:00执行特定任务；</li>
<li>……</li>
</ul>
<p>Cron源自Unix&#x2F;Linux系统自带的crond守护进程，以一个简洁的表达式定义任务触发时间。在Spring中，也可以使用Cron表达式来执行Cron任务，在Spring中，它的格式是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">秒 分 小时 天 月份 星期 年</span><br></pre></td></tr></table></figure>

<p>年是可以忽略的，通常不写。每天凌晨2:15执行的Cron表达式就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">15</span> <span class="number">2</span> * * *</span><br></pre></td></tr></table></figure>

<p>每个工作日12:00执行的Cron表达式就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">12</span> * * MON-FRI</span><br></pre></td></tr></table></figure>

<p>每个月1号，2号，3号和10号12:00执行的Cron表达式就是：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">12</span> <span class="number">1</span>-<span class="number">3</span>,<span class="number">10</span> * *</span><br></pre></td></tr></table></figure>

<p>在Spring中，我们定义一个每天凌晨2:15执行的任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;$&#123;task.report:0 15 2 * * *&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cronDailyReport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;Start daily report task...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cron任务同样可以使用属性占位符，这样修改起来更加方便。</p>
<p>Cron表达式还可以表达每10分钟执行，例如：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>*/<span class="number">10</span> * * * *</span><br></pre></td></tr></table></figure>

<p>这样，在每个小时的0:00，10:00，20:00，30:00，40:00，50:00均会执行任务，实际上它可以取代<code>fixedRate</code>类型的定时任务。</p>
<h3 id="集成Quartz"><a href="#集成Quartz" class="headerlink" title="集成Quartz"></a>集成Quartz</h3><p>在Spring中使用定时任务和Cron任务都十分简单，但是要注意到，这些任务的调度都是在每个JVM进程中的。如果在本机启动两个进程，或者在多台机器上启动应用，这些进程的定时任务和Cron任务都是独立运行的，互不影响。</p>
<p>如果一些定时任务要以集群的方式运行，例如每天23:00执行检查任务，只需要集群中的一台运行即可，这个时候，可以考虑使用<a target="_blank" rel="noopener" href="https://www.quartz-scheduler.org/">Quartz</a>。</p>
<p>Quartz可以配置一个JDBC数据源，以便存储所有的任务调度计划以及任务执行状态。也可以使用内存来调度任务，但这样配置就和使用Spring的调度没啥区别了，额外集成Quartz的意义就不大。</p>
<p>Quartz的JDBC配置比较复杂，Spring对其也有一定的支持。要详细了解Quartz的集成，请参考<a target="_blank" rel="noopener" href="https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#scheduling-quartz">Spring的文档</a>。</p>
<p>思考：如果不使用Quartz的JDBC配置，多个Spring应用同时运行时，如何保证某个任务只在某一台机器执行？</p>
<h2 id="6-4-集成JMX"><a href="#6-4-集成JMX" class="headerlink" title="6.4 集成JMX"></a>6.4 集成JMX</h2><p>在Spring中，可以方便地集成JMX。</p>
<p>那么第一个问题来了：什么是JMX？</p>
<p>JMX是Java Management Extensions，它是一个Java平台的管理和监控接口。为什么要搞JMX呢？因为在所有的应用程序中，对运行中的程序进行监控都是非常重要的，Java应用程序也不例外。我们肯定希望知道Java应用程序当前的状态，例如，占用了多少内存，分配了多少内存，当前有多少活动线程，有多少休眠线程等等。如何获取这些信息呢？</p>
<p>为了标准化管理和监控，Java平台使用JMX作为管理和监控的标准接口，任何程序，只要按JMX规范访问这个接口，就可以获取所有管理与监控信息。</p>
<p>实际上，常用的运维监控如Zabbix、Nagios等工具对JVM本身的监控都是通过JMX获取的信息。</p>
<p>因为JMX是一个标准接口，不但可以用于管理JVM，还可以管理应用程序自身。下图是JMX的架构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    ┌─────────┐  ┌─────────┐</span><br><span class="line">    │jconsole │  │   Web   │</span><br><span class="line">    └─────────┘  └─────────┘</span><br><span class="line">         │            │</span><br><span class="line">┌ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ┼ ─ ─ ─ ─</span><br><span class="line"> JVM     ▼            ▼        │</span><br><span class="line">│   ┌─────────┐  ┌─────────┐</span><br><span class="line">  ┌─┤Connector├──┤ Adaptor ├─┐ │</span><br><span class="line">│ │ └─────────┘  └─────────┘ │</span><br><span class="line">  │       MBeanServer        │ │</span><br><span class="line">│ │ ┌──────┐┌──────┐┌──────┐ │</span><br><span class="line">  └─┤MBean1├┤MBean2├┤MBean3├─┘ │</span><br><span class="line">│   └──────┘└──────┘└──────┘</span><br><span class="line"> ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br></pre></td></tr></table></figure>

<p>JMX把所有被管理的资源都称为MBean（Managed Bean），这些MBean全部由MBeanServer管理，如果要访问MBean，可以通过MBeanServer对外提供的访问接口，例如通过RMI或HTTP访问。</p>
<p>注意到使用JMX不需要安装任何额外组件，也不需要第三方库，因为MBeanServer已经内置在JavaSE标准库中了。JavaSE还提供了一个<code>jconsole</code>程序，用于通过RMI连接到MBeanServer，这样就可以管理整个Java进程。</p>
<p>除了JVM会把自身的各种资源以MBean注册到JMX中，我们自己的配置、监控信息也可以作为MBean注册到JMX，这样，管理程序就可以直接控制我们暴露的MBean。因此，应用程序使用JMX，只需要两步：</p>
<ol>
<li>编写MBean提供管理接口和监控数据；</li>
<li>注册MBean。</li>
</ol>
<p>在Spring应用程序中，使用JMX只需要一步：</p>
<ol>
<li>编写MBean提供管理接口和监控数据。</li>
</ol>
<p>第二步注册的过程由Spring自动完成。我们以实际工程为例，首先在<code>AppConfig</code>中加上<code>@EnableMBeanExport</code>注解，告诉Spring自动注册MBean：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="variable">@ComponentScan</span></span><br><span class="line"><span class="variable">@EnableWebMvc</span></span><br><span class="line"><span class="variable">@EnableMBeanExport</span> <span class="comment">// 自动注册MBean</span></span><br><span class="line"><span class="variable">@EnableTransactionManagement</span></span><br><span class="line"><span class="variable">@PropertySource</span>(&#123; <span class="string">&quot;classpath:/jdbc.properties&quot;</span> &#125;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>剩下的全部工作就是编写MBean。我们以实际问题为例，假设我们希望给应用程序添加一个IP黑名单功能，凡是在黑名单中的IP禁止访问，传统的做法是定义一个配置文件，启动的时候读取：</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># blacklist.txt</span><br><span class="line"><span class="number">1.2.3.4</span></span><br><span class="line"><span class="number">5.6.7.8</span></span><br><span class="line"><span class="number">2.2.3.4</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果要修改黑名单怎么办？修改配置文件，然后重启应用程序。</p>
<p>但是每次都重启应用程序实在是太麻烦了，能不能不重启应用程序？可以自己写一个定时读取配置文件的功能，检测到文件改动时自动重新读取。</p>
<p>上述需求本质上是在应用程序运行期间对参数、配置等进行热更新并要求尽快生效。如果以JMX的方式实现，我们不必自己编写自动重新读取等任何代码，只需要提供一个符合JMX标准的MBean来存储配置即可。</p>
<p>还是以IP黑名单为例，JMX的MBean通常以MBean结尾，因此我们遵循标准命名规范，首先编写一个<code>BlacklistMBean</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlacklistMBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; ips = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span>[] <span class="function"><span class="title">getBlacklist</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.toArray(<span class="built_in">String</span>[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">addBlacklist</span>(<span class="params"><span class="built_in">String</span> ip</span>)</span> &#123;</span><br><span class="line">        ips.add(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">removeBlacklist</span>(<span class="params"><span class="built_in">String</span> ip</span>)</span> &#123;</span><br><span class="line">        ips.remove(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">shouldBlock</span>(<span class="params"><span class="built_in">String</span> ip</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.contains(ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个MBean没什么特殊的，它的逻辑和普通Java类没有任何区别。</p>
<p>下一步，我们要使用JMX的客户端来实时热更新这个MBean，所以要给它加上一些注解，让Spring能根据注解自动把相关方法注册到MBeanServer中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ManagedResource</span>(objectName = <span class="string">&quot;sample:name=blacklist&quot;</span>, description = <span class="string">&quot;Blacklist of IP addresses&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlacklistMBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; ips = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedAttribute</span>(description = <span class="string">&quot;Get IP addresses in blacklist&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span>[] <span class="function"><span class="title">getBlacklist</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.toArray(<span class="built_in">String</span>[]::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedOperation</span></span><br><span class="line">    <span class="meta">@ManagedOperationParameter</span>(name = <span class="string">&quot;ip&quot;</span>, description = <span class="string">&quot;Target IP address that will be added to blacklist&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">addBlacklist</span>(<span class="params"><span class="built_in">String</span> ip</span>)</span> &#123;</span><br><span class="line">        ips.add(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ManagedOperation</span></span><br><span class="line">    <span class="meta">@ManagedOperationParameter</span>(name = <span class="string">&quot;ip&quot;</span>, description = <span class="string">&quot;Target IP address that will be removed from blacklist&quot;</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="function"><span class="title">removeBlacklist</span>(<span class="params"><span class="built_in">String</span> ip</span>)</span> &#123;</span><br><span class="line">        ips.remove(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="function"><span class="title">shouldBlock</span>(<span class="params"><span class="built_in">String</span> ip</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ips.contains(ip);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上述代码，<code>BlacklistMBean</code>首先是一个标准的Spring管理的Bean，其次，添加了<code>@ManagedResource</code>表示这是一个MBean，将要被注册到JMX。objectName指定了这个MBean的名字，通常以<code>company:name=Xxx</code>来分类MBean。</p>
<p>对于属性，使用<code>@ManagedAttribute</code>注解标注。上述MBean只有get属性，没有set属性，说明这是一个只读属性。</p>
<p>对于操作，使用<code>@ManagedOperation</code>注解标准。上述MBean定义了两个操作：<code>addBlacklist()</code>和<code>removeBlacklist()</code>，其他方法如<code>shouldBlock()</code>不会被暴露给JMX。</p>
<p>使用MBean和普通Bean是完全一样的。例如，我们在<code>BlacklistInterceptor</code>对IP进行黑名单拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlacklistInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    BlacklistMBean blacklistMBean;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String ip = request.getRemoteAddr();</span><br><span class="line">        logger.info(<span class="string">&quot;check ip address &#123;&#125;...&quot;</span>, ip);</span><br><span class="line">        <span class="comment">// 是否在黑名单中:</span></span><br><span class="line">        <span class="keyword">if</span> (blacklistMBean.shouldBlock(ip)) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;will block ip &#123;&#125; for it is in blacklist.&quot;</span>, ip);</span><br><span class="line">            <span class="comment">// 发送403错误响应:</span></span><br><span class="line">            response.sendError(<span class="number">403</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步就是正常启动Web应用程序，不要关闭它，我们打开另一个命令行窗口，输入<code>jconsole</code>启动JavaSE自带的一个JMX客户端程序：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1352171687772226/l" alt="jconsole"></p>
<p>通过jconsole连接到一个Java进程最简单的方法是直接在Local Process中找到正在运行的<code>AppConfig</code>，点击Connect即可连接到我们当前正在运行的Web应用，在jconsole中可直接看到内存、CPU等资源的监控。</p>
<p>我们点击MBean，左侧按分类列出所有MBean，可以在<code>java.lang</code>查看内存等信息：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1352171742298178/l" alt="mbean"></p>
<p>细心的童鞋可以看到HikariCP连接池也是通过JMX监控的。</p>
<p>在<code>sample</code>中可以看到我们自己的MBean，点击可查看属性<code>blacklist</code>：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1352172098814018/l" alt="mbean-value"></p>
<p>点击<code>Operations</code>-<code>addBlacklist</code>，可以填入<code>127.0.0.1</code>并点击<code>addBlacklist</code>按钮，相当于jconsole通过JMX接口，调用了我们自己的<code>BlacklistMBean</code>的<code>addBlacklist()</code>方法，传入的参数就是填入的<code>127.0.0.1</code>：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1352172147048514/l" alt="mbean-invoke-ok"></p>
<p>再次查看属性<code>blacklist</code>，可以看到结果已经更新了：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1352172193185858/l" alt="mbean-modified"></p>
<p>我们可以在浏览器中测试一下黑名单功能是否已生效：</p>
<p><img src="https://www.liaoxuefeng.com/files/attachments/1352172895731745/l" alt="403"></p>
<p>可见，<code>127.0.0.1</code>确实被添加到了黑名单，后台日志打印如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2020</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">12</span> INFO  c.i.l.web.BlacklistInterceptor - check ip address <span class="number">127.0.0.1</span>...</span><br><span class="line"><span class="attribute">2020</span>-<span class="number">06</span>-<span class="number">06</span> <span class="number">20</span>:<span class="number">22</span>:<span class="number">12</span> WARN  c.i.l.web.BlacklistInterceptor - will block ip <span class="number">127.0.0.1</span> for it is in blacklist.</span><br></pre></td></tr></table></figure>

<p>注意：如果使用IPv6，那么需要把<code>0:0:0:0:0:0:0:1</code>这个本机地址加到黑名单。</p>
<p>如果从jconsole中调用<code>removeBlacklist</code>移除<code>127.0.0.1</code>，刷新浏览器可以看到又允许访问了。</p>
<p>使用jconsole直接通过Local Process连接JVM有个限制，就是jconsole和正在运行的JVM必须在同一台机器。如果要远程连接，首先要打开JMX端口。我们在启动<code>AppConfig</code>时，需要传入以下JVM启动参数：</p>
<ul>
<li>-Dcom.sun.management.jmxremote.port&#x3D;19999</li>
<li>-Dcom.sun.management.jmxremote.authenticate&#x3D;false</li>
<li>-Dcom.sun.management.jmxremote.ssl&#x3D;false</li>
</ul>
<p>第一个参数表示在19999端口监听JMX连接，第二个和第三个参数表示无需验证，不使用SSL连接，在开发测试阶段比较方便，生产环境必须指定验证方式并启用SSL。详细参数可参考Oracle<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html#gdeum">官方文档</a>。这样jconsole可以用<code>ip:19999</code>的远程方式连接JMX。连接后的操作是完全一样的。</p>
<p>许多JavaEE服务器如JBoss的管理后台都是通过JMX提供管理接口，并由Web方式访问，对用户更加友好。</p>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/04/Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_1.Java%20Web/" rel="prev" title="1.Java Web">
                  <i class="fa fa-chevron-left"></i> 1.Java Web
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/04/Java_4.%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6_3.Spring%20MVC/" rel="next" title="3.Spring MVC">
                  3.Spring MVC <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
