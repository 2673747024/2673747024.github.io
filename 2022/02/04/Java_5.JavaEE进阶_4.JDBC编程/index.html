<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="JDBC编程简介程序运行的时候，往往需要存取数据。现代应用程序最基本，也是使用最广泛的数据存储就是关系数据库。 Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity），本章我们介绍如何在Java程序中使用JDBC。 在介绍JDBC之前，我们先简单介绍一下关系数据库。 程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到">
<meta property="og:type" content="article">
<meta property="og:title" content="4.JDBC编程">
<meta property="og:url" content="https://2673747024.github.io/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_4.JDBC%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="JDBC编程简介程序运行的时候，往往需要存取数据。现代应用程序最基本，也是使用最广泛的数据存储就是关系数据库。 Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity），本章我们介绍如何在Java程序中使用JDBC。 在介绍JDBC之前，我们先简单介绍一下关系数据库。 程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://2673747024.github.io/4.JDBC%E7%BC%96%E7%A8%8B.assets/0.jpeg">
<meta property="og:image" content="https://2673747024.github.io/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063210.jpeg">
<meta property="og:image" content="https://2673747024.github.io/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063211.jpeg">
<meta property="og:image" content="https://2673747024.github.io/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063212.png">
<meta property="article:published_time" content="2022-02-04T14:30:57.809Z">
<meta property="article:modified_time" content="2022-02-04T15:04:59.824Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://2673747024.github.io/4.JDBC%E7%BC%96%E7%A8%8B.assets/0.jpeg">


<link rel="canonical" href="https://2673747024.github.io/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_4.JDBC%E7%BC%96%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_4.JDBC%E7%BC%96%E7%A8%8B/","path":"2022/02/04/Java_5.JavaEE进阶_4.JDBC编程/","title":"4.JDBC编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>4.JDBC编程 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">JDBC编程简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NoSQL"><span class="nav-number">1.0.1.</span> <span class="nav-text">NoSQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%88%AB"><span class="nav-number">1.0.2.</span> <span class="nav-text">数据库类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85MySQL"><span class="nav-number">1.0.3.</span> <span class="nav-text">安装MySQL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC"><span class="nav-number">1.0.4.</span> <span class="nav-text">JDBC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.</span> <span class="nav-text">JDBC查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.0.1.</span> <span class="nav-text">JDBC连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDBC%E6%9F%A5%E8%AF%A2-1"><span class="nav-number">2.0.2.</span> <span class="nav-text">JDBC查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E6%B3%A8%E5%85%A5"><span class="nav-number">2.0.3.</span> <span class="nav-text">SQL注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.0.4.</span> <span class="nav-text">数据类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC%E6%9B%B4%E6%96%B0"><span class="nav-number">3.</span> <span class="nav-text">JDBC更新</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5"><span class="nav-number">3.0.1.</span> <span class="nav-text">插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E5%B9%B6%E8%8E%B7%E5%8F%96%E4%B8%BB%E9%94%AE"><span class="nav-number">3.0.2.</span> <span class="nav-text">插入并获取主键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0"><span class="nav-number">3.0.3.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4"><span class="nav-number">3.0.4.</span> <span class="nav-text">删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.</span> <span class="nav-text">JDBC事务</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC-Batch"><span class="nav-number">5.</span> <span class="nav-text">JDBC Batch</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">6.</span> <span class="nav-text">JDBC连接池</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">74</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_4.JDBC%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          4.JDBC编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-02-04 22:30:57 / 修改时间：23:04:59" itemprop="dateCreated datePublished" datetime="2022-02-04T22:30:57+08:00">2022-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/5-JavaEE%E8%BF%9B%E9%98%B6/" itemprop="url" rel="index"><span itemprop="name">5.JavaEE进阶</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：7.6k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈30 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="JDBC编程简介"><a href="#JDBC编程简介" class="headerlink" title="JDBC编程简介"></a>JDBC编程简介</h1><p>程序运行的时候，往往需要存取数据。现代应用程序最基本，也是使用最广泛的数据存储就是关系数据库。</p>
<p>Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity），本章我们介绍如何在Java程序中使用JDBC。</p>
<p>在介绍JDBC之前，我们先简单介绍一下关系数据库。</p>
<p>程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。</p>
<p>而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：</p>
<table>
<thead>
<tr>
<th align="left">名字</th>
<th align="left">成绩</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Michael</td>
<td align="left">99</td>
</tr>
<tr>
<td align="left">Bob</td>
<td align="left">85</td>
</tr>
<tr>
<td align="left">Bart</td>
<td align="left">59</td>
</tr>
<tr>
<td align="left">Lisa</td>
<td align="left">87</td>
</tr>
</tbody></table>
<p>你可以用一个文本文件保存，一行保存一个学生，用<code>,</code>隔开：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Michael</span>,<span class="number">99</span></span><br><span class="line"><span class="attribute">Bob</span>,<span class="number">85</span></span><br><span class="line"><span class="attribute">Bart</span>,<span class="number">59</span></span><br><span class="line"><span class="attribute">Lisa</span>,<span class="number">87</span></span><br></pre></td></tr></table></figure>

<p>你还可以用JSON格式保存，也是文本文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Michael&quot;</span>,<span class="attr">&quot;score&quot;</span>:<span class="number">99</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Bob&quot;</span>,<span class="attr">&quot;score&quot;</span>:<span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Bart&quot;</span>,<span class="attr">&quot;score&quot;</span>:<span class="number">59</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">&quot;name&quot;</span>:<span class="string">&quot;Lisa&quot;</span>,<span class="attr">&quot;score&quot;</span>:<span class="number">87</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>你还可以定义各种保存格式，但是问题来了：</p>
<p>存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；</p>
<p>不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存（比如蓝光电影，40GB的数据），根本无法全部读入内存。</p>
<p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p>
<p>数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。</p>
<p>关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：</p>
<p>假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来：</p>
<p><img src="/4.JDBC%E7%BC%96%E7%A8%8B.assets/0.jpeg" alt="grade"></p>
<p>每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格：</p>
<p><img src="/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063210.jpeg" alt="class"></p>
<p>这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级：</p>
<p><img src="/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063211.jpeg" alt="grade-classes"></p>
<p>也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p>
<p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> classes <span class="keyword">WHERE</span> grade_id = <span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>结果也是一个表：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---------<span class="code">+----------+</span>----------</span><br><span class="line"><span class="section">grade_id | class_id | name</span></span><br><span class="line"><span class="section">---------+----------+----------</span></span><br><span class="line"><span class="section">1        | 11       | 一年级一班</span></span><br><span class="line"><span class="section">---------+----------+----------</span></span><br><span class="line"><span class="section">1        | 12       | 一年级二班</span></span><br><span class="line"><span class="section">---------+----------+----------</span></span><br><span class="line"><span class="section">1        | 13       | 一年级三班</span></span><br><span class="line"><span class="section">---------+----------+----------</span></span><br></pre></td></tr></table></figure>

<p>类似的，Class表的一行记录又可以关联到Student表的多行记录：</p>
<p><img src="/4.JDBC%E7%BC%96%E7%A8%8B.assets/0-164189551063212.png" alt="class-students"></p>
<p>由于本教程不涉及到关系数据库的详细内容，如果你想从零学习关系数据库和基本的SQL语句，请参考<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1177760294764384">SQL课程</a>。</p>
<h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>你也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被他们忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？</p>
<h3 id="数据库类别"><a href="#数据库类别" class="headerlink" title="数据库类别"></a>数据库类别</h3><p>既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：</p>
<p>付费的商用数据库：</p>
<ul>
<li>Oracle，典型的高富帅；</li>
<li>SQL Server，微软自家产品，Windows定制专款；</li>
<li>DB2，IBM的产品，听起来挺高端；</li>
<li>Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。</li>
</ul>
<p>这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：</p>
<ul>
<li>MySQL，大家都在用，一般错不了；</li>
<li>PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；</li>
<li>sqlite，嵌入式数据库，适合桌面和移动应用。</li>
</ul>
<p>作为一个Java工程师，选择哪个免费数据库呢？当然是MySQL。因为MySQL普及率最高，出了错，可以很容易找到解决方法。而且，围绕MySQL有一大堆监控和运维的工具，安装和使用很方便。</p>
<h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><p>为了能继续后面的学习，你需要从MySQL官方网站下载并安装<a target="_blank" rel="noopener" href="http://dev.mysql.com/downloads/mysql/">MySQL Community Server 5.6</a>，这个版本是免费的，其他高级版本是要收钱的（请放心，收钱的功能我们用不上）。MySQL是跨平台的，选择对应的平台下载安装文件，安装即可。</p>
<p>安装时，MySQL会提示输入<code>root</code>用户的口令，请务必记清楚。如果怕记不住，就把口令设置为<code>password</code>。</p>
<p>在Windows上，安装时请选择<code>UTF-8</code>编码，以便正确地处理中文。</p>
<p>在Mac或Linux上，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。MySQL的配置文件默认存放在<code>/etc/my.cnf</code>或者<code>/etc/mysql/my.cnf</code>：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">default-character-set</span> = utf8</span><br><span class="line"></span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">default-storage-engine</span> = INNODB</span><br><span class="line"><span class="attr">character-set-server</span> = utf8</span><br><span class="line"><span class="attr">collation-server</span> = utf8_general_ci</span><br></pre></td></tr></table></figure>

<p>重启MySQL后，可以通过MySQL的客户端命令行检查编码：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;%char%&#x27;;</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">|<span class="string"> Variable_name            </span>|<span class="string"> Value                                                  </span>|</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">|<span class="string"> character_set_client     </span>|<span class="string"> utf8                                                   </span>|</span><br><span class="line">|<span class="string"> character_set_connection </span>|<span class="string"> utf8                                                   </span>|</span><br><span class="line">|<span class="string"> character_set_database   </span>|<span class="string"> utf8                                                   </span>|</span><br><span class="line">|<span class="string"> character_set_filesystem </span>|<span class="string"> binary                                                 </span>|</span><br><span class="line">|<span class="string"> character_set_results    </span>|<span class="string"> utf8                                                   </span>|</span><br><span class="line">|<span class="string"> character_set_server     </span>|<span class="string"> utf8                                                   </span>|</span><br><span class="line">|<span class="string"> character_set_system     </span>|<span class="string"> utf8                                                   </span>|</span><br><span class="line">|<span class="string"> character_sets_dir       </span>|<span class="string"> /usr/local/mysql-5.1.65-osx10.6-x86_64/share/charsets/ </span>|</span><br><span class="line">+--------------------------+--------------------------------------------------------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>看到<code>utf8</code>字样就表示编码设置正确。</p>
<p><em>注</em>：如果MySQL的版本≥5.5.3，可以把编码设置为<code>utf8mb4</code>，<code>utf8mb4</code>和<code>utf8</code>完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。</p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>什么是JDBC？JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。</p>
<p>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。</p>
<p>例如，我们在Java代码中如果要访问MySQL，那么必须编写代码操作JDBC接口。注意到JDBC接口是Java标准库自带的，所以可以直接编译。而具体的JDBC驱动是由数据库厂商提供的，例如，MySQL的JDBC驱动由Oracle提供。因此，访问某个具体的数据库，我们只需要引入该厂商提供的JDBC驱动，就可以通过JDBC接口来访问，这样保证了Java程序编写的是一套数据库访问代码，却可以访问各种不同的数据库，因为他们都提供了标准的JDBC驱动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line"></span><br><span class="line">│  ┌───────────────┐  │</span><br><span class="line">   │   Java App    │</span><br><span class="line">│  └───────────────┘  │</span><br><span class="line">           │</span><br><span class="line">│          ▼          │</span><br><span class="line">   ┌───────────────┐</span><br><span class="line">│  │JDBC Interface │&lt;─┼─── JDK</span><br><span class="line">   └───────────────┘</span><br><span class="line">│          │          │</span><br><span class="line">           ▼</span><br><span class="line">│  ┌───────────────┐  │</span><br><span class="line">   │  JDBC Driver  │&lt;───── Vendor</span><br><span class="line">│  └───────────────┘  │</span><br><span class="line">           │</span><br><span class="line">└ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ┘</span><br><span class="line">           ▼</span><br><span class="line">   ┌───────────────┐</span><br><span class="line">   │   Database    │</span><br><span class="line">   └───────────────┘</span><br></pre></td></tr></table></figure>

<p>从代码来看，Java标准库自带的JDBC接口其实就是定义了一组接口，而某个具体的JDBC驱动其实就是实现了这些接口的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line"></span><br><span class="line">│  ┌───────────────┐  │</span><br><span class="line">   │   Java App    │</span><br><span class="line">│  └───────────────┘  │</span><br><span class="line">           │</span><br><span class="line">│          ▼          │</span><br><span class="line">   ┌───────────────┐</span><br><span class="line">│  │JDBC Interface │&lt;─┼─── JDK</span><br><span class="line">   └───────────────┘</span><br><span class="line">│          │          │</span><br><span class="line">           ▼</span><br><span class="line">│  ┌───────────────┐  │</span><br><span class="line">   │ MySQL Driver  │&lt;───── Oracle</span><br><span class="line">│  └───────────────┘  │</span><br><span class="line">           │</span><br><span class="line">└ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ┘</span><br><span class="line">           ▼</span><br><span class="line">   ┌───────────────┐</span><br><span class="line">   │     MySQL     │</span><br><span class="line">   └───────────────┘</span><br></pre></td></tr></table></figure>

<p>实际上，一个MySQL的JDBC的驱动就是一个jar包，它本身也是纯Java编写的。我们自己编写的代码只需要引用Java标准库提供的java.sql包下面的相关接口，由此再间接地通过MySQL驱动的jar包通过网络访问MySQL服务器，所有复杂的网络通讯都被封装到JDBC驱动中，因此，Java程序本身只需要引入一个MySQL驱动的jar包就可以正常访问MySQL服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐</span><br><span class="line">   ┌───────────────┐</span><br><span class="line">│  │   App.class   │  │</span><br><span class="line">   └───────────────┘</span><br><span class="line">│          │          │</span><br><span class="line">           ▼</span><br><span class="line">│  ┌───────────────┐  │</span><br><span class="line">   │  java.sql.*   │</span><br><span class="line">│  └───────────────┘  │</span><br><span class="line">           │</span><br><span class="line">│          ▼          │</span><br><span class="line">   ┌───────────────┐     TCP    ┌───────────────┐</span><br><span class="line">│  │ mysql-xxx.jar │──┼────────&gt;│     MySQL     │</span><br><span class="line">   └───────────────┘            └───────────────┘</span><br><span class="line">└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘</span><br><span class="line">          JVM</span><br></pre></td></tr></table></figure>

<h1 id="JDBC查询"><a href="#JDBC查询" class="headerlink" title="JDBC查询"></a>JDBC查询</h1><p>前面我们讲了Java程序要通过JDBC接口来查询数据库。JDBC是一套接口规范，它在哪呢？就在Java的标准库<code>java.sql</code>里放着，不过这里面大部分都是接口。接口并不能直接实例化，而是必须实例化对应的实现类，然后通过接口引用这个实例。那么问题来了：JDBC接口的实现类在哪？</p>
<p>因为JDBC接口并不知道我们要使用哪个数据库，所以，用哪个数据库，我们就去使用哪个数据库的“实现类”，我们把某个数据库实现了JDBC接口的jar包称为JDBC驱动。</p>
<p>因为我们选择了MySQL 5.x作为数据库，所以我们首先得找一个MySQL的JDBC驱动。所谓JDBC驱动，其实就是一个第三方jar包，我们直接添加一个Maven依赖就可以了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意到这里添加依赖的<code>scope</code>是<code>runtime</code>，因为编译Java程序并不需要MySQL的这个jar包，只有在运行期才需要使用。如果把<code>runtime</code>改成<code>compile</code>，虽然也能正常编译，但是在IDE里写程序的时候，会多出来一大堆类似<code>com.mysql.jdbc.Connection</code>这样的类，非常容易与Java标准库的JDBC接口混淆，所以坚决不要设置为<code>compile</code>。</p>
<p>有了驱动，我们还要确保MySQL在本机正常运行，并且还需要准备一点数据。这里我们用一个脚本创建数据库和表，然后插入一些数据：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库learjdbc:</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> learnjdbc;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> learnjdbc;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建登录用户learn/口令learnpassword</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> learn@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;learnpassword&#x27;</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> learnjdbc.* <span class="keyword">TO</span> learn@<span class="string">&#x27;%&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line">FLUSH <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表students:</span></span><br><span class="line">USE learnjdbc;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">  id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="type">name</span> <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  gender TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  grade <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  score <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY KEY</span>(id)</span><br><span class="line">) Engine=INNODB <span class="keyword">DEFAULT</span> CHARSET=UTF8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入初始数据:</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小明&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">88</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小红&#x27;</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">95</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小军&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">93</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小白&#x27;</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小牛&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">96</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小兵&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小强&#x27;</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">86</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小乔&#x27;</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">79</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小青&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">85</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小王&#x27;</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小林&#x27;</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">91</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (<span class="type">name</span>, gender, grade, score) <span class="keyword">VALUES</span> (<span class="string">&#x27;小贝&#x27;</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure>

<p>在控制台输入<code>mysql -u root -p</code>，输入<code>root</code>口令后以<code>root</code>身份，把上述SQL贴到控制台执行一遍就行。如果你运行的是最新版MySQL 8.x，需要调整一下<code>CREATE USER</code>语句。</p>
<h3 id="JDBC连接"><a href="#JDBC连接" class="headerlink" title="JDBC连接"></a>JDBC连接</h3><p>使用JDBC时，我们先了解什么是Connection。Connection代表一个JDBC连接，它相当于Java程序到数据库的连接（通常是TCP连接）。打开一个Connection时，需要准备URL、用户名和口令，才能成功连接到数据库。</p>
<p>URL是由数据库厂商指定的格式，例如，MySQL的URL是：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">jdbc</span>:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;db&gt;?key<span class="number">1</span>=value<span class="number">1</span>&amp;key<span class="number">2</span>=value<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>假设数据库运行在本机<code>localhost</code>，端口使用标准的<code>3306</code>，数据库名称是<code>learnjdbc</code>，那么URL如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">jdbc</span>:mysql://localhost:<span class="number">3306</span>/learnjdbc?useSSL=false&amp;characterEncoding=utf<span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>后面的两个参数表示不使用SSL加密，使用UTF-8作为字符编码（注意MySQL的UTF-8是<code>utf8</code>）。</p>
<p>要获取数据库连接，使用如下代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDBC连接的URL, 不同数据库有不同的格式:</span></span><br><span class="line"><span class="keyword">String</span> JDBC_URL = <span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;</span><br><span class="line"><span class="keyword">String</span> JDBC_USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">String</span> JDBC_PASSWORD = <span class="string">&quot;password&quot;</span>;</span><br><span class="line"><span class="comment">// 获取连接:</span></span><br><span class="line">Connection conn = DriverManager.<span class="built_in">getConnection</span>(JDBC_URL, JDBC_USER, JDBC_PASSWORD);</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 访问数据库...</span></span><br><span class="line"><span class="comment">// 关闭连接:</span></span><br><span class="line">conn.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>

<p>核心代码是<code>DriverManager</code>提供的静态方法<code>getConnection()</code>。<code>DriverManager</code>会自动扫描classpath，找到所有的JDBC驱动，然后根据我们传入的URL自动挑选一个合适的驱动。</p>
<p>因为JDBC连接是一种昂贵的资源，所以使用后要及时释放。使用<code>try (resource)</code>来自动释放JDBC连接是一个好方法：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;<span class="operator"></span></span><br><span class="line"><span class="operator">    ...</span></span><br><span class="line"><span class="operator"></span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JDBC查询-1"><a href="#JDBC查询-1" class="headerlink" title="JDBC查询"></a>JDBC查询</h3><p>获取到JDBC连接后，下一步我们就可以查询数据库了。查询数据库分以下几步：</p>
<p>第一步，通过<code>Connection</code>提供的<code>createStatement()</code>方法创建一个<code>Statement</code>对象，用于执行一个查询；</p>
<p>第二步，执行<code>Statement</code>对象提供的<code>executeQuery(&quot;SELECT * FROM students&quot;)</code>并传入SQL语句，执行查询并获得返回的结果集，使用<code>ResultSet</code>来引用这个结果集；</p>
<p>第三步，反复调用<code>ResultSet</code>的<code>next()</code>方法并读取每一行结果。</p>
<p>完整查询代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> (Statement stmt = conn.create<span class="constructor">Statement()</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = stmt.execute<span class="constructor">Query(<span class="string">&quot;SELECT id, grade, name, gender FROM students WHERE gender=1&quot;</span>)</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next<span class="literal">()</span>) &#123;</span><br><span class="line">                long id = rs.get<span class="constructor">Long(1)</span>; <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">                long grade = rs.get<span class="constructor">Long(2)</span>;</span><br><span class="line">                String name = rs.get<span class="constructor">String(3)</span>;</span><br><span class="line">                <span class="built_in">int</span> gender = rs.get<span class="constructor">Int(4)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意要点：</p>
<p><code>Statment</code>和<code>ResultSet</code>都是需要关闭的资源，因此嵌套使用<code>try (resource)</code>确保及时关闭；</p>
<p><code>rs.next()</code>用于判断是否有下一行记录，如果有，将自动把当前行移动到下一行（一开始获得<code>ResultSet</code>时当前行不是第一行）；</p>
<p><code>ResultSet</code>获取列时，索引从<code>1</code>开始而不是<code>0</code>；</p>
<p>必须根据<code>SELECT</code>的列的对应位置来调用<code>getLong(1)</code>，<code>getString(2)</code>这些方法，否则对应位置的数据类型不对，将报错。</p>
<h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>使用<code>Statement</code>拼字符串非常容易引发SQL注入的问题，这是因为SQL参数往往是从方法参数传入的。</p>
<p>我们来看一个例子：假设用户登录的验证方法如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> <span class="title">login</span>(<span class="keyword">String</span> name, <span class="keyword">String</span> pass) &#123;</span><br><span class="line">    ...</span><br><span class="line">    stmt.executeQuery(<span class="string">&quot;SELECT * FROM user WHERE login=&#x27;&quot;</span> + name + <span class="string">&quot;&#x27; AND pass=&#x27;&quot;</span> + pass + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，参数<code>name</code>和<code>pass</code>通常都是Web页面输入后由程序接收到的。</p>
<p>如果用户的输入是程序期待的值，就可以拼出正确的SQL。例如：name &#x3D; <code>&quot;bob&quot;</code>，pass &#x3D; <code>&quot;1234&quot;</code>：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">login</span>=<span class="string">&#x27;bob&#x27;</span> <span class="keyword">AND</span> pass=<span class="string">&#x27;1234&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是，如果用户的输入是一个精心构造的字符串，就可以拼出意想不到的SQL，这个SQL也是正确的，但它查询的条件不是程序设计的意图。例如：name &#x3D; <code>&quot;bob&#39; OR pass=&quot;</code>, pass &#x3D; <code>&quot; OR pass=&#39;&quot;</code>：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> <span class="keyword">login</span>=<span class="string">&#x27;bob&#x27;</span> <span class="keyword">OR</span> pass=<span class="string">&#x27; AND pass=&#x27;</span> <span class="keyword">OR</span> pass=<span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这个SQL语句执行的时候，根本不用判断口令是否正确，这样一来，登录就形同虚设。</p>
<p>要避免SQL注入攻击，一个办法是针对所有字符串参数进行转义，但是转义很麻烦，而且需要在任何使用SQL的地方增加转义代码。</p>
<p>还有一个办法就是使用<code>PreparedStatement</code>。使用<code>PreparedStatement</code>可以<em>完全避免SQL注入</em>的问题，因为<code>PreparedStatement</code>始终使用<code>?</code>作为占位符，并且把数据连同SQL本身传给数据库，这样可以保证每次传给数据库的SQL语句是相同的，只是占位符的数据不同，还能高效利用数据库本身对查询的缓存。上述登录SQL如果用<code>PreparedStatement</code>可以改写如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> <span class="title">login</span>(<span class="keyword">String</span> name, <span class="keyword">String</span> pass) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">String</span> sql = <span class="string">&quot;SELECT * FROM user WHERE login=? AND pass=?&quot;</span>;</span><br><span class="line">    PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">    ps.setObject(<span class="number">1</span>, name);</span><br><span class="line">    ps.setObject(<span class="number">2</span>, pass);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，<code>PreparedStatement</code>比<code>Statement</code>更安全，而且更快。</p>
<p> 使用Java对数据库进行操作时，必须使用PreparedStatement，严禁任何通过参数拼字符串的代码！</p>
<p>我们把上面使用<code>Statement</code>的代码改为使用<code>PreparedStatement</code>：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepare<span class="constructor">Statement(<span class="string">&quot;SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?&quot;</span>)</span>) &#123;</span><br><span class="line">        ps.set<span class="constructor">Object(1, <span class="string">&quot;M&quot;</span>)</span>; <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">        ps.set<span class="constructor">Object(2, 3)</span>;</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = ps.execute<span class="constructor">Query()</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next<span class="literal">()</span>) &#123;</span><br><span class="line">                long id = rs.get<span class="constructor">Long(<span class="string">&quot;id&quot;</span>)</span>;</span><br><span class="line">                long grade = rs.get<span class="constructor">Long(<span class="string">&quot;grade&quot;</span>)</span>;</span><br><span class="line">                String name = rs.get<span class="constructor">String(<span class="string">&quot;name&quot;</span>)</span>;</span><br><span class="line">                String gender = rs.get<span class="constructor">String(<span class="string">&quot;gender&quot;</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>PreparedStatement</code>和<code>Statement</code>稍有不同，必须首先调用<code>setObject()</code>设置每个占位符<code>?</code>的值，最后获取的仍然是<code>ResultSet</code>对象。</p>
<p>另外注意到从结果集读取列时，使用<code>String</code>类型的列名比索引要易读，而且不易出错。</p>
<p>注意到JDBC查询的返回值总是<code>ResultSet</code>，即使我们写这样的聚合查询<code>SELECT SUM(score) FROM ...</code>，也需要按结果集读取：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = ...</span><br><span class="line"><span class="keyword">if</span> (rs.<span class="keyword">next</span>()) &#123;</span><br><span class="line">    <span class="built_in">double</span> <span class="keyword">sum</span> = rs.getDouble(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>有的童鞋可能注意到了，使用JDBC的时候，我们需要在Java数据类型和SQL数据类型之间进行转换。JDBC在<code>java.sql.Types</code>定义了一组常量来表示如何映射SQL数据类型，但是平时我们使用的类型通常也就以下几种：</p>
<table>
<thead>
<tr>
<th align="left">SQL数据类型</th>
<th align="left">Java数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">BIT, BOOL</td>
<td align="left">boolean</td>
</tr>
<tr>
<td align="left">INTEGER</td>
<td align="left">int</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">long</td>
</tr>
<tr>
<td align="left">REAL</td>
<td align="left">float</td>
</tr>
<tr>
<td align="left">FLOAT, DOUBLE</td>
<td align="left">double</td>
</tr>
<tr>
<td align="left">CHAR, VARCHAR</td>
<td align="left">String</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">BigDecimal</td>
</tr>
<tr>
<td align="left">DATE</td>
<td align="left">java.sql.Date, LocalDate</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">java.sql.Time, LocalTime</td>
</tr>
</tbody></table>
<p>注意：只有最新的JDBC驱动才支持<code>LocalDate</code>和<code>LocalTime</code>。</p>
<h1 id="JDBC更新"><a href="#JDBC更新" class="headerlink" title="JDBC更新"></a>JDBC更新</h1><p>数据库操作总结起来就四个字：增删改查，行话叫CRUD：Create，Retrieve，Update和Delete。</p>
<p>查就是查询，我们已经讲过了，就是使用<code>PreparedStatement</code>进行各种<code>SELECT</code>，然后处理结果集。现在我们来看看如何使用JDBC进行增删改。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入操作是<code>INSERT</code>，即插入一条新记录。通过JDBC进行插入，本质上也是用<code>PreparedStatement</code>执行一条SQL语句，不过最后执行的不是<code>executeQuery()</code>，而是<code>executeUpdate()</code>。示例代码如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    try (PreparedStatement ps = conn.prepareStatement(</span><br><span class="line">            <span class="string">&quot;INSERT INTO students (id, grade, name, gender) VALUES (?,?,?,?)&quot;</span>)) &#123;</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="number">999</span>); <span class="regexp">//</span> 注意：索引从<span class="number">1</span>开始</span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="number">1</span>); <span class="regexp">//</span> grade</span><br><span class="line">        ps.setObject(<span class="number">3</span>, <span class="string">&quot;Bob&quot;</span>); <span class="regexp">//</span> name</span><br><span class="line">        ps.setObject(<span class="number">4</span>, <span class="string">&quot;M&quot;</span>); <span class="regexp">//</span> gender</span><br><span class="line">        int n = ps.executeUpdate(); <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置参数与查询是一样的，有几个<code>?</code>占位符就必须设置对应的参数。虽然<code>Statement</code>也可以执行插入操作，但我们仍然要严格遵循<em>绝不能手动拼SQL字符串</em>的原则，以避免安全漏洞。</p>
<p>当成功执行<code>executeUpdate()</code>后，返回值是<code>int</code>，表示插入的记录数量。此处总是<code>1</code>，因为只插入了一条记录。</p>
<h3 id="插入并获取主键"><a href="#插入并获取主键" class="headerlink" title="插入并获取主键"></a>插入并获取主键</h3><p>如果数据库的表设置了自增主键，那么在执行<code>INSERT</code>语句时，并不需要指定主键，数据库会自动分配主键。对于使用自增主键的程序，有个额外的步骤，就是如何获取插入后的自增主键的值。</p>
<p>要获取自增主键，不能先插入，再查询。因为两条SQL执行期间可能有别的程序也插入了同一个表。获取自增主键的正确写法是在创建<code>PreparedStatement</code>的时候，指定一个<code>RETURN_GENERATED_KEYS</code>标志位，表示JDBC驱动必须返回插入的自增主键。示例代码如下：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) &#123;</span><br><span class="line">    try (PreparedStatement ps = conn.prepareStatement(</span><br><span class="line">            <span class="string">&quot;INSERT INTO students (grade, name, gender) VALUES (?,?,?)&quot;</span>,</span><br><span class="line">            Statement.RETURN_GENERATED_KEYS)) &#123;</span><br><span class="line">        ps.setObject(<span class="number">1</span>, <span class="number">1</span>); <span class="regexp">//</span> grade</span><br><span class="line">        ps.setObject(<span class="number">2</span>, <span class="string">&quot;Bob&quot;</span>); <span class="regexp">//</span> name</span><br><span class="line">        ps.setObject(<span class="number">3</span>, <span class="string">&quot;M&quot;</span>); <span class="regexp">//</span> gender</span><br><span class="line">        int n = ps.executeUpdate(); <span class="regexp">//</span> <span class="number">1</span></span><br><span class="line">        try (ResultSet rs = ps.getGeneratedKeys()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rs.<span class="keyword">next</span>()) &#123;</span><br><span class="line">                long id = rs.getLong(<span class="number">1</span>); <span class="regexp">//</span> 注意：索引从<span class="number">1</span>开始</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上述代码，有两点注意事项：</p>
<p>一是调用<code>prepareStatement()</code>时，第二个参数必须传入常量<code>Statement.RETURN_GENERATED_KEYS</code>，否则JDBC驱动不会返回自增主键；</p>
<p>二是执行<code>executeUpdate()</code>方法后，必须调用<code>getGeneratedKeys()</code>获取一个<code>ResultSet</code>对象，这个对象包含了数据库自动生成的主键的值，读取该对象的每一行来获取自增主键的值。如果一次插入多条记录，那么这个<code>ResultSet</code>对象就会有多行返回值。如果插入时有多列自增，那么<code>ResultSet</code>对象的每一行都会对应多个自增值（自增列不一定必须是主键）。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>更新操作是<code>UPDATE</code>语句，它可以一次更新若干列的记录。更新操作和插入操作在JDBC代码的层面上实际上没有区别，除了SQL语句不同：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepare<span class="constructor">Statement(<span class="string">&quot;UPDATE students SET name=? WHERE id=?&quot;</span>)</span>) &#123;</span><br><span class="line">        ps.set<span class="constructor">Object(1, <span class="string">&quot;Bob&quot;</span>)</span>; <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">        ps.set<span class="constructor">Object(2, 999)</span>;</span><br><span class="line">        <span class="built_in">int</span> n = ps.execute<span class="constructor">Update()</span>; <span class="comment">// 返回更新的行数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>executeUpdate()</code>返回数据库实际更新的行数。返回结果可能是正数，也可能是0（表示没有任何记录更新）。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除操作是<code>DELETE</code>语句，它可以一次删除若干列。和更新一样，除了SQL语句不同外，JDBC代码都是相同的：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = <span class="module-access"><span class="module"><span class="identifier">DriverManager</span>.</span></span>get<span class="constructor">Connection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement ps = conn.prepare<span class="constructor">Statement(<span class="string">&quot;DELETE FROM students WHERE id=?&quot;</span>)</span>) &#123;</span><br><span class="line">        ps.set<span class="constructor">Object(1, 999)</span>; <span class="comment">// 注意：索引从1开始</span></span><br><span class="line">        <span class="built_in">int</span> n = ps.execute<span class="constructor">Update()</span>; <span class="comment">// 删除的行数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h1><p>数据库事务（Transaction）是由若干个SQL语句构成的一个操作序列，有点类似于Java的<code>synchronized</code>同步。数据库系统保证在一个事务中的所有SQL要么全部执行成功，要么全部不执行，即数据库事务具有ACID特性：</p>
<ul>
<li>Atomicity：原子性</li>
<li>Consistency：一致性</li>
<li>Isolation：隔离性</li>
<li>Durability：持久性</li>
</ul>
<p>数据库事务可以并发执行，而数据库系统从效率考虑，对事务定义了不同的隔离级别。SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>
<table>
<thead>
<tr>
<th align="left">Isolation Level</th>
<th align="left">脏读（Dirty Read）</th>
<th align="left">不可重复读（Non Repeatable Read）</th>
<th align="left">幻读（Phantom Read）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Read Uncommitted</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Read Committed</td>
<td align="left">-</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Repeatable Read</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Serializable</td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody></table>
<p>对应用程序来说，数据库事务非常重要，很多运行着关键任务的应用程序，都必须依赖数据库事务保证程序的结果正常。</p>
<p>举个例子：假设小明准备给小红支付100，两人在数据库中的记录主键分别是<code>123</code>和<code>456</code>，那么用两条SQL语句操作如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE accounts <span class="builtin-name">SET</span> balance = balance - 100 WHERE <span class="attribute">id</span>=123 <span class="keyword">AND</span> balance &gt;= 100;</span><br><span class="line">UPDATE accounts <span class="builtin-name">SET</span> balance = balance + 100 WHERE <span class="attribute">id</span>=456;</span><br></pre></td></tr></table></figure>

<p>这两条语句必须以事务方式执行才能保证业务的正确性，因为一旦第一条SQL执行成功而第二条SQL失败的话，系统的钱就会凭空减少100，而有了事务，要么这笔转账成功，要么转账失败，双方账户的钱都不变。</p>
<p>这里我们不讨论详细的SQL事务，如果对SQL事务不熟悉，请参考<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611198786848">SQL事务</a>。</p>
<p>要在JDBC中执行事务，本质上就是如何把多条SQL包裹在一个数据库事务中执行。我们来看JDBC的事务代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = <span class="keyword">open</span><span class="constructor">Connection()</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭自动提交:</span></span><br><span class="line">    conn.set<span class="constructor">AutoCommit(<span class="params">false</span>)</span>;</span><br><span class="line">    <span class="comment">// 执行多条SQL语句:</span></span><br><span class="line">    insert<span class="literal">()</span>; update<span class="literal">()</span>; delete<span class="literal">()</span>;</span><br><span class="line">    <span class="comment">// 提交事务:</span></span><br><span class="line">    conn.commit<span class="literal">()</span>;</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 回滚事务:</span></span><br><span class="line">    conn.rollback<span class="literal">()</span>;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    conn.set<span class="constructor">AutoCommit(<span class="params">true</span>)</span>;</span><br><span class="line">    conn.close<span class="literal">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，开启事务的关键代码是<code>conn.setAutoCommit(false)</code>，表示关闭自动提交。提交事务的代码在执行完指定的若干条SQL语句后，调用<code>conn.commit()</code>。要注意事务不是总能成功，如果事务提交失败，会抛出SQL异常（也可能在执行SQL语句的时候就抛出了），此时我们必须捕获并调用<code>conn.rollback()</code>回滚事务。最后，在<code>finally</code>中通过<code>conn.setAutoCommit(true)</code>把<code>Connection</code>对象的状态恢复到初始值。</p>
<p>实际上，默认情况下，我们获取到<code>Connection</code>连接后，总是处于“自动提交”模式，也就是每执行一条SQL都是作为事务自动执行的，这也是为什么前面几节我们的更新操作总能成功的原因：因为默认有这种“隐式事务”。只要关闭了<code>Connection</code>的<code>autoCommit</code>，那么就可以在一个事务中执行多条语句，事务以<code>commit()</code>方法结束。</p>
<p>如果要设定事务的隔离级别，可以使用如下代码：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 设定隔离级别为READ COMMITTED:</span><br><span class="line">conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br></pre></td></tr></table></figure>

<p>如果没有调用上述方法，那么会使用数据库的默认隔离级别。MySQL的默认隔离级别是<code>REPEATABLE READ</code>。</p>
<h1 id="JDBC-Batch"><a href="#JDBC-Batch" class="headerlink" title="JDBC Batch"></a>JDBC Batch</h1><p>使用JDBC操作数据库的时候，经常会执行一些批量操作。</p>
<p>例如，一次性给会员增加可用优惠券若干，我们可以执行以下SQL代码：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> coupons (user_id, <span class="built_in">type</span>, expires) <span class="keyword">VALUES</span> (<span class="number">123</span>, <span class="string">&#x27;DISCOUNT&#x27;</span>, <span class="string">&#x27;2030-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> coupons (user_id, <span class="built_in">type</span>, expires) <span class="keyword">VALUES</span> (<span class="number">234</span>, <span class="string">&#x27;DISCOUNT&#x27;</span>, <span class="string">&#x27;2030-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> coupons (user_id, <span class="built_in">type</span>, expires) <span class="keyword">VALUES</span> (<span class="number">345</span>, <span class="string">&#x27;DISCOUNT&#x27;</span>, <span class="string">&#x27;2030-12-31&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> coupons (user_id, <span class="built_in">type</span>, expires) <span class="keyword">VALUES</span> (<span class="number">456</span>, <span class="string">&#x27;DISCOUNT&#x27;</span>, <span class="string">&#x27;2030-12-31&#x27;</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>实际上执行JDBC时，因为只有占位符参数不同，所以SQL实际上是一样的：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var params : paramsList) &#123;</span><br><span class="line">    PreparedStatement ps = conn.prepared<span class="constructor">Statement(<span class="string">&quot;INSERT INTO coupons (user_id, type, expires) VALUES (?,?,?)&quot;</span>)</span>;</span><br><span class="line">    ps.set<span class="constructor">Long(<span class="params">params</span>.<span class="params">get</span>(0)</span>);</span><br><span class="line">    ps.set<span class="constructor">String(<span class="params">params</span>.<span class="params">get</span>(1)</span>);</span><br><span class="line">    ps.set<span class="constructor">String(<span class="params">params</span>.<span class="params">get</span>(2)</span>);</span><br><span class="line">    ps.execute<span class="constructor">Update()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似的还有，给每个员工薪水增加10%～30%：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary = salary * ? <span class="keyword">WHERE</span> id = ?</span><br></pre></td></tr></table></figure>

<p>通过一个循环来执行每个<code>PreparedStatement</code>虽然可行，但是性能很低。SQL数据库对SQL语句相同，但只有参数不同的若干语句可以作为batch执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个SQL。</p>
<p>在JDBC代码中，我们可以利用SQL数据库的这一特性，把同一个SQL但参数不同的若干次操作合并为一个batch执行。我们以批量插入为例，示例代码如下：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (PreparedStatement ps = conn.prepare<span class="constructor">Statement(<span class="string">&quot;INSERT INTO students (name, gender, grade, score) VALUES (?, ?, ?, ?)&quot;</span>)</span>) &#123;</span><br><span class="line">    <span class="comment">// 对同一个PreparedStatement反复设置参数并调用addBatch():</span></span><br><span class="line">    <span class="keyword">for</span> (Student s : students) &#123;</span><br><span class="line">        ps.set<span class="constructor">String(1, <span class="params">s</span>.<span class="params">name</span>)</span>;</span><br><span class="line">        ps.set<span class="constructor">Boolean(2, <span class="params">s</span>.<span class="params">gender</span>)</span>;</span><br><span class="line">        ps.set<span class="constructor">Int(3, <span class="params">s</span>.<span class="params">grade</span>)</span>;</span><br><span class="line">        ps.set<span class="constructor">Int(4, <span class="params">s</span>.<span class="params">score</span>)</span>;</span><br><span class="line">        ps.add<span class="constructor">Batch()</span>; <span class="comment">// 添加到batch</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行batch:</span></span><br><span class="line">    <span class="built_in">int</span><span class="literal">[]</span> ns = ps.execute<span class="constructor">Batch()</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> n : ns) &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.println(n + <span class="string">&quot; inserted.&quot;</span>); <span class="comment">// batch中每个SQL执行的结果数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行batch和执行一个SQL不同点在于，需要对同一个<code>PreparedStatement</code>反复设置参数并调用<code>addBatch()</code>，这样就相当于给一个SQL加上了多组参数，相当于变成了“多行”SQL。</p>
<p>第二个不同点是调用的不是<code>executeUpdate()</code>，而是<code>executeBatch()</code>，因为我们设置了多组参数，相应地，返回结果也是多个<code>int</code>值，因此返回类型是<code>int[]</code>，循环<code>int[]</code>数组即可获取每组参数执行后影响的结果数量。</p>
<h1 id="JDBC连接池"><a href="#JDBC连接池" class="headerlink" title="JDBC连接池"></a>JDBC连接池</h1><p>我们在讲多线程的时候说过，创建线程是一个昂贵的操作，如果有大量的小任务需要执行，并且频繁地创建和销毁线程，实际上会消耗大量的系统资源，往往创建和消耗线程所耗费的时间比执行任务的时间还长，所以，为了提高效率，可以用线程池。</p>
<p>类似的，在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。</p>
<p>JDBC连接池有一个标准的接口<code>javax.sql.DataSource</code>，注意这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，我们必须选择一个JDBC连接池的实现。常用的JDBC连接池有：</p>
<ul>
<li>HikariCP</li>
<li>C3P0</li>
<li>BoneCP</li>
<li>Druid</li>
</ul>
<p>目前使用最广泛的是HikariCP。我们以HikariCP为例，要使用JDBC连接池，先添加HikariCP的依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>紧接着，我们需要创建一个<code>DataSource</code>实例，这个实例就是连接池：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HikariConfig config = <span class="keyword">new</span> <span class="constructor">HikariConfig()</span>;</span><br><span class="line">config.set<span class="constructor">JdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>)</span>;</span><br><span class="line">config.set<span class="constructor">Username(<span class="string">&quot;root&quot;</span>)</span>;</span><br><span class="line">config.set<span class="constructor">Password(<span class="string">&quot;password&quot;</span>)</span>;</span><br><span class="line">config.add<span class="constructor">DataSourceProperty(<span class="string">&quot;connectionTimeout&quot;</span>, <span class="string">&quot;1000&quot;</span>)</span>; <span class="comment">// 连接超时：1秒</span></span><br><span class="line">config.add<span class="constructor">DataSourceProperty(<span class="string">&quot;idleTimeout&quot;</span>, <span class="string">&quot;60000&quot;</span>)</span>; <span class="comment">// 空闲超时：60秒</span></span><br><span class="line">config.add<span class="constructor">DataSourceProperty(<span class="string">&quot;maximumPoolSize&quot;</span>, <span class="string">&quot;10&quot;</span>)</span>; <span class="comment">// 最大连接数：10</span></span><br><span class="line">DataSource ds = <span class="keyword">new</span> <span class="constructor">HikariDataSource(<span class="params">config</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>注意创建<code>DataSource</code>也是一个非常昂贵的操作，所以通常<code>DataSource</code>实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期。</p>
<p>有了连接池以后，我们如何使用它呢？和前面的代码类似，只是获取<code>Connection</code>时，把<code>DriverManage.getConnection()</code>改为<code>ds.getConnection()</code>：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> <span class="params">(Connection <span class="attr">conn</span> = ds.getConnection()</span>) &#123; <span class="string">//</span> 在此获取连接</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">&#125; <span class="string">//</span> 在此“关闭”连接</span><br></pre></td></tr></table></figure>

<p>通过连接池获取连接时，并不需要指定JDBC的相关URL、用户名、口令等信息，因为这些信息已经存储在连接池内部了（创建<code>HikariDataSource</code>时传入的<code>HikariConfig</code>持有这些信息）。一开始，连接池内部并没有连接，所以，第一次调用<code>ds.getConnection()</code>，会迫使连接池内部先创建一个<code>Connection</code>，再返回给客户端使用。当我们调用<code>conn.close()</code>方法时（<code>在try(resource)&#123;...&#125;</code>结束处），不是真正“关闭”连接，而是释放到连接池中，以便下次获取连接时能直接返回。</p>
<p>因此，连接池内部维护了若干个<code>Connection</code>实例，如果调用<code>ds.getConnection()</code>，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对<code>Connection</code>调用<code>close()</code>，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，我们就通过连接池维护了少量连接，但可以频繁地执行大量的SQL语句。</p>
<p>通常连接池提供了大量的参数可以配置，例如，维护的最小、最大活动连接数，指定一个连接在空闲一段时间后自动关闭等，需要根据应用程序的负载合理地配置这些参数。此外，大多数连接池都提供了详细的实时状态以便进行监控。</p>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_3.Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="prev" title="3.Netty网络编程">
                  <i class="fa fa-chevron-left"></i> 3.Netty网络编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/04/Java_5.JavaEE%E8%BF%9B%E9%98%B6_5.%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="next" title="5.函数式编程">
                  5.函数式编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
