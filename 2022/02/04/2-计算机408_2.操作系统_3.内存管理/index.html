<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"2673747024.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="内存管理概念内存管理的基本原理和要求 什么是内存，有何作用  概念：可存放数据，程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾  在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方？  给内存的存储单元编地址（内存地址从0开始，每个地址对应一个存储单元）   存储单元、内存地址的概念和">
<meta property="og:type" content="article">
<meta property="og:title" content="内存管理">
<meta property="og:url" content="https://2673747024.github.io/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="mananaの博客">
<meta property="og:description" content="内存管理概念内存管理的基本原理和要求 什么是内存，有何作用  概念：可存放数据，程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾  在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方？  给内存的存储单元编地址（内存地址从0开始，每个地址对应一个存储单元）   存储单元、内存地址的概念和">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/d86a40e0-e91f-45aa-81bb-52ea5017ccdf-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/53b08ac3-1665-4036-8899-8091f57f5d36-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/9136a4b8-c517-41b4-87b8-9c6ea81a287b-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/c05183c3-da02-4fd1-9206-af9442ae9774-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/38531f73-f4c2-41fe-bb6b-eeb4f2344018-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/7542c512-c73d-48ac-b6ab-1f8bf0fa8b30-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/38677fac-d419-456d-acf9-a28636ae3423-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/9e10c503-67bf-4c88-adea-db5e476bb15b-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/e3c5de56-9ced-48bf-b50b-f2fa221dcc70-3224585.jpg">
<meta property="og:image" content="https://api2.mubu.com/v3/document_image/3611414e-4452-4a26-8dbe-c54a19daea90-3224585.jpg">
<meta property="article:published_time" content="2022-02-04T11:26:23.704Z">
<meta property="article:modified_time" content="2022-02-04T16:10:27.273Z">
<meta property="article:author" content="QQ2673747024">
<meta property="article:tag" content="写作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api2.mubu.com/v3/document_image/d86a40e0-e91f-45aa-81bb-52ea5017ccdf-3224585.jpg">


<link rel="canonical" href="https://2673747024.github.io/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://2673747024.github.io/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","path":"2022/02/04/2-计算机408_2.操作系统_3.内存管理/","title":"内存管理"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>内存管理 | mananaの博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">mananaの博客</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习中的点点滴滴</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">内存管理概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%92%8C%E8%A6%81%E6%B1%82"><span class="nav-number">1.1.</span> <span class="nav-text">内存管理的基本原理和要求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">1.2.</span> <span class="nav-text">内存管理的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="nav-number">1.3.</span> <span class="nav-text">覆盖与交换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">连续分配管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.</span> <span class="nav-text">动态分配算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.6.</span> <span class="nav-text">非连续分配管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.7.</span> <span class="nav-text">基本分段存储管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.</span> <span class="nav-text">段页式管理方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">虚拟内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">虚拟内存的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">请求分页管理方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">页面置换算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">2.4.</span> <span class="nav-text">页面分配策略</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">QQ2673747024</p>
  <div class="site-description" itemprop="description">短暂的休息不是退缩，而是为了更好地战斗</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">112</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://2673747024.github.io/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_3.%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="QQ2673747024">
      <meta itemprop="description" content="短暂的休息不是退缩，而是为了更好地战斗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mananaの博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          内存管理
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-04 19:26:23" itemprop="dateCreated datePublished" datetime="2022-02-04T19:26:23+08:00">2022-02-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-02-05 00:10:27" itemprop="dateModified" datetime="2022-02-05T00:10:27+08:00">2022-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/" itemprop="url" rel="index"><span itemprop="name">计算机408</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">2.操作系统</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA408/2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">3.内存管理</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>


          <span title="post.wordcount">
            字数统计：17.3k 字
          </span>
          <span title="post.min2read">
            &nbsp;|&nbsp;&nbsp;阅读时间≈59 分钟
          </span>

        </div>

      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h1><h2 id="内存管理的基本原理和要求"><a href="#内存管理的基本原理和要求" class="headerlink" title="内存管理的基本原理和要求"></a>内存管理的基本原理和要求</h2><ul>
<li><p>什么是内存，有何作用</p>
<ul>
<li><p>概念：可存放数据，程序执行前需要先放到内存中才能被CPU处理——缓和CPU与硬盘之间的速度矛盾</p>
</li>
<li><p>在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方？</p>
<ul>
<li>给内存的存储单元编地址（内存地址从0开始，每个地址对应一个存储单元）</li>
</ul>
</li>
<li><p>存储单元、内存地址的概念和联系</p>
<ul>
<li><p>计算内存地址长度：即需要多少个二进制位才能表示相应数目的存储单元</p>
<ul>
<li>内存中可以存放 4*2^30个字节</li>
<li>如果是按字节编址的话，需要 2^32个地址才能一一标识，所以地址需要用 32 个二进制位来表示（0~ 2^32 -1）</li>
</ul>
</li>
</ul>
</li>
<li><p>按字节编址  vs  按字编址</p>
<ul>
<li><p>如果计算机“按字节编址”，则每个存储单元大小为 1字节，即 1B，即 8个二进制位</p>
</li>
<li><p>如果字长为16位的计算机“按字编址”，则每个存储单元大小为 1个字；每个字的大小为 16 个二进制位</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>进程运行的基本原理</p>
<ul>
<li><p>指令的基本原理</p>
<ul>
<li><p>指令：操作码+若干参数（可能包含地址参数）</p>
</li>
<li><p>源代码通过编译，转化为指令</p>
<ul>
<li>指令的工作基于“地址”。每个地址对应一个数据的存储单元</li>
</ul>
</li>
<li><p>CPU通过访问内存中的程序段，执行CPU能识别的指令</p>
</li>
<li><p>这些指令告诉CPU去内存的数据段（哪个地址）读&#x2F;写数据，并且该数据做什么样的处理</p>
<ul>
<li><p>将内存中的数据段读入CPU寄存器，或将CPU寄存器中的数据写入内存的数据段</p>
</li>
<li><p>有的系统中，寄存器和内存可能统一编址</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑地址空间(相对地址)   vs  物理地址空间(绝对地址)</p>
<ul>
<li><p>如果进程不是从地址#0 开始存放的，指令中的地址参数如何转换为实际存放地址（物理地址）</p>
</li>
<li><p>逻辑地址空间：</p>
<ul>
<li><p>即相对地址（相对于进程的起始地址而言的地址），链接程序依次按照各个概块的相对地址构成统一的从0号单元开始编址的逻辑地址空间</p>
</li>
<li><p>程序经过编译、链接后生成的指令中指明的是逻辑地址（相对地址）</p>
</li>
<li><p>C语言程序经过编译、链接处理后，生成装入模块，即可执行文件（可执行文件中指令指明的是逻辑地址(相对地址)）</p>
</li>
</ul>
</li>
<li><p>物理地址空间</p>
<ul>
<li><p>内存中物理单元的集合，是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取</p>
</li>
<li><p>将装入模块（可执行文件）装入内存后，需要将指令中的逻辑地址转换为物理地址（绝对地址）</p>
<ul>
<li>逻辑地址转换为物理地址的三种方式，即三种装入方式</li>
</ul>
</li>
<li><p>地址重定位：逻辑地址转换成物理地址的过程</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>从写程序到程序运行</p>
<ul>
<li><p>编辑源代码文件</p>
</li>
<li><p>编译：解译程序将用户源代码编译成若干目标模块，把高级语言翻译为机器语言</p>
</li>
<li><p>链接：由链接程序将编译后的形成的一组目标模块及所需要的库函数链接在一起，形成一个完整的装入模块</p>
</li>
<li><p>装入：由装入程序将装入模块装入到内存运行</p>
</li>
</ul>
</li>
<li><p>三种链接方式</p>
<ul>
<li><p>静态链接：程序运行之前，将库函数连接成一个完整的可执行程序（装入模块），之后不再拆开<img src="https://api2.mubu.com/v3/document_image/d86a40e0-e91f-45aa-81bb-52ea5017ccdf-3224585.jpg" alt="img"></p>
</li>
<li><p>装入时动态链接：将用户源程序编译后得到目标模块，装入内存时，采用边装入边链接的方式（将所有目标模块进行链接）<img src="https://api2.mubu.com/v3/document_image/53b08ac3-1665-4036-8899-8091f57f5d36-3224585.jpg" alt="img"></p>
</li>
<li><p>运行时动态链接：对于某些目标模块的链接，程序需要时才会对其链接（只链接部分模块，用不到的模块不需要装入内存）</p>
<ul>
<li>优点：便于修改和更新，便于实现对目标模块的共享</li>
</ul>
</li>
</ul>
</li>
<li><p>三种转入方式</p>
<ul>
<li><p>绝对装入</p>
<ul>
<li><p>前提：编译时，如果知道程序将放到内存中的哪个位置，编译程序将直接产生绝对地址的目标代码</p>
</li>
<li><p>概念：装入时按照装入模块中的地址（实际的内存地址），将程序和数据装入内存</p>
</li>
<li><p>即，编译、链接后得到的装入模块的指令直接就使用了绝对地址</p>
</li>
<li><p>程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时转换为绝对地址</p>
</li>
<li><p>优点：不要要对程序和数据的地址进行修改</p>
</li>
<li><p>缺点：只适用于单道程序环境</p>
</li>
</ul>
</li>
<li><p>可重定位装入（静态重定位）</p>
<ul>
<li><p>装入模块中采用相对地址，装入时对地址进行“重定位”，将逻辑地址变为物理地址（地址变换是在装入时一次完成的），然后将程序和数据装入内存</p>
</li>
<li><p>装入时对目标程序中指令和数据的更改过程称为重定位，地址变换通常是在装入时一次完成的，又按称为静态重定位</p>
</li>
<li><p>即编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址</p>
</li>
<li><p>如果装入的起始物理地址为x，则所有地址相关的参数都 + x</p>
</li>
<li><p>特点：作业装入必须要一次性全部装入，并自运行中作业不能在内存中移动，也不能再申请内存空间</p>
</li>
<li><p>适用于早期的多道批处理操作系统</p>
</li>
</ul>
</li>
<li><p>动态运行时装入（动态重定位）</p>
<ul>
<li><p>装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，当程序真正执行时才进行转换，因此装入内存后所有的地址依然是逻辑地址</p>
</li>
<li><p>装入时依然保持使用逻辑地址，需要一个重定位寄存器的支持</p>
<ul>
<li>重定位寄存器：存放装入模块存放的起始位置</li>
</ul>
</li>
<li><p>物理地址 &#x3D; 逻辑地址 + 重定位寄存器中的数据</p>
</li>
<li><p>特点：允许程序在内存中发生移动</p>
<ul>
<li><p>可将程序分配到不连续的存储区中</p>
</li>
<li><p>在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</p>
</li>
<li><p>便于程序段的共享</p>
</li>
<li><p>可以向用户提供一个比存储空间大得多的地址空间（地址空间大于存储空间）</p>
</li>
</ul>
</li>
<li><p>适用于现代操作系统</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h2><ul>
<li><p>内存空间的分配与回收：操作系统完成主存储器空间的分配和管理</p>
<ul>
<li><p>分配：内存中很多地方都可以存放进程，如何为进程分配内存空间，如何标记内存空间是否已分配</p>
</li>
<li><p>回收：当进程运行结束之后，如何将进程占用的内存空间回收</p>
</li>
</ul>
</li>
<li><p>内存空间的扩充：利用虚拟存确技术或者自动覆盖技术，从逻辑上扩充内存</p>
<ul>
<li><p>覆盖技术</p>
</li>
<li><p>交换技术</p>
</li>
<li><p>虚拟存储技术</p>
</li>
</ul>
</li>
<li><p>地址转换：将逻辑地址转换为物理地址</p>
<ul>
<li><p>为了使编程更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址</p>
</li>
<li><p>而逻辑地址到物理地址的转换（这个过程称为地址重定位，即三种装入方式）应该由操作系统负责</p>
</li>
</ul>
</li>
<li><p>存储保护：保护各道作业在各自存储空间运行，互不干扰</p>
<ul>
<li><p>方法1：在CPU中设置上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时，分别和两个寄存器的数据比较，判断是有越界</p>
</li>
<li><p>方法2：采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）进行越界检查。重定位寄存器中包含最小物理地址值，界地址寄存器包含逻辑地址的最大值</p>
<ul>
<li><p>越界检查过程：</p>
<ul>
<li><p>界地址寄存器：逻辑地址是否小于界地址寄存器中的数据</p>
</li>
<li><p>重定位寄存器：逻辑地址+重定位寄存器中的数据&#x3D;物理地址</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h2><ul>
<li><p>覆盖</p>
<ul>
<li><p>思想：将程序分为多个段（多个模块），常用的段常驻内存，不常用的段在需要时调用内存</p>
</li>
<li><p>将用户空间分为一个固定区和若干覆盖区，活跃部分放在固定区，即将访问的段放在覆盖区</p>
<ul>
<li><p>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）</p>
</li>
<li><p>不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</p>
</li>
</ul>
</li>
<li><p>特点：打破了必须将一个讲程的全部信息装入主存后才能运行的限制，内存中能够更新的地方只有覆盖区的段，不在覆盖区的段会常驻内存</p>
</li>
<li><p>缺点：对用户不透明，增加了用户编程负担</p>
<ul>
<li><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖</p>
</li>
<li><p>覆盖技术只用于早期的操作系统</p>
</li>
</ul>
</li>
<li><p>适用于程序大小超过物理内存总和</p>
</li>
</ul>
</li>
<li><p>交换</p>
<ul>
<li><p>思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）</p>
</li>
<li><p>换出：将处于等待状态的程序从内存中转移到辅存</p>
<ul>
<li>使进程处于挂起状态（分为就绪挂起、阻塞挂起）</li>
</ul>
</li>
<li><p>换入：把准备好竞争CPU运行的程序从辅存转移到内存</p>
<ul>
<li>中级调度（内存调度）：就是将哪个处于挂起状态的进程重新调入内存</li>
</ul>
</li>
<li><p>1、在外存（磁盘）的什么位置保存被换出的进程</p>
<ul>
<li><p>结构：把磁盘空间分为文件区和对接区两部分<img src="https://api2.mubu.com/v3/document_image/9136a4b8-c517-41b4-87b8-9c6ea81a287b-3224585.jpg" alt="img"></p>
</li>
<li><p>文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式</p>
</li>
<li><p>对换区空间只占磁盘空间的小部分，被换出的进程数据（例如PCB）就存放在对换区，主要追求换入换出速度（对换直接影响系统的整体速度），因此通常对换区采用连续分配方式</p>
<ul>
<li>对换区的I&#x2F;O速度比文件区更快</li>
</ul>
</li>
<li><p>注意：PCB会常驻内存，不会被换出外存</p>
</li>
</ul>
</li>
<li><p>2、什么时候进程交换</p>
<ul>
<li><p>交换通常在许多进程运行且内存吃紧时进行进程交换，而系统负荷降低就暂停</p>
</li>
<li><p>例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出</p>
</li>
</ul>
</li>
<li><p>3、优先换出哪些进程</p>
<ul>
<li>阻塞进程、优先级低的进程、进程在内存的驻留时间较短的进程（防止饥饿）</li>
</ul>
</li>
</ul>
</li>
<li><p>交换存在的问题</p>
<ul>
<li><p>备份存储，使用快速硬盘，要求存储空间足够大，并且能够对内存映像进行直接访问</p>
</li>
<li><p>转移时间和所交换的内存空间成正比</p>
</li>
<li><p>只有内存空闲状态才能将进程换出</p>
</li>
<li><p>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来会很快</p>
</li>
<li><p>交换通常在有许多进程运行且内存吃紧时开始启动，连负荷降低就暂停</p>
</li>
<li><p>普通的交换使用不多，但交换策路的某些变体在许多系统中仍发挥作用</p>
</li>
</ul>
</li>
</ul>
<h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><p>连续分配：为用户进程分配的必须是一个连续的内存空间）</p>
<ul>
<li><p>单一连续分配</p>
<ul>
<li><p>内存分为系统区和用户区</p>
<ul>
<li><p>系统区仅供操作系统使用，通常在低地址部分</p>
</li>
<li><p>用户区为用户提供</p>
<ul>
<li>内存中只能有一道用户程序，用户程序独占整个用户区空间</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>实现简单，无外部碎片</p>
</li>
<li><p>采用覆盖技术，不需要额外技术支持</p>
</li>
<li><p>无须进行内存保护，不会出现越界异常</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>只适用于单用户，单任务的操作系统，不支持多道程序并发运行</p>
</li>
<li><p>存在内部碎片（分配给某个进程的内存区域中有一部分没用上），存储器利用率低</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>固定分区分配</p>
<ul>
<li><p>背景：为了在内存中装入多道程序，且这些程序之间不会相互干扰</p>
</li>
<li><p>将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业</p>
</li>
<li><p>种类</p>
<ul>
<li><p>分区大小相等：用一台计算机去控制多个相同对象的场合，缺乏灵活性</p>
</li>
<li><p>分区大小不等：划分为多个较小的分区，适量的中等分区和少量大分区</p>
</li>
</ul>
</li>
<li><p>实现各个分区的分配与回收</p>
<ul>
<li><p>操作系统建立一个数据结构——分区说明表</p>
<ul>
<li><p>每个表项对应一个分区，通常按分区大小排列</p>
</li>
<li><p>每个表项包括对应分区的大小、起始地址、状态（是否已分配）</p>
</li>
</ul>
</li>
<li><p>用数据结构的数组（或链表）即可表示这个表</p>
</li>
<li><p>将程序装入内存时：</p>
<ul>
<li>由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”</li>
</ul>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>适用于多道程序的存储，无外部碎片</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>有可能程序太大，无法放入任何一个分区；此时又不得不采用覆盖技术来解决，又会降低性能</p>
</li>
<li><p>存在内部碎片，主存利用率低</p>
</li>
<li><p>不能实现多进程共享一个主存区</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>动态分区分配</p>
<ul>
<li><p>不会预先划分内存分区，在进程装入内存的时候，根据内存的大小动态的建立分区，使分区的大小正好适合进程的需要，因此用户区的分区大小和数目是可变的</p>
</li>
<li><p>1、系统要用什么样的数据结构记录内存的使用情况</p>
<ul>
<li><p>空闲分区表：</p>
<ul>
<li>每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息</li>
</ul>
</li>
<li><p>空闲分区链：</p>
<ul>
<li>每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li>
</ul>
</li>
</ul>
</li>
<li><p>2、当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</p>
<ul>
<li>使用动态分区分配算法选择分区进行分配</li>
</ul>
</li>
<li><p>3、如何进行分区的分配与回收操作</p>
<ul>
<li><p>分配操作：</p>
<ul>
<li><p>1.进程所占内存 &lt; 分区大小：修改分区大小（原-进程大小）和起始地址（原+进程大小）</p>
</li>
<li><p>2.进程所占内存&#x3D;分区大小：删除对应表项，或删除对应结点</p>
</li>
</ul>
</li>
<li><p>回收操作：</p>
<ul>
<li><p>1.回收区的后面有一个相邻的空闲分区（合并两个相邻的空闲分区）：修改分区大小（原+进程大小）和起始地址（原-进程大小）</p>
</li>
<li><p>2.回收区的前面有一个相邻的空闲分区（合并两个相邻的空闲分区）：修改分区大小（原+进程大小）和起始地址（不变）</p>
</li>
<li><p>3.回收区的前、后各有一个相邻的空闲分区（三个相邻的空闲分区合并为一个）：删除起始地址靠后的表项，修改起始地址靠前表项的分区大小（三个分区大小之和）和起始地址（不变）</p>
</li>
<li><p>4.回收区的前、后都没有相邻的空闲分区：增加空闲分区表表项</p>
</li>
</ul>
</li>
<li><p>注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定</p>
</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>分区大小可以根据进程的实际情况进行分配</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>存在外部碎片，最后导致主存利用率下降；不存在内部碎片</p>
<ul>
<li><p>采用紧凑技术可以缓解这种缺陷（解决外部碎片）——进程挪位</p>
</li>
<li><p>内部碎片：分配给某进程的内存区域中，如果有些部分没有用上</p>
</li>
<li><p>外部碎片：内存中的某些空闲分区由于太小而难以利用</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>注：</p>
<ul>
<li><p>什么是换入&#x2F;换出？</p>
</li>
<li><p>什么是中级调度（内存调度）？</p>
</li>
<li><p>动态分区分配应使用哪种装入方式：动态重定位</p>
</li>
<li><p>“紧凑”之后需要做什么处理：修改进程的起始地址，存放在PCB中，进程上CPU运行之前，将进程的起始地址放到重定位寄存器（基址寄存器）中</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="动态分配算法"><a href="#动态分配算法" class="headerlink" title="动态分配算法"></a>动态分配算法</h2><ul>
<li><p>首次适应算法</p>
<ul>
<li><p>算法思想：从低地址开始查找，找到第一个能满足大小的空闲分区</p>
</li>
<li><p>实现：</p>
<ul>
<li><p>空闲分区以地址递增的次序排列</p>
</li>
<li><p>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
</li>
</ul>
</li>
<li><p>优点：</p>
<ul>
<li>综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排序</li>
</ul>
</li>
<li><p>缺点：</p>
</li>
</ul>
</li>
<li><p>最佳适应算法</p>
<ul>
<li><p>算法思想：动态分区分配是一种连续分配方式，为了保留大片的空闲区，优先使用更小的空闲区</p>
</li>
<li><p>实现：</p>
<ul>
<li><p>空闲分区按容量递增次序链接</p>
</li>
<li><p>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
</li>
</ul>
</li>
<li><p>优点：可以尽可能多地留下大片的空闲区</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p>性能较差：回收分区后可能需要对空闲分区队列重新排序</p>
</li>
<li><p>产生最多的外部碎片：对很小的内存进行分配，会留下更小的内存块，这些更小的内存块难以利用，产生很多的外部碎片</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最坏适应算法（最大适应算法）</p>
<ul>
<li><p>算法思想：优先使用最大的连续空闲区</p>
<ul>
<li>为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用</li>
</ul>
</li>
<li><p>实现：</p>
<ul>
<li><p>空闲分区按容量递减次序链接</p>
</li>
<li><p>每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
</li>
</ul>
</li>
<li><p>算法优化：</p>
<ul>
<li><p>如果第一个空闲分区满足就要求，就可直接分配</p>
</li>
<li><p>如果第一个空闲分区不满足要求，说明无空闲分区满足要求</p>
</li>
</ul>
</li>
<li><p>优点：可以减少难以利用的小碎片</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p>导致很快没有较大的内存块，不利于大进程</p>
</li>
<li><p>算法开销大，性能很差（排序）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>邻近适应算法</p>
<ul>
<li><p>算法思想：分配内存时从上次查找结束的位置开始继续查找</p>
<ul>
<li>首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题</li>
</ul>
</li>
<li><p>实现：</p>
<ul>
<li><p>空闲分区以地址递增的顺序排列（可排成一个循环链表）</p>
</li>
<li><p>每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>
</li>
</ul>
</li>
<li><p>优点：算法开销小</p>
</li>
<li><p>缺点：会使高地址的大分区也被用完（有最坏(大)适应算法的缺点）</p>
</li>
</ul>
</li>
</ul>
<h2 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h2><p>为进程分配的是分散的内存空间</p>
<ul>
<li><p>基本分页存储管理方式</p>
<ul>
<li><p>设计思想</p>
<ul>
<li><p>将内存空间分为一个个大小相等的分区，每个分区就是一个页框（主存的基本单位）。每个页框有一个编号，即“页框号”，页框号从0开始</p>
<ul>
<li><p>页框&#x3D;页帧&#x3D;内存块&#x3D;物理块&#x3D;物理页面</p>
</li>
<li><p>页框号&#x3D;页帧号&#x3D;内存块号&#x3D;物理块号&#x3D;物理页号</p>
</li>
</ul>
</li>
<li><p>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，页号也是从0开始</p>
</li>
<li><p>分页存储与固定分区技术很像，但是其分页相对于分区又很小，分页管理不会产生外部碎片，产生的内部碎片也非常的小</p>
</li>
</ul>
</li>
<li><p>概念定义</p>
<ul>
<li><p>地址空间</p>
<ul>
<li><p>逻辑地址空间</p>
</li>
<li><p>物理地址空间：指令在内存中连续存放</p>
</li>
</ul>
</li>
<li><p>页（页面）vs 页框（页帧、物理页）</p>
<ul>
<li><p>不同点</p>
<ul>
<li><p>页：进程的逻辑地址空间的块</p>
</li>
<li><p>页框：内存的物理地址空间的块</p>
</li>
</ul>
</li>
<li><p>相同点：从0开始</p>
</li>
</ul>
</li>
<li><p>页号（页面号）vs 页框号（页帧号、物理页号）</p>
<ul>
<li><p>不同点</p>
<ul>
<li><p>页号：逻辑地址空间的块的编号</p>
</li>
<li><p>页框号：物理地址空间的块的编号</p>
</li>
</ul>
</li>
<li><p>相同点：从0开始</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分页存储的定义：</p>
<ul>
<li><p>操作系统以页框为单位为各个进程分配内存空间</p>
</li>
<li><p>进程的每个页面分别放入一个页框中，也就是说，进程的页面与内存的页框是一一对应的关系</p>
</li>
<li><p>各个页面不必连续存放，可以放到不相邻的各个页框中</p>
</li>
<li><p>注（小优化）：</p>
<ul>
<li><p>进程的最后一个页面可能没有一个页框那么大</p>
</li>
<li><p>也就是说，分页存储有可能产生内部碎片</p>
</li>
<li><p>因此页框不能太大，否则可能产生过大的内部碎片造成浪费</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分页存储的基本概念</p>
<ul>
<li><p>页面和页面大小</p>
<ul>
<li><p>进程中的块&#x3D;页</p>
</li>
<li><p>内存中的块&#x3D;页框（页帧）</p>
</li>
<li><p>进程申请主存空间，为每个页面分配主存中可用页框，即页与页框一一对应</p>
</li>
</ul>
</li>
<li><p>页面大小要适中</p>
<ul>
<li><p>页面太小：进程页面数过多，页表过程，增加内存占用，降低硬件地址转换效率</p>
</li>
<li><p>页面太大：页内碎片过多，降低内存利用率</p>
</li>
</ul>
</li>
<li><p>地址结构</p>
<ul>
<li>页号（有多少页的编号）+页内偏移（页内存了多少东西）</li>
</ul>
</li>
<li><p>页表</p>
<ul>
<li><p>为了便于在内存中找到进程的每个页面对应的物理块</p>
</li>
<li><p>系统为每个进程建立一张页表</p>
</li>
<li><p>进程的每个页面对应一个页表项</p>
</li>
<li><p>页表一般放在内存中</p>
</li>
<li><p>每个页表项的长度是相同的</p>
</li>
<li><p>页表项：页号+物理内存中的块号（不要与地址结构搞混）</p>
<ul>
<li>页表项的物理内存块号+地址结构中的页内偏移&#x3D;物理地址</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>问题1：每个页表项占多少字节</p>
<ul>
<li><p>计算过程</p>
<ul>
<li><p>计算机中内存块的数量：内存大小&#x2F;页面大小</p>
</li>
<li><p>内存块号所占的bit数：2^n&#x3D;内存块数量，求n</p>
</li>
<li><p>表示块号至少需要几个字节：n&#x2F;8向上取整</p>
</li>
</ul>
</li>
<li><p>页表项所占字节数&#x3D;块号所占字节数</p>
<ul>
<li>页号不占用字节（存储空间）：连续存放，隐含</li>
</ul>
</li>
<li><p>i号页表项的存放地址&#x3D;X+3i</p>
<ul>
<li>若每个页表项占3B，且都是连续存放</li>
</ul>
</li>
<li><p>存储整个页表：</p>
<ul>
<li>3*(n+1)，页号从0开始</li>
</ul>
</li>
<li><p>求某个内存块的起始地址：</p>
<ul>
<li>内存块的起始地址&#x3D;块号*内存块大小</li>
</ul>
</li>
</ul>
</li>
<li><p>问题2：如何实现地址转换（逻辑地址转为物理地址）</p>
<ul>
<li><p>特点：进程的各个页面是离散存放的，但页面内部是连续存放的</p>
</li>
<li><p>思想</p>
<ul>
<li><p>1.确定逻辑地址A对应的页号P</p>
</li>
<li><p>2.找到页号P对应的块号（查询页表），计算P号页面在内存中的起始地址</p>
</li>
<li><p>3.确定逻辑地址A的页内偏移量W</p>
</li>
<li><p>物理地址&#x3D;P号页面在内存中的起始地址+页内偏移量W</p>
</li>
</ul>
</li>
<li><p>计算过程</p>
<ul>
<li><p>页号&#x3D;逻辑地址&#x2F;页面长度（取除法的整数部分）</p>
</li>
<li><p>页内偏移量&#x3D;逻辑地址%页面长度（取余法的余数部分）</p>
</li>
<li><p>页面在内存中的起始地址&#x3D;页号对应块号*内存大小</p>
</li>
<li><p>物理地址&#x3D;页面在内存中的起始地址+页内偏移量</p>
</li>
</ul>
</li>
<li><p>小优化：页面大小是2的整数次幂</p>
<ul>
<li><p>原因1：计算机硬件可以快速的将逻辑地址拆分为页号和页内偏移量——逻辑地址拆分更迅速</p>
<ul>
<li><p>例：如果计算机用32位二进制数表示逻辑地址，页面大小是4KB</p>
<ul>
<li><p>则一个页面的逻辑地址范围是0~4095，也就是后12位</p>
</li>
<li><p>所以前20位表示页号，后12位表示页面偏移量</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原因2：计算机硬件可以很快找到页号和页面偏移量所对应的物理地址——物理地址的计算更迅速</p>
<ul>
<li>例：如果页号为2，页内偏移量为1<ul>
<li>则这个页面的物理地址&#x3D;物理块号（页号对应的块号*内存块大小）拼接上页内偏移量</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑地址结构</p>
<ul>
<li><p>如果有 K 位表示“页内偏移量W”，则说明该系统中一个页面的大小是 2^K个内存单元</p>
</li>
<li><p>如果有 M 位表示“页号W”，则说明在该系统中，一个进程最多允许有 2^M 个页面</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>基本地址变换机构</p>
<ul>
<li><p>是什么：在基本分页存储管理中用于实现逻辑地址到物理地址转换的一组硬件机构<img src="https://api2.mubu.com/v3/document_image/c05183c3-da02-4fd1-9206-af9442ae9774-3224585.jpg" alt="img"></p>
</li>
<li><p>逻辑地址中需要包括的信息</p>
<ul>
<li><p>页号</p>
</li>
<li><p>页内偏移量</p>
</li>
<li><p>页面在内存中存放的位置</p>
</li>
</ul>
</li>
<li><p>硬件：页表寄存器（PTR）</p>
<ul>
<li><p>存放：</p>
<ul>
<li><p>页表在内存中的起始地址F</p>
</li>
<li><p>页表长度M</p>
</li>
</ul>
</li>
<li><p>注：进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中</p>
</li>
</ul>
</li>
<li><p>页面大小为L，逻辑地址A到物理地址E的变换过程：</p>
<ul>
<li><p>1、进程切换相关的内核程序恢复进程运行环境</p>
<ul>
<li><p>进程运行环境的相关信息保存在PCB中</p>
</li>
<li><p>内核程序会将PCB中的相关信息（页表起始地址F、页表长度M）放到页表寄存器中</p>
</li>
<li><p>内核程序会将PCB中的相关信息（下一条指令的逻辑地址A）放到程序计数器中</p>
</li>
</ul>
</li>
<li><p>2、根据逻辑地址A计算出页号P、页内偏移量W</p>
<ul>
<li><p>页号P：逻辑地址前m位</p>
</li>
<li><p>页内偏移量W：逻辑地址后n位</p>
</li>
</ul>
</li>
<li><p>3、对页号的合法性检查</p>
<ul>
<li><p>如果页号P&gt;&#x3D;页表长度，说明逻辑地址非法，导致越界中断（内中断）</p>
</li>
<li><p>如果页号&lt;页表长度，说明逻辑地址合法</p>
</li>
</ul>
</li>
<li><p>4、查询页表，找到页号对应的页表项——第一次访问内存：查询页表中某个页表项内容</p>
<ul>
<li>页号对应的页表项（内存块号）&#x3D;页号*(页表项长度)+页表始址</li>
</ul>
</li>
<li><p>5、用内存块号和页内偏移量得出物理地址</p>
<ul>
<li>内存块号是前n位，页内偏移量是后b位</li>
</ul>
</li>
<li><p>6、访问目标内存单元——第二次访问内存</p>
</li>
</ul>
</li>
<li><p>计算方式</p>
<ul>
<li><p>1、计算页号（逻辑地址对页面大小取整）、页内偏移量（逻辑地址对页面大小取余）</p>
<ul>
<li><p>手算：页号P&#x3D;A&#x2F;L，页内偏移量W&#x3D;A%L</p>
</li>
<li><p>机算：页号P&#x3D;前m位，页内偏移量W&#x3D;后n位</p>
</li>
</ul>
</li>
<li><p>2、比较页号P和页表长度M，若P&gt;&#x3D;M产生越界中断</p>
<ul>
<li>页号从0开始</li>
</ul>
</li>
<li><p>3、页表中页号P对应的页表项地址&#x3D;页表始址F+页号P*页表项长度</p>
<ul>
<li>取出该页表项中的内容，即为内存块号</li>
</ul>
</li>
<li><p>4、计算物理地址E，使用E去访问内存</p>
<ul>
<li><p>手算：E&#x3D;b*L+W</p>
</li>
<li><p>机算：E&#x3D;内存块号和页内偏移量用二进制表示，然后拼接起来</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>概念区分</p>
<ul>
<li><p>页表项长度：每个页表项所占的存储空间</p>
</li>
<li><p>页表长度：这个页表中有多少个页表项</p>
</li>
<li><p>页面大小：一个页面占多大存储空间</p>
</li>
</ul>
</li>
<li><p>例题：若页面大小L 为 1K 字节，页号2对应的内存块号 b &#x3D; 8，将逻辑地址 A&#x3D;2500 转换为物理地址E。</p>
<ul>
<li><p>等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位，页号2对应的内存块号 b &#x3D; 8，将逻辑地址 A&#x3D;2500 转换为物理地址E。</p>
<ul>
<li><p>按字节寻址：每个地址占一个字节</p>
</li>
<li><p>页内偏移量占10位：页面大小&#x3D;2^10&#x3D;1K</p>
</li>
<li><p>综上：页面大小L&#x3D;1K字节</p>
</li>
</ul>
</li>
<li><p>1、求页号、页面偏移量</p>
<ul>
<li><p>页号P&#x3D;A&#x2F;L&#x3D;2500&#x2F;1024&#x3D;2</p>
</li>
<li><p>页内偏移量W&#x3D;A%L&#x3D;452</p>
</li>
</ul>
</li>
<li><p>2、由于页号2存在，所以没有越界，且存放的内存块号b&#x3D;8</p>
</li>
<li><p>3、物理地址E&#x3D;b*L+W&#x3D;8x1024+425&#x3D;8644</p>
</li>
</ul>
</li>
<li><p>分页存储管理（页式管理）中的地址是一维的</p>
<ul>
<li><p>只要确定了每个页面的大小，逻辑地址结构就确定了</p>
</li>
<li><p>因此，只要给出一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要知道这两个部分各占多少位</p>
</li>
</ul>
</li>
<li><p>页表项的大小</p>
<ul>
<li><p>页表项大小的设计应当尽量一页正好能装下所有的页表项</p>
</li>
<li><p>目的：方便页表的查询</p>
</li>
<li><p>原因：各页表项（和进程页表）按顺序连续地存放在内存中，如果一个页表项的大小为3字节，查找下一个页框的页表项时，不能直接使用X+3*M（跨页框查询）</p>
</li>
</ul>
</li>
<li><p>分页管理存在的问题</p>
<ul>
<li><p>地址变换过程必须足够快，否则访存速率会降低</p>
</li>
<li><p>页表不能太大，否则会降低内存利用率</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具有快表的地址交换机构</p>
<ul>
<li><p>可优化方向：如果页表放在内存中，取地址访问一次内存，按照地址取出数据访问一次内存，共需要两次访问内存</p>
</li>
<li><p>优化：地址变换机构中增加一个且有并性查找能力的高速缓冲寄存器（快表），所以只需要访问一次高速缓存和一次内存</p>
<ul>
<li>快表既可以按照地址查找也可以按照内容查找</li>
</ul>
</li>
<li><p>快表，又称联想寄存器（TLB）</p>
<ul>
<li><p>是一种访问速度比内存快很多的高速缓存（TLB不是内存！）</p>
</li>
<li><p>用来存放最近访问的页表项的副本，可以加速地址变换的速度。</p>
</li>
<li><p>与此对应，内存中的页表常称为慢表</p>
</li>
<li><p>TLB与高速缓存区别：TLB （一个硬件）中只存放页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p>
<ul>
<li>即，TLB是只存放页表项的高速缓存</li>
</ul>
</li>
</ul>
</li>
<li><p>存储设备</p>
<ul>
<li><p>内存：将CPU要访问的数据放在内存中，缓和CPU与硬盘读取速度的矛盾</p>
</li>
<li><p>高速缓存：内存虽然已经比硬盘快很多了，但是CPU的处理速度还是比高速缓存快的多，所以将最近有可能被频繁访问的数据放到高速缓存中</p>
<ul>
<li><p>CPU先访问高速缓存，找到所需要的数据，就不再访问内存</p>
</li>
<li><p>由于高速缓存的内存空间很小，所以不可能将整个快表全都放进高速缓存中</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>访问一个逻辑地址的访存次数</p>
<ul>
<li><p>基本地址变换机构</p>
<ul>
<li>两次访存</li>
</ul>
</li>
<li><p>具有快表的地址变换机构</p>
<ul>
<li><p>快表命中，只需一次访存</p>
</li>
<li><p>快表末命中，需要两次访存</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>变换过程</p>
<ul>
<li><p>查找图示<img src="https://api2.mubu.com/v3/document_image/38531f73-f4c2-41fe-bb6b-eeb4f2344018-3224585.jpg" alt="img"></p>
</li>
<li><p>1、进程上处理机运行（进程切换）后，系统会清空快表（一个硬件）的内容</p>
</li>
<li><p>2、越界检查</p>
</li>
<li><p>3、查询快表，是否命中</p>
</li>
<li><p>4、若快表命中，直接从快表中找到该页号对应的内存块号，与页内偏移量拼接成物理地址</p>
</li>
<li><p>5、若快表不命中，再按照正常方式从页表中查询相应页表项，并将该页表项存入快表中（按照一定策略）</p>
</li>
</ul>
</li>
<li><p>变换过程——文字</p>
<ul>
<li><p>1、CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较</p>
</li>
<li><p>2、如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可</p>
</li>
<li><p>3、 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p>
</li>
</ul>
</li>
<li><p>性能：</p>
<ul>
<li><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到 90% 以上。</p>
<ul>
<li><p>局部性原理：</p>
<ul>
<li><p>时间局部性：程序中存在大量的循环</p>
<ul>
<li><p>如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行</p>
</li>
<li><p>如果某个数据被访问过，不久之后该数据很可能再次被访问</p>
</li>
</ul>
</li>
<li><p>空间局部性：很多数据在内存中都是连续存放的</p>
<ul>
<li><p>程序对应的指令，很有可能集中存放一个或几个页面中</p>
</li>
<li><p>程序中定义的变量，很有可能集中存放在一个或几个页面中</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>例题：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？</p>
<ul>
<li><p>(1+100) * 0.9 + (1+100+100) * 0.1 &#x3D; 111 us</p>
</li>
<li><p>若支持快表和慢表同时查找，平均耗时应该是 (1+100) * 0.9 + (100+100) * 0.1 &#x3D;110.9 us<img src="https://api2.mubu.com/v3/document_image/7542c512-c73d-48ac-b6ab-1f8bf0fa8b30-3224585.jpg" alt="img"></p>
</li>
<li><p>若未采用快表机制，则访问一个逻辑地址需要 100+100 &#x3D; 200us</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有无快表的对比<img src="https://api2.mubu.com/v3/document_image/38677fac-d419-456d-acf9-a28636ae3423-3224585.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>两级页表</p>
<ul>
<li><p>单级页表存在的问题，如何解决</p>
<ul>
<li><p>问题：</p>
<ul>
<li><p>1、页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</p>
</li>
<li><p>2、没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</p>
</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li><p>解决问题1：两级页表</p>
</li>
<li><p>解决问题2：虚拟存储技术（在需要访问页面时才把页面调入内存）</p>
<ul>
<li><p>在页表项中增加一个标志位，用于表示该页面是否已经调入内存</p>
</li>
<li><p>若想访问的页面不在内存中，则产生缺页中断（内中断&#x2F;异常），然后将目标页面从外存调入内存</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>两级页表的原理、逻辑地址结构</p>
<ul>
<li><p>原理：</p>
<ul>
<li><p>将页表进行分组，使得每一个内存块刚好可以放入一个分组（各个分组离散地放入各个内存块中）</p>
</li>
<li><p>为离散分配的页表再建立一张页表，称为页目录表（&#x3D;外层页表&#x3D;顶层页表）</p>
</li>
</ul>
</li>
<li><p>地址结构<img src="https://api2.mubu.com/v3/document_image/9e10c503-67bf-4c88-adea-db5e476bb15b-3224585.jpg" alt="img"></p>
</li>
<li><p>页目录表包括</p>
<ul>
<li><p>页号：二级页表的页号</p>
</li>
<li><p>内存块号：二级页表的块号</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>地址变换过程（逻辑地址转换为物理地址）</p>
<ul>
<li><p>1、按照地址结构将逻辑地址拆分成三部分</p>
</li>
<li><p>2、从PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p>
</li>
<li><p>3、根据二级页号查二级页表，找到最终想访问的内存块号</p>
</li>
<li><p>4、结合页内偏移量得到物理地址</p>
</li>
</ul>
</li>
<li><p>两级页表问题需要注意的几个小细节</p>
<ul>
<li><p>1、若分为两级页表后，页表依然很长，则可以采用更多级页表，一般来说各级页表的大小不能超过一个页面</p>
<ul>
<li><p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？</p>
<ul>
<li><p>页面大小 &#x3D; 4KB &#x3D;212B，按字节编址，因此页内偏移量为12位</p>
</li>
<li><p>页号 &#x3D; 40 - 12 &#x3D; 28 位</p>
</li>
<li><p>页面大小 &#x3D; 2^12B，页表项大小 &#x3D; 4B ，则每个页面可存放 2^12 &#x2F; 4 &#x3D; 2^10 个页表项</p>
</li>
<li><p>因此各级页表最多包含 2^10 个页表项，因此每一级的页表对应页号应为10位</p>
</li>
<li><p>所以28位的页号至少要分为三级</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2、两级页表的访存次数分析（假设没有快表机构）——3次访存</p>
<ul>
<li><p>第一次访存：访问内存中的页目录表</p>
</li>
<li><p>第二次访存：访问内存中的二级页表</p>
</li>
<li><p>第三次访存：访问目标内存单元</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><ul>
<li><p>出发点</p>
<ul>
<li><p>分页是从计算机角度考虑设计的，目的是为了内存的利用率，提高计算机性能，分页通过硬件机制实现，对用户完全透明</p>
</li>
<li><p>分段是从用户和程序员的角度提出，满足方便编程，信息保护和共享，动态增长及动态链接等多方面的需要</p>
</li>
</ul>
</li>
<li><p>分段</p>
<ul>
<li><p>如何分段：</p>
<ul>
<li>按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址</li>
</ul>
</li>
<li><p>内存分配规则：</p>
<ul>
<li>以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li><p>由于是按逻辑功能模块划分，用户编程更方便，程序的可读性更高</p>
</li>
<li><p>LOAD 1, [D] | <A>;  &#x2F;&#x2F;将分段D中A单元内的值读入寄存器1</p>
<ul>
<li><p>写程序时使用的段名 [D]、[X] 会被编译程序翻译成对应段号</p>
<ul>
<li><p>用户编程时，使用段名操作各个段</p>
</li>
<li><p>CPU执行时，使用段号</p>
</li>
</ul>
</li>
<li><p><A>单元（助记符）、<B>单元会被编译程序翻译成段内地址</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>地址结构</p>
<ul>
<li><p>段号S+段内偏移量W</p>
<ul>
<li><p>段号的位数决定了每个进程最多可以分几个段</p>
</li>
<li><p>段内地址位数决定了每个段的最大长度是多少</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>段表</p>
<ul>
<li><p>背景：</p>
<ul>
<li><p>程序分多个段，各段离散地装入内存</p>
</li>
<li><p>为了保证程序能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“段表”</p>
</li>
</ul>
</li>
<li><p>段表结构</p>
<ul>
<li>段号、段长、段基址（该段在内存中的起始地址）</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li><p>各个段表项的长度是相同的</p>
<ul>
<li><p>段长的位数&#x3D;段内地址的位数</p>
</li>
<li><p>基址&#x3D;能表示整个物理内存地址空间的位数</p>
</li>
</ul>
</li>
<li><p>段号是隐含的，不占存储空间</p>
</li>
</ul>
</li>
<li><p>段表内容&#x3D;段号+段长+本段在主存中的地址</p>
</li>
</ul>
</li>
<li><p>地址变换机构</p>
<ul>
<li><p>变换过程<img src="https://api2.mubu.com/v3/document_image/e3c5de56-9ced-48bf-b50b-f2fa221dcc70-3224585.jpg" alt="img"></p>
</li>
<li><p>1、根据逻辑地址A得到段号S和段内偏移量W</p>
</li>
<li><p>2、判断段号是否越界</p>
<ul>
<li>比较段号S和段表长度M，若S&gt;&#x3D;M，则产生越界中断，否则继续执行</li>
</ul>
</li>
<li><p>3、查询段表，找到相应的段表项</p>
<ul>
<li>段号S对应的段表项地址&#x3D;段表始址F+段号S*段表项长度</li>
</ul>
</li>
<li><p>4、检查段内地址（W）是否超过段长（C）</p>
<ul>
<li>若W≥C，则产生越界中断，否则继续执行</li>
</ul>
</li>
<li><p>5、计算得到物理地址E&#x3D;b+W</p>
<ul>
<li><p>段表项中该段的始址b</p>
</li>
<li><p>段内地址W</p>
</li>
</ul>
</li>
<li><p>6、用得到的物理地址E去访问内存</p>
</li>
</ul>
</li>
<li><p>分段、分页管理的对比</p>
<ul>
<li><p>区别：</p>
<ul>
<li><p>分页：</p>
<ul>
<li><p>页是信息的物理单位</p>
</li>
<li><p>目的是为了实现离散分配，提高内存利用率</p>
</li>
<li><p>系统行为，对用户是不可见的</p>
</li>
<li><p>页的大小固定且由系统决定</p>
</li>
<li><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址</p>
<ul>
<li><p>一个进程的地址空间是连续的</p>
</li>
<li><p>例如：LOAD 1, <A>;</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分段：</p>
<ul>
<li><p>段是信息的逻辑单位</p>
</li>
<li><p>目的是更好地满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息</p>
</li>
<li><p>分段对用户是可见的</p>
</li>
<li><p>段的长度是不固定的，决定于用户编写的程序</p>
</li>
<li><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要显式地给出段名，也要给出段内地址</p>
<ul>
<li><p>一个进程的地址空间是不连续的，被分为一个个的段</p>
</li>
<li><p>例如：LOAD 1, [D] | <A>;</p>
</li>
</ul>
</li>
<li><p>分段更容易实现共享和保护</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>段的共享与保护</p>
<ul>
<li><p>共享：</p>
<ul>
<li><p>功能段：可以存在一个段，用来判断缓冲区此时是否可访问</p>
<ul>
<li>用于允许所有生产者、消费者进程共享访问</li>
</ul>
</li>
<li><p>如何实现两个进程共享的使用一个段：两个进程的段表项指向相同的基址</p>
</li>
<li><p>共享的对象：纯代码（可重入代码）</p>
<ul>
<li><p>纯代码：不能被修改的代码</p>
<ul>
<li>不属于临界资源，是可以共享的，两个进程可以并发访问</li>
</ul>
</li>
<li><p>可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致）</p>
</li>
</ul>
</li>
<li><p>对比：分页不是按照逻辑结构划分的，所以很难实现共享</p>
</li>
</ul>
</li>
<li><p>保护机制</p>
<ul>
<li><p>如何实现：段表项中添加一个数据，是否允许其它进程访问</p>
</li>
<li><p>对比：分页不是按照逻辑结构划分</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分段存储需要两次访存</p>
<ul>
<li><p>1、查询内存中的段表</p>
</li>
<li><p>2、查询目标内存单元</p>
</li>
<li><p>与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度</p>
</li>
</ul>
</li>
</ul>
<h2 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h2><ul>
<li><p>分段与分页优缺点</p>
<ul>
<li><p>分页管理</p>
<ul>
<li><p>优点：内存空间利用率高，不会产生外部碎片，只会有少量的内部碎片</p>
</li>
<li><p>缺点：不方便按照逻辑模块实现信息的共享和保护</p>
</li>
</ul>
</li>
<li><p>分段管理</p>
<ul>
<li><p>优点：很方便按照逻辑模块实现信息的共享和保护</p>
</li>
<li><p>缺点</p>
<ul>
<li><p>如果段长过大，为其分配很大的连续空间会很不方便</p>
</li>
<li><p>段式管理会产生外部碎片（虽然也可以使用“紧凑”技术解决，但是需要付出时间代价）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分段和分页的结合——段页式管理方式</p>
<ul>
<li><p>将进程先按照逻辑模块分段，然后将各个段分页（如每个页面4KB）</p>
</li>
<li><p>再将内存空间分为大小相等的内存块（页框、页帧、物理块号&#x3D;进程页面大小4KB）</p>
</li>
<li><p>将进程的各个页面被放到内存块中</p>
</li>
</ul>
</li>
<li><p>段页式的逻辑地址结构</p>
<ul>
<li><p>段号S+页号P+页内偏移量W</p>
<ul>
<li><p>段号的位数决定了每个进程最多可以分几个段</p>
</li>
<li><p>页号位数决定了每个段最大有多少页</p>
</li>
<li><p>页内偏移量决定了页面大小、内存块大小是多少</p>
</li>
</ul>
</li>
<li><p>段页式管理的地址结构是二维的</p>
<ul>
<li><p>“分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址</p>
</li>
<li><p>将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>段表、页表</p>
<ul>
<li><p>段表：段号、页表长度、页表存放块号</p>
<ul>
<li><p>根据块号即可算出页表存放的内存地址</p>
</li>
<li><p>每个段表项长度相等，段号是隐含的</p>
</li>
<li><p>每个段对应一个段表项</p>
</li>
<li><p>一个进程对应一个段表</p>
</li>
</ul>
</li>
<li><p>页表：页号、内存块号</p>
<ul>
<li><p>每个页对应一个页表项</p>
</li>
<li><p>每个页表项长度相等，页号是隐含的</p>
</li>
<li><p>一个进程可能对应多个页表</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>硬件：段表寄存器</p>
<ul>
<li><p>段表始址F</p>
</li>
<li><p>段表长度M</p>
</li>
</ul>
</li>
<li><p>如何实现地址转换</p>
<ul>
<li><p>1、根据逻辑地址得到段号S、页号P、页内偏移量M</p>
</li>
<li><p>2、判断段号是否越界。</p>
<ul>
<li>若S≥M，则产生越界中断，否则继续执行</li>
</ul>
</li>
<li><p>3、查询段表，找到对应的段表项——第一次访存</p>
<ul>
<li>段表项的存放地址为F+S*段表项长度</li>
</ul>
</li>
<li><p>4、检查页号是否越界</p>
<ul>
<li><p>（每个页对应的页表大小不同）</p>
</li>
<li><p>若页号≥页表长度，则发生越界中断，否则继续执行</p>
</li>
</ul>
</li>
<li><p>5、根据页表存放块号和页号查询页表，找到对应页表项——第二次访存</p>
</li>
<li><p>6、根据内存块号、页内偏移量得到最终的物理地址</p>
</li>
<li><p>7、访问目标内存单元——第三次访存</p>
</li>
</ul>
</li>
<li><p>访存次数：3次</p>
<ul>
<li><p>1、访问段表</p>
</li>
<li><p>2、访问页表</p>
</li>
<li><p>3、访问目标内存单元</p>
</li>
<li><p>优化：也可引入快表机构</p>
<ul>
<li>用段号和页号作为查询快表的关键字。若快表命中则仅需一次访存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><h2 id="虚拟内存的基本概念"><a href="#虚拟内存的基本概念" class="headerlink" title="虚拟内存的基本概念"></a>虚拟内存的基本概念</h2><ul>
<li><p>传统存储管理方式的特征、缺点</p>
<ul>
<li><p>一次性：作业必须一次性全部装入内存后，才能开始运行</p>
<ul>
<li><p>作业很大无法装入则无法运行</p>
</li>
<li><p>大量作业要求运行时，由于内存不足，只能一部分作业先运行，导致多道程序度下降</p>
</li>
</ul>
</li>
<li><p>驻留性：作业装入内存后，一直驻留在内存中，任何部分不会被换出</p>
</li>
</ul>
</li>
<li><p>局部性原理</p>
<ul>
<li><p>时间局部性</p>
<ul>
<li><p>一条指令执行后，不就之后指令可能被再次执行，数据被访问后，不久后数据可能再次被访问</p>
</li>
<li><p>原因：程序中存在着大量的循环操作</p>
</li>
<li><p>解决：将最近使用的指令和数据存储在高速缓冲存储器中</p>
</li>
</ul>
</li>
<li><p>空间局部性</p>
<ul>
<li><p>一旦程序访问了某个存储单元，不久之后附近的存储单元也将被访问</p>
</li>
<li><p>原因：指令通常是顺序存放，顺序执行的，数据一般也是以向量、数组、表等形式簇聚存储的</p>
</li>
<li><p>解决：使用较大的高速缓存，将预取机制集成到高速缓存控制逻辑中实现</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟存储器的定义和特征</p>
<ul>
<li><p>基于局部性原理，程序的一部分装入内存，一部分留在外存，需要的时候将外存内容调入内存，就好像产生了一个巨大的内存空间</p>
<ul>
<li><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</p>
</li>
<li><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>
</li>
<li><p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</p>
</li>
</ul>
</li>
<li><p>注：虚拟内存的最大容量、虚拟内存的实际容量</p>
<ul>
<li><p>虚拟内存的最大容量由计算机的地址结构（CPU寻址范围）确定的</p>
</li>
<li><p>虚拟内存的实际容量 &#x3D; min（内存和外存容量之和，CPU寻址范围）</p>
</li>
<li><p>例题：某计算机地址结构为32位，按字节编址，内存大小为512MB，外存大小为2GB。</p>
<ul>
<li><p>虚拟内存的最大容量为 232 B &#x3D; 4GB</p>
</li>
<li><p>虚拟内存的实际容量 &#x3D; min (232B, 512MB+2GB) &#x3D; 2GB+512MB</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>特征</p>
<ul>
<li><p>多次性：作业在运行时，分多次调入内存运行</p>
</li>
<li><p>对换性：作业不必一直驻留内存，允许作业在运行过程中进行换进换出</p>
</li>
<li><p>虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于实际的内存容量</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>虚拟内存技术的实现</p>
<ul>
<li><p>建立在离散分配的内存管理方式上</p>
<ul>
<li>如果采用连续分配方式，进程所占的连续存储空间会越来越大，且需要预留大量存储空间，所以不方便实现</li>
</ul>
</li>
<li><p>实现方式</p>
<ul>
<li><p>请求分页存储管理</p>
</li>
<li><p>请求分段存储管理</p>
</li>
<li><p>请求段页式存储管理</p>
</li>
</ul>
</li>
<li><p>虚拟内存的和传统的非连续分配存储管理方式的主要区别</p>
<ul>
<li><p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序</p>
<ul>
<li>操作系统要提供请求调页（或请求调段）功能</li>
</ul>
</li>
<li><p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>
<ul>
<li>操作系统要提供页面置换（或段置换）的功能</li>
</ul>
</li>
</ul>
</li>
<li><p>硬件支持</p>
<ul>
<li><p>一定容量的内存和外存</p>
</li>
<li><p>页表机制（或者段表机制）</p>
</li>
<li><p>中断机构</p>
</li>
<li><p>地址变换机构</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h2><ul>
<li><p>系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能</p>
</li>
<li><p>页表机制</p>
<ul>
<li><p>区别1：请求分页管理中，为了实现“请求调页”</p>
<ul>
<li><p>操作系统需要知道每个页面是否已经调入内存</p>
</li>
<li><p>如果还没调入，那么也需要知道该页面在外存中存放的位置</p>
</li>
</ul>
</li>
<li><p>区别2：当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面</p>
<ul>
<li><p>有的页面没有被修改过，就不用再浪费时间写回外存</p>
</li>
<li><p>有的页面修改过，就需要将外存中的旧数据覆盖，因此操作系统也需要记录各个页面</p>
</li>
</ul>
</li>
<li><p>组成</p>
<ul>
<li><p>页号</p>
</li>
<li><p>物理块号</p>
</li>
<li><p>状态位P：是否已调入内存</p>
</li>
<li><p>访问字段A：可记录最近被访问过几次，或记录上次访问的时间，供置换算法选择换出页面时参考</p>
</li>
<li><p>修改位M：页面调入内存后是否被修改过</p>
</li>
<li><p>外存地址：页面在外存中的存放位置（通常是物理块号）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缺页中断机构</p>
<ul>
<li><p>当访问页面不在内存时，就会产生缺页中断</p>
</li>
<li><p>特点</p>
<ul>
<li><p>指令执行期间产生中断，而不是指令执行之后产生中断和处理中然后由操作系统的缺页中断处理程序处理中断</p>
</li>
<li><p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列</p>
</li>
<li><p>如果内存中有空闲块，则可以将这个空闲块分配给缺页进程，将目标页面从外存放入内存中，并修改页表中相应的页表项</p>
</li>
<li><p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若淘汰的页面在内存期间被修改过，则要将其写回外存。若淘汰的页面未修改过就不用写回外存</p>
</li>
<li><p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p>
</li>
<li><p>一条指令在执行期间，可能产生多次缺页中断</p>
<ul>
<li>一条指令可能会访问多个内存单元，将A复制到B，如果A、B不处于同一个页面，就有可能发送两次缺页中断</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>地址变换机构</p>
<ul>
<li><p>新增步骤</p>
<ul>
<li><p>1、请求调页（查到页表项时，对页面是否在内存进行判断）</p>
</li>
<li><p>2、页面置换（需要调入页面，但没有空闲内存块时进行页面置换）</p>
</li>
<li><p>3、需要修改请求页表中新增的表项</p>
</li>
</ul>
</li>
<li><p>如何实现地址转换</p>
<ul>
<li><p>在快表中的页面一定是在内存中的</p>
<ul>
<li>若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面</li>
</ul>
</li>
<li><p>在慢表中，找到对应页表项后，若对应页面未调入内存，则产生缺页中断，之后由操作系统的缺页中断处理程序进行处理</p>
</li>
</ul>
</li>
<li><p>细节：</p>
<ul>
<li><p>1、只有“写指令”才需要修改“修改位”。并且一般来说只需修改快表中的数据</p>
<ul>
<li><p>修改位：内存中的数据被修改过，才改变</p>
</li>
<li><p>只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数</p>
</li>
</ul>
</li>
<li><p>2、和普通的中断处理一样，缺页中断处理依然需要保留CPU现场</p>
</li>
<li><p>3、需要用某种“页面置换算法”来决定一个换出页面</p>
</li>
<li><p>4、换入&#x2F;换出页面都需要启动慢速的I&#x2F;O操作，如果换入&#x2F;换出太频繁，会有很大的开销</p>
</li>
<li><p>5、页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中</p>
</li>
<li><p>6、访问一个逻辑地址时，若发生缺页，则地址变换步骤是：</p>
<ul>
<li>查快表(未命中)——查慢表(发现未调入内存)——调页(调入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul>
<li><p>最佳置换算法（OPT）</p>
<ul>
<li><p>选择永不使用或者最长时间内不再访问的页面进行淘汰，但是现实中是无法预知的<img src="https://api2.mubu.com/v3/document_image/3611414e-4452-4a26-8dbe-c54a19daea90-3224585.jpg" alt="img"></p>
</li>
<li><p>实现：选择目前在内存中且将会在最后被访问的页面，进行淘汰</p>
</li>
<li><p>结果：整个过程缺页中断发生了9次，页面置换发生了6次</p>
<ul>
<li>缺页时未必发生页面置换，也就是说如果还有可用的空闲内存块，就不用进行页面置换。</li>
</ul>
</li>
<li><p>缺页率：缺页次数&#x2F;访问页面总次数&#x3D;9&#x2F;20&#x3D;45%</p>
</li>
<li><p>优点：缺页率最小，性能最好</p>
</li>
<li><p>缺点：最佳置换算法是无法实现的</p>
<ul>
<li>操作系统无法提前预判页面访问序列</li>
</ul>
</li>
</ul>
</li>
<li><p>先进先出页面置换算法（FIFO）</p>
<ul>
<li><p>优先淘汰最早进入的页面</p>
</li>
<li><p>实现：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可</p>
<ul>
<li>队列的最大长度取决于系统为进程分配了多少个内存块</li>
</ul>
</li>
<li><p>优点：实现简单</p>
</li>
<li><p>缺点：算法性能差，Belady异常</p>
</li>
<li><p>Belady异常：增大分配的物理块数但是故障数不减反增</p>
<ul>
<li><p>只有先进先出算法会出现</p>
</li>
<li><p>原因：先进入的页面有可能最经常被访问</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>最近最久未使用（LRU）置换算法</p>
<ul>
<li><p>选择最近最长时间没有被访问的页面进行淘汰，每个页面设置一个访问字段，用来标识上次被访问到现在经历的时间</p>
</li>
<li><p>优点：性能好</p>
</li>
<li><p>缺点：实现复杂、需要寄存器和栈的硬件支持、LRU是堆栈类算法</p>
</li>
</ul>
</li>
<li><p>时钟（CLOCK）置换算法（最近未用算法）</p>
<ul>
<li><p>增加访问位，优先淘汰最近没有被访问过的页面</p>
<ul>
<li><p>访问位&#x3D;1，说明最近被访问过</p>
</li>
<li><p>访问位&#x3D;0，说明最近没有被访问过</p>
</li>
</ul>
</li>
<li><p>实现</p>
<ul>
<li><p>为每个页面设置一个使用位（访问位），再将内存中的页面都通过链接指针链接成一个循环队列</p>
</li>
<li><p>当需要淘汰一个页面时，只需检查存放在内存块中的页的访问位，如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面</p>
</li>
<li><p>若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描时访问位应该均为0），因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描</p>
</li>
</ul>
</li>
<li><p>优点：性能接近于最佳置换算法、实现简单、开销小</p>
</li>
<li><p>缺点：未考虑页面是否被修改过</p>
</li>
</ul>
</li>
<li><p>改进型CLOCK算法</p>
<ul>
<li><p>在使用位（访问位）的基础上增加修改位，如果被淘汰的页面没有被修改过，就不需要执行I&#x2F;O操作写回外存，使得性能提升</p>
<ul>
<li><p>修改位&#x3D;0，表示页面没有被修改过</p>
</li>
<li><p>修改位&#x3D;1，表示页面被修改过</p>
</li>
</ul>
</li>
<li><p>扫描过程</p>
<ul>
<li><p>为每个页面设置一个使用位（访问位）和修改位，再将内存中的页面都通过链接指针链接成一个循环队列</p>
</li>
<li><p>第一轮：从当前位置开始扫描到第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p>
<ul>
<li>第一优先级：最近没访问，且没修改的页面</li>
</ul>
</li>
<li><p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。且本轮将所有扫描过的帧访问位设为0</p>
<ul>
<li>第二优先级：最近没访问，但修改过的页面</li>
</ul>
</li>
<li><p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0, 0）的帧用于替换。本轮扫描不修改任何标志位</p>
<ul>
<li>第三优先级：最近访问过，但没修改的页面</li>
</ul>
</li>
<li><p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换</p>
<ul>
<li>第四优先级：最近访问过，且修改过的页面</li>
</ul>
</li>
<li><p>注：由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描</p>
</li>
</ul>
</li>
<li><p>优点：相对于未改进型，节省了时间</p>
</li>
</ul>
</li>
</ul>
<h2 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h2><ul>
<li><p>驻留集：请求分页存储管理中给一个进程的分配的物理块的集合</p>
<ul>
<li><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小</p>
</li>
<li><p>驻留集大小的考虑因素</p>
<ul>
<li><p>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少</p>
</li>
<li><p>驻留集太大，会导致多道程序并发度下降，资源利用率降低</p>
</li>
<li><p>所以应该选择一个合适的驻留集大小</p>
</li>
</ul>
</li>
<li><p>根据驻留集大小是否改变分类</p>
<ul>
<li><p>固定分配：驻留集大小不变</p>
<ul>
<li>操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变</li>
</ul>
</li>
<li><p>可变分配：驻留集大小可变</p>
<ul>
<li>先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少</li>
</ul>
</li>
</ul>
</li>
<li><p>根据置换时，置换的范围分类</p>
<ul>
<li><p>局部置换：发生缺页时只能选进程自己的物理块进行置换</p>
</li>
<li><p>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>页面分配、置换策略</p>
<ul>
<li><p>固定分配局部置换</p>
<ul>
<li><p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变</p>
</li>
<li><p>若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面</p>
</li>
<li><p>缺点：很难在刚开始就确定应为每个进程分配多少个物理块才算合理</p>
<ul>
<li>采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数</li>
</ul>
</li>
</ul>
</li>
<li><p>可变分配全局置换</p>
<ul>
<li><p>刚开始会为每个进程分配一定数量的物理块，在整个运行期间物理块数可以改变。操作系统会保持一个空闲物理块队列。</p>
</li>
<li><p>当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程</p>
<ul>
<li>未锁定：系统会锁定一些页面，这些页面中的内容不能置换出外存（例如：重要的内核数据可以设为“锁定”）</li>
</ul>
</li>
<li><p>采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出</p>
</li>
<li><p>缺点：被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程（被调出页的进程）拥有的物理块会减少，缺页率会增加</p>
</li>
<li><p>优点：最容易实现，动态调整物理块分配</p>
</li>
<li><p>缺点：如果盲目分配物理块，就会导致多道程序并发能力下降</p>
</li>
</ul>
</li>
<li><p>可变分配局部置换</p>
<ul>
<li><p>刚开始会为每个进程分配一定数量的物理块</p>
</li>
<li><p>当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存</p>
</li>
<li><p>如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块</p>
</li>
<li><p>优点：保持了系统的多道程序并发能力</p>
</li>
<li><p>缺点：增大了开销，实现复杂</p>
</li>
</ul>
</li>
<li><p>不存在固定分配全局置换</p>
<ul>
<li>如果使用全局置换，意味着进程拥有的物理块数量必然会改变，因此不可能是固定分配</li>
</ul>
</li>
<li><p>区别</p>
<ul>
<li><p>可变分配全局置换：只要缺页就给分配新物理块（物理块数只会增加）</p>
</li>
<li><p>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块（物理块数有可能增加，有可能减少）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>调入页面的时机（一般情况下两种策略同时使用）</p>
<ul>
<li><p>预调页策略：运行前调入</p>
<ul>
<li><p>将预计不久被访问的页面调入，成功率约为50%</p>
</li>
<li><p>根据局部性原理（主要指空间局部性），即：如果当前访问了某个内存单元，在之后很有可能会接着访问与其相邻的那些内存单元</p>
</li>
<li><p>如果提前调入的页面中大多数都没被访问过，则是低效的</p>
</li>
<li><p>主要用于进程的首次调入，由程序员指出应该先调入哪些部分</p>
</li>
</ul>
</li>
<li><p>请求调页策略：进程时调入</p>
<ul>
<li><p>当进程提出缺页的时候，再按照一定策略进行调页</p>
</li>
<li><p>特点：一次调入一页，这种策略调入的页面一定会被访问到，调入&#x2F;调出页面次数很多时，会产生较大的I&#x2F;O开销</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>从何处调入页</p>
<ul>
<li><p>外存分为对换区和文件区</p>
<ul>
<li><p>对换区：读&#x2F;写 速度更快，采用连续分配方式</p>
</li>
<li><p>文件区：读&#x2F;写 速度更慢，采用离散分配方式</p>
</li>
<li><p>运行前将相关数据从文件区复制到对换区</p>
</li>
</ul>
</li>
<li><p>1、系统拥有足够的对换空间</p>
<ul>
<li><p>页面的调入、调出都是在内存与对换区之间进行，速度快</p>
</li>
<li><p>在进程运行前，需将进程相关的数据从文件区复制到对换区</p>
</li>
</ul>
</li>
<li><p>2、系统缺少足够的对换区空间</p>
<ul>
<li><p>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可</p>
</li>
<li><p>对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入</p>
<ul>
<li>原理：读速度比写速度块</li>
</ul>
</li>
</ul>
</li>
<li><p>UNIX方式</p>
<ul>
<li><p>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入</p>
</li>
<li><p>若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>抖动</p>
<ul>
<li><p>刚换出的页面又要换入内存，刚刚换入的页面马上又要换出外存</p>
</li>
<li><p>原因</p>
<ul>
<li><p>分配的物理块数不足（主要原因）</p>
</li>
<li><p>置换算法不当</p>
</li>
</ul>
</li>
<li><p>解决：适当分配物理块数</p>
<ul>
<li>为了研究为应该为每个进程分配多少个物理块，提出了进程“工作集”的概念</li>
</ul>
</li>
</ul>
</li>
<li><p>工作集</p>
<ul>
<li><p>某段时间内，进程要访问的页面集合</p>
</li>
<li><p>操作系统会根据“窗口尺寸”来算出工作集</p>
</li>
<li><p>例如：某进程的页面访问序列如下，窗口尺寸为 4，各时刻的工作集为</p>
<ul>
<li><p>访问序列：24，15，18，23，24，17，18，24，18，17，17，15</p>
</li>
<li><p>1、工作集大小可能小于窗口尺寸</p>
<ul>
<li>工作集：一个窗口尺寸内，进程实际访问的不同页面的个数</li>
</ul>
</li>
<li><p>2、实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块</p>
<ul>
<li>如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要</li>
</ul>
</li>
</ul>
</li>
<li><p>驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</p>
</li>
<li><p>拓展：根据进程近期访问的页面集合（工作集）来设计一种页面置换算法</p>
<ul>
<li><p>原因：基于局部性原理可知，进程最近访问的页面与不久之后会访问的页面是有相关性的</p>
</li>
<li><p>实现过程</p>
<ul>
<li><p>落入工作集的页面需要调入驻留集中，落在工作集外面的页面可以从驻留集中换出</p>
</li>
<li><p>若还有空闲物理块，可以再调入一进程到内存以增加多道程序并发度</p>
</li>
<li><p>若所有进程的工作集之和超过了可用物理块的总数，操作系统就会暂停一个进程，并将其页面调出并将其物理块分配给其他进程</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%86%99%E4%BD%9C/" rel="tag"># 写作</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_2.%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="prev" title="进程管理">
                  <i class="fa fa-chevron-left"></i> 进程管理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/04/2-%E8%AE%A1%E7%AE%97%E6%9C%BA408_2.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_4.%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/" rel="next" title="文件管理">
                  文件管理 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">manana</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
